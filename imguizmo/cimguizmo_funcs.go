// Code generated by cmd/codegen from https://github.com/AllenDang/cimgui-go.
// DO NOT EDIT.

package imguizmo

import (
	"unsafe"

	"github.com/AllenDang/cimgui-go/datautils"
	"github.com/AllenDang/cimgui-go/imgui"
)

// #include "../imgui/extra_types.h"
// #include "cimguizmo_structs_accessor.h"
// #include "cimguizmo_wrapper.h"
import "C"

func AllowAxisFlip(value bool) {
	C.ImGuizmo_AllowAxisFlip(C.bool(value))
}

func BeginFrame() {
	C.ImGuizmo_BeginFrame()
}

func DecomposeMatrixToComponents(matrix []float32, translation *float32, rotation *float32, scale *float32) {
	translationArg, translationFin := datautils.WrapNumberPtr[C.float, float32](translation)
	rotationArg, rotationFin := datautils.WrapNumberPtr[C.float, float32](rotation)
	scaleArg, scaleFin := datautils.WrapNumberPtr[C.float, float32](scale)
	C.ImGuizmo_DecomposeMatrixToComponents((*C.float)(&(matrix[0])), translationArg, rotationArg, scaleArg)

	translationFin()
	rotationFin()
	scaleFin()
}

func DrawCubes(view []float32, projection []float32, matrices []float32, matrixCount int32) {
	C.ImGuizmo_DrawCubes((*C.float)(&(view[0])), (*C.float)(&(projection[0])), (*C.float)(&(matrices[0])), C.int(matrixCount))
}

func DrawGrid(view []float32, projection []float32, matrix []float32, gridSize float32) {
	C.ImGuizmo_DrawGrid((*C.float)(&(view[0])), (*C.float)(&(projection[0])), (*C.float)(&(matrix[0])), C.float(gridSize))
}

func Enable(enable bool) {
	C.ImGuizmo_Enable(C.bool(enable))
}

func GetIDPtr(ptr_id uintptr) imgui.ID {
	return *imgui.NewIDFromC(func() *C.ImGuiID { result := C.wrap_ImGuizmo_GetID_Ptr(C.uintptr_t(ptr_id)); return &result }())
}

func GetIDStr(str_id string) imgui.ID {
	str_idArg, str_idFin := datautils.WrapString[C.char](str_id)

	defer func() {
		str_idFin()
	}()
	return *imgui.NewIDFromC(func() *C.ImGuiID { result := C.ImGuizmo_GetID_Str(str_idArg); return &result }())
}

func GetIDStrStr(str_id_begin string, str_id_end string) imgui.ID {
	str_id_beginArg, str_id_beginFin := datautils.WrapString[C.char](str_id_begin)
	str_id_endArg, str_id_endFin := datautils.WrapString[C.char](str_id_end)

	defer func() {
		str_id_beginFin()
		str_id_endFin()
	}()
	return *imgui.NewIDFromC(func() *C.ImGuiID { result := C.ImGuizmo_GetID_StrStr(str_id_beginArg, str_id_endArg); return &result }())
}

func GetStyle() *Style {
	return NewStyleFromC(C.ImGuizmo_GetStyle())
}

func IsOverFloatPtr(position *float32, pixelRadius float32) bool {
	positionArg, positionFin := datautils.WrapNumberPtr[C.float, float32](position)

	defer func() {
		positionFin()
	}()
	return C.ImGuizmo_IsOver_FloatPtr(positionArg, C.float(pixelRadius)) == C.bool(true)
}

func IsOver() bool {
	return C.ImGuizmo_IsOver_Nil() == C.bool(true)
}

func IsOverOPERATION(op OPERATION) bool {
	return C.ImGuizmo_IsOver_OPERATION(C.OPERATION(op)) == C.bool(true)
}

func IsUsing() bool {
	return C.ImGuizmo_IsUsing() == C.bool(true)
}

func IsUsingAny() bool {
	return C.ImGuizmo_IsUsingAny() == C.bool(true)
}

func IsUsingViewManipulate() bool {
	return C.ImGuizmo_IsUsingViewManipulate() == C.bool(true)
}

// ManipulateV parameter default value hint:
// deltaMatrix: NULL
// snap: NULL
// localBounds: NULL
// boundsSnap: NULL
func ManipulateV(view []float32, projection []float32, operation OPERATION, mode MODE, matrix *float32, deltaMatrix *float32, snap []float32, localBounds []float32, boundsSnap []float32) bool {
	matrixArg, matrixFin := datautils.WrapNumberPtr[C.float, float32](matrix)
	deltaMatrixArg, deltaMatrixFin := datautils.WrapNumberPtr[C.float, float32](deltaMatrix)

	defer func() {
		matrixFin()
		deltaMatrixFin()
	}()
	return C.ImGuizmo_Manipulate((*C.float)(&(view[0])), (*C.float)(&(projection[0])), C.OPERATION(operation), C.MODE(mode), matrixArg, deltaMatrixArg, (*C.float)(&(snap[0])), (*C.float)(&(localBounds[0])), (*C.float)(&(boundsSnap[0]))) == C.bool(true)
}

func PopID() {
	C.ImGuizmo_PopID()
}

func PushIDInt(int_id int32) {
	C.ImGuizmo_PushID_Int(C.int(int_id))
}

func PushIDPtr(ptr_id uintptr) {
	C.wrap_ImGuizmo_PushID_Ptr(C.uintptr_t(ptr_id))
}

func PushIDStr(str_id string) {
	str_idArg, str_idFin := datautils.WrapString[C.char](str_id)
	C.ImGuizmo_PushID_Str(str_idArg)

	str_idFin()
}

func PushIDStrStr(str_id_begin string, str_id_end string) {
	str_id_beginArg, str_id_beginFin := datautils.WrapString[C.char](str_id_begin)
	str_id_endArg, str_id_endFin := datautils.WrapString[C.char](str_id_end)
	C.ImGuizmo_PushID_StrStr(str_id_beginArg, str_id_endArg)

	str_id_beginFin()
	str_id_endFin()
}

func RecomposeMatrixFromComponents(translation []float32, rotation []float32, scale []float32, matrix *float32) {
	matrixArg, matrixFin := datautils.WrapNumberPtr[C.float, float32](matrix)
	C.ImGuizmo_RecomposeMatrixFromComponents((*C.float)(&(translation[0])), (*C.float)(&(rotation[0])), (*C.float)(&(scale[0])), matrixArg)

	matrixFin()
}

func SetAlternativeWindow(window *imgui.Window) {
	windowArg, windowFin := window.Handle()
	C.ImGuizmo_SetAlternativeWindow(datautils.ConvertCTypes[*C.ImGuiWindow](windowArg))

	windowFin()
}

func SetAxisLimit(value float32) {
	C.ImGuizmo_SetAxisLimit(C.float(value))
}

func SetAxisMask(x bool, y bool, z bool) {
	C.ImGuizmo_SetAxisMask(C.bool(x), C.bool(y), C.bool(z))
}

// SetDrawlistV parameter default value hint:
// drawlist: nullptr
func SetDrawlistV(drawlist *imgui.DrawList) {
	drawlistArg, drawlistFin := drawlist.Handle()
	C.ImGuizmo_SetDrawlist(datautils.ConvertCTypes[*C.ImDrawList](drawlistArg))

	drawlistFin()
}

func SetGizmoSizeClipSpace(value float32) {
	C.ImGuizmo_SetGizmoSizeClipSpace(C.float(value))
}

func SetID(id int32) {
	C.ImGuizmo_SetID(C.int(id))
}

func SetImGuiContext(ctx *imgui.Context) {
	ctxArg, ctxFin := ctx.Handle()
	C.ImGuizmo_SetImGuiContext(datautils.ConvertCTypes[*C.ImGuiContext](ctxArg))

	ctxFin()
}

func SetOrthographic(isOrthographic bool) {
	C.ImGuizmo_SetOrthographic(C.bool(isOrthographic))
}

func SetPlaneLimit(value float32) {
	C.ImGuizmo_SetPlaneLimit(C.float(value))
}

func SetRect(x float32, y float32, width float32, height float32) {
	C.ImGuizmo_SetRect(C.float(x), C.float(y), C.float(width), C.float(height))
}

func ViewManipulateFloat(view *float32, length float32, position imgui.Vec2, size imgui.Vec2, backgroundColor uint32) {
	viewArg, viewFin := datautils.WrapNumberPtr[C.float, float32](view)
	C.ImGuizmo_ViewManipulate_Float(viewArg, C.float(length), datautils.ConvertCTypes[C.ImVec2](position.ToC()), datautils.ConvertCTypes[C.ImVec2](size.ToC()), C.ImU32(backgroundColor))

	viewFin()
}

func ViewManipulateFloatPtr(view *float32, projection []float32, operation OPERATION, mode MODE, matrix *float32, length float32, position imgui.Vec2, size imgui.Vec2, backgroundColor uint32) {
	viewArg, viewFin := datautils.WrapNumberPtr[C.float, float32](view)
	matrixArg, matrixFin := datautils.WrapNumberPtr[C.float, float32](matrix)
	C.ImGuizmo_ViewManipulate_FloatPtr(viewArg, (*C.float)(&(projection[0])), C.OPERATION(operation), C.MODE(mode), matrixArg, C.float(length), datautils.ConvertCTypes[C.ImVec2](position.ToC()), datautils.ConvertCTypes[C.ImVec2](size.ToC()), C.ImU32(backgroundColor))

	viewFin()
	matrixFin()
}

func NewStyle() *Style {
	return NewStyleFromC(C.Style_Style())
}

func (self *Style) Destroy() {
	selfArg, selfFin := self.Handle()
	C.Style_destroy(datautils.ConvertCTypes[*C.Style](selfArg))

	selfFin()
}

func Manipulate(view []float32, projection []float32, operation OPERATION, mode MODE, matrix *float32) bool {
	matrixArg, matrixFin := datautils.WrapNumberPtr[C.float, float32](matrix)

	defer func() {
		matrixFin()
	}()
	return C.wrap_ImGuizmo_Manipulate((*C.float)(&(view[0])), (*C.float)(&(projection[0])), C.OPERATION(operation), C.MODE(mode), matrixArg) == C.bool(true)
}

func SetDrawlist() {
	C.wrap_ImGuizmo_SetDrawlist()
}

func (self Style) SetTranslationLineThickness(v float32) {
	selfArg, selfFin := self.Handle()
	defer selfFin()
	C.wrap_Style_SetTranslationLineThickness(selfArg, C.float(v))
}

func (self *Style) TranslationLineThickness() float32 {
	selfArg, selfFin := self.Handle()

	defer func() {
		selfFin()
	}()
	return float32(C.wrap_Style_GetTranslationLineThickness(datautils.ConvertCTypes[*C.Style](selfArg)))
}

func (self Style) SetTranslationLineArrowSize(v float32) {
	selfArg, selfFin := self.Handle()
	defer selfFin()
	C.wrap_Style_SetTranslationLineArrowSize(selfArg, C.float(v))
}

func (self *Style) TranslationLineArrowSize() float32 {
	selfArg, selfFin := self.Handle()

	defer func() {
		selfFin()
	}()
	return float32(C.wrap_Style_GetTranslationLineArrowSize(datautils.ConvertCTypes[*C.Style](selfArg)))
}

func (self Style) SetRotationLineThickness(v float32) {
	selfArg, selfFin := self.Handle()
	defer selfFin()
	C.wrap_Style_SetRotationLineThickness(selfArg, C.float(v))
}

func (self *Style) RotationLineThickness() float32 {
	selfArg, selfFin := self.Handle()

	defer func() {
		selfFin()
	}()
	return float32(C.wrap_Style_GetRotationLineThickness(datautils.ConvertCTypes[*C.Style](selfArg)))
}

func (self Style) SetRotationOuterLineThickness(v float32) {
	selfArg, selfFin := self.Handle()
	defer selfFin()
	C.wrap_Style_SetRotationOuterLineThickness(selfArg, C.float(v))
}

func (self *Style) RotationOuterLineThickness() float32 {
	selfArg, selfFin := self.Handle()

	defer func() {
		selfFin()
	}()
	return float32(C.wrap_Style_GetRotationOuterLineThickness(datautils.ConvertCTypes[*C.Style](selfArg)))
}

func (self Style) SetScaleLineThickness(v float32) {
	selfArg, selfFin := self.Handle()
	defer selfFin()
	C.wrap_Style_SetScaleLineThickness(selfArg, C.float(v))
}

func (self *Style) ScaleLineThickness() float32 {
	selfArg, selfFin := self.Handle()

	defer func() {
		selfFin()
	}()
	return float32(C.wrap_Style_GetScaleLineThickness(datautils.ConvertCTypes[*C.Style](selfArg)))
}

func (self Style) SetScaleLineCircleSize(v float32) {
	selfArg, selfFin := self.Handle()
	defer selfFin()
	C.wrap_Style_SetScaleLineCircleSize(selfArg, C.float(v))
}

func (self *Style) ScaleLineCircleSize() float32 {
	selfArg, selfFin := self.Handle()

	defer func() {
		selfFin()
	}()
	return float32(C.wrap_Style_GetScaleLineCircleSize(datautils.ConvertCTypes[*C.Style](selfArg)))
}

func (self Style) SetHatchedAxisLineThickness(v float32) {
	selfArg, selfFin := self.Handle()
	defer selfFin()
	C.wrap_Style_SetHatchedAxisLineThickness(selfArg, C.float(v))
}

func (self *Style) HatchedAxisLineThickness() float32 {
	selfArg, selfFin := self.Handle()

	defer func() {
		selfFin()
	}()
	return float32(C.wrap_Style_GetHatchedAxisLineThickness(datautils.ConvertCTypes[*C.Style](selfArg)))
}

func (self Style) SetCenterCircleSize(v float32) {
	selfArg, selfFin := self.Handle()
	defer selfFin()
	C.wrap_Style_SetCenterCircleSize(selfArg, C.float(v))
}

func (self *Style) CenterCircleSize() float32 {
	selfArg, selfFin := self.Handle()

	defer func() {
		selfFin()
	}()
	return float32(C.wrap_Style_GetCenterCircleSize(datautils.ConvertCTypes[*C.Style](selfArg)))
}

func (self Style) SetColors(v *[15]imgui.Vec4) {
	vArg := make([]C.ImVec4, len(v))
	for i, vV := range v {
		vArg[i] = datautils.ConvertCTypes[C.ImVec4](vV.ToC())
	}

	selfArg, selfFin := self.Handle()
	defer selfFin()
	C.wrap_Style_SetColors(selfArg, (*C.ImVec4)(&vArg[0]))

	for i, vV := range vArg {
		(*v)[i] = func() imgui.Vec4 { out := vV; return *(&imgui.Vec4{}).FromC(unsafe.Pointer(&out)) }()
	}
}

func (self *Style) Colors() [15]imgui.Vec4 {
	selfArg, selfFin := self.Handle()

	defer func() {
		selfFin()
	}()
	return func() [15]imgui.Vec4 {
		result := [15]imgui.Vec4{}
		resultMirr := C.wrap_Style_GetColors(datautils.ConvertCTypes[*C.Style](selfArg))
		for i := range result {
			result[i] = func() imgui.Vec4 {
				out := C.cimguizmo_ImVec4_GetAtIdx(resultMirr, C.int(i))
				return *(&imgui.Vec4{}).FromC(unsafe.Pointer(&out))
			}()
		}

		return result
	}()
}
