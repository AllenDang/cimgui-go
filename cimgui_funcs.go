// Code generated by cmd/codegen from https://github.com/AllenDang/cimgui-go.
// DO NOT EDIT.

package imgui

// #include "extra_types.h"
// #include "cimgui_structs_accessor.h"
// #include "cimgui_wrapper.h"
import "C"
import "unsafe"

func (self *BitVector) InternalClear() {
	selfArg, selfFin := self.handle()
	C.ImBitVector_Clear(selfArg)

	selfFin()
}

func (self *BitVector) InternalClearBit(n int32) {
	selfArg, selfFin := self.handle()
	C.ImBitVector_ClearBit(selfArg, C.int(n))

	selfFin()
}

func (self *BitVector) InternalCreate(sz int32) {
	selfArg, selfFin := self.handle()
	C.ImBitVector_Create(selfArg, C.int(sz))

	selfFin()
}

func (self *BitVector) InternalSetBit(n int32) {
	selfArg, selfFin := self.handle()
	C.ImBitVector_SetBit(selfArg, C.int(n))

	selfFin()
}

func (self *BitVector) InternalTestBit(n int32) bool {
	selfArg, selfFin := self.handle()

	defer func() {
		selfFin()
	}()
	return C.ImBitVector_TestBit(selfArg, C.int(n)) == C.bool(true)
}

// ColorHSVV parameter default value hint:
// a: 1.0f
func ColorHSVV(h float32, s float32, v float32, a float32) Color {
	pOut := new(Color)
	pOutArg, pOutFin := wrap[C.ImColor, *Color](pOut)

	C.ImColor_HSV(pOutArg, C.float(h), C.float(s), C.float(v), C.float(a))

	pOutFin()

	return *pOut
}

// SetHSVV parameter default value hint:
// a: 1.0f
func (self *Color) SetHSVV(h float32, s float32, v float32, a float32) {
	selfArg, selfFin := wrap[C.ImColor, *Color](self)
	C.ImColor_SetHSV(selfArg, C.float(h), C.float(s), C.float(v), C.float(a))

	selfFin()
}

func (self *Color) Destroy() {
	selfArg, selfFin := wrap[C.ImColor, *Color](self)
	C.ImColor_destroy(selfArg)

	selfFin()
}

func (self *DrawCmd) TexID() TextureID {
	selfArg, selfFin := self.handle()

	defer func() {
		selfFin()
	}()
	return *newTextureIDFromC(func() *C.ImTextureID { result := C.ImDrawCmd_GetTexID(selfArg); return &result }())
}

// Also ensure our padding fields are zeroed
func NewDrawCmd() *DrawCmd {
	return newDrawCmdFromC(C.ImDrawCmd_ImDrawCmd())
}

func (self *DrawCmd) Destroy() {
	selfArg, selfFin := self.handle()
	C.ImDrawCmd_destroy(selfArg)

	selfFin()
}

func InternalNewDrawDataBuilder() *DrawDataBuilder {
	return newDrawDataBuilderFromC(C.ImDrawDataBuilder_ImDrawDataBuilder())
}

func (self *DrawDataBuilder) Destroy() {
	selfArg, selfFin := self.handle()
	C.ImDrawDataBuilder_destroy(selfArg)

	selfFin()
}

// Helper to add an external draw list into an existing ImDrawData.
func (self *DrawData) AddDrawList(draw_list *DrawList) {
	selfArg, selfFin := self.handle()
	draw_listArg, draw_listFin := draw_list.handle()
	C.ImDrawData_AddDrawList(selfArg, draw_listArg)

	selfFin()
	draw_listFin()
}

func (self *DrawData) Clear() {
	selfArg, selfFin := self.handle()
	C.ImDrawData_Clear(selfArg)

	selfFin()
}

// Helper to convert all buffers from indexed to non-indexed, in case you cannot render indexed. Note: this is slow and most likely a waste of resources. Always prefer indexed rendering!
func (self *DrawData) DeIndexAllBuffers() {
	selfArg, selfFin := self.handle()
	C.ImDrawData_DeIndexAllBuffers(selfArg)

	selfFin()
}

func NewDrawData() *DrawData {
	return newDrawDataFromC(C.ImDrawData_ImDrawData())
}

// Helper to scale the ClipRect field of each ImDrawCmd. Use if your final output buffer is at a different scale than Dear ImGui expects, or if there is a difference between your window resolution and framebuffer resolution.
func (self *DrawData) ScaleClipRects(fb_scale Vec2) {
	selfArg, selfFin := self.handle()
	C.ImDrawData_ScaleClipRects(selfArg, fb_scale.toC())

	selfFin()
}

func (self *DrawData) Destroy() {
	selfArg, selfFin := self.handle()
	C.ImDrawData_destroy(selfArg)

	selfFin()
}

func InternalNewDrawListSharedData() *DrawListSharedData {
	return newDrawListSharedDataFromC(C.ImDrawListSharedData_ImDrawListSharedData())
}

func (self *DrawListSharedData) InternalSetCircleTessellationMaxError(max_error float32) {
	selfArg, selfFin := self.handle()
	C.ImDrawListSharedData_SetCircleTessellationMaxError(selfArg, C.float(max_error))

	selfFin()
}

func (self *DrawListSharedData) Destroy() {
	selfArg, selfFin := self.handle()
	C.ImDrawListSharedData_destroy(selfArg)

	selfFin()
}

// Do not clear Channels[] so our allocations are reused next frame
func (self *DrawListSplitter) Clear() {
	selfArg, selfFin := self.handle()
	C.ImDrawListSplitter_Clear(selfArg)

	selfFin()
}

func (self *DrawListSplitter) ClearFreeMemory() {
	selfArg, selfFin := self.handle()
	C.ImDrawListSplitter_ClearFreeMemory(selfArg)

	selfFin()
}

func NewDrawListSplitter() *DrawListSplitter {
	return newDrawListSplitterFromC(C.ImDrawListSplitter_ImDrawListSplitter())
}

func (self *DrawListSplitter) Merge(draw_list *DrawList) {
	selfArg, selfFin := self.handle()
	draw_listArg, draw_listFin := draw_list.handle()
	C.ImDrawListSplitter_Merge(selfArg, draw_listArg)

	selfFin()
	draw_listFin()
}

func (self *DrawListSplitter) SetCurrentChannel(draw_list *DrawList, channel_idx int32) {
	selfArg, selfFin := self.handle()
	draw_listArg, draw_listFin := draw_list.handle()
	C.ImDrawListSplitter_SetCurrentChannel(selfArg, draw_listArg, C.int(channel_idx))

	selfFin()
	draw_listFin()
}

func (self *DrawListSplitter) Split(draw_list *DrawList, count int32) {
	selfArg, selfFin := self.handle()
	draw_listArg, draw_listFin := draw_list.handle()
	C.ImDrawListSplitter_Split(selfArg, draw_listArg, C.int(count))

	selfFin()
	draw_listFin()
}

func (self *DrawListSplitter) Destroy() {
	selfArg, selfFin := self.handle()
	C.ImDrawListSplitter_destroy(selfArg)

	selfFin()
}

// Cubic Bezier (4 control points)
// AddBezierCubicV parameter default value hint:
// num_segments: 0
func (self *DrawList) AddBezierCubicV(p1 Vec2, p2 Vec2, p3 Vec2, p4 Vec2, col uint32, thickness float32, num_segments int32) {
	selfArg, selfFin := self.handle()
	C.ImDrawList_AddBezierCubic(selfArg, p1.toC(), p2.toC(), p3.toC(), p4.toC(), C.ImU32(col), C.float(thickness), C.int(num_segments))

	selfFin()
}

// Quadratic Bezier (3 control points)
// AddBezierQuadraticV parameter default value hint:
// num_segments: 0
func (self *DrawList) AddBezierQuadraticV(p1 Vec2, p2 Vec2, p3 Vec2, col uint32, thickness float32, num_segments int32) {
	selfArg, selfFin := self.handle()
	C.ImDrawList_AddBezierQuadratic(selfArg, p1.toC(), p2.toC(), p3.toC(), C.ImU32(col), C.float(thickness), C.int(num_segments))

	selfFin()
}

// AddCircleV parameter default value hint:
// num_segments: 0
// thickness: 1.0f
func (self *DrawList) AddCircleV(center Vec2, radius float32, col uint32, num_segments int32, thickness float32) {
	selfArg, selfFin := self.handle()
	C.ImDrawList_AddCircle(selfArg, center.toC(), C.float(radius), C.ImU32(col), C.int(num_segments), C.float(thickness))

	selfFin()
}

// AddCircleFilledV parameter default value hint:
// num_segments: 0
func (self *DrawList) AddCircleFilledV(center Vec2, radius float32, col uint32, num_segments int32) {
	selfArg, selfFin := self.handle()
	C.ImDrawList_AddCircleFilled(selfArg, center.toC(), C.float(radius), C.ImU32(col), C.int(num_segments))

	selfFin()
}

func (self *DrawList) AddConvexPolyFilled(points *Vec2, num_points int32, col uint32) {
	selfArg, selfFin := self.handle()
	pointsArg, pointsFin := wrap[C.ImVec2, *Vec2](points)
	C.ImDrawList_AddConvexPolyFilled(selfArg, pointsArg, C.int(num_points), C.ImU32(col))

	selfFin()
	pointsFin()
}

// This is useful if you need to forcefully create a new draw call (to allow for dependent rendering / blending). Otherwise primitives are merged into the same draw-call as much as possible
func (self *DrawList) AddDrawCmd() {
	selfArg, selfFin := self.handle()
	C.ImDrawList_AddDrawCmd(selfArg)

	selfFin()
}

// AddEllipseV parameter default value hint:
// rot: 0.0f
// num_segments: 0
// thickness: 1.0f
func (self *DrawList) AddEllipseV(center Vec2, radius_x float32, radius_y float32, col uint32, rot float32, num_segments int32, thickness float32) {
	selfArg, selfFin := self.handle()
	C.ImDrawList_AddEllipse(selfArg, center.toC(), C.float(radius_x), C.float(radius_y), C.ImU32(col), C.float(rot), C.int(num_segments), C.float(thickness))

	selfFin()
}

// AddEllipseFilledV parameter default value hint:
// rot: 0.0f
// num_segments: 0
func (self *DrawList) AddEllipseFilledV(center Vec2, radius_x float32, radius_y float32, col uint32, rot float32, num_segments int32) {
	selfArg, selfFin := self.handle()
	C.ImDrawList_AddEllipseFilled(selfArg, center.toC(), C.float(radius_x), C.float(radius_y), C.ImU32(col), C.float(rot), C.int(num_segments))

	selfFin()
}

// AddImageV parameter default value hint:
// uv_min: ImVec2(0,0)
// uv_max: ImVec2(1,1)
// col: 4294967295
func (self *DrawList) AddImageV(user_texture_id TextureID, p_min Vec2, p_max Vec2, uv_min Vec2, uv_max Vec2, col uint32) {
	selfArg, selfFin := self.handle()
	user_texture_idArg, user_texture_idFin := user_texture_id.c()
	C.ImDrawList_AddImage(selfArg, user_texture_idArg, p_min.toC(), p_max.toC(), uv_min.toC(), uv_max.toC(), C.ImU32(col))

	selfFin()
	user_texture_idFin()
}

// AddImageQuadV parameter default value hint:
// uv1: ImVec2(0,0)
// uv2: ImVec2(1,0)
// uv3: ImVec2(1,1)
// uv4: ImVec2(0,1)
// col: 4294967295
func (self *DrawList) AddImageQuadV(user_texture_id TextureID, p1 Vec2, p2 Vec2, p3 Vec2, p4 Vec2, uv1 Vec2, uv2 Vec2, uv3 Vec2, uv4 Vec2, col uint32) {
	selfArg, selfFin := self.handle()
	user_texture_idArg, user_texture_idFin := user_texture_id.c()
	C.ImDrawList_AddImageQuad(selfArg, user_texture_idArg, p1.toC(), p2.toC(), p3.toC(), p4.toC(), uv1.toC(), uv2.toC(), uv3.toC(), uv4.toC(), C.ImU32(col))

	selfFin()
	user_texture_idFin()
}

// AddImageRoundedV parameter default value hint:
// flags: 0
func (self *DrawList) AddImageRoundedV(user_texture_id TextureID, p_min Vec2, p_max Vec2, uv_min Vec2, uv_max Vec2, col uint32, rounding float32, flags DrawFlags) {
	selfArg, selfFin := self.handle()
	user_texture_idArg, user_texture_idFin := user_texture_id.c()
	C.ImDrawList_AddImageRounded(selfArg, user_texture_idArg, p_min.toC(), p_max.toC(), uv_min.toC(), uv_max.toC(), C.ImU32(col), C.float(rounding), C.ImDrawFlags(flags))

	selfFin()
	user_texture_idFin()
}

// AddLineV parameter default value hint:
// thickness: 1.0f
func (self *DrawList) AddLineV(p1 Vec2, p2 Vec2, col uint32, thickness float32) {
	selfArg, selfFin := self.handle()
	C.ImDrawList_AddLine(selfArg, p1.toC(), p2.toC(), C.ImU32(col), C.float(thickness))

	selfFin()
}

// AddNgonV parameter default value hint:
// thickness: 1.0f
func (self *DrawList) AddNgonV(center Vec2, radius float32, col uint32, num_segments int32, thickness float32) {
	selfArg, selfFin := self.handle()
	C.ImDrawList_AddNgon(selfArg, center.toC(), C.float(radius), C.ImU32(col), C.int(num_segments), C.float(thickness))

	selfFin()
}

func (self *DrawList) AddNgonFilled(center Vec2, radius float32, col uint32, num_segments int32) {
	selfArg, selfFin := self.handle()
	C.ImDrawList_AddNgonFilled(selfArg, center.toC(), C.float(radius), C.ImU32(col), C.int(num_segments))

	selfFin()
}

func (self *DrawList) AddPolyline(points *Vec2, num_points int32, col uint32, flags DrawFlags, thickness float32) {
	selfArg, selfFin := self.handle()
	pointsArg, pointsFin := wrap[C.ImVec2, *Vec2](points)
	C.ImDrawList_AddPolyline(selfArg, pointsArg, C.int(num_points), C.ImU32(col), C.ImDrawFlags(flags), C.float(thickness))

	selfFin()
	pointsFin()
}

// AddQuadV parameter default value hint:
// thickness: 1.0f
func (self *DrawList) AddQuadV(p1 Vec2, p2 Vec2, p3 Vec2, p4 Vec2, col uint32, thickness float32) {
	selfArg, selfFin := self.handle()
	C.ImDrawList_AddQuad(selfArg, p1.toC(), p2.toC(), p3.toC(), p4.toC(), C.ImU32(col), C.float(thickness))

	selfFin()
}

func (self *DrawList) AddQuadFilled(p1 Vec2, p2 Vec2, p3 Vec2, p4 Vec2, col uint32) {
	selfArg, selfFin := self.handle()
	C.ImDrawList_AddQuadFilled(selfArg, p1.toC(), p2.toC(), p3.toC(), p4.toC(), C.ImU32(col))

	selfFin()
}

// a: upper-left, b: lower-right (== upper-left + size)
// AddRectV parameter default value hint:
// rounding: 0.0f
// flags: 0
// thickness: 1.0f
func (self *DrawList) AddRectV(p_min Vec2, p_max Vec2, col uint32, rounding float32, flags DrawFlags, thickness float32) {
	selfArg, selfFin := self.handle()
	C.ImDrawList_AddRect(selfArg, p_min.toC(), p_max.toC(), C.ImU32(col), C.float(rounding), C.ImDrawFlags(flags), C.float(thickness))

	selfFin()
}

// a: upper-left, b: lower-right (== upper-left + size)
// AddRectFilledV parameter default value hint:
// rounding: 0.0f
// flags: 0
func (self *DrawList) AddRectFilledV(p_min Vec2, p_max Vec2, col uint32, rounding float32, flags DrawFlags) {
	selfArg, selfFin := self.handle()
	C.ImDrawList_AddRectFilled(selfArg, p_min.toC(), p_max.toC(), C.ImU32(col), C.float(rounding), C.ImDrawFlags(flags))

	selfFin()
}

func (self *DrawList) AddRectFilledMultiColor(p_min Vec2, p_max Vec2, col_upr_left uint32, col_upr_right uint32, col_bot_right uint32, col_bot_left uint32) {
	selfArg, selfFin := self.handle()
	C.ImDrawList_AddRectFilledMultiColor(selfArg, p_min.toC(), p_max.toC(), C.ImU32(col_upr_left), C.ImU32(col_upr_right), C.ImU32(col_bot_right), C.ImU32(col_bot_left))

	selfFin()
}

// AddTextFontPtrV parameter default value hint:
// wrap_width: 0.0f
// cpu_fine_clip_rect: NULL
func (self *DrawList) AddTextFontPtrV(font *Font, font_size float32, pos Vec2, col uint32, text_begin string, wrap_width float32, cpu_fine_clip_rect *Vec4) {
	selfArg, selfFin := self.handle()
	fontArg, fontFin := font.handle()
	text_beginArg, text_beginFin := WrapString(text_begin)
	cpu_fine_clip_rectArg, cpu_fine_clip_rectFin := wrap[C.ImVec4, *Vec4](cpu_fine_clip_rect)
	C.wrap_ImDrawList_AddText_FontPtrV(selfArg, fontArg, C.float(font_size), pos.toC(), C.ImU32(col), text_beginArg, C.float(wrap_width), cpu_fine_clip_rectArg)

	selfFin()
	fontFin()
	text_beginFin()
	cpu_fine_clip_rectFin()
}

// AddTextVec2V parameter default value hint:
func (self *DrawList) AddTextVec2V(pos Vec2, col uint32, text_begin string) {
	selfArg, selfFin := self.handle()
	text_beginArg, text_beginFin := WrapString(text_begin)
	C.wrap_ImDrawList_AddText_Vec2V(selfArg, pos.toC(), C.ImU32(col), text_beginArg)

	selfFin()
	text_beginFin()
}

// AddTriangleV parameter default value hint:
// thickness: 1.0f
func (self *DrawList) AddTriangleV(p1 Vec2, p2 Vec2, p3 Vec2, col uint32, thickness float32) {
	selfArg, selfFin := self.handle()
	C.ImDrawList_AddTriangle(selfArg, p1.toC(), p2.toC(), p3.toC(), C.ImU32(col), C.float(thickness))

	selfFin()
}

func (self *DrawList) AddTriangleFilled(p1 Vec2, p2 Vec2, p3 Vec2, col uint32) {
	selfArg, selfFin := self.handle()
	C.ImDrawList_AddTriangleFilled(selfArg, p1.toC(), p2.toC(), p3.toC(), C.ImU32(col))

	selfFin()
}

func (self *DrawList) ChannelsMerge() {
	selfArg, selfFin := self.handle()
	C.ImDrawList_ChannelsMerge(selfArg)

	selfFin()
}

func (self *DrawList) ChannelsSetCurrent(n int32) {
	selfArg, selfFin := self.handle()
	C.ImDrawList_ChannelsSetCurrent(selfArg, C.int(n))

	selfFin()
}

func (self *DrawList) ChannelsSplit(count int32) {
	selfArg, selfFin := self.handle()
	C.ImDrawList_ChannelsSplit(selfArg, C.int(count))

	selfFin()
}

// Create a clone of the CmdBuffer/IdxBuffer/VtxBuffer.
func (self *DrawList) CloneOutput() *DrawList {
	selfArg, selfFin := self.handle()

	defer func() {
		selfFin()
	}()
	return newDrawListFromC(C.ImDrawList_CloneOutput(selfArg))
}

func (self *DrawList) ClipRectMax() Vec2 {
	pOut := new(Vec2)
	pOutArg, pOutFin := wrap[C.ImVec2, *Vec2](pOut)

	selfArg, selfFin := self.handle()
	C.ImDrawList_GetClipRectMax(pOutArg, selfArg)

	pOutFin()
	selfFin()

	return *pOut
}

func (self *DrawList) ClipRectMin() Vec2 {
	pOut := new(Vec2)
	pOutArg, pOutFin := wrap[C.ImVec2, *Vec2](pOut)

	selfArg, selfFin := self.handle()
	C.ImDrawList_GetClipRectMin(pOutArg, selfArg)

	pOutFin()
	selfFin()

	return *pOut
}

func NewDrawList(shared_data *DrawListSharedData) *DrawList {
	shared_dataArg, shared_dataFin := shared_data.handle()

	defer func() {
		shared_dataFin()
	}()
	return newDrawListFromC(C.ImDrawList_ImDrawList(shared_dataArg))
}

// PathArcToV parameter default value hint:
// num_segments: 0
func (self *DrawList) PathArcToV(center Vec2, radius float32, a_min float32, a_max float32, num_segments int32) {
	selfArg, selfFin := self.handle()
	C.ImDrawList_PathArcTo(selfArg, center.toC(), C.float(radius), C.float(a_min), C.float(a_max), C.int(num_segments))

	selfFin()
}

// Use precomputed angles for a 12 steps circle
func (self *DrawList) PathArcToFast(center Vec2, radius float32, a_min_of_12 int32, a_max_of_12 int32) {
	selfArg, selfFin := self.handle()
	C.ImDrawList_PathArcToFast(selfArg, center.toC(), C.float(radius), C.int(a_min_of_12), C.int(a_max_of_12))

	selfFin()
}

// Cubic Bezier (4 control points)
// PathBezierCubicCurveToV parameter default value hint:
// num_segments: 0
func (self *DrawList) PathBezierCubicCurveToV(p2 Vec2, p3 Vec2, p4 Vec2, num_segments int32) {
	selfArg, selfFin := self.handle()
	C.ImDrawList_PathBezierCubicCurveTo(selfArg, p2.toC(), p3.toC(), p4.toC(), C.int(num_segments))

	selfFin()
}

// Quadratic Bezier (3 control points)
// PathBezierQuadraticCurveToV parameter default value hint:
// num_segments: 0
func (self *DrawList) PathBezierQuadraticCurveToV(p2 Vec2, p3 Vec2, num_segments int32) {
	selfArg, selfFin := self.handle()
	C.ImDrawList_PathBezierQuadraticCurveTo(selfArg, p2.toC(), p3.toC(), C.int(num_segments))

	selfFin()
}

func (self *DrawList) PathClear() {
	selfArg, selfFin := self.handle()
	C.ImDrawList_PathClear(selfArg)

	selfFin()
}

// Ellipse
// PathEllipticalArcToV parameter default value hint:
// num_segments: 0
func (self *DrawList) PathEllipticalArcToV(center Vec2, radius_x float32, radius_y float32, rot float32, a_min float32, a_max float32, num_segments int32) {
	selfArg, selfFin := self.handle()
	C.ImDrawList_PathEllipticalArcTo(selfArg, center.toC(), C.float(radius_x), C.float(radius_y), C.float(rot), C.float(a_min), C.float(a_max), C.int(num_segments))

	selfFin()
}

func (self *DrawList) PathFillConvex(col uint32) {
	selfArg, selfFin := self.handle()
	C.ImDrawList_PathFillConvex(selfArg, C.ImU32(col))

	selfFin()
}

func (self *DrawList) PathLineTo(pos Vec2) {
	selfArg, selfFin := self.handle()
	C.ImDrawList_PathLineTo(selfArg, pos.toC())

	selfFin()
}

func (self *DrawList) PathLineToMergeDuplicate(pos Vec2) {
	selfArg, selfFin := self.handle()
	C.ImDrawList_PathLineToMergeDuplicate(selfArg, pos.toC())

	selfFin()
}

// PathRectV parameter default value hint:
// rounding: 0.0f
// flags: 0
func (self *DrawList) PathRectV(rect_min Vec2, rect_max Vec2, rounding float32, flags DrawFlags) {
	selfArg, selfFin := self.handle()
	C.ImDrawList_PathRect(selfArg, rect_min.toC(), rect_max.toC(), C.float(rounding), C.ImDrawFlags(flags))

	selfFin()
}

// PathStrokeV parameter default value hint:
// flags: 0
// thickness: 1.0f
func (self *DrawList) PathStrokeV(col uint32, flags DrawFlags, thickness float32) {
	selfArg, selfFin := self.handle()
	C.ImDrawList_PathStroke(selfArg, C.ImU32(col), C.ImDrawFlags(flags), C.float(thickness))

	selfFin()
}

func (self *DrawList) PopClipRect() {
	selfArg, selfFin := self.handle()
	C.ImDrawList_PopClipRect(selfArg)

	selfFin()
}

func (self *DrawList) PopTextureID() {
	selfArg, selfFin := self.handle()
	C.ImDrawList_PopTextureID(selfArg)

	selfFin()
}

func (self *DrawList) PrimQuadUV(a Vec2, b Vec2, c Vec2, d Vec2, uv_a Vec2, uv_b Vec2, uv_c Vec2, uv_d Vec2, col uint32) {
	selfArg, selfFin := self.handle()
	C.ImDrawList_PrimQuadUV(selfArg, a.toC(), b.toC(), c.toC(), d.toC(), uv_a.toC(), uv_b.toC(), uv_c.toC(), uv_d.toC(), C.ImU32(col))

	selfFin()
}

// Axis aligned rectangle (composed of two triangles)
func (self *DrawList) PrimRect(a Vec2, b Vec2, col uint32) {
	selfArg, selfFin := self.handle()
	C.ImDrawList_PrimRect(selfArg, a.toC(), b.toC(), C.ImU32(col))

	selfFin()
}

func (self *DrawList) PrimRectUV(a Vec2, b Vec2, uv_a Vec2, uv_b Vec2, col uint32) {
	selfArg, selfFin := self.handle()
	C.ImDrawList_PrimRectUV(selfArg, a.toC(), b.toC(), uv_a.toC(), uv_b.toC(), C.ImU32(col))

	selfFin()
}

func (self *DrawList) PrimReserve(idx_count int32, vtx_count int32) {
	selfArg, selfFin := self.handle()
	C.ImDrawList_PrimReserve(selfArg, C.int(idx_count), C.int(vtx_count))

	selfFin()
}

func (self *DrawList) PrimUnreserve(idx_count int32, vtx_count int32) {
	selfArg, selfFin := self.handle()
	C.ImDrawList_PrimUnreserve(selfArg, C.int(idx_count), C.int(vtx_count))

	selfFin()
}

// Write vertex with unique index
func (self *DrawList) PrimVtx(pos Vec2, uv Vec2, col uint32) {
	selfArg, selfFin := self.handle()
	C.ImDrawList_PrimVtx(selfArg, pos.toC(), uv.toC(), C.ImU32(col))

	selfFin()
}

func (self *DrawList) PrimWriteVtx(pos Vec2, uv Vec2, col uint32) {
	selfArg, selfFin := self.handle()
	C.ImDrawList_PrimWriteVtx(selfArg, pos.toC(), uv.toC(), C.ImU32(col))

	selfFin()
}

// Render-level scissoring. This is passed down to your render function but not used for CPU-side coarse clipping. Prefer using higher-level ImGui::PushClipRect() to affect logic (hit-testing and widget culling)
// PushClipRectV parameter default value hint:
// intersect_with_current_clip_rect: false
func (self *DrawList) PushClipRectV(clip_rect_min Vec2, clip_rect_max Vec2, intersect_with_current_clip_rect bool) {
	selfArg, selfFin := self.handle()
	C.ImDrawList_PushClipRect(selfArg, clip_rect_min.toC(), clip_rect_max.toC(), C.bool(intersect_with_current_clip_rect))

	selfFin()
}

func (self *DrawList) PushClipRectFullScreen() {
	selfArg, selfFin := self.handle()
	C.ImDrawList_PushClipRectFullScreen(selfArg)

	selfFin()
}

func (self *DrawList) PushTextureID(texture_id TextureID) {
	selfArg, selfFin := self.handle()
	texture_idArg, texture_idFin := texture_id.c()
	C.ImDrawList_PushTextureID(selfArg, texture_idArg)

	selfFin()
	texture_idFin()
}

func (self *DrawList) CalcCircleAutoSegmentCount(radius float32) int32 {
	selfArg, selfFin := self.handle()

	defer func() {
		selfFin()
	}()
	return int32(C.ImDrawList__CalcCircleAutoSegmentCount(selfArg, C.float(radius)))
}

func (self *DrawList) ClearFreeMemory() {
	selfArg, selfFin := self.handle()
	C.ImDrawList__ClearFreeMemory(selfArg)

	selfFin()
}

func (self *DrawList) OnChangedClipRect() {
	selfArg, selfFin := self.handle()
	C.ImDrawList__OnChangedClipRect(selfArg)

	selfFin()
}

func (self *DrawList) OnChangedTextureID() {
	selfArg, selfFin := self.handle()
	C.ImDrawList__OnChangedTextureID(selfArg)

	selfFin()
}

func (self *DrawList) OnChangedVtxOffset() {
	selfArg, selfFin := self.handle()
	C.ImDrawList__OnChangedVtxOffset(selfArg)

	selfFin()
}

func (self *DrawList) PathArcToFastEx(center Vec2, radius float32, a_min_sample int32, a_max_sample int32, a_step int32) {
	selfArg, selfFin := self.handle()
	C.ImDrawList__PathArcToFastEx(selfArg, center.toC(), C.float(radius), C.int(a_min_sample), C.int(a_max_sample), C.int(a_step))

	selfFin()
}

func (self *DrawList) PathArcToN(center Vec2, radius float32, a_min float32, a_max float32, num_segments int32) {
	selfArg, selfFin := self.handle()
	C.ImDrawList__PathArcToN(selfArg, center.toC(), C.float(radius), C.float(a_min), C.float(a_max), C.int(num_segments))

	selfFin()
}

func (self *DrawList) PopUnusedDrawCmd() {
	selfArg, selfFin := self.handle()
	C.ImDrawList__PopUnusedDrawCmd(selfArg)

	selfFin()
}

func (self *DrawList) ResetForNewFrame() {
	selfArg, selfFin := self.handle()
	C.ImDrawList__ResetForNewFrame(selfArg)

	selfFin()
}

func (self *DrawList) TryMergeDrawCmds() {
	selfArg, selfFin := self.handle()
	C.ImDrawList__TryMergeDrawCmds(selfArg)

	selfFin()
}

func (self *DrawList) Destroy() {
	selfArg, selfFin := self.handle()
	C.ImDrawList_destroy(selfArg)

	selfFin()
}

func NewFontAtlasCustomRect() *FontAtlasCustomRect {
	return newFontAtlasCustomRectFromC(C.ImFontAtlasCustomRect_ImFontAtlasCustomRect())
}

func (self *FontAtlasCustomRect) IsPacked() bool {
	selfArg, selfFin := self.handle()

	defer func() {
		selfFin()
	}()
	return C.ImFontAtlasCustomRect_IsPacked(selfArg) == C.bool(true)
}

func (self *FontAtlasCustomRect) Destroy() {
	selfArg, selfFin := self.handle()
	C.ImFontAtlasCustomRect_destroy(selfArg)

	selfFin()
}

// AddCustomRectFontGlyphV parameter default value hint:
// offset: ImVec2(0,0)
func (self *FontAtlas) AddCustomRectFontGlyphV(font *Font, id Wchar, width int32, height int32, advance_x float32, offset Vec2) int32 {
	selfArg, selfFin := self.handle()
	fontArg, fontFin := font.handle()

	defer func() {
		selfFin()
		fontFin()
	}()
	return int32(C.ImFontAtlas_AddCustomRectFontGlyph(selfArg, fontArg, C.ImWchar(id), C.int(width), C.int(height), C.float(advance_x), offset.toC()))
}

func (self *FontAtlas) AddCustomRectRegular(width int32, height int32) int32 {
	selfArg, selfFin := self.handle()

	defer func() {
		selfFin()
	}()
	return int32(C.ImFontAtlas_AddCustomRectRegular(selfArg, C.int(width), C.int(height)))
}

func (self *FontAtlas) AddFont(font_cfg *FontConfig) *Font {
	selfArg, selfFin := self.handle()
	font_cfgArg, font_cfgFin := font_cfg.handle()

	defer func() {
		selfFin()
		font_cfgFin()
	}()
	return newFontFromC(C.ImFontAtlas_AddFont(selfArg, font_cfgArg))
}

// AddFontDefaultV parameter default value hint:
// font_cfg: NULL
func (self *FontAtlas) AddFontDefaultV(font_cfg *FontConfig) *Font {
	selfArg, selfFin := self.handle()
	font_cfgArg, font_cfgFin := font_cfg.handle()

	defer func() {
		selfFin()
		font_cfgFin()
	}()
	return newFontFromC(C.ImFontAtlas_AddFontDefault(selfArg, font_cfgArg))
}

// AddFontFromFileTTFV parameter default value hint:
// font_cfg: NULL
// glyph_ranges: NULL
func (self *FontAtlas) AddFontFromFileTTFV(filename string, size_pixels float32, font_cfg *FontConfig, glyph_ranges *Wchar) *Font {
	selfArg, selfFin := self.handle()
	filenameArg, filenameFin := WrapString(filename)
	font_cfgArg, font_cfgFin := font_cfg.handle()

	defer func() {
		selfFin()
		filenameFin()
		font_cfgFin()
	}()
	return newFontFromC(C.ImFontAtlas_AddFontFromFileTTF(selfArg, filenameArg, C.float(size_pixels), font_cfgArg, (*C.ImWchar)(glyph_ranges)))
}

// 'compressed_font_data_base85' still owned by caller. Compress with binary_to_compressed_c.cpp with -base85 parameter.
// AddFontFromMemoryCompressedBase85TTFV parameter default value hint:
// font_cfg: NULL
// glyph_ranges: NULL
func (self *FontAtlas) AddFontFromMemoryCompressedBase85TTFV(compressed_font_data_base85 string, size_pixels float32, font_cfg *FontConfig, glyph_ranges *Wchar) *Font {
	selfArg, selfFin := self.handle()
	compressed_font_data_base85Arg, compressed_font_data_base85Fin := WrapString(compressed_font_data_base85)
	font_cfgArg, font_cfgFin := font_cfg.handle()

	defer func() {
		selfFin()
		compressed_font_data_base85Fin()
		font_cfgFin()
	}()
	return newFontFromC(C.ImFontAtlas_AddFontFromMemoryCompressedBase85TTF(selfArg, compressed_font_data_base85Arg, C.float(size_pixels), font_cfgArg, (*C.ImWchar)(glyph_ranges)))
}

// 'compressed_font_data' still owned by caller. Compress with binary_to_compressed_c.cpp.
// AddFontFromMemoryCompressedTTFV parameter default value hint:
// font_cfg: NULL
// glyph_ranges: NULL
func (self *FontAtlas) AddFontFromMemoryCompressedTTFV(compressed_font_data unsafe.Pointer, compressed_font_data_size int32, size_pixels float32, font_cfg *FontConfig, glyph_ranges *Wchar) *Font {
	selfArg, selfFin := self.handle()
	font_cfgArg, font_cfgFin := font_cfg.handle()

	defer func() {
		selfFin()
		font_cfgFin()
	}()
	return newFontFromC(C.ImFontAtlas_AddFontFromMemoryCompressedTTF(selfArg, (compressed_font_data), C.int(compressed_font_data_size), C.float(size_pixels), font_cfgArg, (*C.ImWchar)(glyph_ranges)))
}

// Note: Transfer ownership of 'ttf_data' to ImFontAtlas! Will be deleted after destruction of the atlas. Set font_cfg->FontDataOwnedByAtlas=false to keep ownership of your data and it won't be freed.
// AddFontFromMemoryTTFV parameter default value hint:
// font_cfg: NULL
// glyph_ranges: NULL
func (self *FontAtlas) AddFontFromMemoryTTFV(font_data unsafe.Pointer, font_data_size int32, size_pixels float32, font_cfg *FontConfig, glyph_ranges *Wchar) *Font {
	selfArg, selfFin := self.handle()
	font_dataArg, font_dataFin := WrapVoidPtr(font_data)
	font_cfgArg, font_cfgFin := font_cfg.handle()

	defer func() {
		selfFin()
		font_dataFin()
		font_cfgFin()
	}()
	return newFontFromC(C.ImFontAtlas_AddFontFromMemoryTTF(selfArg, font_dataArg, C.int(font_data_size), C.float(size_pixels), font_cfgArg, (*C.ImWchar)(glyph_ranges)))
}

// Build pixels data. This is called automatically for you by the GetTexData*** functions.
func (self *FontAtlas) Build() bool {
	selfArg, selfFin := self.handle()

	defer func() {
		selfFin()
	}()
	return C.ImFontAtlas_Build(selfArg) == C.bool(true)
}

func (self *FontAtlas) CalcCustomRectUV(rect *FontAtlasCustomRect, out_uv_min *Vec2, out_uv_max *Vec2) {
	selfArg, selfFin := self.handle()
	rectArg, rectFin := rect.handle()
	out_uv_minArg, out_uv_minFin := wrap[C.ImVec2, *Vec2](out_uv_min)
	out_uv_maxArg, out_uv_maxFin := wrap[C.ImVec2, *Vec2](out_uv_max)
	C.ImFontAtlas_CalcCustomRectUV(selfArg, rectArg, out_uv_minArg, out_uv_maxArg)

	selfFin()
	rectFin()
	out_uv_minFin()
	out_uv_maxFin()
}

// Clear all input and output.
func (self *FontAtlas) Clear() {
	selfArg, selfFin := self.handle()
	C.ImFontAtlas_Clear(selfArg)

	selfFin()
}

// Clear output font data (glyphs storage, UV coordinates).
func (self *FontAtlas) ClearFonts() {
	selfArg, selfFin := self.handle()
	C.ImFontAtlas_ClearFonts(selfArg)

	selfFin()
}

// Clear input data (all ImFontConfig structures including sizes, TTF data, glyph ranges, etc.) = all the data used to build the texture and fonts.
func (self *FontAtlas) ClearInputData() {
	selfArg, selfFin := self.handle()
	C.ImFontAtlas_ClearInputData(selfArg)

	selfFin()
}

// Clear output texture data (CPU side). Saves RAM once the texture has been copied to graphics memory.
func (self *FontAtlas) ClearTexData() {
	selfArg, selfFin := self.handle()
	C.ImFontAtlas_ClearTexData(selfArg)

	selfFin()
}

func (self *FontAtlas) CustomRectByIndex(index int32) *FontAtlasCustomRect {
	selfArg, selfFin := self.handle()

	defer func() {
		selfFin()
	}()
	return newFontAtlasCustomRectFromC(C.ImFontAtlas_GetCustomRectByIndex(selfArg, C.int(index)))
}

// Default + Half-Width + Japanese Hiragana/Katakana + full set of about 21000 CJK Unified Ideographs
func (self *FontAtlas) GlyphRangesChineseFull() *Wchar {
	selfArg, selfFin := self.handle()

	defer func() {
		selfFin()
	}()
	return (*Wchar)(C.ImFontAtlas_GetGlyphRangesChineseFull(selfArg))
}

// Default + Half-Width + Japanese Hiragana/Katakana + set of 2500 CJK Unified Ideographs for common simplified Chinese
func (self *FontAtlas) GlyphRangesChineseSimplifiedCommon() *Wchar {
	selfArg, selfFin := self.handle()

	defer func() {
		selfFin()
	}()
	return (*Wchar)(C.ImFontAtlas_GetGlyphRangesChineseSimplifiedCommon(selfArg))
}

// Default + about 400 Cyrillic characters
func (self *FontAtlas) GlyphRangesCyrillic() *Wchar {
	selfArg, selfFin := self.handle()

	defer func() {
		selfFin()
	}()
	return (*Wchar)(C.ImFontAtlas_GetGlyphRangesCyrillic(selfArg))
}

// Basic Latin, Extended Latin
func (self *FontAtlas) GlyphRangesDefault() *Wchar {
	selfArg, selfFin := self.handle()

	defer func() {
		selfFin()
	}()
	return (*Wchar)(C.ImFontAtlas_GetGlyphRangesDefault(selfArg))
}

// Default + Greek and Coptic
func (self *FontAtlas) GlyphRangesGreek() *Wchar {
	selfArg, selfFin := self.handle()

	defer func() {
		selfFin()
	}()
	return (*Wchar)(C.ImFontAtlas_GetGlyphRangesGreek(selfArg))
}

// Default + Hiragana, Katakana, Half-Width, Selection of 2999 Ideographs
func (self *FontAtlas) GlyphRangesJapanese() *Wchar {
	selfArg, selfFin := self.handle()

	defer func() {
		selfFin()
	}()
	return (*Wchar)(C.ImFontAtlas_GetGlyphRangesJapanese(selfArg))
}

// Default + Korean characters
func (self *FontAtlas) GlyphRangesKorean() *Wchar {
	selfArg, selfFin := self.handle()

	defer func() {
		selfFin()
	}()
	return (*Wchar)(C.ImFontAtlas_GetGlyphRangesKorean(selfArg))
}

// Default + Thai characters
func (self *FontAtlas) GlyphRangesThai() *Wchar {
	selfArg, selfFin := self.handle()

	defer func() {
		selfFin()
	}()
	return (*Wchar)(C.ImFontAtlas_GetGlyphRangesThai(selfArg))
}

// Default + Vietnamese characters
func (self *FontAtlas) GlyphRangesVietnamese() *Wchar {
	selfArg, selfFin := self.handle()

	defer func() {
		selfFin()
	}()
	return (*Wchar)(C.ImFontAtlas_GetGlyphRangesVietnamese(selfArg))
}

func (self *FontAtlas) MouseCursorTexData(cursor MouseCursor, out_offset *Vec2, out_size *Vec2, out_uv_border [2]*Vec2, out_uv_fill [2]*Vec2) bool {
	selfArg, selfFin := self.handle()
	out_offsetArg, out_offsetFin := wrap[C.ImVec2, *Vec2](out_offset)
	out_sizeArg, out_sizeFin := wrap[C.ImVec2, *Vec2](out_size)
	out_uv_borderArg := make([]C.ImVec2, len(out_uv_border))
	out_uv_borderFin := make([]func(), len(out_uv_border))
	for i, out_uv_borderV := range out_uv_border {
		var tmp *C.ImVec2
		tmp, out_uv_borderFin[i] = wrap[C.ImVec2, *Vec2](out_uv_borderV)
		out_uv_borderArg[i] = *tmp
	}

	out_uv_fillArg := make([]C.ImVec2, len(out_uv_fill))
	out_uv_fillFin := make([]func(), len(out_uv_fill))
	for i, out_uv_fillV := range out_uv_fill {
		var tmp *C.ImVec2
		tmp, out_uv_fillFin[i] = wrap[C.ImVec2, *Vec2](out_uv_fillV)
		out_uv_fillArg[i] = *tmp
	}

	defer func() {
		selfFin()
		out_offsetFin()
		out_sizeFin()

		for _, out_uv_borderV := range out_uv_borderFin {
			out_uv_borderV()
		}

		for _, out_uv_fillV := range out_uv_fillFin {
			out_uv_fillV()
		}
	}()
	return C.ImFontAtlas_GetMouseCursorTexData(selfArg, C.ImGuiMouseCursor(cursor), out_offsetArg, out_sizeArg, (*C.ImVec2)(&out_uv_borderArg[0]), (*C.ImVec2)(&out_uv_fillArg[0])) == C.bool(true)
}

func NewFontAtlas() *FontAtlas {
	return newFontAtlasFromC(C.ImFontAtlas_ImFontAtlas())
}

// Bit ambiguous: used to detect when user didn't build texture but effectively we should check TexID != 0 except that would be backend dependent...
func (self *FontAtlas) IsBuilt() bool {
	selfArg, selfFin := self.handle()

	defer func() {
		selfFin()
	}()
	return C.ImFontAtlas_IsBuilt(selfArg) == C.bool(true)
}

func (self *FontAtlas) SetTexID(id TextureID) {
	selfArg, selfFin := self.handle()
	idArg, idFin := id.c()
	C.ImFontAtlas_SetTexID(selfArg, idArg)

	selfFin()
	idFin()
}

func (self *FontAtlas) Destroy() {
	selfArg, selfFin := self.handle()
	C.ImFontAtlas_destroy(selfArg)

	selfFin()
}

func NewFontConfig() *FontConfig {
	return newFontConfigFromC(C.ImFontConfig_ImFontConfig())
}

func (self *FontConfig) Destroy() {
	selfArg, selfFin := self.handle()
	C.ImFontConfig_destroy(selfArg)

	selfFin()
}

// Add character
func (self *FontGlyphRangesBuilder) AddChar(c Wchar) {
	selfArg, selfFin := self.handle()
	C.ImFontGlyphRangesBuilder_AddChar(selfArg, C.ImWchar(c))

	selfFin()
}

// Add ranges, e.g. builder.AddRanges(ImFontAtlas::GetGlyphRangesDefault()) to force add all of ASCII/Latin+Ext
func (self *FontGlyphRangesBuilder) AddRanges(ranges *Wchar) {
	selfArg, selfFin := self.handle()
	C.ImFontGlyphRangesBuilder_AddRanges(selfArg, (*C.ImWchar)(ranges))

	selfFin()
}

// Add string (each character of the UTF-8 string are added)
// AddTextV parameter default value hint:
func (self *FontGlyphRangesBuilder) AddTextV(text string) {
	selfArg, selfFin := self.handle()
	textArg, textFin := WrapString(text)
	C.wrap_ImFontGlyphRangesBuilder_AddTextV(selfArg, textArg)

	selfFin()
	textFin()
}

func (self *FontGlyphRangesBuilder) Clear() {
	selfArg, selfFin := self.handle()
	C.ImFontGlyphRangesBuilder_Clear(selfArg)

	selfFin()
}

// Get bit n in the array
func (self *FontGlyphRangesBuilder) Bit(n uint64) bool {
	selfArg, selfFin := self.handle()

	defer func() {
		selfFin()
	}()
	return C.ImFontGlyphRangesBuilder_GetBit(selfArg, C.xulong(n)) == C.bool(true)
}

func NewFontGlyphRangesBuilder() *FontGlyphRangesBuilder {
	return newFontGlyphRangesBuilderFromC(C.ImFontGlyphRangesBuilder_ImFontGlyphRangesBuilder())
}

// Set bit n in the array
func (self *FontGlyphRangesBuilder) SetBit(n uint64) {
	selfArg, selfFin := self.handle()
	C.ImFontGlyphRangesBuilder_SetBit(selfArg, C.xulong(n))

	selfFin()
}

func (self *FontGlyphRangesBuilder) Destroy() {
	selfArg, selfFin := self.handle()
	C.ImFontGlyphRangesBuilder_destroy(selfArg)

	selfFin()
}

func (self *Font) AddGlyph(src_cfg *FontConfig, c Wchar, x0 float32, y0 float32, x1 float32, y1 float32, u0 float32, v0 float32, u1 float32, v1 float32, advance_x float32) {
	selfArg, selfFin := self.handle()
	src_cfgArg, src_cfgFin := src_cfg.handle()
	C.ImFont_AddGlyph(selfArg, src_cfgArg, C.ImWchar(c), C.float(x0), C.float(y0), C.float(x1), C.float(y1), C.float(u0), C.float(v0), C.float(u1), C.float(v1), C.float(advance_x))

	selfFin()
	src_cfgFin()
}

// Makes 'dst' character/glyph points to 'src' character/glyph. Currently needs to be called AFTER fonts have been built.
// AddRemapCharV parameter default value hint:
// overwrite_dst: true
func (self *Font) AddRemapCharV(dst Wchar, src Wchar, overwrite_dst bool) {
	selfArg, selfFin := self.handle()
	C.ImFont_AddRemapChar(selfArg, C.ImWchar(dst), C.ImWchar(src), C.bool(overwrite_dst))

	selfFin()
}

func (self *Font) BuildLookupTable() {
	selfArg, selfFin := self.handle()
	C.ImFont_BuildLookupTable(selfArg)

	selfFin()
}

// utf8
// CalcTextSizeAV parameter default value hint:
// remaining: NULL
func (self *Font) CalcTextSizeAV(size float32, max_width float32, wrap_width float32, text_begin string, remaining []string) Vec2 {
	pOut := new(Vec2)
	pOutArg, pOutFin := wrap[C.ImVec2, *Vec2](pOut)

	selfArg, selfFin := self.handle()
	text_beginArg, text_beginFin := WrapString(text_begin)
	remainingArg, remainingFin := WrapStringList(remaining)
	C.wrap_ImFont_CalcTextSizeAV(pOutArg, selfArg, C.float(size), C.float(max_width), C.float(wrap_width), text_beginArg, remainingArg)

	pOutFin()
	selfFin()
	text_beginFin()
	remainingFin()

	return *pOut
}

func (self *Font) CalcWordWrapPositionA(scale float32, text string, wrap_width float32) string {
	selfArg, selfFin := self.handle()
	textArg, textFin := WrapString(text)

	defer func() {
		selfFin()
		textFin()
	}()
	return C.GoString(C.wrap_ImFont_CalcWordWrapPositionA(selfArg, C.float(scale), textArg, C.float(wrap_width)))
}

func (self *Font) ClearOutputData() {
	selfArg, selfFin := self.handle()
	C.ImFont_ClearOutputData(selfArg)

	selfFin()
}

func (self *Font) FindGlyph(c Wchar) *FontGlyph {
	selfArg, selfFin := self.handle()

	defer func() {
		selfFin()
	}()
	return newFontGlyphFromC(C.ImFont_FindGlyph(selfArg, C.ImWchar(c)))
}

func (self *Font) FindGlyphNoFallback(c Wchar) *FontGlyph {
	selfArg, selfFin := self.handle()

	defer func() {
		selfFin()
	}()
	return newFontGlyphFromC(C.ImFont_FindGlyphNoFallback(selfArg, C.ImWchar(c)))
}

func (self *Font) CharAdvance(c Wchar) float32 {
	selfArg, selfFin := self.handle()

	defer func() {
		selfFin()
	}()
	return float32(C.ImFont_GetCharAdvance(selfArg, C.ImWchar(c)))
}

func (self *Font) DebugName() string {
	selfArg, selfFin := self.handle()

	defer func() {
		selfFin()
	}()
	return C.GoString(C.ImFont_GetDebugName(selfArg))
}

func (self *Font) GrowIndex(new_size int32) {
	selfArg, selfFin := self.handle()
	C.ImFont_GrowIndex(selfArg, C.int(new_size))

	selfFin()
}

func NewFont() *Font {
	return newFontFromC(C.ImFont_ImFont())
}

func (self *Font) IsGlyphRangeUnused(c_begin uint32, c_last uint32) bool {
	selfArg, selfFin := self.handle()

	defer func() {
		selfFin()
	}()
	return C.ImFont_IsGlyphRangeUnused(selfArg, C.uint(c_begin), C.uint(c_last)) == C.bool(true)
}

func (self *Font) IsLoaded() bool {
	selfArg, selfFin := self.handle()

	defer func() {
		selfFin()
	}()
	return C.ImFont_IsLoaded(selfArg) == C.bool(true)
}

func (self *Font) RenderChar(draw_list *DrawList, size float32, pos Vec2, col uint32, c Wchar) {
	selfArg, selfFin := self.handle()
	draw_listArg, draw_listFin := draw_list.handle()
	C.ImFont_RenderChar(selfArg, draw_listArg, C.float(size), pos.toC(), C.ImU32(col), C.ImWchar(c))

	selfFin()
	draw_listFin()
}

// RenderTextV parameter default value hint:
// wrap_width: 0.0f
// cpu_fine_clip: false
func (self *Font) RenderTextV(draw_list *DrawList, size float32, pos Vec2, col uint32, clip_rect Vec4, text_begin string, wrap_width float32, cpu_fine_clip bool) {
	selfArg, selfFin := self.handle()
	draw_listArg, draw_listFin := draw_list.handle()
	text_beginArg, text_beginFin := WrapString(text_begin)
	C.wrap_ImFont_RenderTextV(selfArg, draw_listArg, C.float(size), pos.toC(), C.ImU32(col), clip_rect.toC(), text_beginArg, C.float(wrap_width), C.bool(cpu_fine_clip))

	selfFin()
	draw_listFin()
	text_beginFin()
}

func (self *Font) SetGlyphVisible(c Wchar, visible bool) {
	selfArg, selfFin := self.handle()
	C.ImFont_SetGlyphVisible(selfArg, C.ImWchar(c), C.bool(visible))

	selfFin()
}

func (self *Font) Destroy() {
	selfArg, selfFin := self.handle()
	C.ImFont_destroy(selfArg)

	selfFin()
}

func InternalNewComboPreviewData() *ComboPreviewData {
	return newComboPreviewDataFromC(C.ImGuiComboPreviewData_ImGuiComboPreviewData())
}

func (self *ComboPreviewData) Destroy() {
	selfArg, selfFin := self.handle()
	C.ImGuiComboPreviewData_destroy(selfArg)

	selfFin()
}

func InternalNewContextHook() *ContextHook {
	return newContextHookFromC(C.ImGuiContextHook_ImGuiContextHook())
}

func (self *ContextHook) Destroy() {
	selfArg, selfFin := self.handle()
	C.ImGuiContextHook_destroy(selfArg)

	selfFin()
}

// // Different to ensure initial submission
//
//	    PlatformImeViewport = 0;
//
//	    DockNodeWindowMenuHandler =                                    ((void *)0)                                       ;
//
//	    SettingsLoaded = false;
//	    SettingsDirtyTimer = 0.0f;
//	    HookIdNext = 0;
//
//	    memset(LocalizationTable, 0, sizeof(LocalizationTable));
//
//	    LogEnabled = false;
//	    LogType = ImGuiLogType_None;
//	    LogNextPrefix = LogNextSuffix =                                        ((void *)0)                                           ;
//	    LogFile =                  ((void *)0)                     ;
//	    LogLinePosY = 3.40282346638528859811704183484516925e+38F                            ;
//	    LogLineFirstItem = false;
//	    LogDepthRef = 0;
//	    LogDepthToExpand = LogDepthToExpandDefault = 2;
//
//	    DebugLogFlags = ImGuiDebugLogFlags_OutputToTTY;
//	    DebugLocateId = 0;
//	    DebugLogClipperAutoDisableFrames = 0;
//	    DebugLocateFrames = 0;
//	    DebugBeginReturnValueCullDepth = -1;
//	    DebugItemPickerActive = false;
//	    DebugItemPickerMouseButton = ImGuiMouseButton_Left;
//	    DebugItemPickerBreakId = 0;
//	    DebugHoveredDockNode =                               ((void *)0)                                  ;
//
//	    memset(FramerateSecPerFrame, 0, sizeof(FramerateSecPerFrame));
//	    FramerateSecPerFrameIdx = FramerateSecPerFrameCount = 0;
//	    FramerateSecPerFrameAccum = 0.0f;
//	    WantCaptureMouseNextFrame = WantCaptureKeyboardNextFrame = WantTextInputNextFrame = -1;
//	}
func InternalNewContext(shared_font_atlas *FontAtlas) *Context {
	shared_font_atlasArg, shared_font_atlasFin := shared_font_atlas.handle()

	defer func() {
		shared_font_atlasFin()
	}()
	return newContextFromC(C.ImGuiContext_ImGuiContext(shared_font_atlasArg))
}

func (self *Context) Destroy() {
	selfArg, selfFin := self.handle()
	C.ImGuiContext_destroy(selfArg)

	selfFin()
}

func (self *DataVarInfo) InternalVarPtr(parent unsafe.Pointer) unsafe.Pointer {
	selfArg, selfFin := self.handle()
	parentArg, parentFin := WrapVoidPtr(parent)

	defer func() {
		selfFin()
		parentFin()
	}()
	return unsafe.Pointer(C.ImGuiDataVarInfo_GetVarPtr(selfArg, parentArg))
}

func InternalNewDockContext() *DockContext {
	return newDockContextFromC(C.ImGuiDockContext_ImGuiDockContext())
}

func (self *DockContext) Destroy() {
	selfArg, selfFin := self.handle()
	C.ImGuiDockContext_destroy(selfArg)

	selfFin()
}

func InternalNewDockNode(id ID) *DockNode {
	idArg, idFin := id.c()

	defer func() {
		idFin()
	}()
	return newDockNodeFromC(C.ImGuiDockNode_ImGuiDockNode(idArg))
}

func (self *DockNode) InternalIsCentralNode() bool {
	selfArg, selfFin := self.handle()

	defer func() {
		selfFin()
	}()
	return C.ImGuiDockNode_IsCentralNode(selfArg) == C.bool(true)
}

func (self *DockNode) InternalIsDockSpace() bool {
	selfArg, selfFin := self.handle()

	defer func() {
		selfFin()
	}()
	return C.ImGuiDockNode_IsDockSpace(selfArg) == C.bool(true)
}

func (self *DockNode) InternalIsEmpty() bool {
	selfArg, selfFin := self.handle()

	defer func() {
		selfFin()
	}()
	return C.ImGuiDockNode_IsEmpty(selfArg) == C.bool(true)
}

func (self *DockNode) InternalIsFloatingNode() bool {
	selfArg, selfFin := self.handle()

	defer func() {
		selfFin()
	}()
	return C.ImGuiDockNode_IsFloatingNode(selfArg) == C.bool(true)
}

// Hidden tab bar can be shown back by clicking the small triangle
func (self *DockNode) InternalIsHiddenTabBar() bool {
	selfArg, selfFin := self.handle()

	defer func() {
		selfFin()
	}()
	return C.ImGuiDockNode_IsHiddenTabBar(selfArg) == C.bool(true)
}

func (self *DockNode) InternalIsLeafNode() bool {
	selfArg, selfFin := self.handle()

	defer func() {
		selfFin()
	}()
	return C.ImGuiDockNode_IsLeafNode(selfArg) == C.bool(true)
}

// Never show a tab bar
func (self *DockNode) InternalIsNoTabBar() bool {
	selfArg, selfFin := self.handle()

	defer func() {
		selfFin()
	}()
	return C.ImGuiDockNode_IsNoTabBar(selfArg) == C.bool(true)
}

func (self *DockNode) InternalIsRootNode() bool {
	selfArg, selfFin := self.handle()

	defer func() {
		selfFin()
	}()
	return C.ImGuiDockNode_IsRootNode(selfArg) == C.bool(true)
}

func (self *DockNode) InternalIsSplitNode() bool {
	selfArg, selfFin := self.handle()

	defer func() {
		selfFin()
	}()
	return C.ImGuiDockNode_IsSplitNode(selfArg) == C.bool(true)
}

func (self *DockNode) InternalRect() Rect {
	pOut := new(Rect)
	pOutArg, pOutFin := wrap[C.ImRect, *Rect](pOut)

	selfArg, selfFin := self.handle()
	C.ImGuiDockNode_Rect(pOutArg, selfArg)

	pOutFin()
	selfFin()

	return *pOut
}

func (self *DockNode) InternalSetLocalFlags(flags DockNodeFlags) {
	selfArg, selfFin := self.handle()
	C.ImGuiDockNode_SetLocalFlags(selfArg, C.ImGuiDockNodeFlags(flags))

	selfFin()
}

func (self *DockNode) InternalUpdateMergedFlags() {
	selfArg, selfFin := self.handle()
	C.ImGuiDockNode_UpdateMergedFlags(selfArg)

	selfFin()
}

func (self *DockNode) InternalDestroy() {
	selfArg, selfFin := self.handle()
	C.ImGuiDockNode_destroy(selfArg)

	selfFin()
}

// Queue a gain/loss of focus for the application (generally based on OS/platform focus of your window)
func (self *IO) AddFocusEvent(focused bool) {
	selfArg, selfFin := self.handle()
	C.ImGuiIO_AddFocusEvent(selfArg, C.bool(focused))

	selfFin()
}

// Queue a new character input
func (self *IO) AddInputCharacter(c uint32) {
	selfArg, selfFin := self.handle()
	C.ImGuiIO_AddInputCharacter(selfArg, C.uint(c))

	selfFin()
}

// Queue a new character input from a UTF-16 character, it can be a surrogate
func (self *IO) AddInputCharacterUTF16(c uint16) {
	selfArg, selfFin := self.handle()
	C.ImGuiIO_AddInputCharacterUTF16(selfArg, C.ImWchar16(c))

	selfFin()
}

// Queue a new characters input from a UTF-8 string
func (self *IO) AddInputCharactersUTF8(str string) {
	selfArg, selfFin := self.handle()
	strArg, strFin := WrapString(str)
	C.ImGuiIO_AddInputCharactersUTF8(selfArg, strArg)

	selfFin()
	strFin()
}

// Queue a new key down/up event for analog values (e.g. ImGuiKey_Gamepad_ values). Dead-zones should be handled by the backend.
func (self *IO) AddKeyAnalogEvent(key Key, down bool, v float32) {
	selfArg, selfFin := self.handle()
	C.ImGuiIO_AddKeyAnalogEvent(selfArg, C.ImGuiKey(key), C.bool(down), C.float(v))

	selfFin()
}

// Queue a new key down/up event. Key should be "translated" (as in, generally ImGuiKey_A matches the key end-user would use to emit an 'A' character)
func (self *IO) AddKeyEvent(key Key, down bool) {
	selfArg, selfFin := self.handle()
	C.ImGuiIO_AddKeyEvent(selfArg, C.ImGuiKey(key), C.bool(down))

	selfFin()
}

// Queue a mouse button change
func (self *IO) AddMouseButtonEvent(button int32, down bool) {
	selfArg, selfFin := self.handle()
	C.ImGuiIO_AddMouseButtonEvent(selfArg, C.int(button), C.bool(down))

	selfFin()
}

// Queue a mouse position update. Use -FLT_MAX,-FLT_MAX to signify no mouse (e.g. app not focused and not hovered)
func (self *IO) AddMousePosEvent(x float32, y float32) {
	selfArg, selfFin := self.handle()
	C.ImGuiIO_AddMousePosEvent(selfArg, C.float(x), C.float(y))

	selfFin()
}

// Queue a mouse source change (Mouse/TouchScreen/Pen)
func (self *IO) AddMouseSourceEvent(source MouseSource) {
	selfArg, selfFin := self.handle()
	C.ImGuiIO_AddMouseSourceEvent(selfArg, C.ImGuiMouseSource(source))

	selfFin()
}

// Queue a mouse hovered viewport. Requires backend to set ImGuiBackendFlags_HasMouseHoveredViewport to call this (for multi-viewport support).
func (self *IO) AddMouseViewportEvent(id ID) {
	selfArg, selfFin := self.handle()
	idArg, idFin := id.c()
	C.ImGuiIO_AddMouseViewportEvent(selfArg, idArg)

	selfFin()
	idFin()
}

// Queue a mouse wheel update. wheel_y<0: scroll down, wheel_y>0: scroll up, wheel_x<0: scroll right, wheel_x>0: scroll left.
func (self *IO) AddMouseWheelEvent(wheel_x float32, wheel_y float32) {
	selfArg, selfFin := self.handle()
	C.ImGuiIO_AddMouseWheelEvent(selfArg, C.float(wheel_x), C.float(wheel_y))

	selfFin()
}

// Clear all incoming events.
func (self *IO) ClearEventsQueue() {
	selfArg, selfFin := self.handle()
	C.ImGuiIO_ClearEventsQueue(selfArg)

	selfFin()
}

// Clear current keyboard/mouse/gamepad state + current frame text input buffer. Equivalent to releasing all keys/buttons.
func (self *IO) ClearInputKeys() {
	selfArg, selfFin := self.handle()
	C.ImGuiIO_ClearInputKeys(selfArg)

	selfFin()
}

func NewIO() *IO {
	return newIOFromC(C.ImGuiIO_ImGuiIO())
}

// Set master flag for accepting key/mouse/text events (default to true). Useful if you have native dialog boxes that are interrupting your application loop/refresh, and you want to disable events being queued while your app is frozen.
func (self *IO) SetAppAcceptingEvents(accepting_events bool) {
	selfArg, selfFin := self.handle()
	C.ImGuiIO_SetAppAcceptingEvents(selfArg, C.bool(accepting_events))

	selfFin()
}

// [Optional] Specify index for legacy <1.87 IsKeyXXX() functions with native indices + specify native keycode, scancode.
// SetKeyEventNativeDataV parameter default value hint:
// native_legacy_index: -1
func (self *IO) SetKeyEventNativeDataV(key Key, native_keycode int32, native_scancode int32, native_legacy_index int32) {
	selfArg, selfFin := self.handle()
	C.ImGuiIO_SetKeyEventNativeData(selfArg, C.ImGuiKey(key), C.int(native_keycode), C.int(native_scancode), C.int(native_legacy_index))

	selfFin()
}

func (self *IO) Destroy() {
	selfArg, selfFin := self.handle()
	C.ImGuiIO_destroy(selfArg)

	selfFin()
}

func InternalNewInputEvent() *InputEvent {
	return newInputEventFromC(C.ImGuiInputEvent_ImGuiInputEvent())
}

func (self *InputEvent) Destroy() {
	selfArg, selfFin := self.handle()
	C.ImGuiInputEvent_destroy(selfArg)

	selfFin()
}

func (self *InputTextCallbackData) ClearSelection() {
	selfArg, selfFin := self.handle()
	C.ImGuiInputTextCallbackData_ClearSelection(selfArg)

	selfFin()
}

func (self *InputTextCallbackData) DeleteChars(pos int32, bytes_count int32) {
	selfArg, selfFin := self.handle()
	C.ImGuiInputTextCallbackData_DeleteChars(selfArg, C.int(pos), C.int(bytes_count))

	selfFin()
}

func (self *InputTextCallbackData) HasSelection() bool {
	selfArg, selfFin := self.handle()

	defer func() {
		selfFin()
	}()
	return C.ImGuiInputTextCallbackData_HasSelection(selfArg) == C.bool(true)
}

func NewInputTextCallbackData() *InputTextCallbackData {
	return newInputTextCallbackDataFromC(C.ImGuiInputTextCallbackData_ImGuiInputTextCallbackData())
}

// InsertCharsV parameter default value hint:
func (self *InputTextCallbackData) InsertCharsV(pos int32, text string) {
	selfArg, selfFin := self.handle()
	textArg, textFin := WrapString(text)
	C.wrap_ImGuiInputTextCallbackData_InsertCharsV(selfArg, C.int(pos), textArg)

	selfFin()
	textFin()
}

func (self *InputTextCallbackData) SelectAll() {
	selfArg, selfFin := self.handle()
	C.ImGuiInputTextCallbackData_SelectAll(selfArg)

	selfFin()
}

func (self *InputTextCallbackData) Destroy() {
	selfArg, selfFin := self.handle()
	C.ImGuiInputTextCallbackData_destroy(selfArg)

	selfFin()
}

func (self *InputTextDeactivatedState) InternalClearFreeMemory() {
	selfArg, selfFin := self.handle()
	C.ImGuiInputTextDeactivatedState_ClearFreeMemory(selfArg)

	selfFin()
}

func InternalNewInputTextDeactivatedState() *InputTextDeactivatedState {
	return newInputTextDeactivatedStateFromC(C.ImGuiInputTextDeactivatedState_ImGuiInputTextDeactivatedState())
}

func (self *InputTextDeactivatedState) Destroy() {
	selfArg, selfFin := self.handle()
	C.ImGuiInputTextDeactivatedState_destroy(selfArg)

	selfFin()
}

func (self *InputTextState) InternalClearFreeMemory() {
	selfArg, selfFin := self.handle()
	C.ImGuiInputTextState_ClearFreeMemory(selfArg)

	selfFin()
}

func (self *InputTextState) InternalClearSelection() {
	selfArg, selfFin := self.handle()
	C.ImGuiInputTextState_ClearSelection(selfArg)

	selfFin()
}

func (self *InputTextState) InternalClearText() {
	selfArg, selfFin := self.handle()
	C.ImGuiInputTextState_ClearText(selfArg)

	selfFin()
}

// After a user-input the cursor stays on for a while without blinking
func (self *InputTextState) InternalCursorAnimReset() {
	selfArg, selfFin := self.handle()
	C.ImGuiInputTextState_CursorAnimReset(selfArg)

	selfFin()
}

func (self *InputTextState) InternalCursorClamp() {
	selfArg, selfFin := self.handle()
	C.ImGuiInputTextState_CursorClamp(selfArg)

	selfFin()
}

func (self *InputTextState) InternalCursorPos() int32 {
	selfArg, selfFin := self.handle()

	defer func() {
		selfFin()
	}()
	return int32(C.ImGuiInputTextState_GetCursorPos(selfArg))
}

func (self *InputTextState) InternalRedoAvailCount() int32 {
	selfArg, selfFin := self.handle()

	defer func() {
		selfFin()
	}()
	return int32(C.ImGuiInputTextState_GetRedoAvailCount(selfArg))
}

func (self *InputTextState) InternalSelectionEnd() int32 {
	selfArg, selfFin := self.handle()

	defer func() {
		selfFin()
	}()
	return int32(C.ImGuiInputTextState_GetSelectionEnd(selfArg))
}

func (self *InputTextState) InternalSelectionStart() int32 {
	selfArg, selfFin := self.handle()

	defer func() {
		selfFin()
	}()
	return int32(C.ImGuiInputTextState_GetSelectionStart(selfArg))
}

func (self *InputTextState) InternalUndoAvailCount() int32 {
	selfArg, selfFin := self.handle()

	defer func() {
		selfFin()
	}()
	return int32(C.ImGuiInputTextState_GetUndoAvailCount(selfArg))
}

func (self *InputTextState) InternalHasSelection() bool {
	selfArg, selfFin := self.handle()

	defer func() {
		selfFin()
	}()
	return C.ImGuiInputTextState_HasSelection(selfArg) == C.bool(true)
}

func InternalNewInputTextState() *InputTextState {
	return newInputTextStateFromC(C.ImGuiInputTextState_ImGuiInputTextState())
}

// Cannot be inline because we call in code in stb_textedit.h implementation
func (self *InputTextState) InternalOnKeyPressed(key int32) {
	selfArg, selfFin := self.handle()
	C.ImGuiInputTextState_OnKeyPressed(selfArg, C.int(key))

	selfFin()
}

func (self *InputTextState) InternalSelectAll() {
	selfArg, selfFin := self.handle()
	C.ImGuiInputTextState_SelectAll(selfArg)

	selfFin()
}

func (self *InputTextState) Destroy() {
	selfArg, selfFin := self.handle()
	C.ImGuiInputTextState_destroy(selfArg)

	selfFin()
}

func InternalNewKeyOwnerData() *KeyOwnerData {
	return newKeyOwnerDataFromC(C.ImGuiKeyOwnerData_ImGuiKeyOwnerData())
}

func (self *KeyOwnerData) Destroy() {
	selfArg, selfFin := self.handle()
	C.ImGuiKeyOwnerData_destroy(selfArg)

	selfFin()
}

func InternalNewKeyRoutingData() *KeyRoutingData {
	return newKeyRoutingDataFromC(C.ImGuiKeyRoutingData_ImGuiKeyRoutingData())
}

func (self *KeyRoutingData) Destroy() {
	selfArg, selfFin := self.handle()
	C.ImGuiKeyRoutingData_destroy(selfArg)

	selfFin()
}

func (self *KeyRoutingTable) InternalClear() {
	selfArg, selfFin := self.handle()
	C.ImGuiKeyRoutingTable_Clear(selfArg)

	selfFin()
}

func InternalNewKeyRoutingTable() *KeyRoutingTable {
	return newKeyRoutingTableFromC(C.ImGuiKeyRoutingTable_ImGuiKeyRoutingTable())
}

func (self *KeyRoutingTable) Destroy() {
	selfArg, selfFin := self.handle()
	C.ImGuiKeyRoutingTable_destroy(selfArg)

	selfFin()
}

func InternalNewLastItemData() *LastItemData {
	return newLastItemDataFromC(C.ImGuiLastItemData_ImGuiLastItemData())
}

func (self *LastItemData) Destroy() {
	selfArg, selfFin := self.handle()
	C.ImGuiLastItemData_destroy(selfArg)

	selfFin()
}

func InternalNewListClipperData() *ListClipperData {
	return newListClipperDataFromC(C.ImGuiListClipperData_ImGuiListClipperData())
}

func (self *ListClipperData) InternalReset(clipper *ListClipper) {
	selfArg, selfFin := self.handle()
	clipperArg, clipperFin := clipper.handle()
	C.ImGuiListClipperData_Reset(selfArg, clipperArg)

	selfFin()
	clipperFin()
}

func (self *ListClipperData) Destroy() {
	selfArg, selfFin := self.handle()
	C.ImGuiListClipperData_destroy(selfArg)

	selfFin()
}

func InternalListClipperRangeFromIndices(min int32, max int32) ListClipperRange {
	return *newListClipperRangeFromC(func() *C.ImGuiListClipperRange {
		result := C.ImGuiListClipperRange_FromIndices(C.int(min), C.int(max))
		return &result
	}())
}

func InternalListClipperRangeFromPositions(y1 float32, y2 float32, off_min int32, off_max int32) ListClipperRange {
	return *newListClipperRangeFromC(func() *C.ImGuiListClipperRange {
		result := C.ImGuiListClipperRange_FromPositions(C.float(y1), C.float(y2), C.int(off_min), C.int(off_max))
		return &result
	}())
}

// BeginV parameter default value hint:
// items_height: -1.0f
func (self *ListClipper) BeginV(items_count int32, items_height float32) {
	selfArg, selfFin := self.handle()
	C.ImGuiListClipper_Begin(selfArg, C.int(items_count), C.float(items_height))

	selfFin()
}

// Automatically called on the last call of Step() that returns false.
func (self *ListClipper) End() {
	selfArg, selfFin := self.handle()
	C.ImGuiListClipper_End(selfArg)

	selfFin()
}

func NewListClipper() *ListClipper {
	return newListClipperFromC(C.ImGuiListClipper_ImGuiListClipper())
}

func (self *ListClipper) IncludeItemByIndex(item_index int32) {
	selfArg, selfFin := self.handle()
	C.ImGuiListClipper_IncludeItemByIndex(selfArg, C.int(item_index))

	selfFin()
}

// item_end is exclusive e.g. use (42, 42+1) to make item 42 never clipped.
func (self *ListClipper) IncludeItemsByIndex(item_begin int32, item_end int32) {
	selfArg, selfFin := self.handle()
	C.ImGuiListClipper_IncludeItemsByIndex(selfArg, C.int(item_begin), C.int(item_end))

	selfFin()
}

// Call until it returns false. The DisplayStart/DisplayEnd fields will be set and you can process/draw those items.
func (self *ListClipper) Step() bool {
	selfArg, selfFin := self.handle()

	defer func() {
		selfFin()
	}()
	return C.ImGuiListClipper_Step(selfArg) == C.bool(true)
}

func (self *ListClipper) Destroy() {
	selfArg, selfFin := self.handle()
	C.ImGuiListClipper_destroy(selfArg)

	selfFin()
}

func (self *MenuColumns) InternalCalcNextTotalWidth(update_offsets bool) {
	selfArg, selfFin := self.handle()
	C.ImGuiMenuColumns_CalcNextTotalWidth(selfArg, C.bool(update_offsets))

	selfFin()
}

func (self *MenuColumns) InternalDeclColumns(w_icon float32, w_label float32, w_shortcut float32, w_mark float32) float32 {
	selfArg, selfFin := self.handle()

	defer func() {
		selfFin()
	}()
	return float32(C.ImGuiMenuColumns_DeclColumns(selfArg, C.float(w_icon), C.float(w_label), C.float(w_shortcut), C.float(w_mark)))
}

func InternalNewMenuColumns() *MenuColumns {
	return newMenuColumnsFromC(C.ImGuiMenuColumns_ImGuiMenuColumns())
}

func (self *MenuColumns) InternalUpdate(spacing float32, window_reappearing bool) {
	selfArg, selfFin := self.handle()
	C.ImGuiMenuColumns_Update(selfArg, C.float(spacing), C.bool(window_reappearing))

	selfFin()
}

func (self *MenuColumns) Destroy() {
	selfArg, selfFin := self.handle()
	C.ImGuiMenuColumns_destroy(selfArg)

	selfFin()
}

func (self *NavItemData) InternalClear() {
	selfArg, selfFin := self.handle()
	C.ImGuiNavItemData_Clear(selfArg)

	selfFin()
}

func InternalNewNavItemData() *NavItemData {
	return newNavItemDataFromC(C.ImGuiNavItemData_ImGuiNavItemData())
}

func (self *NavItemData) Destroy() {
	selfArg, selfFin := self.handle()
	C.ImGuiNavItemData_destroy(selfArg)

	selfFin()
}

// Also cleared manually by ItemAdd()!
func (self *NextItemData) InternalClearFlags() {
	selfArg, selfFin := self.handle()
	C.ImGuiNextItemData_ClearFlags(selfArg)

	selfFin()
}

func InternalNewNextItemData() *NextItemData {
	return newNextItemDataFromC(C.ImGuiNextItemData_ImGuiNextItemData())
}

func (self *NextItemData) Destroy() {
	selfArg, selfFin := self.handle()
	C.ImGuiNextItemData_destroy(selfArg)

	selfFin()
}

func (self *NextWindowData) InternalClearFlags() {
	selfArg, selfFin := self.handle()
	C.ImGuiNextWindowData_ClearFlags(selfArg)

	selfFin()
}

func InternalNewNextWindowData() *NextWindowData {
	return newNextWindowDataFromC(C.ImGuiNextWindowData_ImGuiNextWindowData())
}

func (self *NextWindowData) Destroy() {
	selfArg, selfFin := self.handle()
	C.ImGuiNextWindowData_destroy(selfArg)

	selfFin()
}

func InternalNewOldColumnData() *OldColumnData {
	return newOldColumnDataFromC(C.ImGuiOldColumnData_ImGuiOldColumnData())
}

func (self *OldColumnData) Destroy() {
	selfArg, selfFin := self.handle()
	C.ImGuiOldColumnData_destroy(selfArg)

	selfFin()
}

func InternalNewOldColumns() *OldColumns {
	return newOldColumnsFromC(C.ImGuiOldColumns_ImGuiOldColumns())
}

func (self *OldColumns) Destroy() {
	selfArg, selfFin := self.handle()
	C.ImGuiOldColumns_destroy(selfArg)

	selfFin()
}

func NewOnceUponAFrame() *OnceUponAFrame {
	return newOnceUponAFrameFromC(C.ImGuiOnceUponAFrame_ImGuiOnceUponAFrame())
}

func (self *OnceUponAFrame) Destroy() {
	selfArg, selfFin := self.handle()
	C.ImGuiOnceUponAFrame_destroy(selfArg)

	selfFin()
}

func (self *Payload) Clear() {
	selfArg, selfFin := self.handle()
	C.ImGuiPayload_Clear(selfArg)

	selfFin()
}

func NewPayload() *Payload {
	return newPayloadFromC(C.ImGuiPayload_ImGuiPayload())
}

func (self *Payload) IsDataType(typeArg string) bool {
	selfArg, selfFin := self.handle()
	typeArgArg, typeArgFin := WrapString(typeArg)

	defer func() {
		selfFin()
		typeArgFin()
	}()
	return C.ImGuiPayload_IsDataType(selfArg, typeArgArg) == C.bool(true)
}

func (self *Payload) IsDelivery() bool {
	selfArg, selfFin := self.handle()

	defer func() {
		selfFin()
	}()
	return C.ImGuiPayload_IsDelivery(selfArg) == C.bool(true)
}

func (self *Payload) IsPreview() bool {
	selfArg, selfFin := self.handle()

	defer func() {
		selfFin()
	}()
	return C.ImGuiPayload_IsPreview(selfArg) == C.bool(true)
}

func (self *Payload) Destroy() {
	selfArg, selfFin := self.handle()
	C.ImGuiPayload_destroy(selfArg)

	selfFin()
}

// Zero clear
func NewPlatformIO() *PlatformIO {
	return newPlatformIOFromC(C.ImGuiPlatformIO_ImGuiPlatformIO())
}

func (self *PlatformIO) Destroy() {
	selfArg, selfFin := self.handle()
	C.ImGuiPlatformIO_destroy(selfArg)

	selfFin()
}

func NewPlatformImeData() *PlatformImeData {
	return newPlatformImeDataFromC(C.ImGuiPlatformImeData_ImGuiPlatformImeData())
}

func (self *PlatformImeData) Destroy() {
	selfArg, selfFin := self.handle()
	C.ImGuiPlatformImeData_destroy(selfArg)

	selfFin()
}

func NewPlatformMonitor() *PlatformMonitor {
	return newPlatformMonitorFromC(C.ImGuiPlatformMonitor_ImGuiPlatformMonitor())
}

func (self *PlatformMonitor) Destroy() {
	selfArg, selfFin := self.handle()
	C.ImGuiPlatformMonitor_destroy(selfArg)

	selfFin()
}

func InternalNewPopupData() *PopupData {
	return newPopupDataFromC(C.ImGuiPopupData_ImGuiPopupData())
}

func (self *PopupData) Destroy() {
	selfArg, selfFin := self.handle()
	C.ImGuiPopupData_destroy(selfArg)

	selfFin()
}

func InternalNewPtrOrIndexInt(index int32) *PtrOrIndex {
	return newPtrOrIndexFromC(C.ImGuiPtrOrIndex_ImGuiPtrOrIndex_Int(C.int(index)))
}

func InternalNewPtrOrIndexPtr(ptr unsafe.Pointer) *PtrOrIndex {
	ptrArg, ptrFin := WrapVoidPtr(ptr)

	defer func() {
		ptrFin()
	}()
	return newPtrOrIndexFromC(C.ImGuiPtrOrIndex_ImGuiPtrOrIndex_Ptr(ptrArg))
}

func (self *PtrOrIndex) Destroy() {
	selfArg, selfFin := self.handle()
	C.ImGuiPtrOrIndex_destroy(selfArg)

	selfFin()
}

func InternalNewSettingsHandler() *SettingsHandler {
	return newSettingsHandlerFromC(C.ImGuiSettingsHandler_ImGuiSettingsHandler())
}

func (self *SettingsHandler) Destroy() {
	selfArg, selfFin := self.handle()
	C.ImGuiSettingsHandler_destroy(selfArg)

	selfFin()
}

func InternalNewStackLevelInfo() *StackLevelInfo {
	return newStackLevelInfoFromC(C.ImGuiStackLevelInfo_ImGuiStackLevelInfo())
}

func (self *StackLevelInfo) Destroy() {
	selfArg, selfFin := self.handle()
	C.ImGuiStackLevelInfo_destroy(selfArg)

	selfFin()
}

func (self *StackSizes) InternalCompareWithContextState(ctx *Context) {
	selfArg, selfFin := self.handle()
	ctxArg, ctxFin := ctx.handle()
	C.ImGuiStackSizes_CompareWithContextState(selfArg, ctxArg)

	selfFin()
	ctxFin()
}

func InternalNewStackSizes() *StackSizes {
	return newStackSizesFromC(C.ImGuiStackSizes_ImGuiStackSizes())
}

func (self *StackSizes) InternalSetToContextState(ctx *Context) {
	selfArg, selfFin := self.handle()
	ctxArg, ctxFin := ctx.handle()
	C.ImGuiStackSizes_SetToContextState(selfArg, ctxArg)

	selfFin()
	ctxFin()
}

func (self *StackSizes) Destroy() {
	selfArg, selfFin := self.handle()
	C.ImGuiStackSizes_destroy(selfArg)

	selfFin()
}

func InternalNewStackTool() *StackTool {
	return newStackToolFromC(C.ImGuiStackTool_ImGuiStackTool())
}

func (self *StackTool) Destroy() {
	selfArg, selfFin := self.handle()
	C.ImGuiStackTool_destroy(selfArg)

	selfFin()
}

func NewStoragePairFloat(_key ID, _val_f float32) *StoragePair {
	_keyArg, _keyFin := _key.c()

	defer func() {
		_keyFin()
	}()
	return newStoragePairFromC(C.ImGuiStoragePair_ImGuiStoragePair_Float(_keyArg, C.float(_val_f)))
}

func NewStoragePairInt(_key ID, _val_i int32) *StoragePair {
	_keyArg, _keyFin := _key.c()

	defer func() {
		_keyFin()
	}()
	return newStoragePairFromC(C.ImGuiStoragePair_ImGuiStoragePair_Int(_keyArg, C.int(_val_i)))
}

func NewStoragePairPtr(_key ID, _val_p unsafe.Pointer) *StoragePair {
	_keyArg, _keyFin := _key.c()
	_val_pArg, _val_pFin := WrapVoidPtr(_val_p)

	defer func() {
		_keyFin()
		_val_pFin()
	}()
	return newStoragePairFromC(C.ImGuiStoragePair_ImGuiStoragePair_Ptr(_keyArg, _val_pArg))
}

func (self *StoragePair) Destroy() {
	selfArg, selfFin := self.handle()
	C.ImGuiStoragePair_destroy(selfArg)

	selfFin()
}

func (self *Storage) BuildSortByKey() {
	selfArg, selfFin := self.handle()
	C.ImGuiStorage_BuildSortByKey(selfArg)

	selfFin()
}

func (self *Storage) Clear() {
	selfArg, selfFin := self.handle()
	C.ImGuiStorage_Clear(selfArg)

	selfFin()
}

// BoolV parameter default value hint:
// default_val: false
func (self *Storage) BoolV(key ID, default_val bool) bool {
	selfArg, selfFin := self.handle()
	keyArg, keyFin := key.c()

	defer func() {
		selfFin()
		keyFin()
	}()
	return C.ImGuiStorage_GetBool(selfArg, keyArg, C.bool(default_val)) == C.bool(true)
}

// FloatV parameter default value hint:
// default_val: 0.0f
func (self *Storage) FloatV(key ID, default_val float32) float32 {
	selfArg, selfFin := self.handle()
	keyArg, keyFin := key.c()

	defer func() {
		selfFin()
		keyFin()
	}()
	return float32(C.ImGuiStorage_GetFloat(selfArg, keyArg, C.float(default_val)))
}

// FloatRefV parameter default value hint:
// default_val: 0.0f
func (self *Storage) FloatRefV(key ID, default_val float32) *float32 {
	selfArg, selfFin := self.handle()
	keyArg, keyFin := key.c()

	defer func() {
		selfFin()
		keyFin()
	}()
	return (*float32)(C.ImGuiStorage_GetFloatRef(selfArg, keyArg, C.float(default_val)))
}

// IntV parameter default value hint:
// default_val: 0
func (self *Storage) IntV(key ID, default_val int32) int32 {
	selfArg, selfFin := self.handle()
	keyArg, keyFin := key.c()

	defer func() {
		selfFin()
		keyFin()
	}()
	return int32(C.ImGuiStorage_GetInt(selfArg, keyArg, C.int(default_val)))
}

// IntRefV parameter default value hint:
// default_val: 0
func (self *Storage) IntRefV(key ID, default_val int32) *int32 {
	selfArg, selfFin := self.handle()
	keyArg, keyFin := key.c()

	defer func() {
		selfFin()
		keyFin()
	}()
	return (*int32)(C.ImGuiStorage_GetIntRef(selfArg, keyArg, C.int(default_val)))
}

// default_val is NULL
func (self *Storage) VoidPtr(key ID) unsafe.Pointer {
	selfArg, selfFin := self.handle()
	keyArg, keyFin := key.c()

	defer func() {
		selfFin()
		keyFin()
	}()
	return unsafe.Pointer(C.ImGuiStorage_GetVoidPtr(selfArg, keyArg))
}

func (self *Storage) SetAllInt(val int32) {
	selfArg, selfFin := self.handle()
	C.ImGuiStorage_SetAllInt(selfArg, C.int(val))

	selfFin()
}

func (self *Storage) SetBool(key ID, val bool) {
	selfArg, selfFin := self.handle()
	keyArg, keyFin := key.c()
	C.ImGuiStorage_SetBool(selfArg, keyArg, C.bool(val))

	selfFin()
	keyFin()
}

func (self *Storage) SetFloat(key ID, val float32) {
	selfArg, selfFin := self.handle()
	keyArg, keyFin := key.c()
	C.ImGuiStorage_SetFloat(selfArg, keyArg, C.float(val))

	selfFin()
	keyFin()
}

func (self *Storage) SetInt(key ID, val int32) {
	selfArg, selfFin := self.handle()
	keyArg, keyFin := key.c()
	C.ImGuiStorage_SetInt(selfArg, keyArg, C.int(val))

	selfFin()
	keyFin()
}

func (self *Storage) SetVoidPtr(key ID, val unsafe.Pointer) {
	selfArg, selfFin := self.handle()
	keyArg, keyFin := key.c()
	valArg, valFin := WrapVoidPtr(val)
	C.ImGuiStorage_SetVoidPtr(selfArg, keyArg, valArg)

	selfFin()
	keyFin()
	valFin()
}

func InternalNewStyleModFloat(idx StyleVar, v float32) *StyleMod {
	return newStyleModFromC(C.ImGuiStyleMod_ImGuiStyleMod_Float(C.ImGuiStyleVar(idx), C.float(v)))
}

func InternalNewStyleModInt(idx StyleVar, v int32) *StyleMod {
	return newStyleModFromC(C.ImGuiStyleMod_ImGuiStyleMod_Int(C.ImGuiStyleVar(idx), C.int(v)))
}

func InternalNewStyleModVec2(idx StyleVar, v Vec2) *StyleMod {
	return newStyleModFromC(C.ImGuiStyleMod_ImGuiStyleMod_Vec2(C.ImGuiStyleVar(idx), v.toC()))
}

func (self *StyleMod) Destroy() {
	selfArg, selfFin := self.handle()
	C.ImGuiStyleMod_destroy(selfArg)

	selfFin()
}

func NewStyle() *Style {
	return newStyleFromC(C.ImGuiStyle_ImGuiStyle())
}

func (self *Style) ScaleAllSizes(scale_factor float32) {
	selfArg, selfFin := self.handle()
	C.ImGuiStyle_ScaleAllSizes(selfArg, C.float(scale_factor))

	selfFin()
}

func (self *Style) Destroy() {
	selfArg, selfFin := self.handle()
	C.ImGuiStyle_destroy(selfArg)

	selfFin()
}

func InternalNewTabBar() *TabBar {
	return newTabBarFromC(C.ImGuiTabBar_ImGuiTabBar())
}

func (self *TabBar) Destroy() {
	selfArg, selfFin := self.handle()
	C.ImGuiTabBar_destroy(selfArg)

	selfFin()
}

func InternalNewTabItem() *TabItem {
	return newTabItemFromC(C.ImGuiTabItem_ImGuiTabItem())
}

func (self *TabItem) Destroy() {
	selfArg, selfFin := self.handle()
	C.ImGuiTabItem_destroy(selfArg)

	selfFin()
}

func InternalNewTableColumnSettings() *TableColumnSettings {
	return newTableColumnSettingsFromC(C.ImGuiTableColumnSettings_ImGuiTableColumnSettings())
}

func (self *TableColumnSettings) Destroy() {
	selfArg, selfFin := self.handle()
	C.ImGuiTableColumnSettings_destroy(selfArg)

	selfFin()
}

func NewTableColumnSortSpecs() *TableColumnSortSpecs {
	return newTableColumnSortSpecsFromC(C.ImGuiTableColumnSortSpecs_ImGuiTableColumnSortSpecs())
}

func (self *TableColumnSortSpecs) Destroy() {
	selfArg, selfFin := self.handle()
	C.ImGuiTableColumnSortSpecs_destroy(selfArg)

	selfFin()
}

func InternalNewTableColumn() *TableColumn {
	return newTableColumnFromC(C.ImGuiTableColumn_ImGuiTableColumn())
}

func (self *TableColumn) Destroy() {
	selfArg, selfFin := self.handle()
	C.ImGuiTableColumn_destroy(selfArg)

	selfFin()
}

func InternalNewTableInstanceData() *TableInstanceData {
	return newTableInstanceDataFromC(C.ImGuiTableInstanceData_ImGuiTableInstanceData())
}

func (self *TableInstanceData) Destroy() {
	selfArg, selfFin := self.handle()
	C.ImGuiTableInstanceData_destroy(selfArg)

	selfFin()
}

func (self *TableSettings) InternalColumnSettings() *TableColumnSettings {
	selfArg, selfFin := self.handle()

	defer func() {
		selfFin()
	}()
	return newTableColumnSettingsFromC(C.ImGuiTableSettings_GetColumnSettings(selfArg))
}

func InternalNewTableSettings() *TableSettings {
	return newTableSettingsFromC(C.ImGuiTableSettings_ImGuiTableSettings())
}

func (self *TableSettings) Destroy() {
	selfArg, selfFin := self.handle()
	C.ImGuiTableSettings_destroy(selfArg)

	selfFin()
}

func NewTableSortSpecs() *TableSortSpecs {
	return newTableSortSpecsFromC(C.ImGuiTableSortSpecs_ImGuiTableSortSpecs())
}

func (self *TableSortSpecs) Destroy() {
	selfArg, selfFin := self.handle()
	C.ImGuiTableSortSpecs_destroy(selfArg)

	selfFin()
}

func InternalNewTableTempData() *TableTempData {
	return newTableTempDataFromC(C.ImGuiTableTempData_ImGuiTableTempData())
}

func (self *TableTempData) Destroy() {
	selfArg, selfFin := self.handle()
	C.ImGuiTableTempData_destroy(selfArg)

	selfFin()
}

func InternalNewTable() *Table {
	return newTableFromC(C.ImGuiTable_ImGuiTable())
}

func (self *Table) InternalDestroy() {
	selfArg, selfFin := self.handle()
	C.ImGuiTable_destroy(selfArg)

	selfFin()
}

func NewTextBuffer() *TextBuffer {
	return newTextBufferFromC(C.ImGuiTextBuffer_ImGuiTextBuffer())
}

// AppendV parameter default value hint:
// str_end: NULL
func (self *TextBuffer) AppendV(str string, str_end string) {
	selfArg, selfFin := self.handle()
	strArg, strFin := WrapString(str)
	str_endArg, str_endFin := WrapString(str_end)
	C.ImGuiTextBuffer_append(selfArg, strArg, str_endArg)

	selfFin()
	strFin()
	str_endFin()
}

func (self *TextBuffer) Appendf(fmt string) {
	selfArg, selfFin := self.handle()
	fmtArg, fmtFin := WrapString(fmt)
	C.wrap_ImGuiTextBuffer_Appendf(selfArg, fmtArg)

	selfFin()
	fmtFin()
}

func (self *TextBuffer) Begin() string {
	selfArg, selfFin := self.handle()

	defer func() {
		selfFin()
	}()
	return C.GoString(C.ImGuiTextBuffer_begin(selfArg))
}

func (self *TextBuffer) cstr() string {
	selfArg, selfFin := self.handle()

	defer func() {
		selfFin()
	}()
	return C.GoString(C.ImGuiTextBuffer_c_str(selfArg))
}

func (self *TextBuffer) Clear() {
	selfArg, selfFin := self.handle()
	C.ImGuiTextBuffer_clear(selfArg)

	selfFin()
}

func (self *TextBuffer) Destroy() {
	selfArg, selfFin := self.handle()
	C.ImGuiTextBuffer_destroy(selfArg)

	selfFin()
}

func (self *TextBuffer) Empty() bool {
	selfArg, selfFin := self.handle()

	defer func() {
		selfFin()
	}()
	return C.ImGuiTextBuffer_empty(selfArg) == C.bool(true)
}

// Buf is zero-terminated, so end() will point on the zero-terminator
func (self *TextBuffer) End() string {
	selfArg, selfFin := self.handle()

	defer func() {
		selfFin()
	}()
	return C.GoString(C.ImGuiTextBuffer_end(selfArg))
}

func (self *TextBuffer) Reserve(capacity int32) {
	selfArg, selfFin := self.handle()
	C.ImGuiTextBuffer_reserve(selfArg, C.int(capacity))

	selfFin()
}

func (self *TextBuffer) Size() int32 {
	selfArg, selfFin := self.handle()

	defer func() {
		selfFin()
	}()
	return int32(C.ImGuiTextBuffer_size(selfArg))
}

func (self *TextFilter) Build() {
	selfArg, selfFin := self.handle()
	C.ImGuiTextFilter_Build(selfArg)

	selfFin()
}

func (self *TextFilter) Clear() {
	selfArg, selfFin := self.handle()
	C.ImGuiTextFilter_Clear(selfArg)

	selfFin()
}

// Helper calling InputText+Build
// DrawV parameter default value hint:
// label: "Filter(inc,-exc)"
// width: 0.0f
func (self *TextFilter) DrawV(label string, width float32) bool {
	selfArg, selfFin := self.handle()
	labelArg, labelFin := WrapString(label)

	defer func() {
		selfFin()
		labelFin()
	}()
	return C.ImGuiTextFilter_Draw(selfArg, labelArg, C.float(width)) == C.bool(true)
}

// NewTextFilter parameter default value hint:
// default_filter: ""
func NewTextFilter(default_filter string) *TextFilter {
	default_filterArg, default_filterFin := WrapString(default_filter)

	defer func() {
		default_filterFin()
	}()
	return newTextFilterFromC(C.ImGuiTextFilter_ImGuiTextFilter(default_filterArg))
}

func (self *TextFilter) IsActive() bool {
	selfArg, selfFin := self.handle()

	defer func() {
		selfFin()
	}()
	return C.ImGuiTextFilter_IsActive(selfArg) == C.bool(true)
}

// PassFilterV parameter default value hint:
func (self *TextFilter) PassFilterV(text string) bool {
	selfArg, selfFin := self.handle()
	textArg, textFin := WrapString(text)

	defer func() {
		selfFin()
		textFin()
	}()
	return C.wrap_ImGuiTextFilter_PassFilterV(selfArg, textArg) == C.bool(true)
}

func (self *TextFilter) Destroy() {
	selfArg, selfFin := self.handle()
	C.ImGuiTextFilter_destroy(selfArg)

	selfFin()
}

func (self *TextIndex) InternalAppend(base string, old_size int32, new_size int32) {
	selfArg, selfFin := self.handle()
	baseArg, baseFin := WrapString(base)
	C.ImGuiTextIndex_append(selfArg, baseArg, C.int(old_size), C.int(new_size))

	selfFin()
	baseFin()
}

func (self *TextIndex) InternalClear() {
	selfArg, selfFin := self.handle()
	C.ImGuiTextIndex_clear(selfArg)

	selfFin()
}

func (self *TextIndex) Internalgetlinebegin(base string, n int32) string {
	selfArg, selfFin := self.handle()
	baseArg, baseFin := WrapString(base)

	defer func() {
		selfFin()
		baseFin()
	}()
	return C.GoString(C.ImGuiTextIndex_get_line_begin(selfArg, baseArg, C.int(n)))
}

func (self *TextIndex) Internalgetlineend(base string, n int32) string {
	selfArg, selfFin := self.handle()
	baseArg, baseFin := WrapString(base)

	defer func() {
		selfFin()
		baseFin()
	}()
	return C.GoString(C.ImGuiTextIndex_get_line_end(selfArg, baseArg, C.int(n)))
}

func (self *TextIndex) InternalSize() int32 {
	selfArg, selfFin := self.handle()

	defer func() {
		selfFin()
	}()
	return int32(C.ImGuiTextIndex_size(selfArg))
}

func NewTextRangeNil() *TextRange {
	return newTextRangeFromC(C.ImGuiTextRange_ImGuiTextRange_Nil())
}

func NewTextRangeStr(_b string, _e string) *TextRange {
	_bArg, _bFin := WrapString(_b)
	_eArg, _eFin := WrapString(_e)

	defer func() {
		_bFin()
		_eFin()
	}()
	return newTextRangeFromC(C.ImGuiTextRange_ImGuiTextRange_Str(_bArg, _eArg))
}

func (self *TextRange) Destroy() {
	selfArg, selfFin := self.handle()
	C.ImGuiTextRange_destroy(selfArg)

	selfFin()
}

func (self *TextRange) Empty() bool {
	selfArg, selfFin := self.handle()

	defer func() {
		selfFin()
	}()
	return C.ImGuiTextRange_empty(selfArg) == C.bool(true)
}

// We preserve remaining data for easier debugging
func (self *TypingSelectState) InternalClear() {
	selfArg, selfFin := self.handle()
	C.ImGuiTypingSelectState_Clear(selfArg)

	selfFin()
}

func InternalNewTypingSelectState() *TypingSelectState {
	return newTypingSelectStateFromC(C.ImGuiTypingSelectState_ImGuiTypingSelectState())
}

func (self *TypingSelectState) Destroy() {
	selfArg, selfFin := self.handle()
	C.ImGuiTypingSelectState_destroy(selfArg)

	selfFin()
}

func (self *ViewportP) InternalCalcWorkRectPos(off_min Vec2) Vec2 {
	pOut := new(Vec2)
	pOutArg, pOutFin := wrap[C.ImVec2, *Vec2](pOut)

	selfArg, selfFin := self.handle()
	C.ImGuiViewportP_CalcWorkRectPos(pOutArg, selfArg, off_min.toC())

	pOutFin()
	selfFin()

	return *pOut
}

func (self *ViewportP) InternalCalcWorkRectSize(off_min Vec2, off_max Vec2) Vec2 {
	pOut := new(Vec2)
	pOutArg, pOutFin := wrap[C.ImVec2, *Vec2](pOut)

	selfArg, selfFin := self.handle()
	C.ImGuiViewportP_CalcWorkRectSize(pOutArg, selfArg, off_min.toC(), off_max.toC())

	pOutFin()
	selfFin()

	return *pOut
}

func (self *ViewportP) InternalClearRequestFlags() {
	selfArg, selfFin := self.handle()
	C.ImGuiViewportP_ClearRequestFlags(selfArg)

	selfFin()
}

func (self *ViewportP) InternalBuildWorkRect() Rect {
	pOut := new(Rect)
	pOutArg, pOutFin := wrap[C.ImRect, *Rect](pOut)

	selfArg, selfFin := self.handle()
	C.ImGuiViewportP_GetBuildWorkRect(pOutArg, selfArg)

	pOutFin()
	selfFin()

	return *pOut
}

func (self *ViewportP) InternalMainRect() Rect {
	pOut := new(Rect)
	pOutArg, pOutFin := wrap[C.ImRect, *Rect](pOut)

	selfArg, selfFin := self.handle()
	C.ImGuiViewportP_GetMainRect(pOutArg, selfArg)

	pOutFin()
	selfFin()

	return *pOut
}

func (self *ViewportP) InternalWorkRect() Rect {
	pOut := new(Rect)
	pOutArg, pOutFin := wrap[C.ImRect, *Rect](pOut)

	selfArg, selfFin := self.handle()
	C.ImGuiViewportP_GetWorkRect(pOutArg, selfArg)

	pOutFin()
	selfFin()

	return *pOut
}

func InternalNewViewportP() *ViewportP {
	return newViewportPFromC(C.ImGuiViewportP_ImGuiViewportP())
}

// Update public fields
func (self *ViewportP) InternalUpdateWorkRect() {
	selfArg, selfFin := self.handle()
	C.ImGuiViewportP_UpdateWorkRect(selfArg)

	selfFin()
}

func (self *ViewportP) InternalDestroy() {
	selfArg, selfFin := self.handle()
	C.ImGuiViewportP_destroy(selfArg)

	selfFin()
}

func (self *Viewport) Center() Vec2 {
	pOut := new(Vec2)
	pOutArg, pOutFin := wrap[C.ImVec2, *Vec2](pOut)

	selfArg, selfFin := self.handle()
	C.ImGuiViewport_GetCenter(pOutArg, selfArg)

	pOutFin()
	selfFin()

	return *pOut
}

func (self *Viewport) WorkCenter() Vec2 {
	pOut := new(Vec2)
	pOutArg, pOutFin := wrap[C.ImVec2, *Vec2](pOut)

	selfArg, selfFin := self.handle()
	C.ImGuiViewport_GetWorkCenter(pOutArg, selfArg)

	pOutFin()
	selfFin()

	return *pOut
}

func NewViewport() *Viewport {
	return newViewportFromC(C.ImGuiViewport_ImGuiViewport())
}

func (self *Viewport) Destroy() {
	selfArg, selfFin := self.handle()
	C.ImGuiViewport_destroy(selfArg)

	selfFin()
}

func NewWindowClass() *WindowClass {
	return newWindowClassFromC(C.ImGuiWindowClass_ImGuiWindowClass())
}

func (self *WindowClass) Destroy() {
	selfArg, selfFin := self.handle()
	C.ImGuiWindowClass_destroy(selfArg)

	selfFin()
}

func (self *WindowSettings) InternalName() string {
	selfArg, selfFin := self.handle()

	defer func() {
		selfFin()
	}()
	return C.GoString(C.ImGuiWindowSettings_GetName(selfArg))
}

func InternalNewWindowSettings() *WindowSettings {
	return newWindowSettingsFromC(C.ImGuiWindowSettings_ImGuiWindowSettings())
}

func (self *WindowSettings) Destroy() {
	selfArg, selfFin := self.handle()
	C.ImGuiWindowSettings_destroy(selfArg)

	selfFin()
}

func (self *Window) InternalCalcFontSize() float32 {
	selfArg, selfFin := self.handle()

	defer func() {
		selfFin()
	}()
	return float32(C.ImGuiWindow_CalcFontSize(selfArg))
}

func (self *Window) InternalIDFromRectangle(r_abs Rect) ID {
	selfArg, selfFin := self.handle()

	defer func() {
		selfFin()
	}()
	return *newIDFromC(func() *C.ImGuiID { result := C.ImGuiWindow_GetIDFromRectangle(selfArg, r_abs.toC()); return &result }())
}

func (self *Window) InternalIDInt(n int32) ID {
	selfArg, selfFin := self.handle()

	defer func() {
		selfFin()
	}()
	return *newIDFromC(func() *C.ImGuiID { result := C.ImGuiWindow_GetID_Int(selfArg, C.int(n)); return &result }())
}

func (self *Window) InternalIDPtr(ptr unsafe.Pointer) ID {
	selfArg, selfFin := self.handle()

	defer func() {
		selfFin()
	}()
	return *newIDFromC(func() *C.ImGuiID { result := C.ImGuiWindow_GetID_Ptr(selfArg, (ptr)); return &result }())
}

// InternalIDStrV parameter default value hint:
// str_end: NULL
func (self *Window) InternalIDStrV(str string, str_end string) ID {
	selfArg, selfFin := self.handle()
	strArg, strFin := WrapString(str)
	str_endArg, str_endFin := WrapString(str_end)

	defer func() {
		selfFin()
		strFin()
		str_endFin()
	}()
	return *newIDFromC(func() *C.ImGuiID { result := C.ImGuiWindow_GetID_Str(selfArg, strArg, str_endArg); return &result }())
}

func InternalNewWindow(context *Context, name string) *Window {
	contextArg, contextFin := context.handle()
	nameArg, nameFin := WrapString(name)

	defer func() {
		contextFin()
		nameFin()
	}()
	return newWindowFromC(C.ImGuiWindow_ImGuiWindow(contextArg, nameArg))
}

func (self *Window) InternalMenuBarHeight() float32 {
	selfArg, selfFin := self.handle()

	defer func() {
		selfFin()
	}()
	return float32(C.ImGuiWindow_MenuBarHeight(selfArg))
}

func (self *Window) InternalMenuBarRect() Rect {
	pOut := new(Rect)
	pOutArg, pOutFin := wrap[C.ImRect, *Rect](pOut)

	selfArg, selfFin := self.handle()
	C.ImGuiWindow_MenuBarRect(pOutArg, selfArg)

	pOutFin()
	selfFin()

	return *pOut
}

func (self *Window) InternalRect() Rect {
	pOut := new(Rect)
	pOutArg, pOutFin := wrap[C.ImRect, *Rect](pOut)

	selfArg, selfFin := self.handle()
	C.ImGuiWindow_Rect(pOutArg, selfArg)

	pOutFin()
	selfFin()

	return *pOut
}

func (self *Window) InternalTitleBarHeight() float32 {
	selfArg, selfFin := self.handle()

	defer func() {
		selfFin()
	}()
	return float32(C.ImGuiWindow_TitleBarHeight(selfArg))
}

func (self *Window) InternalTitleBarRect() Rect {
	pOut := new(Rect)
	pOutArg, pOutFin := wrap[C.ImRect, *Rect](pOut)

	selfArg, selfFin := self.handle()
	C.ImGuiWindow_TitleBarRect(pOutArg, selfArg)

	pOutFin()
	selfFin()

	return *pOut
}

func (self *Window) InternalDestroy() {
	selfArg, selfFin := self.handle()
	C.ImGuiWindow_destroy(selfArg)

	selfFin()
}

func (self *Rect) InternalAddRect(r Rect) {
	selfArg, selfFin := wrap[C.ImRect, *Rect](self)
	C.ImRect_Add_Rect(selfArg, r.toC())

	selfFin()
}

func (self *Rect) InternalAddVec2(p Vec2) {
	selfArg, selfFin := wrap[C.ImRect, *Rect](self)
	C.ImRect_Add_Vec2(selfArg, p.toC())

	selfFin()
}

// Simple version, may lead to an inverted rectangle, which is fine for Contains/Overlaps test but not for display.
func (self *Rect) InternalClipWith(r Rect) {
	selfArg, selfFin := wrap[C.ImRect, *Rect](self)
	C.ImRect_ClipWith(selfArg, r.toC())

	selfFin()
}

// Full version, ensure both points are fully clipped.
func (self *Rect) InternalClipWithFull(r Rect) {
	selfArg, selfFin := wrap[C.ImRect, *Rect](self)
	C.ImRect_ClipWithFull(selfArg, r.toC())

	selfFin()
}

func (self *Rect) InternalContainsRect(r Rect) bool {
	selfArg, selfFin := wrap[C.ImRect, *Rect](self)

	defer func() {
		selfFin()
	}()
	return C.ImRect_Contains_Rect(selfArg, r.toC()) == C.bool(true)
}

func (self *Rect) InternalContainsVec2(p Vec2) bool {
	selfArg, selfFin := wrap[C.ImRect, *Rect](self)

	defer func() {
		selfFin()
	}()
	return C.ImRect_Contains_Vec2(selfArg, p.toC()) == C.bool(true)
}

func (self *Rect) InternalExpandFloat(amount float32) {
	selfArg, selfFin := wrap[C.ImRect, *Rect](self)
	C.ImRect_Expand_Float(selfArg, C.float(amount))

	selfFin()
}

func (self *Rect) InternalExpandVec2(amount Vec2) {
	selfArg, selfFin := wrap[C.ImRect, *Rect](self)
	C.ImRect_Expand_Vec2(selfArg, amount.toC())

	selfFin()
}

func (self *Rect) InternalFloor() {
	selfArg, selfFin := wrap[C.ImRect, *Rect](self)
	C.ImRect_Floor(selfArg)

	selfFin()
}

func (self *Rect) InternalArea() float32 {
	selfArg, selfFin := wrap[C.ImRect, *Rect](self)

	defer func() {
		selfFin()
	}()
	return float32(C.ImRect_GetArea(selfArg))
}

// Bottom-left
func (self *Rect) InternalBL() Vec2 {
	pOut := new(Vec2)
	pOutArg, pOutFin := wrap[C.ImVec2, *Vec2](pOut)

	selfArg, selfFin := wrap[C.ImRect, *Rect](self)
	C.ImRect_GetBL(pOutArg, selfArg)

	pOutFin()
	selfFin()

	return *pOut
}

// Bottom-right
func (self *Rect) InternalBR() Vec2 {
	pOut := new(Vec2)
	pOutArg, pOutFin := wrap[C.ImVec2, *Vec2](pOut)

	selfArg, selfFin := wrap[C.ImRect, *Rect](self)
	C.ImRect_GetBR(pOutArg, selfArg)

	pOutFin()
	selfFin()

	return *pOut
}

func (self *Rect) InternalCenter() Vec2 {
	pOut := new(Vec2)
	pOutArg, pOutFin := wrap[C.ImVec2, *Vec2](pOut)

	selfArg, selfFin := wrap[C.ImRect, *Rect](self)
	C.ImRect_GetCenter(pOutArg, selfArg)

	pOutFin()
	selfFin()

	return *pOut
}

func (self *Rect) InternalHeight() float32 {
	selfArg, selfFin := wrap[C.ImRect, *Rect](self)

	defer func() {
		selfFin()
	}()
	return float32(C.ImRect_GetHeight(selfArg))
}

func (self *Rect) InternalSize() Vec2 {
	pOut := new(Vec2)
	pOutArg, pOutFin := wrap[C.ImVec2, *Vec2](pOut)

	selfArg, selfFin := wrap[C.ImRect, *Rect](self)
	C.ImRect_GetSize(pOutArg, selfArg)

	pOutFin()
	selfFin()

	return *pOut
}

// Top-left
func (self *Rect) InternalTL() Vec2 {
	pOut := new(Vec2)
	pOutArg, pOutFin := wrap[C.ImVec2, *Vec2](pOut)

	selfArg, selfFin := wrap[C.ImRect, *Rect](self)
	C.ImRect_GetTL(pOutArg, selfArg)

	pOutFin()
	selfFin()

	return *pOut
}

// Top-right
func (self *Rect) InternalTR() Vec2 {
	pOut := new(Vec2)
	pOutArg, pOutFin := wrap[C.ImVec2, *Vec2](pOut)

	selfArg, selfFin := wrap[C.ImRect, *Rect](self)
	C.ImRect_GetTR(pOutArg, selfArg)

	pOutFin()
	selfFin()

	return *pOut
}

func (self *Rect) InternalWidth() float32 {
	selfArg, selfFin := wrap[C.ImRect, *Rect](self)

	defer func() {
		selfFin()
	}()
	return float32(C.ImRect_GetWidth(selfArg))
}

func (self *Rect) InternalIsInverted() bool {
	selfArg, selfFin := wrap[C.ImRect, *Rect](self)

	defer func() {
		selfFin()
	}()
	return C.ImRect_IsInverted(selfArg) == C.bool(true)
}

func (self *Rect) InternalOverlaps(r Rect) bool {
	selfArg, selfFin := wrap[C.ImRect, *Rect](self)

	defer func() {
		selfFin()
	}()
	return C.ImRect_Overlaps(selfArg, r.toC()) == C.bool(true)
}

func (self *Rect) InternalToVec4() Vec4 {
	pOut := new(Vec4)
	pOutArg, pOutFin := wrap[C.ImVec4, *Vec4](pOut)

	selfArg, selfFin := wrap[C.ImRect, *Rect](self)
	C.ImRect_ToVec4(pOutArg, selfArg)

	pOutFin()
	selfFin()

	return *pOut
}

func (self *Rect) InternalTranslate(d Vec2) {
	selfArg, selfFin := wrap[C.ImRect, *Rect](self)
	C.ImRect_Translate(selfArg, d.toC())

	selfFin()
}

func (self *Rect) InternalTranslateX(dx float32) {
	selfArg, selfFin := wrap[C.ImRect, *Rect](self)
	C.ImRect_TranslateX(selfArg, C.float(dx))

	selfFin()
}

func (self *Rect) InternalTranslateY(dy float32) {
	selfArg, selfFin := wrap[C.ImRect, *Rect](self)
	C.ImRect_TranslateY(selfArg, C.float(dy))

	selfFin()
}

func (self *Rect) Destroy() {
	selfArg, selfFin := wrap[C.ImRect, *Rect](self)
	C.ImRect_destroy(selfArg)

	selfFin()
}

func InternalNewVec1Float(_x float32) *Vec1 {
	return newVec1FromC(C.ImVec1_ImVec1_Float(C.float(_x)))
}

func InternalNewVec1Nil() *Vec1 {
	return newVec1FromC(C.ImVec1_ImVec1_Nil())
}

func (self *Vec1) Destroy() {
	selfArg, selfFin := self.handle()
	C.ImVec1_destroy(selfArg)

	selfFin()
}

func (self *Vec2) Destroy() {
	selfArg, selfFin := wrap[C.ImVec2, *Vec2](self)
	C.ImVec2_destroy(selfArg)

	selfFin()
}

func (self *Vec4) Destroy() {
	selfArg, selfFin := wrap[C.ImVec4, *Vec4](self)
	C.ImVec4_destroy(selfArg)

	selfFin()
}

// accept contents of a given type. If ImGuiDragDropFlags_AcceptBeforeDelivery is set you can peek into the payload before the mouse button is released.
// AcceptDragDropPayloadV parameter default value hint:
// flags: 0
func AcceptDragDropPayloadV(typeArg string, flags DragDropFlags) *Payload {
	typeArgArg, typeArgFin := WrapString(typeArg)

	defer func() {
		typeArgFin()
	}()
	return newPayloadFromC(C.igAcceptDragDropPayload(typeArgArg, C.ImGuiDragDropFlags(flags)))
}

// Activate an item by ID (button, checkbox, tree node etc.). Activation is queued and processed on the next frame when the item is encountered again.
func InternalActivateItemByID(id ID) {
	idArg, idFin := id.c()
	C.igActivateItemByID(idArg)

	idFin()
}

func InternalAddContextHook(context *Context, hook *ContextHook) ID {
	contextArg, contextFin := context.handle()
	hookArg, hookFin := hook.handle()

	defer func() {
		contextFin()
		hookFin()
	}()
	return *newIDFromC(func() *C.ImGuiID { result := C.igAddContextHook(contextArg, hookArg); return &result }())
}

func InternalAddSettingsHandler(handler *SettingsHandler) {
	handlerArg, handlerFin := handler.handle()
	C.igAddSettingsHandler(handlerArg)

	handlerFin()
}

// vertically align upcoming text baseline to FramePadding.y so that it will align properly to regularly framed items (call if you have text on a line before a framed item)
func AlignTextToFramePadding() {
	C.igAlignTextToFramePadding()
}

// square button with an arrow shape
func ArrowButton(str_id string, dir Dir) bool {
	str_idArg, str_idFin := WrapString(str_id)

	defer func() {
		str_idFin()
	}()
	return C.igArrowButton(str_idArg, C.ImGuiDir(dir)) == C.bool(true)
}

// InternalArrowButtonExV parameter default value hint:
// flags: 0
func InternalArrowButtonExV(str_id string, dir Dir, size_arg Vec2, flags ButtonFlags) bool {
	str_idArg, str_idFin := WrapString(str_id)

	defer func() {
		str_idFin()
	}()
	return C.igArrowButtonEx(str_idArg, C.ImGuiDir(dir), size_arg.toC(), C.ImGuiButtonFlags(flags)) == C.bool(true)
}

// BeginV parameter default value hint:
// p_open: NULL
// flags: 0
func BeginV(name string, p_open *bool, flags WindowFlags) bool {
	nameArg, nameFin := WrapString(name)
	p_openArg, p_openFin := WrapBool(p_open)

	defer func() {
		nameFin()
		p_openFin()
	}()
	return C.igBegin(nameArg, p_openArg, C.ImGuiWindowFlags(flags)) == C.bool(true)
}

func InternalBeginChildEx(name string, id ID, size_arg Vec2, border bool, flags WindowFlags) bool {
	nameArg, nameFin := WrapString(name)
	idArg, idFin := id.c()

	defer func() {
		nameFin()
		idFin()
	}()
	return C.igBeginChildEx(nameArg, idArg, size_arg.toC(), C.bool(border), C.ImGuiWindowFlags(flags)) == C.bool(true)
}

// helper to create a child window / scrolling region that looks like a normal widget frame
// BeginChildFrameV parameter default value hint:
// flags: 0
func BeginChildFrameV(id ID, size Vec2, flags WindowFlags) bool {
	idArg, idFin := id.c()

	defer func() {
		idFin()
	}()
	return C.igBeginChildFrame(idArg, size.toC(), C.ImGuiWindowFlags(flags)) == C.bool(true)
}

// BeginChildIDV parameter default value hint:
// size: ImVec2(0,0)
// border: false
// flags: 0
func BeginChildIDV(id ID, size Vec2, border bool, flags WindowFlags) bool {
	idArg, idFin := id.c()

	defer func() {
		idFin()
	}()
	return C.igBeginChild_ID(idArg, size.toC(), C.bool(border), C.ImGuiWindowFlags(flags)) == C.bool(true)
}

// BeginChildStrV parameter default value hint:
// size: ImVec2(0,0)
// border: false
// flags: 0
func BeginChildStrV(str_id string, size Vec2, border bool, flags WindowFlags) bool {
	str_idArg, str_idFin := WrapString(str_id)

	defer func() {
		str_idFin()
	}()
	return C.igBeginChild_Str(str_idArg, size.toC(), C.bool(border), C.ImGuiWindowFlags(flags)) == C.bool(true)
}

// setup number of columns. use an identifier to distinguish multiple column sets. close with EndColumns().
// InternalBeginColumnsV parameter default value hint:
// flags: 0
func InternalBeginColumnsV(str_id string, count int32, flags OldColumnFlags) {
	str_idArg, str_idFin := WrapString(str_id)
	C.igBeginColumns(str_idArg, C.int(count), C.ImGuiOldColumnFlags(flags))

	str_idFin()
}

// BeginComboV parameter default value hint:
// flags: 0
func BeginComboV(label string, preview_value string, flags ComboFlags) bool {
	labelArg, labelFin := WrapString(label)
	preview_valueArg, preview_valueFin := WrapString(preview_value)

	defer func() {
		labelFin()
		preview_valueFin()
	}()
	return C.igBeginCombo(labelArg, preview_valueArg, C.ImGuiComboFlags(flags)) == C.bool(true)
}

func InternalBeginComboPopup(popup_id ID, bb Rect, flags ComboFlags) bool {
	popup_idArg, popup_idFin := popup_id.c()

	defer func() {
		popup_idFin()
	}()
	return C.igBeginComboPopup(popup_idArg, bb.toC(), C.ImGuiComboFlags(flags)) == C.bool(true)
}

func InternalBeginComboPreview() bool {
	return C.igBeginComboPreview() == C.bool(true)
}

// BeginDisabledV parameter default value hint:
// disabled: true
func BeginDisabledV(disabled bool) {
	C.igBeginDisabled(C.bool(disabled))
}

func InternalBeginDockableDragDropSource(window *Window) {
	windowArg, windowFin := window.handle()
	C.igBeginDockableDragDropSource(windowArg)

	windowFin()
}

func InternalBeginDockableDragDropTarget(window *Window) {
	windowArg, windowFin := window.handle()
	C.igBeginDockableDragDropTarget(windowArg)

	windowFin()
}

func InternalBeginDocked(window *Window, p_open *bool) {
	windowArg, windowFin := window.handle()
	p_openArg, p_openFin := WrapBool(p_open)
	C.igBeginDocked(windowArg, p_openArg)

	windowFin()
	p_openFin()
}

// call after submitting an item which may be dragged. when this return true, you can call SetDragDropPayload() + EndDragDropSource()
// BeginDragDropSourceV parameter default value hint:
// flags: 0
func BeginDragDropSourceV(flags DragDropFlags) bool {
	return C.igBeginDragDropSource(C.ImGuiDragDropFlags(flags)) == C.bool(true)
}

// call after submitting an item that may receive a payload. If this returns true, you can call AcceptDragDropPayload() + EndDragDropTarget()
func BeginDragDropTarget() bool {
	return C.igBeginDragDropTarget() == C.bool(true)
}

func InternalBeginDragDropTargetCustom(bb Rect, id ID) bool {
	idArg, idFin := id.c()

	defer func() {
		idFin()
	}()
	return C.igBeginDragDropTargetCustom(bb.toC(), idArg) == C.bool(true)
}

// lock horizontal starting position
func BeginGroup() {
	C.igBeginGroup()
}

// begin/append a tooltip window if preceding item was hovered.
func BeginItemTooltip() bool {
	return C.igBeginItemTooltip() == C.bool(true)
}

// open a framed scrolling region
// BeginListBoxV parameter default value hint:
// size: ImVec2(0,0)
func BeginListBoxV(label string, size Vec2) bool {
	labelArg, labelFin := WrapString(label)

	defer func() {
		labelFin()
	}()
	return C.igBeginListBox(labelArg, size.toC()) == C.bool(true)
}

// create and append to a full screen menu-bar.
func BeginMainMenuBar() bool {
	return C.igBeginMainMenuBar() == C.bool(true)
}

// create a sub-menu entry. only call EndMenu() if this returns true!
// BeginMenuV parameter default value hint:
// enabled: true
func BeginMenuV(label string, enabled bool) bool {
	labelArg, labelFin := WrapString(label)

	defer func() {
		labelFin()
	}()
	return C.igBeginMenu(labelArg, C.bool(enabled)) == C.bool(true)
}

// append to menu-bar of current window (requires ImGuiWindowFlags_MenuBar flag set on parent window).
func BeginMenuBar() bool {
	return C.igBeginMenuBar() == C.bool(true)
}

// InternalBeginMenuExV parameter default value hint:
// enabled: true
func InternalBeginMenuExV(label string, icon string, enabled bool) bool {
	labelArg, labelFin := WrapString(label)
	iconArg, iconFin := WrapString(icon)

	defer func() {
		labelFin()
		iconFin()
	}()
	return C.igBeginMenuEx(labelArg, iconArg, C.bool(enabled)) == C.bool(true)
}

// return true if the popup is open, and you can start outputting to it.
// BeginPopupV parameter default value hint:
// flags: 0
func BeginPopupV(str_id string, flags WindowFlags) bool {
	str_idArg, str_idFin := WrapString(str_id)

	defer func() {
		str_idFin()
	}()
	return C.igBeginPopup(str_idArg, C.ImGuiWindowFlags(flags)) == C.bool(true)
}

// open+begin popup when clicked on last item. Use str_id==NULL to associate the popup to previous item. If you want to use that on a non-interactive item such as Text() you need to pass in an explicit ID here. read comments in .cpp!
// BeginPopupContextItemV parameter default value hint:
// str_id: NULL
// popup_flags: 1
func BeginPopupContextItemV(str_id string, popup_flags PopupFlags) bool {
	str_idArg, str_idFin := WrapString(str_id)

	defer func() {
		str_idFin()
	}()
	return C.igBeginPopupContextItem(str_idArg, C.ImGuiPopupFlags(popup_flags)) == C.bool(true)
}

// open+begin popup when clicked in void (where there are no windows).
// BeginPopupContextVoidV parameter default value hint:
// str_id: NULL
// popup_flags: 1
func BeginPopupContextVoidV(str_id string, popup_flags PopupFlags) bool {
	str_idArg, str_idFin := WrapString(str_id)

	defer func() {
		str_idFin()
	}()
	return C.igBeginPopupContextVoid(str_idArg, C.ImGuiPopupFlags(popup_flags)) == C.bool(true)
}

// open+begin popup when clicked on current window.
// BeginPopupContextWindowV parameter default value hint:
// str_id: NULL
// popup_flags: 1
func BeginPopupContextWindowV(str_id string, popup_flags PopupFlags) bool {
	str_idArg, str_idFin := WrapString(str_id)

	defer func() {
		str_idFin()
	}()
	return C.igBeginPopupContextWindow(str_idArg, C.ImGuiPopupFlags(popup_flags)) == C.bool(true)
}

func InternalBeginPopupEx(id ID, extra_flags WindowFlags) bool {
	idArg, idFin := id.c()

	defer func() {
		idFin()
	}()
	return C.igBeginPopupEx(idArg, C.ImGuiWindowFlags(extra_flags)) == C.bool(true)
}

// return true if the modal is open, and you can start outputting to it.
// BeginPopupModalV parameter default value hint:
// p_open: NULL
// flags: 0
func BeginPopupModalV(name string, p_open *bool, flags WindowFlags) bool {
	nameArg, nameFin := WrapString(name)
	p_openArg, p_openFin := WrapBool(p_open)

	defer func() {
		nameFin()
		p_openFin()
	}()
	return C.igBeginPopupModal(nameArg, p_openArg, C.ImGuiWindowFlags(flags)) == C.bool(true)
}

// create and append into a TabBar
// BeginTabBarV parameter default value hint:
// flags: 0
func BeginTabBarV(str_id string, flags TabBarFlags) bool {
	str_idArg, str_idFin := WrapString(str_id)

	defer func() {
		str_idFin()
	}()
	return C.igBeginTabBar(str_idArg, C.ImGuiTabBarFlags(flags)) == C.bool(true)
}

func InternalBeginTabBarEx(tab_bar *TabBar, bb Rect, flags TabBarFlags) bool {
	tab_barArg, tab_barFin := tab_bar.handle()

	defer func() {
		tab_barFin()
	}()
	return C.igBeginTabBarEx(tab_barArg, bb.toC(), C.ImGuiTabBarFlags(flags)) == C.bool(true)
}

// create a Tab. Returns true if the Tab is selected.
// BeginTabItemV parameter default value hint:
// p_open: NULL
// flags: 0
func BeginTabItemV(label string, p_open *bool, flags TabItemFlags) bool {
	labelArg, labelFin := WrapString(label)
	p_openArg, p_openFin := WrapBool(p_open)

	defer func() {
		labelFin()
		p_openFin()
	}()
	return C.igBeginTabItem(labelArg, p_openArg, C.ImGuiTabItemFlags(flags)) == C.bool(true)
}

// BeginTableV parameter default value hint:
// flags: 0
// outer_size: ImVec2(0.0f,0.0f)
// inner_width: 0.0f
func BeginTableV(str_id string, column int32, flags TableFlags, outer_size Vec2, inner_width float32) bool {
	str_idArg, str_idFin := WrapString(str_id)

	defer func() {
		str_idFin()
	}()
	return C.igBeginTable(str_idArg, C.int(column), C.ImGuiTableFlags(flags), outer_size.toC(), C.float(inner_width)) == C.bool(true)
}

// InternalBeginTableExV parameter default value hint:
// flags: 0
// outer_size: ImVec2(0,0)
// inner_width: 0.0f
func InternalBeginTableExV(name string, id ID, columns_count int32, flags TableFlags, outer_size Vec2, inner_width float32) bool {
	nameArg, nameFin := WrapString(name)
	idArg, idFin := id.c()

	defer func() {
		nameFin()
		idFin()
	}()
	return C.igBeginTableEx(nameArg, idArg, C.int(columns_count), C.ImGuiTableFlags(flags), outer_size.toC(), C.float(inner_width)) == C.bool(true)
}

// begin/append a tooltip window.
func BeginTooltip() bool {
	return C.igBeginTooltip() == C.bool(true)
}

func InternalBeginTooltipEx(tooltip_flags TooltipFlags, extra_window_flags WindowFlags) bool {
	return C.igBeginTooltipEx(C.ImGuiTooltipFlags(tooltip_flags), C.ImGuiWindowFlags(extra_window_flags)) == C.bool(true)
}

func InternalBeginViewportSideBar(name string, viewport *Viewport, dir Dir, size float32, window_flags WindowFlags) bool {
	nameArg, nameFin := WrapString(name)
	viewportArg, viewportFin := viewport.handle()

	defer func() {
		nameFin()
		viewportFin()
	}()
	return C.igBeginViewportSideBar(nameArg, viewportArg, C.ImGuiDir(dir), C.float(size), C.ImGuiWindowFlags(window_flags)) == C.bool(true)
}

func InternalBringWindowToDisplayBack(window *Window) {
	windowArg, windowFin := window.handle()
	C.igBringWindowToDisplayBack(windowArg)

	windowFin()
}

func InternalBringWindowToDisplayBehind(window *Window, above_window *Window) {
	windowArg, windowFin := window.handle()
	above_windowArg, above_windowFin := above_window.handle()
	C.igBringWindowToDisplayBehind(windowArg, above_windowArg)

	windowFin()
	above_windowFin()
}

func InternalBringWindowToDisplayFront(window *Window) {
	windowArg, windowFin := window.handle()
	C.igBringWindowToDisplayFront(windowArg)

	windowFin()
}

func InternalBringWindowToFocusFront(window *Window) {
	windowArg, windowFin := window.handle()
	C.igBringWindowToFocusFront(windowArg)

	windowFin()
}

// draw a small circle + keep the cursor on the same line. advance cursor x position by GetTreeNodeToLabelSpacing(), same distance that TreeNode() uses
func Bullet() {
	C.igBullet()
}

// shortcut for Bullet()+Text()
func BulletText(fmt string) {
	fmtArg, fmtFin := WrapString(fmt)
	C.wrap_igBulletText(fmtArg)

	fmtFin()
}

// button
// ButtonV parameter default value hint:
// size: ImVec2(0,0)
func ButtonV(label string, size Vec2) bool {
	labelArg, labelFin := WrapString(label)

	defer func() {
		labelFin()
	}()
	return C.igButton(labelArg, size.toC()) == C.bool(true)
}

// InternalButtonBehaviorV parameter default value hint:
// flags: 0
func InternalButtonBehaviorV(bb Rect, id ID, out_hovered *bool, out_held *bool, flags ButtonFlags) bool {
	idArg, idFin := id.c()
	out_hoveredArg, out_hoveredFin := WrapBool(out_hovered)
	out_heldArg, out_heldFin := WrapBool(out_held)

	defer func() {
		idFin()
		out_hoveredFin()
		out_heldFin()
	}()
	return C.igButtonBehavior(bb.toC(), idArg, out_hoveredArg, out_heldArg, C.ImGuiButtonFlags(flags)) == C.bool(true)
}

// InternalButtonExV parameter default value hint:
// size_arg: ImVec2(0,0)
// flags: 0
func InternalButtonExV(label string, size_arg Vec2, flags ButtonFlags) bool {
	labelArg, labelFin := WrapString(label)

	defer func() {
		labelFin()
	}()
	return C.igButtonEx(labelArg, size_arg.toC(), C.ImGuiButtonFlags(flags)) == C.bool(true)
}

func InternalCalcItemSize(size Vec2, default_w float32, default_h float32) Vec2 {
	pOut := new(Vec2)
	pOutArg, pOutFin := wrap[C.ImVec2, *Vec2](pOut)

	C.igCalcItemSize(pOutArg, size.toC(), C.float(default_w), C.float(default_h))

	pOutFin()

	return *pOut
}

// width of item given pushed settings and current cursor position. NOT necessarily the width of last item unlike most 'Item' functions.
func CalcItemWidth() float32 {
	return float32(C.igCalcItemWidth())
}

func InternalCalcRoundingFlagsForRectInRect(r_in Rect, r_outer Rect, threshold float32) DrawFlags {
	return DrawFlags(C.igCalcRoundingFlagsForRectInRect(r_in.toC(), r_outer.toC(), C.float(threshold)))
}

// CalcTextSizeV parameter default value hint:
// hide_text_after_double_hash: false
// wrap_width: -1.0f
func CalcTextSizeV(text string, hide_text_after_double_hash bool, wrap_width float32) Vec2 {
	pOut := new(Vec2)
	pOutArg, pOutFin := wrap[C.ImVec2, *Vec2](pOut)

	textArg, textFin := WrapString(text)
	C.wrap_igCalcTextSizeV(pOutArg, textArg, C.bool(hide_text_after_double_hash), C.float(wrap_width))

	pOutFin()
	textFin()

	return *pOut
}

func InternalCalcTypematicRepeatAmount(t0 float32, t1 float32, repeat_delay float32, repeat_rate float32) int32 {
	return int32(C.igCalcTypematicRepeatAmount(C.float(t0), C.float(t1), C.float(repeat_delay), C.float(repeat_rate)))
}

func InternalCalcWindowNextAutoFitSize(window *Window) Vec2 {
	pOut := new(Vec2)
	pOutArg, pOutFin := wrap[C.ImVec2, *Vec2](pOut)

	windowArg, windowFin := window.handle()
	C.igCalcWindowNextAutoFitSize(pOutArg, windowArg)

	pOutFin()
	windowFin()

	return *pOut
}

func InternalCalcWrapWidthForPos(pos Vec2, wrap_pos_x float32) float32 {
	return float32(C.igCalcWrapWidthForPos(pos.toC(), C.float(wrap_pos_x)))
}

func InternalCallContextHooks(context *Context, typeArg ContextHookType) {
	contextArg, contextFin := context.handle()
	C.igCallContextHooks(contextArg, C.ImGuiContextHookType(typeArg))

	contextFin()
}

func Checkbox(label string, v *bool) bool {
	labelArg, labelFin := WrapString(label)
	vArg, vFin := WrapBool(v)

	defer func() {
		labelFin()
		vFin()
	}()
	return C.igCheckbox(labelArg, vArg) == C.bool(true)
}

func CheckboxFlagsIntPtr(label string, flags *int32, flags_value int32) bool {
	labelArg, labelFin := WrapString(label)
	flagsArg, flagsFin := WrapNumberPtr[C.int, int32](flags)

	defer func() {
		labelFin()
		flagsFin()
	}()
	return C.igCheckboxFlags_IntPtr(labelArg, flagsArg, C.int(flags_value)) == C.bool(true)
}

func InternalCheckboxFlagsS64Ptr(label string, flags *int64, flags_value int64) bool {
	labelArg, labelFin := WrapString(label)
	flagsArg, flagsFin := WrapNumberPtr[C.ImS64, int64](flags)

	defer func() {
		labelFin()
		flagsFin()
	}()
	return C.igCheckboxFlags_S64Ptr(labelArg, flagsArg, C.ImS64(flags_value)) == C.bool(true)
}

func InternalCheckboxFlagsU64Ptr(label string, flags *[]uint64, flags_value uint64) bool {
	labelArg, labelFin := WrapString(label)
	flagsArg := make([]C.ImU64, len(*flags))
	for i, flagsV := range *flags {
		flagsArg[i] = C.ImU64(flagsV)
	}

	defer func() {
		labelFin()

		for i, flagsV := range flagsArg {
			(*flags)[i] = uint64(flagsV)
		}
	}()
	return C.igCheckboxFlags_U64Ptr(labelArg, (*C.ImU64)(&flagsArg[0]), C.ImU64(flags_value)) == C.bool(true)
}

func CheckboxFlagsUintPtr(label string, flags *uint32, flags_value uint32) bool {
	labelArg, labelFin := WrapString(label)
	flagsArg, flagsFin := WrapNumberPtr[C.uint, uint32](flags)

	defer func() {
		labelFin()
		flagsFin()
	}()
	return C.igCheckboxFlags_UintPtr(labelArg, flagsArg, C.uint(flags_value)) == C.bool(true)
}

func InternalClearActiveID() {
	C.igClearActiveID()
}

func InternalClearDragDrop() {
	C.igClearDragDrop()
}

func InternalClearIniSettings() {
	C.igClearIniSettings()
}

func InternalClearWindowSettings(name string) {
	nameArg, nameFin := WrapString(name)
	C.igClearWindowSettings(nameArg)

	nameFin()
}

func InternalCloseButton(id ID, pos Vec2) bool {
	idArg, idFin := id.c()

	defer func() {
		idFin()
	}()
	return C.igCloseButton(idArg, pos.toC()) == C.bool(true)
}

// manually close the popup we have begin-ed into.
func CloseCurrentPopup() {
	C.igCloseCurrentPopup()
}

func InternalClosePopupToLevel(remaining int32, restore_focus_to_window_under_popup bool) {
	C.igClosePopupToLevel(C.int(remaining), C.bool(restore_focus_to_window_under_popup))
}

func InternalClosePopupsExceptModals() {
	C.igClosePopupsExceptModals()
}

func InternalClosePopupsOverWindow(ref_window *Window, restore_focus_to_window_under_popup bool) {
	ref_windowArg, ref_windowFin := ref_window.handle()
	C.igClosePopupsOverWindow(ref_windowArg, C.bool(restore_focus_to_window_under_popup))

	ref_windowFin()
}

func InternalCollapseButton(id ID, pos Vec2, dock_node *DockNode) bool {
	idArg, idFin := id.c()
	dock_nodeArg, dock_nodeFin := dock_node.handle()

	defer func() {
		idFin()
		dock_nodeFin()
	}()
	return C.igCollapseButton(idArg, pos.toC(), dock_nodeArg) == C.bool(true)
}

// when 'p_visible != NULL': if '*p_visible==true' display an additional small close button on upper right of the header which will set the bool to false when clicked, if '*p_visible==false' don't display the header.
// CollapsingHeaderBoolPtrV parameter default value hint:
// flags: 0
func CollapsingHeaderBoolPtrV(label string, p_visible *bool, flags TreeNodeFlags) bool {
	labelArg, labelFin := WrapString(label)
	p_visibleArg, p_visibleFin := WrapBool(p_visible)

	defer func() {
		labelFin()
		p_visibleFin()
	}()
	return C.igCollapsingHeader_BoolPtr(labelArg, p_visibleArg, C.ImGuiTreeNodeFlags(flags)) == C.bool(true)
}

// if returning 'true' the header is open. doesn't indent nor push on ID stack. user doesn't have to call TreePop().
// CollapsingHeaderTreeNodeFlagsV parameter default value hint:
// flags: 0
func CollapsingHeaderTreeNodeFlagsV(label string, flags TreeNodeFlags) bool {
	labelArg, labelFin := WrapString(label)

	defer func() {
		labelFin()
	}()
	return C.igCollapsingHeader_TreeNodeFlags(labelArg, C.ImGuiTreeNodeFlags(flags)) == C.bool(true)
}

// display a color square/button, hover for details, return true when pressed.
// ColorButtonV parameter default value hint:
// flags: 0
// size: ImVec2(0,0)
func ColorButtonV(desc_id string, col Vec4, flags ColorEditFlags, size Vec2) bool {
	desc_idArg, desc_idFin := WrapString(desc_id)

	defer func() {
		desc_idFin()
	}()
	return C.igColorButton(desc_idArg, col.toC(), C.ImGuiColorEditFlags(flags), size.toC()) == C.bool(true)
}

func ColorConvertFloat4ToU32(in Vec4) uint32 {
	return uint32(C.igColorConvertFloat4ToU32(in.toC()))
}

func ColorConvertHSVtoRGB(h float32, s float32, v float32, out_r *float32, out_g *float32, out_b *float32) {
	out_rArg, out_rFin := WrapNumberPtr[C.float, float32](out_r)
	out_gArg, out_gFin := WrapNumberPtr[C.float, float32](out_g)
	out_bArg, out_bFin := WrapNumberPtr[C.float, float32](out_b)
	C.igColorConvertHSVtoRGB(C.float(h), C.float(s), C.float(v), out_rArg, out_gArg, out_bArg)

	out_rFin()
	out_gFin()
	out_bFin()
}

func ColorConvertRGBtoHSV(r float32, g float32, b float32, out_h *float32, out_s *float32, out_v *float32) {
	out_hArg, out_hFin := WrapNumberPtr[C.float, float32](out_h)
	out_sArg, out_sFin := WrapNumberPtr[C.float, float32](out_s)
	out_vArg, out_vFin := WrapNumberPtr[C.float, float32](out_v)
	C.igColorConvertRGBtoHSV(C.float(r), C.float(g), C.float(b), out_hArg, out_sArg, out_vArg)

	out_hFin()
	out_sFin()
	out_vFin()
}

func ColorConvertU32ToFloat4(in uint32) Vec4 {
	pOut := new(Vec4)
	pOutArg, pOutFin := wrap[C.ImVec4, *Vec4](pOut)

	C.igColorConvertU32ToFloat4(pOutArg, C.ImU32(in))

	pOutFin()

	return *pOut
}

// ColorEdit3V parameter default value hint:
// flags: 0
func ColorEdit3V(label string, col *[3]float32, flags ColorEditFlags) bool {
	labelArg, labelFin := WrapString(label)

	colArg := make([]C.float, len(col))
	for i, colV := range col {
		colArg[i] = C.float(colV)
	}

	defer func() {
		labelFin()

		for i, colV := range colArg {
			(*col)[i] = float32(colV)
		}
	}()
	return C.igColorEdit3(labelArg, (*C.float)(&colArg[0]), C.ImGuiColorEditFlags(flags)) == C.bool(true)
}

// ColorEdit4V parameter default value hint:
// flags: 0
func ColorEdit4V(label string, col *[4]float32, flags ColorEditFlags) bool {
	labelArg, labelFin := WrapString(label)

	colArg := make([]C.float, len(col))
	for i, colV := range col {
		colArg[i] = C.float(colV)
	}

	defer func() {
		labelFin()

		for i, colV := range colArg {
			(*col)[i] = float32(colV)
		}
	}()
	return C.igColorEdit4(labelArg, (*C.float)(&colArg[0]), C.ImGuiColorEditFlags(flags)) == C.bool(true)
}

func InternalColorEditOptionsPopup(col []float32, flags ColorEditFlags) {
	C.igColorEditOptionsPopup((*C.float)(&(col[0])), C.ImGuiColorEditFlags(flags))
}

// ColorPicker3V parameter default value hint:
// flags: 0
func ColorPicker3V(label string, col *[3]float32, flags ColorEditFlags) bool {
	labelArg, labelFin := WrapString(label)

	colArg := make([]C.float, len(col))
	for i, colV := range col {
		colArg[i] = C.float(colV)
	}

	defer func() {
		labelFin()

		for i, colV := range colArg {
			(*col)[i] = float32(colV)
		}
	}()
	return C.igColorPicker3(labelArg, (*C.float)(&colArg[0]), C.ImGuiColorEditFlags(flags)) == C.bool(true)
}

// ColorPicker4V parameter default value hint:
// flags: 0
// ref_col: NULL
func ColorPicker4V(label string, col *[4]float32, flags ColorEditFlags, ref_col []float32) bool {
	labelArg, labelFin := WrapString(label)

	colArg := make([]C.float, len(col))
	for i, colV := range col {
		colArg[i] = C.float(colV)
	}

	defer func() {
		labelFin()

		for i, colV := range colArg {
			(*col)[i] = float32(colV)
		}
	}()
	return C.igColorPicker4(labelArg, (*C.float)(&colArg[0]), C.ImGuiColorEditFlags(flags), (*C.float)(&(ref_col[0]))) == C.bool(true)
}

func InternalColorPickerOptionsPopup(ref_col []float32, flags ColorEditFlags) {
	C.igColorPickerOptionsPopup((*C.float)(&(ref_col[0])), C.ImGuiColorEditFlags(flags))
}

func InternalColorTooltip(text string, col []float32, flags ColorEditFlags) {
	textArg, textFin := WrapString(text)
	C.igColorTooltip(textArg, (*C.float)(&(col[0])), C.ImGuiColorEditFlags(flags))

	textFin()
}

// ColumnsV parameter default value hint:
// count: 1
// id: NULL
// border: true
func ColumnsV(count int32, id string, border bool) {
	idArg, idFin := WrapString(id)
	C.igColumns(C.int(count), idArg, C.bool(border))

	idFin()
}

// Separate items with \0 within a string, end item-list with \0\0. e.g. "One\0Two\0Three\0"
// ComboStrV parameter default value hint:
// popup_max_height_in_items: -1
func ComboStrV(label string, current_item *int32, items_separated_by_zeros string, popup_max_height_in_items int32) bool {
	labelArg, labelFin := WrapString(label)
	current_itemArg, current_itemFin := WrapNumberPtr[C.int, int32](current_item)
	items_separated_by_zerosArg, items_separated_by_zerosFin := WrapString(items_separated_by_zeros)

	defer func() {
		labelFin()
		current_itemFin()
		items_separated_by_zerosFin()
	}()
	return C.igCombo_Str(labelArg, current_itemArg, items_separated_by_zerosArg, C.int(popup_max_height_in_items)) == C.bool(true)
}

// ComboStrarrV parameter default value hint:
// popup_max_height_in_items: -1
func ComboStrarrV(label string, current_item *int32, items []string, items_count int32, popup_max_height_in_items int32) bool {
	labelArg, labelFin := WrapString(label)
	current_itemArg, current_itemFin := WrapNumberPtr[C.int, int32](current_item)
	itemsArg, itemsFin := WrapStringList(items)

	defer func() {
		labelFin()
		current_itemFin()
		itemsFin()
	}()
	return C.igCombo_Str_arr(labelArg, current_itemArg, itemsArg, C.int(items_count), C.int(popup_max_height_in_items)) == C.bool(true)
}

func InternalConvertShortcutMod(key_chord KeyChord) KeyChord {
	key_chordArg, key_chordFin := key_chord.c()

	defer func() {
		key_chordFin()
	}()
	return *newKeyChordFromC(func() *C.ImGuiKeyChord { result := C.igConvertShortcutMod(key_chordArg); return &result }())
}

func InternalConvertSingleModFlagToKey(ctx *Context, key Key) Key {
	ctxArg, ctxFin := ctx.handle()

	defer func() {
		ctxFin()
	}()
	return Key(C.igConvertSingleModFlagToKey(ctxArg, C.ImGuiKey(key)))
}

// CreateContextV parameter default value hint:
// shared_font_atlas: NULL
func CreateContextV(shared_font_atlas *FontAtlas) *Context {
	shared_font_atlasArg, shared_font_atlasFin := shared_font_atlas.handle()

	defer func() {
		shared_font_atlasFin()
	}()
	return newContextFromC(C.igCreateContext(shared_font_atlasArg))
}

func InternalCreateNewWindowSettings(name string) *WindowSettings {
	nameArg, nameFin := WrapString(name)

	defer func() {
		nameFin()
	}()
	return newWindowSettingsFromC(C.igCreateNewWindowSettings(nameArg))
}

func InternalDataTypeApplyFromText(buf string, data_type DataType, p_data unsafe.Pointer, format string) bool {
	bufArg, bufFin := WrapString(buf)
	p_dataArg, p_dataFin := WrapVoidPtr(p_data)
	formatArg, formatFin := WrapString(format)

	defer func() {
		bufFin()
		p_dataFin()
		formatFin()
	}()
	return C.igDataTypeApplyFromText(bufArg, C.ImGuiDataType(data_type), p_dataArg, formatArg) == C.bool(true)
}

func InternalDataTypeApplyOp(data_type DataType, op int32, output unsafe.Pointer, arg_1 unsafe.Pointer, arg_2 unsafe.Pointer) {
	outputArg, outputFin := WrapVoidPtr(output)
	C.igDataTypeApplyOp(C.ImGuiDataType(data_type), C.int(op), outputArg, (arg_1), (arg_2))

	outputFin()
}

func InternalDataTypeClamp(data_type DataType, p_data unsafe.Pointer, p_min unsafe.Pointer, p_max unsafe.Pointer) bool {
	p_dataArg, p_dataFin := WrapVoidPtr(p_data)

	defer func() {
		p_dataFin()
	}()
	return C.igDataTypeClamp(C.ImGuiDataType(data_type), p_dataArg, (p_min), (p_max)) == C.bool(true)
}

func InternalDataTypeCompare(data_type DataType, arg_1 unsafe.Pointer, arg_2 unsafe.Pointer) int32 {
	return int32(C.igDataTypeCompare(C.ImGuiDataType(data_type), (arg_1), (arg_2)))
}

func InternalDataTypeFormatString(buf string, buf_size int32, data_type DataType, p_data unsafe.Pointer, format string) int32 {
	bufArg, bufFin := WrapString(buf)
	formatArg, formatFin := WrapString(format)

	defer func() {
		bufFin()
		formatFin()
	}()
	return int32(C.igDataTypeFormatString(bufArg, C.int(buf_size), C.ImGuiDataType(data_type), (p_data), formatArg))
}

func InternalDataTypeGetInfo(data_type DataType) *DataTypeInfo {
	return newDataTypeInfoFromC(C.igDataTypeGetInfo(C.ImGuiDataType(data_type)))
}

// This is called by IMGUI_CHECKVERSION() macro.
func DebugCheckVersionAndDataLayout(version_str string, sz_io uint64, sz_style uint64, sz_vec2 uint64, sz_vec4 uint64, sz_drawvert uint64, sz_drawidx uint64) bool {
	version_strArg, version_strFin := WrapString(version_str)

	defer func() {
		version_strFin()
	}()
	return C.igDebugCheckVersionAndDataLayout(version_strArg, C.xulong(sz_io), C.xulong(sz_style), C.xulong(sz_vec2), C.xulong(sz_vec4), C.xulong(sz_drawvert), C.xulong(sz_drawidx)) == C.bool(true)
}

// InternalDebugDrawCursorPosV parameter default value hint:
// col: 4278190335
func InternalDebugDrawCursorPosV(col uint32) {
	C.igDebugDrawCursorPos(C.ImU32(col))
}

// InternalDebugDrawItemRectV parameter default value hint:
// col: 4278190335
func InternalDebugDrawItemRectV(col uint32) {
	C.igDebugDrawItemRect(C.ImU32(col))
}

// InternalDebugDrawLineExtentsV parameter default value hint:
// col: 4278190335
func InternalDebugDrawLineExtentsV(col uint32) {
	C.igDebugDrawLineExtents(C.ImU32(col))
}

func InternalDebugHookIdInfo(id ID, data_type DataType, data_id unsafe.Pointer, data_id_end unsafe.Pointer) {
	idArg, idFin := id.c()
	C.igDebugHookIdInfo(idArg, C.ImGuiDataType(data_type), (data_id), (data_id_end))

	idFin()
}

// Call sparingly: only 1 at the same time!
func InternalDebugLocateItem(target_id ID) {
	target_idArg, target_idFin := target_id.c()
	C.igDebugLocateItem(target_idArg)

	target_idFin()
}

// Only call on reaction to a mouse Hover: because only 1 at the same time!
func InternalDebugLocateItemOnHover(target_id ID) {
	target_idArg, target_idFin := target_id.c()
	C.igDebugLocateItemOnHover(target_idArg)

	target_idFin()
}

func InternalDebugLocateItemResolveWithLastItem() {
	C.igDebugLocateItemResolveWithLastItem()
}

func InternalDebugLog(fmt string) {
	fmtArg, fmtFin := WrapString(fmt)
	C.wrap_igDebugLog(fmtArg)

	fmtFin()
}

func InternalDebugNodeColumns(columns *OldColumns) {
	columnsArg, columnsFin := columns.handle()
	C.igDebugNodeColumns(columnsArg)

	columnsFin()
}

func InternalDebugNodeDockNode(node *DockNode, label string) {
	nodeArg, nodeFin := node.handle()
	labelArg, labelFin := WrapString(label)
	C.igDebugNodeDockNode(nodeArg, labelArg)

	nodeFin()
	labelFin()
}

func InternalDebugNodeDrawCmdShowMeshAndBoundingBox(out_draw_list *DrawList, draw_list *DrawList, draw_cmd *DrawCmd, show_mesh bool, show_aabb bool) {
	out_draw_listArg, out_draw_listFin := out_draw_list.handle()
	draw_listArg, draw_listFin := draw_list.handle()
	draw_cmdArg, draw_cmdFin := draw_cmd.handle()
	C.igDebugNodeDrawCmdShowMeshAndBoundingBox(out_draw_listArg, draw_listArg, draw_cmdArg, C.bool(show_mesh), C.bool(show_aabb))

	out_draw_listFin()
	draw_listFin()
	draw_cmdFin()
}

func InternalDebugNodeDrawList(window *Window, viewport *ViewportP, draw_list *DrawList, label string) {
	windowArg, windowFin := window.handle()
	viewportArg, viewportFin := viewport.handle()
	draw_listArg, draw_listFin := draw_list.handle()
	labelArg, labelFin := WrapString(label)
	C.igDebugNodeDrawList(windowArg, viewportArg, draw_listArg, labelArg)

	windowFin()
	viewportFin()
	draw_listFin()
	labelFin()
}

func InternalDebugNodeFont(font *Font) {
	fontArg, fontFin := font.handle()
	C.igDebugNodeFont(fontArg)

	fontFin()
}

func InternalDebugNodeFontGlyph(font *Font, glyph *FontGlyph) {
	fontArg, fontFin := font.handle()
	glyphArg, glyphFin := glyph.handle()
	C.igDebugNodeFontGlyph(fontArg, glyphArg)

	fontFin()
	glyphFin()
}

func InternalDebugNodeInputTextState(state *InputTextState) {
	stateArg, stateFin := state.handle()
	C.igDebugNodeInputTextState(stateArg)

	stateFin()
}

func InternalDebugNodeStorage(storage *Storage, label string) {
	storageArg, storageFin := storage.handle()
	labelArg, labelFin := WrapString(label)
	C.igDebugNodeStorage(storageArg, labelArg)

	storageFin()
	labelFin()
}

func InternalDebugNodeTabBar(tab_bar *TabBar, label string) {
	tab_barArg, tab_barFin := tab_bar.handle()
	labelArg, labelFin := WrapString(label)
	C.igDebugNodeTabBar(tab_barArg, labelArg)

	tab_barFin()
	labelFin()
}

func InternalDebugNodeTable(table *Table) {
	tableArg, tableFin := table.handle()
	C.igDebugNodeTable(tableArg)

	tableFin()
}

func InternalDebugNodeTableSettings(settings *TableSettings) {
	settingsArg, settingsFin := settings.handle()
	C.igDebugNodeTableSettings(settingsArg)

	settingsFin()
}

func InternalDebugNodeTypingSelectState(state *TypingSelectState) {
	stateArg, stateFin := state.handle()
	C.igDebugNodeTypingSelectState(stateArg)

	stateFin()
}

func InternalDebugNodeViewport(viewport *ViewportP) {
	viewportArg, viewportFin := viewport.handle()
	C.igDebugNodeViewport(viewportArg)

	viewportFin()
}

func InternalDebugNodeWindow(window *Window, label string) {
	windowArg, windowFin := window.handle()
	labelArg, labelFin := WrapString(label)
	C.igDebugNodeWindow(windowArg, labelArg)

	windowFin()
	labelFin()
}

func InternalDebugNodeWindowSettings(settings *WindowSettings) {
	settingsArg, settingsFin := settings.handle()
	C.igDebugNodeWindowSettings(settingsArg)

	settingsFin()
}

func InternalDebugRenderKeyboardPreview(draw_list *DrawList) {
	draw_listArg, draw_listFin := draw_list.handle()
	C.igDebugRenderKeyboardPreview(draw_listArg)

	draw_listFin()
}

func InternalDebugRenderViewportThumbnail(draw_list *DrawList, viewport *ViewportP, bb Rect) {
	draw_listArg, draw_listFin := draw_list.handle()
	viewportArg, viewportFin := viewport.handle()
	C.igDebugRenderViewportThumbnail(draw_listArg, viewportArg, bb.toC())

	draw_listFin()
	viewportFin()
}

func InternalDebugStartItemPicker() {
	C.igDebugStartItemPicker()
}

func DebugTextEncoding(text string) {
	textArg, textFin := WrapString(text)
	C.igDebugTextEncoding(textArg)

	textFin()
}

// NULL = destroy current context
// DestroyContextV parameter default value hint:
// ctx: NULL
func DestroyContextV(ctx *Context) {
	ctxArg, ctxFin := ctx.handle()
	C.igDestroyContext(ctxArg)

	ctxFin()
}

func InternalDestroyPlatformWindow(viewport *ViewportP) {
	viewportArg, viewportFin := viewport.handle()
	C.igDestroyPlatformWindow(viewportArg)

	viewportFin()
}

// call DestroyWindow platform functions for all viewports. call from backend Shutdown() if you need to close platform windows before imgui shutdown. otherwise will be called by DestroyContext().
func DestroyPlatformWindows() {
	C.igDestroyPlatformWindows()
}

// InternalDockBuilderAddNodeV parameter default value hint:
// node_id: 0
// flags: 0
func InternalDockBuilderAddNodeV(node_id ID, flags DockNodeFlags) ID {
	node_idArg, node_idFin := node_id.c()

	defer func() {
		node_idFin()
	}()
	return *newIDFromC(func() *C.ImGuiID {
		result := C.igDockBuilderAddNode(node_idArg, C.ImGuiDockNodeFlags(flags))
		return &result
	}())
}

func InternalDockBuilderCopyWindowSettings(src_name string, dst_name string) {
	src_nameArg, src_nameFin := WrapString(src_name)
	dst_nameArg, dst_nameFin := WrapString(dst_name)
	C.igDockBuilderCopyWindowSettings(src_nameArg, dst_nameArg)

	src_nameFin()
	dst_nameFin()
}

func InternalDockBuilderDockWindow(window_name string, node_id ID) {
	window_nameArg, window_nameFin := WrapString(window_name)
	node_idArg, node_idFin := node_id.c()
	C.igDockBuilderDockWindow(window_nameArg, node_idArg)

	window_nameFin()
	node_idFin()
}

func InternalDockBuilderFinish(node_id ID) {
	node_idArg, node_idFin := node_id.c()
	C.igDockBuilderFinish(node_idArg)

	node_idFin()
}

func InternalDockBuilderGetCentralNode(node_id ID) *DockNode {
	node_idArg, node_idFin := node_id.c()

	defer func() {
		node_idFin()
	}()
	return newDockNodeFromC(C.igDockBuilderGetCentralNode(node_idArg))
}

func InternalDockBuilderGetNode(node_id ID) *DockNode {
	node_idArg, node_idFin := node_id.c()

	defer func() {
		node_idFin()
	}()
	return newDockNodeFromC(C.igDockBuilderGetNode(node_idArg))
}

// Remove node and all its child, undock all windows
func InternalDockBuilderRemoveNode(node_id ID) {
	node_idArg, node_idFin := node_id.c()
	C.igDockBuilderRemoveNode(node_idArg)

	node_idFin()
}

// Remove all split/hierarchy. All remaining docked windows will be re-docked to the remaining root node (node_id).
func InternalDockBuilderRemoveNodeChildNodes(node_id ID) {
	node_idArg, node_idFin := node_id.c()
	C.igDockBuilderRemoveNodeChildNodes(node_idArg)

	node_idFin()
}

// InternalDockBuilderRemoveNodeDockedWindowsV parameter default value hint:
// clear_settings_refs: true
func InternalDockBuilderRemoveNodeDockedWindowsV(node_id ID, clear_settings_refs bool) {
	node_idArg, node_idFin := node_id.c()
	C.igDockBuilderRemoveNodeDockedWindows(node_idArg, C.bool(clear_settings_refs))

	node_idFin()
}

func InternalDockBuilderSetNodePos(node_id ID, pos Vec2) {
	node_idArg, node_idFin := node_id.c()
	C.igDockBuilderSetNodePos(node_idArg, pos.toC())

	node_idFin()
}

func InternalDockBuilderSetNodeSize(node_id ID, size Vec2) {
	node_idArg, node_idFin := node_id.c()
	C.igDockBuilderSetNodeSize(node_idArg, size.toC())

	node_idFin()
}

// Create 2 child nodes in this parent node.
func InternalDockBuilderSplitNode(node_id ID, split_dir Dir, size_ratio_for_node_at_dir float32, out_id_at_dir *ID, out_id_at_opposite_dir *ID) ID {
	node_idArg, node_idFin := node_id.c()
	out_id_at_dirArg, out_id_at_dirFin := out_id_at_dir.handle()
	out_id_at_opposite_dirArg, out_id_at_opposite_dirFin := out_id_at_opposite_dir.handle()

	defer func() {
		node_idFin()
		out_id_at_dirFin()
		out_id_at_opposite_dirFin()
	}()
	return *newIDFromC(func() *C.ImGuiID {
		result := C.igDockBuilderSplitNode(node_idArg, C.ImGuiDir(split_dir), C.float(size_ratio_for_node_at_dir), out_id_at_dirArg, out_id_at_opposite_dirArg)
		return &result
	}())
}

func InternalDockContextCalcDropPosForDocking(target *Window, target_node *DockNode, payload_window *Window, payload_node *DockNode, split_dir Dir, split_outer bool, out_pos *Vec2) bool {
	targetArg, targetFin := target.handle()
	target_nodeArg, target_nodeFin := target_node.handle()
	payload_windowArg, payload_windowFin := payload_window.handle()
	payload_nodeArg, payload_nodeFin := payload_node.handle()
	out_posArg, out_posFin := wrap[C.ImVec2, *Vec2](out_pos)

	defer func() {
		targetFin()
		target_nodeFin()
		payload_windowFin()
		payload_nodeFin()
		out_posFin()
	}()
	return C.igDockContextCalcDropPosForDocking(targetArg, target_nodeArg, payload_windowArg, payload_nodeArg, C.ImGuiDir(split_dir), C.bool(split_outer), out_posArg) == C.bool(true)
}

// Use root_id==0 to clear all
func InternalDockContextClearNodes(ctx *Context, root_id ID, clear_settings_refs bool) {
	ctxArg, ctxFin := ctx.handle()
	root_idArg, root_idFin := root_id.c()
	C.igDockContextClearNodes(ctxArg, root_idArg, C.bool(clear_settings_refs))

	ctxFin()
	root_idFin()
}

func InternalDockContextEndFrame(ctx *Context) {
	ctxArg, ctxFin := ctx.handle()
	C.igDockContextEndFrame(ctxArg)

	ctxFin()
}

func InternalDockContextFindNodeByID(ctx *Context, id ID) *DockNode {
	ctxArg, ctxFin := ctx.handle()
	idArg, idFin := id.c()

	defer func() {
		ctxFin()
		idFin()
	}()
	return newDockNodeFromC(C.igDockContextFindNodeByID(ctxArg, idArg))
}

func InternalDockContextGenNodeID(ctx *Context) ID {
	ctxArg, ctxFin := ctx.handle()

	defer func() {
		ctxFin()
	}()
	return *newIDFromC(func() *C.ImGuiID { result := C.igDockContextGenNodeID(ctxArg); return &result }())
}

func InternalDockContextInitialize(ctx *Context) {
	ctxArg, ctxFin := ctx.handle()
	C.igDockContextInitialize(ctxArg)

	ctxFin()
}

func InternalDockContextNewFrameUpdateDocking(ctx *Context) {
	ctxArg, ctxFin := ctx.handle()
	C.igDockContextNewFrameUpdateDocking(ctxArg)

	ctxFin()
}

func InternalDockContextNewFrameUpdateUndocking(ctx *Context) {
	ctxArg, ctxFin := ctx.handle()
	C.igDockContextNewFrameUpdateUndocking(ctxArg)

	ctxFin()
}

func InternalDockContextProcessUndockNode(ctx *Context, node *DockNode) {
	ctxArg, ctxFin := ctx.handle()
	nodeArg, nodeFin := node.handle()
	C.igDockContextProcessUndockNode(ctxArg, nodeArg)

	ctxFin()
	nodeFin()
}

// InternalDockContextProcessUndockWindowV parameter default value hint:
// clear_persistent_docking_ref: true
func InternalDockContextProcessUndockWindowV(ctx *Context, window *Window, clear_persistent_docking_ref bool) {
	ctxArg, ctxFin := ctx.handle()
	windowArg, windowFin := window.handle()
	C.igDockContextProcessUndockWindow(ctxArg, windowArg, C.bool(clear_persistent_docking_ref))

	ctxFin()
	windowFin()
}

func InternalDockContextQueueDock(ctx *Context, target *Window, target_node *DockNode, payload *Window, split_dir Dir, split_ratio float32, split_outer bool) {
	ctxArg, ctxFin := ctx.handle()
	targetArg, targetFin := target.handle()
	target_nodeArg, target_nodeFin := target_node.handle()
	payloadArg, payloadFin := payload.handle()
	C.igDockContextQueueDock(ctxArg, targetArg, target_nodeArg, payloadArg, C.ImGuiDir(split_dir), C.float(split_ratio), C.bool(split_outer))

	ctxFin()
	targetFin()
	target_nodeFin()
	payloadFin()
}

func InternalDockContextQueueUndockNode(ctx *Context, node *DockNode) {
	ctxArg, ctxFin := ctx.handle()
	nodeArg, nodeFin := node.handle()
	C.igDockContextQueueUndockNode(ctxArg, nodeArg)

	ctxFin()
	nodeFin()
}

func InternalDockContextQueueUndockWindow(ctx *Context, window *Window) {
	ctxArg, ctxFin := ctx.handle()
	windowArg, windowFin := window.handle()
	C.igDockContextQueueUndockWindow(ctxArg, windowArg)

	ctxFin()
	windowFin()
}

func InternalDockContextRebuildNodes(ctx *Context) {
	ctxArg, ctxFin := ctx.handle()
	C.igDockContextRebuildNodes(ctxArg)

	ctxFin()
}

func InternalDockContextShutdown(ctx *Context) {
	ctxArg, ctxFin := ctx.handle()
	C.igDockContextShutdown(ctxArg)

	ctxFin()
}

func InternalDockNodeBeginAmendTabBar(node *DockNode) bool {
	nodeArg, nodeFin := node.handle()

	defer func() {
		nodeFin()
	}()
	return C.igDockNodeBeginAmendTabBar(nodeArg) == C.bool(true)
}

func InternalDockNodeEndAmendTabBar() {
	C.igDockNodeEndAmendTabBar()
}

func InternalDockNodeGetDepth(node *DockNode) int32 {
	nodeArg, nodeFin := node.handle()

	defer func() {
		nodeFin()
	}()
	return int32(C.igDockNodeGetDepth(nodeArg))
}

func InternalDockNodeGetRootNode(node *DockNode) *DockNode {
	nodeArg, nodeFin := node.handle()

	defer func() {
		nodeFin()
	}()
	return newDockNodeFromC(C.igDockNodeGetRootNode(nodeArg))
}

func InternalDockNodeGetWindowMenuButtonId(node *DockNode) ID {
	nodeArg, nodeFin := node.handle()

	defer func() {
		nodeFin()
	}()
	return *newIDFromC(func() *C.ImGuiID { result := C.igDockNodeGetWindowMenuButtonId(nodeArg); return &result }())
}

func InternalDockNodeIsInHierarchyOf(node *DockNode, parent *DockNode) bool {
	nodeArg, nodeFin := node.handle()
	parentArg, parentFin := parent.handle()

	defer func() {
		nodeFin()
		parentFin()
	}()
	return C.igDockNodeIsInHierarchyOf(nodeArg, parentArg) == C.bool(true)
}

func InternalDockNodeWindowMenuHandlerDefault(ctx *Context, node *DockNode, tab_bar *TabBar) {
	ctxArg, ctxFin := ctx.handle()
	nodeArg, nodeFin := node.handle()
	tab_barArg, tab_barFin := tab_bar.handle()
	C.igDockNodeWindowMenuHandler_Default(ctxArg, nodeArg, tab_barArg)

	ctxFin()
	nodeFin()
	tab_barFin()
}

// DockSpaceV parameter default value hint:
// size: ImVec2(0,0)
// flags: 0
// window_class: NULL
func DockSpaceV(id ID, size Vec2, flags DockNodeFlags, window_class *WindowClass) ID {
	idArg, idFin := id.c()
	window_classArg, window_classFin := window_class.handle()

	defer func() {
		idFin()
		window_classFin()
	}()
	return *newIDFromC(func() *C.ImGuiID {
		result := C.igDockSpace(idArg, size.toC(), C.ImGuiDockNodeFlags(flags), window_classArg)
		return &result
	}())
}

// DockSpaceOverViewportV parameter default value hint:
// viewport: NULL
// flags: 0
// window_class: NULL
func DockSpaceOverViewportV(viewport *Viewport, flags DockNodeFlags, window_class *WindowClass) ID {
	viewportArg, viewportFin := viewport.handle()
	window_classArg, window_classFin := window_class.handle()

	defer func() {
		viewportFin()
		window_classFin()
	}()
	return *newIDFromC(func() *C.ImGuiID {
		result := C.igDockSpaceOverViewport(viewportArg, C.ImGuiDockNodeFlags(flags), window_classArg)
		return &result
	}())
}

func InternalDragBehavior(id ID, data_type DataType, p_v unsafe.Pointer, v_speed float32, p_min unsafe.Pointer, p_max unsafe.Pointer, format string, flags SliderFlags) bool {
	idArg, idFin := id.c()
	p_vArg, p_vFin := WrapVoidPtr(p_v)
	formatArg, formatFin := WrapString(format)

	defer func() {
		idFin()
		p_vFin()
		formatFin()
	}()
	return C.igDragBehavior(idArg, C.ImGuiDataType(data_type), p_vArg, C.float(v_speed), (p_min), (p_max), formatArg, C.ImGuiSliderFlags(flags)) == C.bool(true)
}

// If v_min >= v_max we have no bound
// DragFloatV parameter default value hint:
// v_speed: 1.0f
// v_min: 0.0f
// v_max: 0.0f
// format: "%.3f"
// flags: 0
func DragFloatV(label string, v *float32, v_speed float32, v_min float32, v_max float32, format string, flags SliderFlags) bool {
	labelArg, labelFin := WrapString(label)
	vArg, vFin := WrapNumberPtr[C.float, float32](v)
	formatArg, formatFin := WrapString(format)

	defer func() {
		labelFin()
		vFin()
		formatFin()
	}()
	return C.igDragFloat(labelArg, vArg, C.float(v_speed), C.float(v_min), C.float(v_max), formatArg, C.ImGuiSliderFlags(flags)) == C.bool(true)
}

// DragFloat2V parameter default value hint:
// v_speed: 1.0f
// v_min: 0.0f
// v_max: 0.0f
// format: "%.3f"
// flags: 0
func DragFloat2V(label string, v *[2]float32, v_speed float32, v_min float32, v_max float32, format string, flags SliderFlags) bool {
	labelArg, labelFin := WrapString(label)

	vArg := make([]C.float, len(v))
	for i, vV := range v {
		vArg[i] = C.float(vV)
	}
	formatArg, formatFin := WrapString(format)

	defer func() {
		labelFin()

		for i, vV := range vArg {
			(*v)[i] = float32(vV)
		}

		formatFin()
	}()
	return C.igDragFloat2(labelArg, (*C.float)(&vArg[0]), C.float(v_speed), C.float(v_min), C.float(v_max), formatArg, C.ImGuiSliderFlags(flags)) == C.bool(true)
}

// DragFloat3V parameter default value hint:
// v_speed: 1.0f
// v_min: 0.0f
// v_max: 0.0f
// format: "%.3f"
// flags: 0
func DragFloat3V(label string, v *[3]float32, v_speed float32, v_min float32, v_max float32, format string, flags SliderFlags) bool {
	labelArg, labelFin := WrapString(label)

	vArg := make([]C.float, len(v))
	for i, vV := range v {
		vArg[i] = C.float(vV)
	}
	formatArg, formatFin := WrapString(format)

	defer func() {
		labelFin()

		for i, vV := range vArg {
			(*v)[i] = float32(vV)
		}

		formatFin()
	}()
	return C.igDragFloat3(labelArg, (*C.float)(&vArg[0]), C.float(v_speed), C.float(v_min), C.float(v_max), formatArg, C.ImGuiSliderFlags(flags)) == C.bool(true)
}

// DragFloat4V parameter default value hint:
// v_speed: 1.0f
// v_min: 0.0f
// v_max: 0.0f
// format: "%.3f"
// flags: 0
func DragFloat4V(label string, v *[4]float32, v_speed float32, v_min float32, v_max float32, format string, flags SliderFlags) bool {
	labelArg, labelFin := WrapString(label)

	vArg := make([]C.float, len(v))
	for i, vV := range v {
		vArg[i] = C.float(vV)
	}
	formatArg, formatFin := WrapString(format)

	defer func() {
		labelFin()

		for i, vV := range vArg {
			(*v)[i] = float32(vV)
		}

		formatFin()
	}()
	return C.igDragFloat4(labelArg, (*C.float)(&vArg[0]), C.float(v_speed), C.float(v_min), C.float(v_max), formatArg, C.ImGuiSliderFlags(flags)) == C.bool(true)
}

// DragFloatRange2V parameter default value hint:
// v_speed: 1.0f
// v_min: 0.0f
// v_max: 0.0f
// format: "%.3f"
// format_max: NULL
// flags: 0
func DragFloatRange2V(label string, v_current_min *float32, v_current_max *float32, v_speed float32, v_min float32, v_max float32, format string, format_max string, flags SliderFlags) bool {
	labelArg, labelFin := WrapString(label)
	v_current_minArg, v_current_minFin := WrapNumberPtr[C.float, float32](v_current_min)
	v_current_maxArg, v_current_maxFin := WrapNumberPtr[C.float, float32](v_current_max)
	formatArg, formatFin := WrapString(format)
	format_maxArg, format_maxFin := WrapString(format_max)

	defer func() {
		labelFin()
		v_current_minFin()
		v_current_maxFin()
		formatFin()
		format_maxFin()
	}()
	return C.igDragFloatRange2(labelArg, v_current_minArg, v_current_maxArg, C.float(v_speed), C.float(v_min), C.float(v_max), formatArg, format_maxArg, C.ImGuiSliderFlags(flags)) == C.bool(true)
}

// If v_min >= v_max we have no bound
// DragIntV parameter default value hint:
// v_speed: 1.0f
// v_min: 0
// v_max: 0
// format: "%d"
// flags: 0
func DragIntV(label string, v *int32, v_speed float32, v_min int32, v_max int32, format string, flags SliderFlags) bool {
	labelArg, labelFin := WrapString(label)
	vArg, vFin := WrapNumberPtr[C.int, int32](v)
	formatArg, formatFin := WrapString(format)

	defer func() {
		labelFin()
		vFin()
		formatFin()
	}()
	return C.igDragInt(labelArg, vArg, C.float(v_speed), C.int(v_min), C.int(v_max), formatArg, C.ImGuiSliderFlags(flags)) == C.bool(true)
}

// DragInt2V parameter default value hint:
// v_speed: 1.0f
// v_min: 0
// v_max: 0
// format: "%d"
// flags: 0
func DragInt2V(label string, v *[2]int32, v_speed float32, v_min int32, v_max int32, format string, flags SliderFlags) bool {
	labelArg, labelFin := WrapString(label)

	vArg := make([]C.int, len(v))
	for i, vV := range v {
		vArg[i] = C.int(vV)
	}
	formatArg, formatFin := WrapString(format)

	defer func() {
		labelFin()

		for i, vV := range vArg {
			(*v)[i] = int32(vV)
		}

		formatFin()
	}()
	return C.igDragInt2(labelArg, (*C.int)(&vArg[0]), C.float(v_speed), C.int(v_min), C.int(v_max), formatArg, C.ImGuiSliderFlags(flags)) == C.bool(true)
}

// DragInt3V parameter default value hint:
// v_speed: 1.0f
// v_min: 0
// v_max: 0
// format: "%d"
// flags: 0
func DragInt3V(label string, v *[3]int32, v_speed float32, v_min int32, v_max int32, format string, flags SliderFlags) bool {
	labelArg, labelFin := WrapString(label)

	vArg := make([]C.int, len(v))
	for i, vV := range v {
		vArg[i] = C.int(vV)
	}
	formatArg, formatFin := WrapString(format)

	defer func() {
		labelFin()

		for i, vV := range vArg {
			(*v)[i] = int32(vV)
		}

		formatFin()
	}()
	return C.igDragInt3(labelArg, (*C.int)(&vArg[0]), C.float(v_speed), C.int(v_min), C.int(v_max), formatArg, C.ImGuiSliderFlags(flags)) == C.bool(true)
}

// DragInt4V parameter default value hint:
// v_speed: 1.0f
// v_min: 0
// v_max: 0
// format: "%d"
// flags: 0
func DragInt4V(label string, v *[4]int32, v_speed float32, v_min int32, v_max int32, format string, flags SliderFlags) bool {
	labelArg, labelFin := WrapString(label)

	vArg := make([]C.int, len(v))
	for i, vV := range v {
		vArg[i] = C.int(vV)
	}
	formatArg, formatFin := WrapString(format)

	defer func() {
		labelFin()

		for i, vV := range vArg {
			(*v)[i] = int32(vV)
		}

		formatFin()
	}()
	return C.igDragInt4(labelArg, (*C.int)(&vArg[0]), C.float(v_speed), C.int(v_min), C.int(v_max), formatArg, C.ImGuiSliderFlags(flags)) == C.bool(true)
}

// DragIntRange2V parameter default value hint:
// v_speed: 1.0f
// v_min: 0
// v_max: 0
// format: "%d"
// format_max: NULL
// flags: 0
func DragIntRange2V(label string, v_current_min *int32, v_current_max *int32, v_speed float32, v_min int32, v_max int32, format string, format_max string, flags SliderFlags) bool {
	labelArg, labelFin := WrapString(label)
	v_current_minArg, v_current_minFin := WrapNumberPtr[C.int, int32](v_current_min)
	v_current_maxArg, v_current_maxFin := WrapNumberPtr[C.int, int32](v_current_max)
	formatArg, formatFin := WrapString(format)
	format_maxArg, format_maxFin := WrapString(format_max)

	defer func() {
		labelFin()
		v_current_minFin()
		v_current_maxFin()
		formatFin()
		format_maxFin()
	}()
	return C.igDragIntRange2(labelArg, v_current_minArg, v_current_maxArg, C.float(v_speed), C.int(v_min), C.int(v_max), formatArg, format_maxArg, C.ImGuiSliderFlags(flags)) == C.bool(true)
}

// DragScalarV parameter default value hint:
// v_speed: 1.0f
// p_min: NULL
// p_max: NULL
// format: NULL
// flags: 0
func DragScalarV(label string, data_type DataType, p_data unsafe.Pointer, v_speed float32, p_min unsafe.Pointer, p_max unsafe.Pointer, format string, flags SliderFlags) bool {
	labelArg, labelFin := WrapString(label)
	p_dataArg, p_dataFin := WrapVoidPtr(p_data)
	formatArg, formatFin := WrapString(format)

	defer func() {
		labelFin()
		p_dataFin()
		formatFin()
	}()
	return C.igDragScalar(labelArg, C.ImGuiDataType(data_type), p_dataArg, C.float(v_speed), (p_min), (p_max), formatArg, C.ImGuiSliderFlags(flags)) == C.bool(true)
}

// DragScalarNV parameter default value hint:
// v_speed: 1.0f
// p_min: NULL
// p_max: NULL
// format: NULL
// flags: 0
func DragScalarNV(label string, data_type DataType, p_data unsafe.Pointer, components int32, v_speed float32, p_min unsafe.Pointer, p_max unsafe.Pointer, format string, flags SliderFlags) bool {
	labelArg, labelFin := WrapString(label)
	p_dataArg, p_dataFin := WrapVoidPtr(p_data)
	formatArg, formatFin := WrapString(format)

	defer func() {
		labelFin()
		p_dataFin()
		formatFin()
	}()
	return C.igDragScalarN(labelArg, C.ImGuiDataType(data_type), p_dataArg, C.int(components), C.float(v_speed), (p_min), (p_max), formatArg, C.ImGuiSliderFlags(flags)) == C.bool(true)
}

// add a dummy item of given size. unlike InvisibleButton(), Dummy() won't take the mouse click or be navigable into.
func Dummy(size Vec2) {
	C.igDummy(size.toC())
}

func End() {
	C.igEnd()
}

func EndChild() {
	C.igEndChild()
}

// always call EndChildFrame() regardless of BeginChildFrame() return values (which indicates a collapsed/clipped window)
func EndChildFrame() {
	C.igEndChildFrame()
}

// close columns
func InternalEndColumns() {
	C.igEndColumns()
}

// only call EndCombo() if BeginCombo() returns true!
func EndCombo() {
	C.igEndCombo()
}

func InternalEndComboPreview() {
	C.igEndComboPreview()
}

func EndDisabled() {
	C.igEndDisabled()
}

// only call EndDragDropSource() if BeginDragDropSource() returns true!
func EndDragDropSource() {
	C.igEndDragDropSource()
}

// only call EndDragDropTarget() if BeginDragDropTarget() returns true!
func EndDragDropTarget() {
	C.igEndDragDropTarget()
}

// ends the Dear ImGui frame. automatically called by Render(). If you don't need to render data (skipping rendering) you may call EndFrame() without Render()... but you'll have wasted CPU already! If you don't need to render, better to not create any windows and not call NewFrame() at all!
func EndFrame() {
	C.igEndFrame()
}

// unlock horizontal starting position + capture the whole group bounding box into one "item" (so you can use IsItemHovered() or layout primitives such as SameLine() on whole group, etc.)
func EndGroup() {
	C.igEndGroup()
}

// only call EndListBox() if BeginListBox() returned true!
func EndListBox() {
	C.igEndListBox()
}

// only call EndMainMenuBar() if BeginMainMenuBar() returns true!
func EndMainMenuBar() {
	C.igEndMainMenuBar()
}

// only call EndMenu() if BeginMenu() returns true!
func EndMenu() {
	C.igEndMenu()
}

// only call EndMenuBar() if BeginMenuBar() returns true!
func EndMenuBar() {
	C.igEndMenuBar()
}

// only call EndPopup() if BeginPopupXXX() returns true!
func EndPopup() {
	C.igEndPopup()
}

// only call EndTabBar() if BeginTabBar() returns true!
func EndTabBar() {
	C.igEndTabBar()
}

// only call EndTabItem() if BeginTabItem() returns true!
func EndTabItem() {
	C.igEndTabItem()
}

// only call EndTable() if BeginTable() returns true!
func EndTable() {
	C.igEndTable()
}

// only call EndTooltip() if BeginTooltip()/BeginItemTooltip() returns true!
func EndTooltip() {
	C.igEndTooltip()
}

func InternalErrorCheckUsingSetCursorPosToExtendParentBoundaries() {
	C.igErrorCheckUsingSetCursorPosToExtendParentBoundaries()
}

func InternalFindBestWindowPosForPopup(window *Window) Vec2 {
	pOut := new(Vec2)
	pOutArg, pOutFin := wrap[C.ImVec2, *Vec2](pOut)

	windowArg, windowFin := window.handle()
	C.igFindBestWindowPosForPopup(pOutArg, windowArg)

	pOutFin()
	windowFin()

	return *pOut
}

func InternalFindBlockingModal(window *Window) *Window {
	windowArg, windowFin := window.handle()

	defer func() {
		windowFin()
	}()
	return newWindowFromC(C.igFindBlockingModal(windowArg))
}

func InternalFindBottomMostVisibleWindowWithinBeginStack(window *Window) *Window {
	windowArg, windowFin := window.handle()

	defer func() {
		windowFin()
	}()
	return newWindowFromC(C.igFindBottomMostVisibleWindowWithinBeginStack(windowArg))
}

func InternalFindHoveredViewportFromPlatformWindowStack(mouse_platform_pos Vec2) *ViewportP {
	return newViewportPFromC(C.igFindHoveredViewportFromPlatformWindowStack(mouse_platform_pos.toC()))
}

func InternalFindOrCreateColumns(window *Window, id ID) *OldColumns {
	windowArg, windowFin := window.handle()
	idArg, idFin := id.c()

	defer func() {
		windowFin()
		idFin()
	}()
	return newOldColumnsFromC(C.igFindOrCreateColumns(windowArg, idArg))
}

// Find the optional ## from which we stop displaying text.
// InternalFindRenderedTextEndV parameter default value hint:
func InternalFindRenderedTextEndV(text string) string {
	textArg, textFin := WrapString(text)

	defer func() {
		textFin()
	}()
	return C.GoString(C.wrap_igFindRenderedTextEndV(textArg))
}

func InternalFindSettingsHandler(type_name string) *SettingsHandler {
	type_nameArg, type_nameFin := WrapString(type_name)

	defer func() {
		type_nameFin()
	}()
	return newSettingsHandlerFromC(C.igFindSettingsHandler(type_nameArg))
}

// this is a helper for backends.
func FindViewportByID(id ID) *Viewport {
	idArg, idFin := id.c()

	defer func() {
		idFin()
	}()
	return newViewportFromC(C.igFindViewportByID(idArg))
}

// this is a helper for backends. the type platform_handle is decided by the backend (e.g. HWND, MyWindow*, GLFWwindow* etc.)
func FindViewportByPlatformHandle(platform_handle unsafe.Pointer) *Viewport {
	platform_handleArg, platform_handleFin := WrapVoidPtr(platform_handle)

	defer func() {
		platform_handleFin()
	}()
	return newViewportFromC(C.igFindViewportByPlatformHandle(platform_handleArg))
}

func InternalFindWindowByID(id ID) *Window {
	idArg, idFin := id.c()

	defer func() {
		idFin()
	}()
	return newWindowFromC(C.igFindWindowByID(idArg))
}

func InternalFindWindowByName(name string) *Window {
	nameArg, nameFin := WrapString(name)

	defer func() {
		nameFin()
	}()
	return newWindowFromC(C.igFindWindowByName(nameArg))
}

func InternalFindWindowDisplayIndex(window *Window) int32 {
	windowArg, windowFin := window.handle()

	defer func() {
		windowFin()
	}()
	return int32(C.igFindWindowDisplayIndex(windowArg))
}

func InternalFindWindowSettingsByID(id ID) *WindowSettings {
	idArg, idFin := id.c()

	defer func() {
		idFin()
	}()
	return newWindowSettingsFromC(C.igFindWindowSettingsByID(idArg))
}

func InternalFindWindowSettingsByWindow(window *Window) *WindowSettings {
	windowArg, windowFin := window.handle()

	defer func() {
		windowFin()
	}()
	return newWindowSettingsFromC(C.igFindWindowSettingsByWindow(windowArg))
}

// Focus last item (no selection/activation).
func InternalFocusItem() {
	C.igFocusItem()
}

func InternalFocusTopMostWindowUnderOne(under_this_window *Window, ignore_window *Window, filter_viewport *Viewport, flags FocusRequestFlags) {
	under_this_windowArg, under_this_windowFin := under_this_window.handle()
	ignore_windowArg, ignore_windowFin := ignore_window.handle()
	filter_viewportArg, filter_viewportFin := filter_viewport.handle()
	C.igFocusTopMostWindowUnderOne(under_this_windowArg, ignore_windowArg, filter_viewportArg, C.ImGuiFocusRequestFlags(flags))

	under_this_windowFin()
	ignore_windowFin()
	filter_viewportFin()
}

// InternalFocusWindowV parameter default value hint:
// flags: 0
func InternalFocusWindowV(window *Window, flags FocusRequestFlags) {
	windowArg, windowFin := window.handle()
	C.igFocusWindow(windowArg, C.ImGuiFocusRequestFlags(flags))

	windowFin()
}

func InternalGcAwakeTransientWindowBuffers(window *Window) {
	windowArg, windowFin := window.handle()
	C.igGcAwakeTransientWindowBuffers(windowArg)

	windowFin()
}

func InternalGcCompactTransientMiscBuffers() {
	C.igGcCompactTransientMiscBuffers()
}

func InternalGcCompactTransientWindowBuffers(window *Window) {
	windowArg, windowFin := window.handle()
	C.igGcCompactTransientWindowBuffers(windowArg)

	windowFin()
}

func InternalActiveID() ID {
	return *newIDFromC(func() *C.ImGuiID { result := C.igGetActiveID(); return &result }())
}

// get background draw list for the viewport associated to the current window. this draw list will be the first rendering one. Useful to quickly draw shapes/text behind dear imgui contents.
func BackgroundDrawListNil() *DrawList {
	return newDrawListFromC(C.igGetBackgroundDrawList_Nil())
}

// get background draw list for the given viewport. this draw list will be the first rendering one. Useful to quickly draw shapes/text behind dear imgui contents.
func BackgroundDrawListViewportPtr(viewport *Viewport) *DrawList {
	viewportArg, viewportFin := viewport.handle()

	defer func() {
		viewportFin()
	}()
	return newDrawListFromC(C.igGetBackgroundDrawList_ViewportPtr(viewportArg))
}

func ClipboardText() string {
	return C.GoString(C.igGetClipboardText())
}

// retrieve given style color with style alpha applied and optional extra alpha multiplier, packed as a 32-bit value suitable for ImDrawList
// ColorU32ColV parameter default value hint:
// alpha_mul: 1.0f
func ColorU32ColV(idx Col, alpha_mul float32) uint32 {
	return uint32(C.igGetColorU32_Col(C.ImGuiCol(idx), C.float(alpha_mul)))
}

// retrieve given color with style alpha applied, packed as a 32-bit value suitable for ImDrawList
func ColorU32U32(col uint32) uint32 {
	return uint32(C.igGetColorU32_U32(C.ImU32(col)))
}

// retrieve given color with style alpha applied, packed as a 32-bit value suitable for ImDrawList
func ColorU32Vec4(col Vec4) uint32 {
	return uint32(C.igGetColorU32_Vec4(col.toC()))
}

// get current column index
func ColumnIndex() int32 {
	return int32(C.igGetColumnIndex())
}

func InternalColumnNormFromOffset(columns *OldColumns, offset float32) float32 {
	columnsArg, columnsFin := columns.handle()

	defer func() {
		columnsFin()
	}()
	return float32(C.igGetColumnNormFromOffset(columnsArg, C.float(offset)))
}

// get position of column line (in pixels, from the left side of the contents region). pass -1 to use current column, otherwise 0..GetColumnsCount() inclusive. column 0 is typically 0.0f
// ColumnOffsetV parameter default value hint:
// column_index: -1
func ColumnOffsetV(column_index int32) float32 {
	return float32(C.igGetColumnOffset(C.int(column_index)))
}

func InternalColumnOffsetFromNorm(columns *OldColumns, offset_norm float32) float32 {
	columnsArg, columnsFin := columns.handle()

	defer func() {
		columnsFin()
	}()
	return float32(C.igGetColumnOffsetFromNorm(columnsArg, C.float(offset_norm)))
}

// get column width (in pixels). pass -1 to use current column
// ColumnWidthV parameter default value hint:
// column_index: -1
func ColumnWidthV(column_index int32) float32 {
	return float32(C.igGetColumnWidth(C.int(column_index)))
}

func ColumnsCount() int32 {
	return int32(C.igGetColumnsCount())
}

func InternalColumnsID(str_id string, count int32) ID {
	str_idArg, str_idFin := WrapString(str_id)

	defer func() {
		str_idFin()
	}()
	return *newIDFromC(func() *C.ImGuiID { result := C.igGetColumnsID(str_idArg, C.int(count)); return &result }())
}

// == GetContentRegionMax() - GetCursorPos()
func ContentRegionAvail() Vec2 {
	pOut := new(Vec2)
	pOutArg, pOutFin := wrap[C.ImVec2, *Vec2](pOut)

	C.igGetContentRegionAvail(pOutArg)

	pOutFin()

	return *pOut
}

// current content boundaries (typically window boundaries including scrolling, or current column boundaries), in windows coordinates
func ContentRegionMax() Vec2 {
	pOut := new(Vec2)
	pOutArg, pOutFin := wrap[C.ImVec2, *Vec2](pOut)

	C.igGetContentRegionMax(pOutArg)

	pOutFin()

	return *pOut
}

func InternalContentRegionMaxAbs() Vec2 {
	pOut := new(Vec2)
	pOutArg, pOutFin := wrap[C.ImVec2, *Vec2](pOut)

	C.igGetContentRegionMaxAbs(pOutArg)

	pOutFin()

	return *pOut
}

func CurrentContext() *Context {
	return newContextFromC(C.igGetCurrentContext())
}

// Focus scope we are outputting into, set by PushFocusScope()
func InternalCurrentFocusScope() ID {
	return *newIDFromC(func() *C.ImGuiID { result := C.igGetCurrentFocusScope(); return &result }())
}

func InternalCurrentTabBar() *TabBar {
	return newTabBarFromC(C.igGetCurrentTabBar())
}

func InternalCurrentTable() *Table {
	return newTableFromC(C.igGetCurrentTable())
}

func InternalCurrentWindow() *Window {
	return newWindowFromC(C.igGetCurrentWindow())
}

func InternalCurrentWindowRead() *Window {
	return newWindowFromC(C.igGetCurrentWindowRead())
}

// cursor position in window coordinates (relative to window position)
func CursorPos() Vec2 {
	pOut := new(Vec2)
	pOutArg, pOutFin := wrap[C.ImVec2, *Vec2](pOut)

	C.igGetCursorPos(pOutArg)

	pOutFin()

	return *pOut
}

// (some functions are using window-relative coordinates, such as: GetCursorPos, GetCursorStartPos, GetContentRegionMax, GetWindowContentRegion* etc.
func CursorPosX() float32 {
	return float32(C.igGetCursorPosX())
}

// other functions such as GetCursorScreenPos or everything in ImDrawList::
func CursorPosY() float32 {
	return float32(C.igGetCursorPosY())
}

// cursor position in absolute coordinates (useful to work with ImDrawList API). generally top-left == GetMainViewport()->Pos == (0,0) in single viewport mode, and bottom-right == GetMainViewport()->Pos+Size == io.DisplaySize in single-viewport mode.
func CursorScreenPos() Vec2 {
	pOut := new(Vec2)
	pOutArg, pOutFin := wrap[C.ImVec2, *Vec2](pOut)

	C.igGetCursorScreenPos(pOutArg)

	pOutFin()

	return *pOut
}

// initial cursor position in window coordinates
func CursorStartPos() Vec2 {
	pOut := new(Vec2)
	pOutArg, pOutFin := wrap[C.ImVec2, *Vec2](pOut)

	C.igGetCursorStartPos(pOutArg)

	pOutFin()

	return *pOut
}

func InternalDefaultFont() *Font {
	return newFontFromC(C.igGetDefaultFont())
}

// peek directly into the current payload from anywhere. may return NULL. use ImGuiPayload::IsDataType() to test for the payload type.
func DragDropPayload() *Payload {
	return newPayloadFromC(C.igGetDragDropPayload())
}

// valid after Render() and until the next call to NewFrame(). this is what you have to render.
func CurrentDrawData() *DrawData {
	return newDrawDataFromC(C.igGetDrawData())
}

// you may use this when creating your own ImDrawList instances.
func CurrentDrawListSharedData() *DrawListSharedData {
	return newDrawListSharedDataFromC(C.igGetDrawListSharedData())
}

func InternalFocusID() ID {
	return *newIDFromC(func() *C.ImGuiID { result := C.igGetFocusID(); return &result }())
}

// get current font
func CurrentFont() *Font {
	return newFontFromC(C.igGetFont())
}

// get current font size (= height in pixels) of current font with current scale applied
func FontSize() float32 {
	return float32(C.igGetFontSize())
}

// get UV coordinate for a while pixel, useful to draw custom shapes via the ImDrawList API
func FontTexUvWhitePixel() Vec2 {
	pOut := new(Vec2)
	pOutArg, pOutFin := wrap[C.ImVec2, *Vec2](pOut)

	C.igGetFontTexUvWhitePixel(pOutArg)

	pOutFin()

	return *pOut
}

// get foreground draw list for the viewport associated to the current window. this draw list will be the last rendered one. Useful to quickly draw shapes/text over dear imgui contents.
func ForegroundDrawListNil() *DrawList {
	return newDrawListFromC(C.igGetForegroundDrawList_Nil())
}

// get foreground draw list for the given viewport. this draw list will be the last rendered one. Useful to quickly draw shapes/text over dear imgui contents.
func ForegroundDrawListViewportPtr(viewport *Viewport) *DrawList {
	viewportArg, viewportFin := viewport.handle()

	defer func() {
		viewportFin()
	}()
	return newDrawListFromC(C.igGetForegroundDrawList_ViewportPtr(viewportArg))
}

func InternalForegroundDrawListWindowPtr(window *Window) *DrawList {
	windowArg, windowFin := window.handle()

	defer func() {
		windowFin()
	}()
	return newDrawListFromC(C.igGetForegroundDrawList_WindowPtr(windowArg))
}

// get global imgui frame count. incremented by 1 every frame.
func FrameCount() int32 {
	return int32(C.igGetFrameCount())
}

// ~ FontSize + style.FramePadding.y * 2
func FrameHeight() float32 {
	return float32(C.igGetFrameHeight())
}

// ~ FontSize + style.FramePadding.y * 2 + style.ItemSpacing.y (distance in pixels between 2 consecutive lines of framed widgets)
func FrameHeightWithSpacing() float32 {
	return float32(C.igGetFrameHeightWithSpacing())
}

func InternalHoveredID() ID {
	return *newIDFromC(func() *C.ImGuiID { result := C.igGetHoveredID(); return &result }())
}

func InternalIDWithSeedInt(n int32, seed ID) ID {
	seedArg, seedFin := seed.c()

	defer func() {
		seedFin()
	}()
	return *newIDFromC(func() *C.ImGuiID { result := C.igGetIDWithSeed_Int(C.int(n), seedArg); return &result }())
}

func InternalIDWithSeedStr(str_id_begin string, str_id_end string, seed ID) ID {
	str_id_beginArg, str_id_beginFin := WrapString(str_id_begin)
	str_id_endArg, str_id_endFin := WrapString(str_id_end)
	seedArg, seedFin := seed.c()

	defer func() {
		str_id_beginFin()
		str_id_endFin()
		seedFin()
	}()
	return *newIDFromC(func() *C.ImGuiID {
		result := C.igGetIDWithSeed_Str(str_id_beginArg, str_id_endArg, seedArg)
		return &result
	}())
}

func IDPtr(ptr_id unsafe.Pointer) ID {
	return *newIDFromC(func() *C.ImGuiID { result := C.igGetID_Ptr((ptr_id)); return &result }())
}

// calculate unique ID (hash of whole ID stack + given parameter). e.g. if you want to query into ImGuiStorage yourself
func IDStr(str_id string) ID {
	str_idArg, str_idFin := WrapString(str_id)

	defer func() {
		str_idFin()
	}()
	return *newIDFromC(func() *C.ImGuiID { result := C.igGetID_Str(str_idArg); return &result }())
}

func IDStrStr(str_id_begin string, str_id_end string) ID {
	str_id_beginArg, str_id_beginFin := WrapString(str_id_begin)
	str_id_endArg, str_id_endFin := WrapString(str_id_end)

	defer func() {
		str_id_beginFin()
		str_id_endFin()
	}()
	return *newIDFromC(func() *C.ImGuiID { result := C.igGetID_StrStr(str_id_beginArg, str_id_endArg); return &result }())
}

// access the IO structure (mouse/keyboard/gamepad inputs, time, various configuration options/flags)
func CurrentIO() *IO {
	return newIOFromC(C.igGetIO())
}

// Get input text state if active
func InternalInputTextState(id ID) *InputTextState {
	idArg, idFin := id.c()

	defer func() {
		idFin()
	}()
	return newInputTextStateFromC(C.igGetInputTextState(idArg))
}

func InternalItemFlags() ItemFlags {
	return ItemFlags(C.igGetItemFlags())
}

// get ID of last item (~~ often same ImGui::GetID(label) beforehand)
func ItemID() ID {
	return *newIDFromC(func() *C.ImGuiID { result := C.igGetItemID(); return &result }())
}

// get lower-right bounding rectangle of the last item (screen space)
func ItemRectMax() Vec2 {
	pOut := new(Vec2)
	pOutArg, pOutFin := wrap[C.ImVec2, *Vec2](pOut)

	C.igGetItemRectMax(pOutArg)

	pOutFin()

	return *pOut
}

// get upper-left bounding rectangle of the last item (screen space)
func ItemRectMin() Vec2 {
	pOut := new(Vec2)
	pOutArg, pOutFin := wrap[C.ImVec2, *Vec2](pOut)

	C.igGetItemRectMin(pOutArg)

	pOutFin()

	return *pOut
}

// get size of last item
func ItemRectSize() Vec2 {
	pOut := new(Vec2)
	pOutArg, pOutFin := wrap[C.ImVec2, *Vec2](pOut)

	C.igGetItemRectSize(pOutArg)

	pOutFin()

	return *pOut
}

func InternalItemStatusFlags() ItemStatusFlags {
	return ItemStatusFlags(C.igGetItemStatusFlags())
}

func InternalKeyChordName(key_chord KeyChord, out_buf string, out_buf_size int32) {
	key_chordArg, key_chordFin := key_chord.c()
	out_bufArg, out_bufFin := WrapString(out_buf)
	C.igGetKeyChordName(key_chordArg, out_bufArg, C.int(out_buf_size))

	key_chordFin()
	out_bufFin()
}

func InternalKeyDataContextPtr(ctx *Context, key Key) *KeyData {
	ctxArg, ctxFin := ctx.handle()

	defer func() {
		ctxFin()
	}()
	return newKeyDataFromC(C.igGetKeyData_ContextPtr(ctxArg, C.ImGuiKey(key)))
}

func InternalKeyDataKey(key Key) *KeyData {
	return newKeyDataFromC(C.igGetKeyData_Key(C.ImGuiKey(key)))
}

// map ImGuiKey_* values into legacy native key index. == io.KeyMap[key]
func KeyIndex(key Key) Key {
	return Key(C.igGetKeyIndex(C.ImGuiKey(key)))
}

func InternalKeyMagnitude2d(key_left Key, key_right Key, key_up Key, key_down Key) Vec2 {
	pOut := new(Vec2)
	pOutArg, pOutFin := wrap[C.ImVec2, *Vec2](pOut)

	C.igGetKeyMagnitude2d(pOutArg, C.ImGuiKey(key_left), C.ImGuiKey(key_right), C.ImGuiKey(key_up), C.ImGuiKey(key_down))

	pOutFin()

	return *pOut
}

// [DEBUG] returns English name of the key. Those names a provided for debugging purpose and are not meant to be saved persistently not compared.
func KeyName(key Key) string {
	return C.GoString(C.igGetKeyName(C.ImGuiKey(key)))
}

func InternalKeyOwner(key Key) ID {
	return *newIDFromC(func() *C.ImGuiID { result := C.igGetKeyOwner(C.ImGuiKey(key)); return &result }())
}

func InternalKeyOwnerData(ctx *Context, key Key) *KeyOwnerData {
	ctxArg, ctxFin := ctx.handle()

	defer func() {
		ctxFin()
	}()
	return newKeyOwnerDataFromC(C.igGetKeyOwnerData(ctxArg, C.ImGuiKey(key)))
}

// uses provided repeat rate/delay. return a count, most often 0 or 1 but might be >1 if RepeatRate is small enough that DeltaTime > RepeatRate
func KeyPressedAmount(key Key, repeat_delay float32, rate float32) int32 {
	return int32(C.igGetKeyPressedAmount(C.ImGuiKey(key), C.float(repeat_delay), C.float(rate)))
}

// return primary/default viewport. This can never be NULL.
func MainViewport() *Viewport {
	return newViewportFromC(C.igGetMainViewport())
}

// return the number of successive mouse-clicks at the time where a click happen (otherwise 0).
func MouseClickedCount(button MouseButton) int32 {
	return int32(C.igGetMouseClickedCount(C.ImGuiMouseButton(button)))
}

// get desired mouse cursor shape. Important: reset in ImGui::NewFrame(), this is updated during the frame. valid before Render(). If you use software rendering by setting io.MouseDrawCursor ImGui will render those for you
func CurrentMouseCursor() MouseCursor {
	return MouseCursor(C.igGetMouseCursor())
}

// return the delta from the initial clicking position while the mouse button is pressed or was just released. This is locked and return 0.0f until the mouse moves past a distance threshold at least once (if lock_threshold < -1.0f, uses io.MouseDraggingThreshold)
// MouseDragDeltaV parameter default value hint:
// button: 0
// lock_threshold: -1.0f
func MouseDragDeltaV(button MouseButton, lock_threshold float32) Vec2 {
	pOut := new(Vec2)
	pOutArg, pOutFin := wrap[C.ImVec2, *Vec2](pOut)

	C.igGetMouseDragDelta(pOutArg, C.ImGuiMouseButton(button), C.float(lock_threshold))

	pOutFin()

	return *pOut
}

// shortcut to ImGui::GetIO().MousePos provided by user, to be consistent with other calls
func MousePos() Vec2 {
	pOut := new(Vec2)
	pOutArg, pOutFin := wrap[C.ImVec2, *Vec2](pOut)

	C.igGetMousePos(pOutArg)

	pOutFin()

	return *pOut
}

// retrieve mouse position at the time of opening popup we have BeginPopup() into (helper to avoid user backing that value themselves)
func MousePosOnOpeningCurrentPopup() Vec2 {
	pOut := new(Vec2)
	pOutArg, pOutFin := wrap[C.ImVec2, *Vec2](pOut)

	C.igGetMousePosOnOpeningCurrentPopup(pOutArg)

	pOutFin()

	return *pOut
}

func InternalNavTweakPressedAmount(axis Axis) float32 {
	return float32(C.igGetNavTweakPressedAmount(C.ImGuiAxis(axis)))
}

// platform/renderer functions, for backend to setup + viewports list.
func CurrentPlatformIO() *PlatformIO {
	return newPlatformIOFromC(C.igGetPlatformIO())
}

func InternalPopupAllowedExtentRect(window *Window) Rect {
	pOut := new(Rect)
	pOutArg, pOutFin := wrap[C.ImRect, *Rect](pOut)

	windowArg, windowFin := window.handle()
	C.igGetPopupAllowedExtentRect(pOutArg, windowArg)

	pOutFin()
	windowFin()

	return *pOut
}

// get maximum scrolling amount ~~ ContentSize.x - WindowSize.x - DecorationsSize.x
func ScrollMaxX() float32 {
	return float32(C.igGetScrollMaxX())
}

// get maximum scrolling amount ~~ ContentSize.y - WindowSize.y - DecorationsSize.y
func ScrollMaxY() float32 {
	return float32(C.igGetScrollMaxY())
}

// get scrolling amount [0 .. GetScrollMaxX()]
func ScrollX() float32 {
	return float32(C.igGetScrollX())
}

// get scrolling amount [0 .. GetScrollMaxY()]
func ScrollY() float32 {
	return float32(C.igGetScrollY())
}

func InternalShortcutRoutingData(key_chord KeyChord) *KeyRoutingData {
	key_chordArg, key_chordFin := key_chord.c()

	defer func() {
		key_chordFin()
	}()
	return newKeyRoutingDataFromC(C.igGetShortcutRoutingData(key_chordArg))
}

func StateStorage() *Storage {
	return newStorageFromC(C.igGetStateStorage())
}

// access the Style structure (colors, sizes). Always use PushStyleCol(), PushStyleVar() to modify style mid-frame!
func CurrentStyle() *Style {
	return newStyleFromC(C.igGetStyle())
}

// get a string corresponding to the enum value (for display, saving, etc.).
func StyleColorName(idx Col) string {
	return C.GoString(C.igGetStyleColorName(C.ImGuiCol(idx)))
}

// retrieve style color as stored in ImGuiStyle structure. use to feed back into PushStyleColor(), otherwise use GetColorU32() to get style color with style alpha baked in.
func StyleColorVec4(idx Col) *Vec4 {
	return (&Vec4{}).fromC(*C.igGetStyleColorVec4(C.ImGuiCol(idx)))
}

func InternalStyleVarInfo(idx StyleVar) *DataVarInfo {
	return newDataVarInfoFromC(C.igGetStyleVarInfo(C.ImGuiStyleVar(idx)))
}

// ~ FontSize
func TextLineHeight() float32 {
	return float32(C.igGetTextLineHeight())
}

// ~ FontSize + style.ItemSpacing.y (distance in pixels between 2 consecutive lines of text)
func TextLineHeightWithSpacing() float32 {
	return float32(C.igGetTextLineHeightWithSpacing())
}

// get global imgui time. incremented by io.DeltaTime every frame.
func Time() float64 {
	return float64(C.igGetTime())
}

func InternalTopMostAndVisiblePopupModal() *Window {
	return newWindowFromC(C.igGetTopMostAndVisiblePopupModal())
}

func InternalTopMostPopupModal() *Window {
	return newWindowFromC(C.igGetTopMostPopupModal())
}

// horizontal distance preceding label when using TreeNode*() or Bullet() == (g.FontSize + style.FramePadding.x*2) for a regular unframed TreeNode
func TreeNodeToLabelSpacing() float32 {
	return float32(C.igGetTreeNodeToLabelSpacing())
}

func InternalTypematicRepeatRate(flags InputFlags, repeat_delay *float32, repeat_rate *float32) {
	repeat_delayArg, repeat_delayFin := WrapNumberPtr[C.float, float32](repeat_delay)
	repeat_rateArg, repeat_rateFin := WrapNumberPtr[C.float, float32](repeat_rate)
	C.igGetTypematicRepeatRate(C.ImGuiInputFlags(flags), repeat_delayArg, repeat_rateArg)

	repeat_delayFin()
	repeat_rateFin()
}

// InternalTypingSelectRequestV parameter default value hint:
// flags: ImGuiTypingSelectFlags_None
func InternalTypingSelectRequestV(flags TypingSelectFlags) *TypingSelectRequest {
	return newTypingSelectRequestFromC(C.igGetTypingSelectRequest(C.ImGuiTypingSelectFlags(flags)))
}

// get the compiled version string e.g. "1.80 WIP" (essentially the value for IMGUI_VERSION from the compiled version of imgui.cpp)
func Version() string {
	return C.GoString(C.igGetVersion())
}

func InternalViewportPlatformMonitor(viewport *Viewport) *PlatformMonitor {
	viewportArg, viewportFin := viewport.handle()

	defer func() {
		viewportFin()
	}()
	return newPlatformMonitorFromC(C.igGetViewportPlatformMonitor(viewportArg))
}

func InternalWindowAlwaysWantOwnTabBar(window *Window) bool {
	windowArg, windowFin := window.handle()

	defer func() {
		windowFin()
	}()
	return C.igGetWindowAlwaysWantOwnTabBar(windowArg) == C.bool(true)
}

// content boundaries max for the full window (roughly (0,0)+Size-Scroll) where Size can be overridden with SetNextWindowContentSize(), in window coordinates
func WindowContentRegionMax() Vec2 {
	pOut := new(Vec2)
	pOutArg, pOutFin := wrap[C.ImVec2, *Vec2](pOut)

	C.igGetWindowContentRegionMax(pOutArg)

	pOutFin()

	return *pOut
}

// content boundaries min for the full window (roughly (0,0)-Scroll), in window coordinates
func WindowContentRegionMin() Vec2 {
	pOut := new(Vec2)
	pOutArg, pOutFin := wrap[C.ImVec2, *Vec2](pOut)

	C.igGetWindowContentRegionMin(pOutArg)

	pOutFin()

	return *pOut
}

func WindowDockID() ID {
	return *newIDFromC(func() *C.ImGuiID { result := C.igGetWindowDockID(); return &result }())
}

func InternalWindowDockNode() *DockNode {
	return newDockNodeFromC(C.igGetWindowDockNode())
}

// get DPI scale currently associated to the current window's viewport.
func WindowDpiScale() float32 {
	return float32(C.igGetWindowDpiScale())
}

// get draw list associated to the current window, to append your own drawing primitives
func WindowDrawList() *DrawList {
	return newDrawListFromC(C.igGetWindowDrawList())
}

// get current window height (shortcut for GetWindowSize().y)
func WindowHeight() float32 {
	return float32(C.igGetWindowHeight())
}

// get current window position in screen space (note: it is unlikely you need to use this. Consider using current layout pos instead, GetScreenCursorPos())
func WindowPos() Vec2 {
	pOut := new(Vec2)
	pOutArg, pOutFin := wrap[C.ImVec2, *Vec2](pOut)

	C.igGetWindowPos(pOutArg)

	pOutFin()

	return *pOut
}

func InternalWindowResizeBorderID(window *Window, dir Dir) ID {
	windowArg, windowFin := window.handle()

	defer func() {
		windowFin()
	}()
	return *newIDFromC(func() *C.ImGuiID { result := C.igGetWindowResizeBorderID(windowArg, C.ImGuiDir(dir)); return &result }())
}

// 0..3: corners
func InternalWindowResizeCornerID(window *Window, n int32) ID {
	windowArg, windowFin := window.handle()

	defer func() {
		windowFin()
	}()
	return *newIDFromC(func() *C.ImGuiID { result := C.igGetWindowResizeCornerID(windowArg, C.int(n)); return &result }())
}

func InternalWindowScrollbarID(window *Window, axis Axis) ID {
	windowArg, windowFin := window.handle()

	defer func() {
		windowFin()
	}()
	return *newIDFromC(func() *C.ImGuiID { result := C.igGetWindowScrollbarID(windowArg, C.ImGuiAxis(axis)); return &result }())
}

func InternalWindowScrollbarRect(window *Window, axis Axis) Rect {
	pOut := new(Rect)
	pOutArg, pOutFin := wrap[C.ImRect, *Rect](pOut)

	windowArg, windowFin := window.handle()
	C.igGetWindowScrollbarRect(pOutArg, windowArg, C.ImGuiAxis(axis))

	pOutFin()
	windowFin()

	return *pOut
}

// get current window size (note: it is unlikely you need to use this. Consider using GetScreenCursorPos() and e.g. GetContentRegionAvail() instead)
func WindowSize() Vec2 {
	pOut := new(Vec2)
	pOutArg, pOutFin := wrap[C.ImVec2, *Vec2](pOut)

	C.igGetWindowSize(pOutArg)

	pOutFin()

	return *pOut
}

// get viewport currently associated to the current window.
func WindowViewport() *Viewport {
	return newViewportFromC(C.igGetWindowViewport())
}

// get current window width (shortcut for GetWindowSize().x)
func WindowWidth() float32 {
	return float32(C.igGetWindowWidth())
}

func InternalImAbsFloat(x float32) float32 {
	return float32(C.igImAbs_Float(C.float(x)))
}

func InternalImAbsInt(x int32) int32 {
	return int32(C.igImAbs_Int(C.int(x)))
}

func InternalImAbsDouble(x float64) float64 {
	return float64(C.igImAbs_double(C.double(x)))
}

func InternalImAlphaBlendColors(col_a uint32, col_b uint32) uint32 {
	return uint32(C.igImAlphaBlendColors(C.ImU32(col_a), C.ImU32(col_b)))
}

func InternalImBezierCubicCalc(p1 Vec2, p2 Vec2, p3 Vec2, p4 Vec2, t float32) Vec2 {
	pOut := new(Vec2)
	pOutArg, pOutFin := wrap[C.ImVec2, *Vec2](pOut)

	C.igImBezierCubicCalc(pOutArg, p1.toC(), p2.toC(), p3.toC(), p4.toC(), C.float(t))

	pOutFin()

	return *pOut
}

// For curves with explicit number of segments
func InternalImBezierCubicClosestPoint(p1 Vec2, p2 Vec2, p3 Vec2, p4 Vec2, p Vec2, num_segments int32) Vec2 {
	pOut := new(Vec2)
	pOutArg, pOutFin := wrap[C.ImVec2, *Vec2](pOut)

	C.igImBezierCubicClosestPoint(pOutArg, p1.toC(), p2.toC(), p3.toC(), p4.toC(), p.toC(), C.int(num_segments))

	pOutFin()

	return *pOut
}

// For auto-tessellated curves you can use tess_tol = style.CurveTessellationTol
func InternalImBezierCubicClosestPointCasteljau(p1 Vec2, p2 Vec2, p3 Vec2, p4 Vec2, p Vec2, tess_tol float32) Vec2 {
	pOut := new(Vec2)
	pOutArg, pOutFin := wrap[C.ImVec2, *Vec2](pOut)

	C.igImBezierCubicClosestPointCasteljau(pOutArg, p1.toC(), p2.toC(), p3.toC(), p4.toC(), p.toC(), C.float(tess_tol))

	pOutFin()

	return *pOut
}

func InternalImBezierQuadraticCalc(p1 Vec2, p2 Vec2, p3 Vec2, t float32) Vec2 {
	pOut := new(Vec2)
	pOutArg, pOutFin := wrap[C.ImVec2, *Vec2](pOut)

	C.igImBezierQuadraticCalc(pOutArg, p1.toC(), p2.toC(), p3.toC(), C.float(t))

	pOutFin()

	return *pOut
}

func InternalImBitArrayClearAllBits(arr *uint32, bitcount int32) {
	arrArg, arrFin := WrapNumberPtr[C.ImU32, uint32](arr)
	C.igImBitArrayClearAllBits(arrArg, C.int(bitcount))

	arrFin()
}

func InternalImBitArrayClearBit(arr *uint32, n int32) {
	arrArg, arrFin := WrapNumberPtr[C.ImU32, uint32](arr)
	C.igImBitArrayClearBit(arrArg, C.int(n))

	arrFin()
}

func InternalImBitArrayGetStorageSizeInBytes(bitcount int32) uint64 {
	return uint64(C.igImBitArrayGetStorageSizeInBytes(C.int(bitcount)))
}

func InternalImBitArraySetBit(arr *uint32, n int32) {
	arrArg, arrFin := WrapNumberPtr[C.ImU32, uint32](arr)
	C.igImBitArraySetBit(arrArg, C.int(n))

	arrFin()
}

func InternalImBitArraySetBitRange(arr *uint32, n int32, n2 int32) {
	arrArg, arrFin := WrapNumberPtr[C.ImU32, uint32](arr)
	C.igImBitArraySetBitRange(arrArg, C.int(n), C.int(n2))

	arrFin()
}

func InternalImBitArrayTestBit(arr *[]uint32, n int32) bool {
	arrArg := make([]C.ImU32, len(*arr))
	for i, arrV := range *arr {
		arrArg[i] = C.ImU32(arrV)
	}

	defer func() {
		for i, arrV := range arrArg {
			(*arr)[i] = uint32(arrV)
		}
	}()
	return C.igImBitArrayTestBit((*C.ImU32)(&arrArg[0]), C.int(n)) == C.bool(true)
}

func InternalImCharIsBlankA(c rune) bool {
	return C.igImCharIsBlankA(C.char(c)) == C.bool(true)
}

func InternalImCharIsBlankW(c uint32) bool {
	return C.igImCharIsBlankW(C.uint(c)) == C.bool(true)
}

func InternalImClamp(v Vec2, mn Vec2, mx Vec2) Vec2 {
	pOut := new(Vec2)
	pOutArg, pOutFin := wrap[C.ImVec2, *Vec2](pOut)

	C.igImClamp(pOutArg, v.toC(), mn.toC(), mx.toC())

	pOutFin()

	return *pOut
}

func InternalImDot(a Vec2, b Vec2) float32 {
	return float32(C.igImDot(a.toC(), b.toC()))
}

func InternalImExponentialMovingAverage(avg float32, sample float32, n int32) float32 {
	return float32(C.igImExponentialMovingAverage(C.float(avg), C.float(sample), C.int(n)))
}

// InternalImFileLoadToMemoryV parameter default value hint:
// out_file_size: NULL
// padding_bytes: 0
func InternalImFileLoadToMemoryV(filename string, mode string, out_file_size *uint64, padding_bytes int32) unsafe.Pointer {
	filenameArg, filenameFin := WrapString(filename)
	modeArg, modeFin := WrapString(mode)

	defer func() {
		filenameFin()
		modeFin()
	}()
	return unsafe.Pointer(C.igImFileLoadToMemory(filenameArg, modeArg, (*C.xulong)(out_file_size), C.int(padding_bytes)))
}

// Decent replacement for floorf()
func InternalImFloorSignedFloat(f float32) float32 {
	return float32(C.igImFloorSigned_Float(C.float(f)))
}

func InternalImFloorSignedVec2(v Vec2) Vec2 {
	pOut := new(Vec2)
	pOutArg, pOutFin := wrap[C.ImVec2, *Vec2](pOut)

	C.igImFloorSigned_Vec2(pOutArg, v.toC())

	pOutFin()

	return *pOut
}

func InternalImFloorFloat(f float32) float32 {
	return float32(C.igImFloor_Float(C.float(f)))
}

func InternalImFloorVec2(v Vec2) Vec2 {
	pOut := new(Vec2)
	pOutArg, pOutFin := wrap[C.ImVec2, *Vec2](pOut)

	C.igImFloor_Vec2(pOutArg, v.toC())

	pOutFin()

	return *pOut
}

func InternalImFontAtlasBuildFinish(atlas *FontAtlas) {
	atlasArg, atlasFin := atlas.handle()
	C.igImFontAtlasBuildFinish(atlasArg)

	atlasFin()
}

func InternalImFontAtlasBuildInit(atlas *FontAtlas) {
	atlasArg, atlasFin := atlas.handle()
	C.igImFontAtlasBuildInit(atlasArg)

	atlasFin()
}

func InternalImFontAtlasBuildPackCustomRects(atlas *FontAtlas, stbrp_context_opaque unsafe.Pointer) {
	atlasArg, atlasFin := atlas.handle()
	stbrp_context_opaqueArg, stbrp_context_opaqueFin := WrapVoidPtr(stbrp_context_opaque)
	C.igImFontAtlasBuildPackCustomRects(atlasArg, stbrp_context_opaqueArg)

	atlasFin()
	stbrp_context_opaqueFin()
}

func InternalImFontAtlasBuildRender32bppRectFromString(atlas *FontAtlas, x int32, y int32, w int32, h int32, in_str string, in_marker_char rune, in_marker_pixel_value uint32) {
	atlasArg, atlasFin := atlas.handle()
	in_strArg, in_strFin := WrapString(in_str)
	C.igImFontAtlasBuildRender32bppRectFromString(atlasArg, C.int(x), C.int(y), C.int(w), C.int(h), in_strArg, C.char(in_marker_char), C.uint(in_marker_pixel_value))

	atlasFin()
	in_strFin()
}

func InternalImFontAtlasBuildRender8bppRectFromString(atlas *FontAtlas, x int32, y int32, w int32, h int32, in_str string, in_marker_char rune, in_marker_pixel_value uint) {
	atlasArg, atlasFin := atlas.handle()
	in_strArg, in_strFin := WrapString(in_str)
	C.igImFontAtlasBuildRender8bppRectFromString(atlasArg, C.int(x), C.int(y), C.int(w), C.int(h), in_strArg, C.char(in_marker_char), C.uchar(in_marker_pixel_value))

	atlasFin()
	in_strFin()
}

func InternalImFontAtlasBuildSetupFont(atlas *FontAtlas, font *Font, font_config *FontConfig, ascent float32, descent float32) {
	atlasArg, atlasFin := atlas.handle()
	fontArg, fontFin := font.handle()
	font_configArg, font_configFin := font_config.handle()
	C.igImFontAtlasBuildSetupFont(atlasArg, fontArg, font_configArg, C.float(ascent), C.float(descent))

	atlasFin()
	fontFin()
	font_configFin()
}

func InternalImFontAtlasGetBuilderForStbTruetype() *FontBuilderIO {
	return newFontBuilderIOFromC(C.igImFontAtlasGetBuilderForStbTruetype())
}

func InternalImFontAtlasUpdateConfigDataPointers(atlas *FontAtlas) {
	atlasArg, atlasFin := atlas.handle()
	C.igImFontAtlasUpdateConfigDataPointers(atlasArg)

	atlasFin()
}

func InternalImFormatString(buf string, buf_size uint64, fmt string) int32 {
	bufArg, bufFin := WrapString(buf)
	fmtArg, fmtFin := WrapString(fmt)

	defer func() {
		bufFin()
		fmtFin()
	}()
	return int32(C.wrap_igImFormatString(bufArg, C.xulong(buf_size), fmtArg))
}

func InternalImFormatStringToTempBuffer(out_buf []string, out_buf_end []string, fmt string) {
	out_bufArg, out_bufFin := WrapStringList(out_buf)
	out_buf_endArg, out_buf_endFin := WrapStringList(out_buf_end)
	fmtArg, fmtFin := WrapString(fmt)
	C.wrap_igImFormatStringToTempBuffer(out_bufArg, out_buf_endArg, fmtArg)

	out_bufFin()
	out_buf_endFin()
	fmtFin()
}

// InternalImHashDataV parameter default value hint:
// seed: 0
func InternalImHashDataV(data unsafe.Pointer, data_size uint64, seed ID) ID {
	seedArg, seedFin := seed.c()

	defer func() {
		seedFin()
	}()
	return *newIDFromC(func() *C.ImGuiID { result := C.igImHashData((data), C.xulong(data_size), seedArg); return &result }())
}

// InternalImHashStrV parameter default value hint:
// data_size: 0
// seed: 0
func InternalImHashStrV(data string, data_size uint64, seed ID) ID {
	dataArg, dataFin := WrapString(data)
	seedArg, seedFin := seed.c()

	defer func() {
		dataFin()
		seedFin()
	}()
	return *newIDFromC(func() *C.ImGuiID { result := C.igImHashStr(dataArg, C.xulong(data_size), seedArg); return &result }())
}

func InternalImInvLength(lhs Vec2, fail_value float32) float32 {
	return float32(C.igImInvLength(lhs.toC(), C.float(fail_value)))
}

func InternalImIsFloatAboveGuaranteedIntegerPrecision(f float32) bool {
	return C.igImIsFloatAboveGuaranteedIntegerPrecision(C.float(f)) == C.bool(true)
}

func InternalImIsPowerOfTwoInt(v int32) bool {
	return C.igImIsPowerOfTwo_Int(C.int(v)) == C.bool(true)
}

func InternalImIsPowerOfTwoU64(v uint64) bool {
	return C.igImIsPowerOfTwo_U64(C.ImU64(v)) == C.bool(true)
}

func InternalImLengthSqrVec2(lhs Vec2) float32 {
	return float32(C.igImLengthSqr_Vec2(lhs.toC()))
}

func InternalImLengthSqrVec4(lhs Vec4) float32 {
	return float32(C.igImLengthSqr_Vec4(lhs.toC()))
}

func InternalImLerpVec2Float(a Vec2, b Vec2, t float32) Vec2 {
	pOut := new(Vec2)
	pOutArg, pOutFin := wrap[C.ImVec2, *Vec2](pOut)

	C.igImLerp_Vec2Float(pOutArg, a.toC(), b.toC(), C.float(t))

	pOutFin()

	return *pOut
}

func InternalImLerpVec2Vec2(a Vec2, b Vec2, t Vec2) Vec2 {
	pOut := new(Vec2)
	pOutArg, pOutFin := wrap[C.ImVec2, *Vec2](pOut)

	C.igImLerp_Vec2Vec2(pOutArg, a.toC(), b.toC(), t.toC())

	pOutFin()

	return *pOut
}

func InternalImLerpVec4(a Vec4, b Vec4, t float32) Vec4 {
	pOut := new(Vec4)
	pOutArg, pOutFin := wrap[C.ImVec4, *Vec4](pOut)

	C.igImLerp_Vec4(pOutArg, a.toC(), b.toC(), C.float(t))

	pOutFin()

	return *pOut
}

func InternalImLineClosestPoint(a Vec2, b Vec2, p Vec2) Vec2 {
	pOut := new(Vec2)
	pOutArg, pOutFin := wrap[C.ImVec2, *Vec2](pOut)

	C.igImLineClosestPoint(pOutArg, a.toC(), b.toC(), p.toC())

	pOutFin()

	return *pOut
}

func InternalImLinearSweep(current float32, target float32, speed float32) float32 {
	return float32(C.igImLinearSweep(C.float(current), C.float(target), C.float(speed)))
}

// DragBehaviorT/SliderBehaviorT uses ImLog with either float/double and need the precision
func InternalImLogFloat(x float32) float32 {
	return float32(C.igImLog_Float(C.float(x)))
}

func InternalImLogDouble(x float64) float64 {
	return float64(C.igImLog_double(C.double(x)))
}

func InternalImMax(lhs Vec2, rhs Vec2) Vec2 {
	pOut := new(Vec2)
	pOutArg, pOutFin := wrap[C.ImVec2, *Vec2](pOut)

	C.igImMax(pOutArg, lhs.toC(), rhs.toC())

	pOutFin()

	return *pOut
}

func InternalImMin(lhs Vec2, rhs Vec2) Vec2 {
	pOut := new(Vec2)
	pOutArg, pOutFin := wrap[C.ImVec2, *Vec2](pOut)

	C.igImMin(pOutArg, lhs.toC(), rhs.toC())

	pOutFin()

	return *pOut
}

func InternalImModPositive(a int32, b int32) int32 {
	return int32(C.igImModPositive(C.int(a), C.int(b)))
}

func InternalImMul(lhs Vec2, rhs Vec2) Vec2 {
	pOut := new(Vec2)
	pOutArg, pOutFin := wrap[C.ImVec2, *Vec2](pOut)

	C.igImMul(pOutArg, lhs.toC(), rhs.toC())

	pOutFin()

	return *pOut
}

func InternalImParseFormatFindEnd(format string) string {
	formatArg, formatFin := WrapString(format)

	defer func() {
		formatFin()
	}()
	return C.GoString(C.igImParseFormatFindEnd(formatArg))
}

func InternalImParseFormatFindStart(format string) string {
	formatArg, formatFin := WrapString(format)

	defer func() {
		formatFin()
	}()
	return C.GoString(C.igImParseFormatFindStart(formatArg))
}

func InternalImParseFormatPrecision(format string, default_value int32) int32 {
	formatArg, formatFin := WrapString(format)

	defer func() {
		formatFin()
	}()
	return int32(C.igImParseFormatPrecision(formatArg, C.int(default_value)))
}

func InternalImParseFormatSanitizeForPrinting(fmt_in string, fmt_out string, fmt_out_size uint64) {
	fmt_inArg, fmt_inFin := WrapString(fmt_in)
	fmt_outArg, fmt_outFin := WrapString(fmt_out)
	C.igImParseFormatSanitizeForPrinting(fmt_inArg, fmt_outArg, C.xulong(fmt_out_size))

	fmt_inFin()
	fmt_outFin()
}

func InternalImParseFormatSanitizeForScanning(fmt_in string, fmt_out string, fmt_out_size uint64) string {
	fmt_inArg, fmt_inFin := WrapString(fmt_in)
	fmt_outArg, fmt_outFin := WrapString(fmt_out)

	defer func() {
		fmt_inFin()
		fmt_outFin()
	}()
	return C.GoString(C.igImParseFormatSanitizeForScanning(fmt_inArg, fmt_outArg, C.xulong(fmt_out_size)))
}

func InternalImParseFormatTrimDecorations(format string, buf string, buf_size uint64) string {
	formatArg, formatFin := WrapString(format)
	bufArg, bufFin := WrapString(buf)

	defer func() {
		formatFin()
		bufFin()
	}()
	return C.GoString(C.igImParseFormatTrimDecorations(formatArg, bufArg, C.xulong(buf_size)))
}

// DragBehaviorT/SliderBehaviorT uses ImPow with either float/double and need the precision
func InternalImPowFloat(x float32, y float32) float32 {
	return float32(C.igImPow_Float(C.float(x), C.float(y)))
}

func InternalImPowDouble(x float64, y float64) float64 {
	return float64(C.igImPow_double(C.double(x), C.double(y)))
}

func InternalImRotate(v Vec2, cos_a float32, sin_a float32) Vec2 {
	pOut := new(Vec2)
	pOutArg, pOutFin := wrap[C.ImVec2, *Vec2](pOut)

	C.igImRotate(pOutArg, v.toC(), C.float(cos_a), C.float(sin_a))

	pOutFin()

	return *pOut
}

func InternalImRsqrtFloat(x float32) float32 {
	return float32(C.igImRsqrt_Float(C.float(x)))
}

func InternalImRsqrtDouble(x float64) float64 {
	return float64(C.igImRsqrt_double(C.double(x)))
}

func InternalImSaturate(f float32) float32 {
	return float32(C.igImSaturate(C.float(f)))
}

// Sign operator - returns -1, 0 or 1 based on sign of argument
func InternalImSignFloat(x float32) float32 {
	return float32(C.igImSign_Float(C.float(x)))
}

func InternalImSignDouble(x float64) float64 {
	return float64(C.igImSign_double(C.double(x)))
}

// Find first non-blank character.
func InternalImStrSkipBlank(str string) string {
	strArg, strFin := WrapString(str)

	defer func() {
		strFin()
	}()
	return C.GoString(C.igImStrSkipBlank(strArg))
}

// Remove leading and trailing blanks from a buffer.
func InternalImStrTrimBlanks(str string) {
	strArg, strFin := WrapString(str)
	C.igImStrTrimBlanks(strArg)

	strFin()
}

// Find beginning-of-line (ImWchar string)
func InternalImStrbolW(buf_mid_line *Wchar, buf_begin *Wchar) *Wchar {
	return (*Wchar)(C.igImStrbolW((*C.ImWchar)(buf_mid_line), (*C.ImWchar)(buf_begin)))
}

// Find first occurrence of 'c' in string range.
func InternalImStrchrRange(str_begin string, str_end string, c rune) string {
	str_beginArg, str_beginFin := WrapString(str_begin)
	str_endArg, str_endFin := WrapString(str_end)

	defer func() {
		str_beginFin()
		str_endFin()
	}()
	return C.GoString(C.igImStrchrRange(str_beginArg, str_endArg, C.char(c)))
}

// Duplicate a string.
func InternalImStrdup(str string) string {
	strArg, strFin := WrapString(str)

	defer func() {
		strFin()
	}()
	return C.GoString(C.igImStrdup(strArg))
}

// Copy in provided buffer, recreate buffer if needed.
func InternalImStrdupcpy(dst string, p_dst_size *uint64, str string) string {
	dstArg, dstFin := WrapString(dst)
	strArg, strFin := WrapString(str)

	defer func() {
		dstFin()
		strFin()
	}()
	return C.GoString(C.igImStrdupcpy(dstArg, (*C.xulong)(p_dst_size), strArg))
}

// End end-of-line
func InternalImStreolRange(str string, str_end string) string {
	strArg, strFin := WrapString(str)
	str_endArg, str_endFin := WrapString(str_end)

	defer func() {
		strFin()
		str_endFin()
	}()
	return C.GoString(C.igImStreolRange(strArg, str_endArg))
}

// Case insensitive compare.
func InternalImStricmp(str1 string, str2 string) int32 {
	str1Arg, str1Fin := WrapString(str1)
	str2Arg, str2Fin := WrapString(str2)

	defer func() {
		str1Fin()
		str2Fin()
	}()
	return int32(C.igImStricmp(str1Arg, str2Arg))
}

// Find a substring in a string range.
func InternalImStristr(haystack string, haystack_end string, needle string, needle_end string) string {
	haystackArg, haystackFin := WrapString(haystack)
	haystack_endArg, haystack_endFin := WrapString(haystack_end)
	needleArg, needleFin := WrapString(needle)
	needle_endArg, needle_endFin := WrapString(needle_end)

	defer func() {
		haystackFin()
		haystack_endFin()
		needleFin()
		needle_endFin()
	}()
	return C.GoString(C.igImStristr(haystackArg, haystack_endArg, needleArg, needle_endArg))
}

// Computer string length (ImWchar string)
func InternalImStrlenW(str *Wchar) int32 {
	return int32(C.igImStrlenW((*C.ImWchar)(str)))
}

// Copy to a certain count and always zero terminate (strncpy doesn't).
func InternalImStrncpy(dst string, src string, count uint64) {
	dstArg, dstFin := WrapString(dst)
	srcArg, srcFin := WrapString(src)
	C.igImStrncpy(dstArg, srcArg, C.xulong(count))

	dstFin()
	srcFin()
}

// Case insensitive compare to a certain count.
func InternalImStrnicmp(str1 string, str2 string, count uint64) int32 {
	str1Arg, str1Fin := WrapString(str1)
	str2Arg, str2Fin := WrapString(str2)

	defer func() {
		str1Fin()
		str2Fin()
	}()
	return int32(C.igImStrnicmp(str1Arg, str2Arg, C.xulong(count)))
}

// read one character. return input UTF-8 bytes count
func InternalImTextCharFromUtf8(out_char *uint32, in_text string, in_text_end string) int32 {
	out_charArg, out_charFin := WrapNumberPtr[C.uint, uint32](out_char)
	in_textArg, in_textFin := WrapString(in_text)
	in_text_endArg, in_text_endFin := WrapString(in_text_end)

	defer func() {
		out_charFin()
		in_textFin()
		in_text_endFin()
	}()
	return int32(C.igImTextCharFromUtf8(out_charArg, in_textArg, in_text_endArg))
}

// return out_buf
func InternalImTextCharToUtf8(out_buf *[5]rune, c uint32) string {
	out_bufArg := make([]C.char, len(out_buf))
	for i, out_bufV := range out_buf {
		out_bufArg[i] = C.char(out_bufV)
	}

	defer func() {
		for i, out_bufV := range out_bufArg {
			(*out_buf)[i] = rune(out_bufV)
		}
	}()
	return C.GoString(C.igImTextCharToUtf8((*C.char)(&out_bufArg[0]), C.uint(c)))
}

// return number of UTF-8 code-points (NOT bytes count)
func InternalImTextCountCharsFromUtf8(in_text string, in_text_end string) int32 {
	in_textArg, in_textFin := WrapString(in_text)
	in_text_endArg, in_text_endFin := WrapString(in_text_end)

	defer func() {
		in_textFin()
		in_text_endFin()
	}()
	return int32(C.igImTextCountCharsFromUtf8(in_textArg, in_text_endArg))
}

// return number of bytes to express one char in UTF-8
func InternalImTextCountUtf8BytesFromChar(in_text string, in_text_end string) int32 {
	in_textArg, in_textFin := WrapString(in_text)
	in_text_endArg, in_text_endFin := WrapString(in_text_end)

	defer func() {
		in_textFin()
		in_text_endFin()
	}()
	return int32(C.igImTextCountUtf8BytesFromChar(in_textArg, in_text_endArg))
}

// return number of bytes to express string in UTF-8
func InternalImTextCountUtf8BytesFromStr(in_text *Wchar, in_text_end *Wchar) int32 {
	return int32(C.igImTextCountUtf8BytesFromStr((*C.ImWchar)(in_text), (*C.ImWchar)(in_text_end)))
}

// return previous UTF-8 code-point.
func InternalImTextFindPreviousUtf8Codepoint(in_text_start string, in_text_curr string) string {
	in_text_startArg, in_text_startFin := WrapString(in_text_start)
	in_text_currArg, in_text_currFin := WrapString(in_text_curr)

	defer func() {
		in_text_startFin()
		in_text_currFin()
	}()
	return C.GoString(C.igImTextFindPreviousUtf8Codepoint(in_text_startArg, in_text_currArg))
}

// return input UTF-8 bytes count
// InternalImTextStrFromUtf8V parameter default value hint:
// in_remaining: NULL
func InternalImTextStrFromUtf8V(out_buf *Wchar, out_buf_size int32, in_text string, in_text_end string, in_remaining []string) int32 {
	in_textArg, in_textFin := WrapString(in_text)
	in_text_endArg, in_text_endFin := WrapString(in_text_end)
	in_remainingArg, in_remainingFin := WrapStringList(in_remaining)

	defer func() {
		in_textFin()
		in_text_endFin()
		in_remainingFin()
	}()
	return int32(C.igImTextStrFromUtf8((*C.ImWchar)(out_buf), C.int(out_buf_size), in_textArg, in_text_endArg, in_remainingArg))
}

// return output UTF-8 bytes count
func InternalImTextStrToUtf8(out_buf string, out_buf_size int32, in_text *Wchar, in_text_end *Wchar) int32 {
	out_bufArg, out_bufFin := WrapString(out_buf)

	defer func() {
		out_bufFin()
	}()
	return int32(C.igImTextStrToUtf8(out_bufArg, C.int(out_buf_size), (*C.ImWchar)(in_text), (*C.ImWchar)(in_text_end)))
}

func InternalImToUpper(c rune) rune {
	return rune(C.igImToUpper(C.char(c)))
}

func InternalImTriangleArea(a Vec2, b Vec2, c Vec2) float32 {
	return float32(C.igImTriangleArea(a.toC(), b.toC(), c.toC()))
}

func InternalImTriangleBarycentricCoords(a Vec2, b Vec2, c Vec2, p Vec2, out_u *float32, out_v *float32, out_w *float32) {
	out_uArg, out_uFin := WrapNumberPtr[C.float, float32](out_u)
	out_vArg, out_vFin := WrapNumberPtr[C.float, float32](out_v)
	out_wArg, out_wFin := WrapNumberPtr[C.float, float32](out_w)
	C.igImTriangleBarycentricCoords(a.toC(), b.toC(), c.toC(), p.toC(), out_uArg, out_vArg, out_wArg)

	out_uFin()
	out_vFin()
	out_wFin()
}

func InternalImTriangleClosestPoint(a Vec2, b Vec2, c Vec2, p Vec2) Vec2 {
	pOut := new(Vec2)
	pOutArg, pOutFin := wrap[C.ImVec2, *Vec2](pOut)

	C.igImTriangleClosestPoint(pOutArg, a.toC(), b.toC(), c.toC(), p.toC())

	pOutFin()

	return *pOut
}

func InternalImTriangleContainsPoint(a Vec2, b Vec2, c Vec2, p Vec2) bool {
	return C.igImTriangleContainsPoint(a.toC(), b.toC(), c.toC(), p.toC()) == C.bool(true)
}

func InternalImUpperPowerOfTwo(v int32) int32 {
	return int32(C.igImUpperPowerOfTwo(C.int(v)))
}

// ImageV parameter default value hint:
// uv0: ImVec2(0,0)
// uv1: ImVec2(1,1)
// tint_col: ImVec4(1,1,1,1)
// border_col: ImVec4(0,0,0,0)
func ImageV(user_texture_id TextureID, size Vec2, uv0 Vec2, uv1 Vec2, tint_col Vec4, border_col Vec4) {
	user_texture_idArg, user_texture_idFin := user_texture_id.c()
	C.igImage(user_texture_idArg, size.toC(), uv0.toC(), uv1.toC(), tint_col.toC(), border_col.toC())

	user_texture_idFin()
}

// ImageButtonV parameter default value hint:
// uv0: ImVec2(0,0)
// uv1: ImVec2(1,1)
// bg_col: ImVec4(0,0,0,0)
// tint_col: ImVec4(1,1,1,1)
func ImageButtonV(str_id string, user_texture_id TextureID, size Vec2, uv0 Vec2, uv1 Vec2, bg_col Vec4, tint_col Vec4) bool {
	str_idArg, str_idFin := WrapString(str_id)
	user_texture_idArg, user_texture_idFin := user_texture_id.c()

	defer func() {
		str_idFin()
		user_texture_idFin()
	}()
	return C.igImageButton(str_idArg, user_texture_idArg, size.toC(), uv0.toC(), uv1.toC(), bg_col.toC(), tint_col.toC()) == C.bool(true)
}

// InternalImageButtonExV parameter default value hint:
// flags: 0
func InternalImageButtonExV(id ID, texture_id TextureID, size Vec2, uv0 Vec2, uv1 Vec2, bg_col Vec4, tint_col Vec4, flags ButtonFlags) bool {
	idArg, idFin := id.c()
	texture_idArg, texture_idFin := texture_id.c()

	defer func() {
		idFin()
		texture_idFin()
	}()
	return C.igImageButtonEx(idArg, texture_idArg, size.toC(), uv0.toC(), uv1.toC(), bg_col.toC(), tint_col.toC(), C.ImGuiButtonFlags(flags)) == C.bool(true)
}

// move content position toward the right, by indent_w, or style.IndentSpacing if indent_w <= 0
// IndentV parameter default value hint:
// indent_w: 0.0f
func IndentV(indent_w float32) {
	C.igIndent(C.float(indent_w))
}

func InternalInitialize() {
	C.igInitialize()
}

// InputDoubleV parameter default value hint:
// step: 0.0
// step_fast: 0.0
// format: "%.6f"
// flags: 0
func InputDoubleV(label string, v *float64, step float64, step_fast float64, format string, flags InputTextFlags) bool {
	labelArg, labelFin := WrapString(label)
	vArg, vFin := WrapNumberPtr[C.double, float64](v)
	formatArg, formatFin := WrapString(format)

	defer func() {
		labelFin()
		vFin()
		formatFin()
	}()
	return C.igInputDouble(labelArg, vArg, C.double(step), C.double(step_fast), formatArg, C.ImGuiInputTextFlags(flags)) == C.bool(true)
}

// InputFloatV parameter default value hint:
// step: 0.0f
// step_fast: 0.0f
// format: "%.3f"
// flags: 0
func InputFloatV(label string, v *float32, step float32, step_fast float32, format string, flags InputTextFlags) bool {
	labelArg, labelFin := WrapString(label)
	vArg, vFin := WrapNumberPtr[C.float, float32](v)
	formatArg, formatFin := WrapString(format)

	defer func() {
		labelFin()
		vFin()
		formatFin()
	}()
	return C.igInputFloat(labelArg, vArg, C.float(step), C.float(step_fast), formatArg, C.ImGuiInputTextFlags(flags)) == C.bool(true)
}

// InputFloat2V parameter default value hint:
// format: "%.3f"
// flags: 0
func InputFloat2V(label string, v *[2]float32, format string, flags InputTextFlags) bool {
	labelArg, labelFin := WrapString(label)

	vArg := make([]C.float, len(v))
	for i, vV := range v {
		vArg[i] = C.float(vV)
	}
	formatArg, formatFin := WrapString(format)

	defer func() {
		labelFin()

		for i, vV := range vArg {
			(*v)[i] = float32(vV)
		}

		formatFin()
	}()
	return C.igInputFloat2(labelArg, (*C.float)(&vArg[0]), formatArg, C.ImGuiInputTextFlags(flags)) == C.bool(true)
}

// InputFloat3V parameter default value hint:
// format: "%.3f"
// flags: 0
func InputFloat3V(label string, v *[3]float32, format string, flags InputTextFlags) bool {
	labelArg, labelFin := WrapString(label)

	vArg := make([]C.float, len(v))
	for i, vV := range v {
		vArg[i] = C.float(vV)
	}
	formatArg, formatFin := WrapString(format)

	defer func() {
		labelFin()

		for i, vV := range vArg {
			(*v)[i] = float32(vV)
		}

		formatFin()
	}()
	return C.igInputFloat3(labelArg, (*C.float)(&vArg[0]), formatArg, C.ImGuiInputTextFlags(flags)) == C.bool(true)
}

// InputFloat4V parameter default value hint:
// format: "%.3f"
// flags: 0
func InputFloat4V(label string, v *[4]float32, format string, flags InputTextFlags) bool {
	labelArg, labelFin := WrapString(label)

	vArg := make([]C.float, len(v))
	for i, vV := range v {
		vArg[i] = C.float(vV)
	}
	formatArg, formatFin := WrapString(format)

	defer func() {
		labelFin()

		for i, vV := range vArg {
			(*v)[i] = float32(vV)
		}

		formatFin()
	}()
	return C.igInputFloat4(labelArg, (*C.float)(&vArg[0]), formatArg, C.ImGuiInputTextFlags(flags)) == C.bool(true)
}

// InputIntV parameter default value hint:
// step: 1
// step_fast: 100
// flags: 0
func InputIntV(label string, v *int32, step int32, step_fast int32, flags InputTextFlags) bool {
	labelArg, labelFin := WrapString(label)
	vArg, vFin := WrapNumberPtr[C.int, int32](v)

	defer func() {
		labelFin()
		vFin()
	}()
	return C.igInputInt(labelArg, vArg, C.int(step), C.int(step_fast), C.ImGuiInputTextFlags(flags)) == C.bool(true)
}

// InputInt2V parameter default value hint:
// flags: 0
func InputInt2V(label string, v *[2]int32, flags InputTextFlags) bool {
	labelArg, labelFin := WrapString(label)

	vArg := make([]C.int, len(v))
	for i, vV := range v {
		vArg[i] = C.int(vV)
	}

	defer func() {
		labelFin()

		for i, vV := range vArg {
			(*v)[i] = int32(vV)
		}
	}()
	return C.igInputInt2(labelArg, (*C.int)(&vArg[0]), C.ImGuiInputTextFlags(flags)) == C.bool(true)
}

// InputInt3V parameter default value hint:
// flags: 0
func InputInt3V(label string, v *[3]int32, flags InputTextFlags) bool {
	labelArg, labelFin := WrapString(label)

	vArg := make([]C.int, len(v))
	for i, vV := range v {
		vArg[i] = C.int(vV)
	}

	defer func() {
		labelFin()

		for i, vV := range vArg {
			(*v)[i] = int32(vV)
		}
	}()
	return C.igInputInt3(labelArg, (*C.int)(&vArg[0]), C.ImGuiInputTextFlags(flags)) == C.bool(true)
}

// InputInt4V parameter default value hint:
// flags: 0
func InputInt4V(label string, v *[4]int32, flags InputTextFlags) bool {
	labelArg, labelFin := WrapString(label)

	vArg := make([]C.int, len(v))
	for i, vV := range v {
		vArg[i] = C.int(vV)
	}

	defer func() {
		labelFin()

		for i, vV := range vArg {
			(*v)[i] = int32(vV)
		}
	}()
	return C.igInputInt4(labelArg, (*C.int)(&vArg[0]), C.ImGuiInputTextFlags(flags)) == C.bool(true)
}

// InputScalarV parameter default value hint:
// p_step: NULL
// p_step_fast: NULL
// format: NULL
// flags: 0
func InputScalarV(label string, data_type DataType, p_data unsafe.Pointer, p_step unsafe.Pointer, p_step_fast unsafe.Pointer, format string, flags InputTextFlags) bool {
	labelArg, labelFin := WrapString(label)
	p_dataArg, p_dataFin := WrapVoidPtr(p_data)
	formatArg, formatFin := WrapString(format)

	defer func() {
		labelFin()
		p_dataFin()
		formatFin()
	}()
	return C.igInputScalar(labelArg, C.ImGuiDataType(data_type), p_dataArg, (p_step), (p_step_fast), formatArg, C.ImGuiInputTextFlags(flags)) == C.bool(true)
}

// InputScalarNV parameter default value hint:
// p_step: NULL
// p_step_fast: NULL
// format: NULL
// flags: 0
func InputScalarNV(label string, data_type DataType, p_data unsafe.Pointer, components int32, p_step unsafe.Pointer, p_step_fast unsafe.Pointer, format string, flags InputTextFlags) bool {
	labelArg, labelFin := WrapString(label)
	p_dataArg, p_dataFin := WrapVoidPtr(p_data)
	formatArg, formatFin := WrapString(format)

	defer func() {
		labelFin()
		p_dataFin()
		formatFin()
	}()
	return C.igInputScalarN(labelArg, C.ImGuiDataType(data_type), p_dataArg, C.int(components), (p_step), (p_step_fast), formatArg, C.ImGuiInputTextFlags(flags)) == C.bool(true)
}

func InternalInputTextDeactivateHook(id ID) {
	idArg, idFin := id.c()
	C.igInputTextDeactivateHook(idArg)

	idFin()
}

// flexible button behavior without the visuals, frequently useful to build custom behaviors using the public api (along with IsItemActive, IsItemHovered, etc.)
// InvisibleButtonV parameter default value hint:
// flags: 0
func InvisibleButtonV(str_id string, size Vec2, flags ButtonFlags) bool {
	str_idArg, str_idFin := WrapString(str_id)

	defer func() {
		str_idFin()
	}()
	return C.igInvisibleButton(str_idArg, size.toC(), C.ImGuiButtonFlags(flags)) == C.bool(true)
}

func InternalIsActiveIdUsingNavDir(dir Dir) bool {
	return C.igIsActiveIdUsingNavDir(C.ImGuiDir(dir)) == C.bool(true)
}

func InternalIsAliasKey(key Key) bool {
	return C.igIsAliasKey(C.ImGuiKey(key)) == C.bool(true)
}

// is any item active?
func IsAnyItemActive() bool {
	return C.igIsAnyItemActive() == C.bool(true)
}

// is any item focused?
func IsAnyItemFocused() bool {
	return C.igIsAnyItemFocused() == C.bool(true)
}

// is any item hovered?
func IsAnyItemHovered() bool {
	return C.igIsAnyItemHovered() == C.bool(true)
}

// [WILL OBSOLETE] is any mouse button held? This was designed for backends, but prefer having backend maintain a mask of held mouse buttons, because upcoming input queue system will make this invalid.
func IsAnyMouseDown() bool {
	return C.igIsAnyMouseDown() == C.bool(true)
}

func InternalIsClippedEx(bb Rect, id ID) bool {
	idArg, idFin := id.c()

	defer func() {
		idFin()
	}()
	return C.igIsClippedEx(bb.toC(), idArg) == C.bool(true)
}

func InternalIsDragDropActive() bool {
	return C.igIsDragDropActive() == C.bool(true)
}

func InternalIsDragDropPayloadBeingAccepted() bool {
	return C.igIsDragDropPayloadBeingAccepted() == C.bool(true)
}

func InternalIsGamepadKey(key Key) bool {
	return C.igIsGamepadKey(C.ImGuiKey(key)) == C.bool(true)
}

// was the last item just made active (item was previously inactive).
func IsItemActivated() bool {
	return C.igIsItemActivated() == C.bool(true)
}

// is the last item active? (e.g. button being held, text field being edited. This will continuously return true while holding mouse button on an item. Items that don't interact will always return false)
func IsItemActive() bool {
	return C.igIsItemActive() == C.bool(true)
}

// is the last item hovered and mouse clicked on? (**)  == IsMouseClicked(mouse_button) && IsItemHovered()Important. (**) this is NOT equivalent to the behavior of e.g. Button(). Read comments in function definition.
// IsItemClickedV parameter default value hint:
// mouse_button: 0
func IsItemClickedV(mouse_button MouseButton) bool {
	return C.igIsItemClicked(C.ImGuiMouseButton(mouse_button)) == C.bool(true)
}

// was the last item just made inactive (item was previously active). Useful for Undo/Redo patterns with widgets that require continuous editing.
func IsItemDeactivated() bool {
	return C.igIsItemDeactivated() == C.bool(true)
}

// was the last item just made inactive and made a value change when it was active? (e.g. Slider/Drag moved). Useful for Undo/Redo patterns with widgets that require continuous editing. Note that you may get false positives (some widgets such as Combo()/ListBox()/Selectable() will return true even when clicking an already selected item).
func IsItemDeactivatedAfterEdit() bool {
	return C.igIsItemDeactivatedAfterEdit() == C.bool(true)
}

// did the last item modify its underlying value this frame? or was pressed? This is generally the same as the "bool" return value of many widgets.
func IsItemEdited() bool {
	return C.igIsItemEdited() == C.bool(true)
}

// is the last item focused for keyboard/gamepad navigation?
func IsItemFocused() bool {
	return C.igIsItemFocused() == C.bool(true)
}

// is the last item hovered? (and usable, aka not blocked by a popup, etc.). See ImGuiHoveredFlags for more options.
// IsItemHoveredV parameter default value hint:
// flags: 0
func IsItemHoveredV(flags HoveredFlags) bool {
	return C.igIsItemHovered(C.ImGuiHoveredFlags(flags)) == C.bool(true)
}

// was the last item open state toggled? set by TreeNode().
func IsItemToggledOpen() bool {
	return C.igIsItemToggledOpen() == C.bool(true)
}

// Was the last item selection toggled? (after Selectable(), TreeNode() etc. We only returns toggle _event_ in order to handle clipping correctly)
func InternalIsItemToggledSelection() bool {
	return C.igIsItemToggledSelection() == C.bool(true)
}

// is the last item visible? (items may be out of sight because of clipping/scrolling)
func IsItemVisible() bool {
	return C.igIsItemVisible() == C.bool(true)
}

func InternalIsKeyDownID(key Key, owner_id ID) bool {
	owner_idArg, owner_idFin := owner_id.c()

	defer func() {
		owner_idFin()
	}()
	return C.igIsKeyDown_ID(C.ImGuiKey(key), owner_idArg) == C.bool(true)
}

// is key being held.
func IsKeyDownNil(key Key) bool {
	return C.igIsKeyDown_Nil(C.ImGuiKey(key)) == C.bool(true)
}

// Removed in 1.87: Mapping from named key is always identity!
// InternalIsKeyPressedMapV parameter default value hint:
// repeat: true
func InternalIsKeyPressedMapV(key Key, repeat bool) bool {
	return C.igIsKeyPressedMap(C.ImGuiKey(key), C.bool(repeat)) == C.bool(true)
}

// was key pressed (went from !Down to Down)? if repeat=true, uses io.KeyRepeatDelay / KeyRepeatRate
// IsKeyPressedBoolV parameter default value hint:
// repeat: true
func IsKeyPressedBoolV(key Key, repeat bool) bool {
	return C.igIsKeyPressed_Bool(C.ImGuiKey(key), C.bool(repeat)) == C.bool(true)
}

// Important: when transitioning from old to new IsKeyPressed(): old API has "bool repeat = true", so would default to repeat. New API requiress explicit ImGuiInputFlags_Repeat.
// InternalIsKeyPressedIDV parameter default value hint:
// flags: 0
func InternalIsKeyPressedIDV(key Key, owner_id ID, flags InputFlags) bool {
	owner_idArg, owner_idFin := owner_id.c()

	defer func() {
		owner_idFin()
	}()
	return C.igIsKeyPressed_ID(C.ImGuiKey(key), owner_idArg, C.ImGuiInputFlags(flags)) == C.bool(true)
}

func InternalIsKeyReleasedID(key Key, owner_id ID) bool {
	owner_idArg, owner_idFin := owner_id.c()

	defer func() {
		owner_idFin()
	}()
	return C.igIsKeyReleased_ID(C.ImGuiKey(key), owner_idArg) == C.bool(true)
}

// was key released (went from Down to !Down)?
func IsKeyReleasedNil(key Key) bool {
	return C.igIsKeyReleased_Nil(C.ImGuiKey(key)) == C.bool(true)
}

func InternalIsKeyboardKey(key Key) bool {
	return C.igIsKeyboardKey(C.ImGuiKey(key)) == C.bool(true)
}

func InternalIsLegacyKey(key Key) bool {
	return C.igIsLegacyKey(C.ImGuiKey(key)) == C.bool(true)
}

// did mouse button clicked? (went from !Down to Down). Same as GetMouseClickedCount() == 1.
// IsMouseClickedBoolV parameter default value hint:
// repeat: false
func IsMouseClickedBoolV(button MouseButton, repeat bool) bool {
	return C.igIsMouseClicked_Bool(C.ImGuiMouseButton(button), C.bool(repeat)) == C.bool(true)
}

// InternalIsMouseClickedIDV parameter default value hint:
// flags: 0
func InternalIsMouseClickedIDV(button MouseButton, owner_id ID, flags InputFlags) bool {
	owner_idArg, owner_idFin := owner_id.c()

	defer func() {
		owner_idFin()
	}()
	return C.igIsMouseClicked_ID(C.ImGuiMouseButton(button), owner_idArg, C.ImGuiInputFlags(flags)) == C.bool(true)
}

// did mouse button double-clicked? Same as GetMouseClickedCount() == 2. (note that a double-click will also report IsMouseClicked() == true)
func IsMouseDoubleClicked(button MouseButton) bool {
	return C.igIsMouseDoubleClicked(C.ImGuiMouseButton(button)) == C.bool(true)
}

func InternalIsMouseDownID(button MouseButton, owner_id ID) bool {
	owner_idArg, owner_idFin := owner_id.c()

	defer func() {
		owner_idFin()
	}()
	return C.igIsMouseDown_ID(C.ImGuiMouseButton(button), owner_idArg) == C.bool(true)
}

// is mouse button held?
func IsMouseDownNil(button MouseButton) bool {
	return C.igIsMouseDown_Nil(C.ImGuiMouseButton(button)) == C.bool(true)
}

// InternalIsMouseDragPastThresholdV parameter default value hint:
// lock_threshold: -1.0f
func InternalIsMouseDragPastThresholdV(button MouseButton, lock_threshold float32) bool {
	return C.igIsMouseDragPastThreshold(C.ImGuiMouseButton(button), C.float(lock_threshold)) == C.bool(true)
}

// is mouse dragging? (if lock_threshold < -1.0f, uses io.MouseDraggingThreshold)
// IsMouseDraggingV parameter default value hint:
// lock_threshold: -1.0f
func IsMouseDraggingV(button MouseButton, lock_threshold float32) bool {
	return C.igIsMouseDragging(C.ImGuiMouseButton(button), C.float(lock_threshold)) == C.bool(true)
}

// is mouse hovering given bounding rect (in screen space). clipped by current clipping settings, but disregarding of other consideration of focus/window ordering/popup-block.
// IsMouseHoveringRectV parameter default value hint:
// clip: true
func IsMouseHoveringRectV(r_min Vec2, r_max Vec2, clip bool) bool {
	return C.igIsMouseHoveringRect(r_min.toC(), r_max.toC(), C.bool(clip)) == C.bool(true)
}

func InternalIsMouseKey(key Key) bool {
	return C.igIsMouseKey(C.ImGuiKey(key)) == C.bool(true)
}

// by convention we use (-FLT_MAX,-FLT_MAX) to denote that there is no mouse available
// IsMousePosValidV parameter default value hint:
// mouse_pos: NULL
func IsMousePosValidV(mouse_pos *Vec2) bool {
	mouse_posArg, mouse_posFin := wrap[C.ImVec2, *Vec2](mouse_pos)

	defer func() {
		mouse_posFin()
	}()
	return C.igIsMousePosValid(mouse_posArg) == C.bool(true)
}

func InternalIsMouseReleasedID(button MouseButton, owner_id ID) bool {
	owner_idArg, owner_idFin := owner_id.c()

	defer func() {
		owner_idFin()
	}()
	return C.igIsMouseReleased_ID(C.ImGuiMouseButton(button), owner_idArg) == C.bool(true)
}

// did mouse button released? (went from Down to !Down)
func IsMouseReleasedNil(button MouseButton) bool {
	return C.igIsMouseReleased_Nil(C.ImGuiMouseButton(button)) == C.bool(true)
}

func InternalIsNamedKey(key Key) bool {
	return C.igIsNamedKey(C.ImGuiKey(key)) == C.bool(true)
}

func InternalIsNamedKeyOrModKey(key Key) bool {
	return C.igIsNamedKeyOrModKey(C.ImGuiKey(key)) == C.bool(true)
}

func InternalIsPopupOpenID(id ID, popup_flags PopupFlags) bool {
	idArg, idFin := id.c()

	defer func() {
		idFin()
	}()
	return C.igIsPopupOpen_ID(idArg, C.ImGuiPopupFlags(popup_flags)) == C.bool(true)
}

// return true if the popup is open.
// IsPopupOpenStrV parameter default value hint:
// flags: 0
func IsPopupOpenStrV(str_id string, flags PopupFlags) bool {
	str_idArg, str_idFin := WrapString(str_id)

	defer func() {
		str_idFin()
	}()
	return C.igIsPopupOpen_Str(str_idArg, C.ImGuiPopupFlags(flags)) == C.bool(true)
}

// test if rectangle (of given size, starting from cursor position) is visible / not clipped.
func IsRectVisibleNil(size Vec2) bool {
	return C.igIsRectVisible_Nil(size.toC()) == C.bool(true)
}

// test if rectangle (in screen space) is visible / not clipped. to perform coarse clipping on user's side.
func IsRectVisibleVec2(rect_min Vec2, rect_max Vec2) bool {
	return C.igIsRectVisible_Vec2(rect_min.toC(), rect_max.toC()) == C.bool(true)
}

func InternalIsWindowAbove(potential_above *Window, potential_below *Window) bool {
	potential_aboveArg, potential_aboveFin := potential_above.handle()
	potential_belowArg, potential_belowFin := potential_below.handle()

	defer func() {
		potential_aboveFin()
		potential_belowFin()
	}()
	return C.igIsWindowAbove(potential_aboveArg, potential_belowArg) == C.bool(true)
}

func IsWindowAppearing() bool {
	return C.igIsWindowAppearing() == C.bool(true)
}

func InternalIsWindowChildOf(window *Window, potential_parent *Window, popup_hierarchy bool, dock_hierarchy bool) bool {
	windowArg, windowFin := window.handle()
	potential_parentArg, potential_parentFin := potential_parent.handle()

	defer func() {
		windowFin()
		potential_parentFin()
	}()
	return C.igIsWindowChildOf(windowArg, potential_parentArg, C.bool(popup_hierarchy), C.bool(dock_hierarchy)) == C.bool(true)
}

func IsWindowCollapsed() bool {
	return C.igIsWindowCollapsed() == C.bool(true)
}

// InternalIsWindowContentHoverableV parameter default value hint:
// flags: 0
func InternalIsWindowContentHoverableV(window *Window, flags HoveredFlags) bool {
	windowArg, windowFin := window.handle()

	defer func() {
		windowFin()
	}()
	return C.igIsWindowContentHoverable(windowArg, C.ImGuiHoveredFlags(flags)) == C.bool(true)
}

// is current window docked into another window?
func IsWindowDocked() bool {
	return C.igIsWindowDocked() == C.bool(true)
}

// is current window focused? or its root/child, depending on flags. see flags for options.
// IsWindowFocusedV parameter default value hint:
// flags: 0
func IsWindowFocusedV(flags FocusedFlags) bool {
	return C.igIsWindowFocused(C.ImGuiFocusedFlags(flags)) == C.bool(true)
}

// is current window hovered (and typically: not blocked by a popup/modal)? see flags for options. NB: If you are trying to check whether your mouse should be dispatched to imgui or to your app, you should use the 'io.WantCaptureMouse' boolean for that! Please read the FAQ!
// IsWindowHoveredV parameter default value hint:
// flags: 0
func IsWindowHoveredV(flags HoveredFlags) bool {
	return C.igIsWindowHovered(C.ImGuiHoveredFlags(flags)) == C.bool(true)
}

func InternalIsWindowNavFocusable(window *Window) bool {
	windowArg, windowFin := window.handle()

	defer func() {
		windowFin()
	}()
	return C.igIsWindowNavFocusable(windowArg) == C.bool(true)
}

func InternalIsWindowWithinBeginStackOf(window *Window, potential_parent *Window) bool {
	windowArg, windowFin := window.handle()
	potential_parentArg, potential_parentFin := potential_parent.handle()

	defer func() {
		windowFin()
		potential_parentFin()
	}()
	return C.igIsWindowWithinBeginStackOf(windowArg, potential_parentArg) == C.bool(true)
}

// InternalItemAddV parameter default value hint:
// nav_bb: NULL
// extra_flags: 0
func InternalItemAddV(bb Rect, id ID, nav_bb *Rect, extra_flags ItemFlags) bool {
	idArg, idFin := id.c()
	nav_bbArg, nav_bbFin := wrap[C.ImRect, *Rect](nav_bb)

	defer func() {
		idFin()
		nav_bbFin()
	}()
	return C.igItemAdd(bb.toC(), idArg, nav_bbArg, C.ImGuiItemFlags(extra_flags)) == C.bool(true)
}

func InternalItemHoverable(bb Rect, id ID, item_flags ItemFlags) bool {
	idArg, idFin := id.c()

	defer func() {
		idFin()
	}()
	return C.igItemHoverable(bb.toC(), idArg, C.ImGuiItemFlags(item_flags)) == C.bool(true)
}

// FIXME: This is a misleading API since we expect CursorPos to be bb.Min.
// InternalItemSizeRectV parameter default value hint:
// text_baseline_y: -1.0f
func InternalItemSizeRectV(bb Rect, text_baseline_y float32) {
	C.igItemSize_Rect(bb.toC(), C.float(text_baseline_y))
}

// InternalItemSizeVec2V parameter default value hint:
// text_baseline_y: -1.0f
func InternalItemSizeVec2V(size Vec2, text_baseline_y float32) {
	C.igItemSize_Vec2(size.toC(), C.float(text_baseline_y))
}

func InternalKeepAliveID(id ID) {
	idArg, idFin := id.c()
	C.igKeepAliveID(idArg)

	idFin()
}

// display text+label aligned the same way as value+label widgets
func LabelText(label string, fmt string) {
	labelArg, labelFin := WrapString(label)
	fmtArg, fmtFin := WrapString(fmt)
	C.wrap_igLabelText(labelArg, fmtArg)

	labelFin()
	fmtFin()
}

// ListBoxStrarrV parameter default value hint:
// height_in_items: -1
func ListBoxStrarrV(label string, current_item *int32, items []string, items_count int32, height_in_items int32) bool {
	labelArg, labelFin := WrapString(label)
	current_itemArg, current_itemFin := WrapNumberPtr[C.int, int32](current_item)
	itemsArg, itemsFin := WrapStringList(items)

	defer func() {
		labelFin()
		current_itemFin()
		itemsFin()
	}()
	return C.igListBox_Str_arr(labelArg, current_itemArg, itemsArg, C.int(items_count), C.int(height_in_items)) == C.bool(true)
}

// call after CreateContext() and before the first call to NewFrame(). NewFrame() automatically calls LoadIniSettingsFromDisk(io.IniFilename).
func LoadIniSettingsFromDisk(ini_filename string) {
	ini_filenameArg, ini_filenameFin := WrapString(ini_filename)
	C.igLoadIniSettingsFromDisk(ini_filenameArg)

	ini_filenameFin()
}

// call after CreateContext() and before the first call to NewFrame() to provide .ini data from your own data source.
// LoadIniSettingsFromMemoryV parameter default value hint:
// ini_size: 0
func LoadIniSettingsFromMemoryV(ini_data string, ini_size uint64) {
	ini_dataArg, ini_dataFin := WrapString(ini_data)
	C.igLoadIniSettingsFromMemory(ini_dataArg, C.xulong(ini_size))

	ini_dataFin()
}

func InternalLocalizeGetMsg(key LocKey) string {
	return C.GoString(C.igLocalizeGetMsg(C.ImGuiLocKey(key)))
}

func InternalLocalizeRegisterEntries(entries *LocEntry, count int32) {
	entriesArg, entriesFin := entries.handle()
	C.igLocalizeRegisterEntries(entriesArg, C.int(count))

	entriesFin()
}

// -> BeginCapture() when we design v2 api, for now stay under the radar by using the old name.
func InternalLogBegin(typeArg LogType, auto_open_depth int32) {
	C.igLogBegin(C.ImGuiLogType(typeArg), C.int(auto_open_depth))
}

// helper to display buttons for logging to tty/file/clipboard
func LogButtons() {
	C.igLogButtons()
}

// stop logging (close file, etc.)
func LogFinish() {
	C.igLogFinish()
}

// InternalLogRenderedTextV parameter default value hint:
func InternalLogRenderedTextV(ref_pos *Vec2, text string) {
	ref_posArg, ref_posFin := wrap[C.ImVec2, *Vec2](ref_pos)
	textArg, textFin := WrapString(text)
	C.wrap_igLogRenderedTextV(ref_posArg, textArg)

	ref_posFin()
	textFin()
}

func InternalLogSetNextTextDecoration(prefix string, suffix string) {
	prefixArg, prefixFin := WrapString(prefix)
	suffixArg, suffixFin := WrapString(suffix)
	C.igLogSetNextTextDecoration(prefixArg, suffixArg)

	prefixFin()
	suffixFin()
}

// pass text data straight to log (without being displayed)
func LogText(fmt string) {
	fmtArg, fmtFin := WrapString(fmt)
	C.wrap_igLogText(fmtArg)

	fmtFin()
}

// Start logging/capturing to internal buffer
// InternalLogToBufferV parameter default value hint:
// auto_open_depth: -1
func InternalLogToBufferV(auto_open_depth int32) {
	C.igLogToBuffer(C.int(auto_open_depth))
}

// start logging to OS clipboard
// LogToClipboardV parameter default value hint:
// auto_open_depth: -1
func LogToClipboardV(auto_open_depth int32) {
	C.igLogToClipboard(C.int(auto_open_depth))
}

// start logging to file
// LogToFileV parameter default value hint:
// auto_open_depth: -1
// filename: NULL
func LogToFileV(auto_open_depth int32, filename string) {
	filenameArg, filenameFin := WrapString(filename)
	C.igLogToFile(C.int(auto_open_depth), filenameArg)

	filenameFin()
}

// start logging to tty (stdout)
// LogToTTYV parameter default value hint:
// auto_open_depth: -1
func LogToTTYV(auto_open_depth int32) {
	C.igLogToTTY(C.int(auto_open_depth))
}

func InternalMarkIniSettingsDirtyNil() {
	C.igMarkIniSettingsDirty_Nil()
}

func InternalMarkIniSettingsDirtyWindowPtr(window *Window) {
	windowArg, windowFin := window.handle()
	C.igMarkIniSettingsDirty_WindowPtr(windowArg)

	windowFin()
}

// Mark data associated to given item as "edited", used by IsItemDeactivatedAfterEdit() function.
func InternalMarkItemEdited(id ID) {
	idArg, idFin := id.c()
	C.igMarkItemEdited(idArg)

	idFin()
}

func MemAlloc(size uint64) unsafe.Pointer {
	return unsafe.Pointer(C.igMemAlloc(C.xulong(size)))
}

func MemFree(ptr unsafe.Pointer) {
	ptrArg, ptrFin := WrapVoidPtr(ptr)
	C.igMemFree(ptrArg)

	ptrFin()
}

// InternalMenuItemExV parameter default value hint:
// shortcut: NULL
// selected: false
// enabled: true
func InternalMenuItemExV(label string, icon string, shortcut string, selected bool, enabled bool) bool {
	labelArg, labelFin := WrapString(label)
	iconArg, iconFin := WrapString(icon)
	shortcutArg, shortcutFin := WrapString(shortcut)

	defer func() {
		labelFin()
		iconFin()
		shortcutFin()
	}()
	return C.igMenuItemEx(labelArg, iconArg, shortcutArg, C.bool(selected), C.bool(enabled)) == C.bool(true)
}

// return true when activated.
// MenuItemBoolV parameter default value hint:
// shortcut: NULL
// selected: false
// enabled: true
func MenuItemBoolV(label string, shortcut string, selected bool, enabled bool) bool {
	labelArg, labelFin := WrapString(label)
	shortcutArg, shortcutFin := WrapString(shortcut)

	defer func() {
		labelFin()
		shortcutFin()
	}()
	return C.igMenuItem_Bool(labelArg, shortcutArg, C.bool(selected), C.bool(enabled)) == C.bool(true)
}

// return true when activated + toggle (*p_selected) if p_selected != NULL
// MenuItemBoolPtrV parameter default value hint:
// enabled: true
func MenuItemBoolPtrV(label string, shortcut string, p_selected *bool, enabled bool) bool {
	labelArg, labelFin := WrapString(label)
	shortcutArg, shortcutFin := WrapString(shortcut)
	p_selectedArg, p_selectedFin := WrapBool(p_selected)

	defer func() {
		labelFin()
		shortcutFin()
		p_selectedFin()
	}()
	return C.igMenuItem_BoolPtr(labelArg, shortcutArg, p_selectedArg, C.bool(enabled)) == C.bool(true)
}

func InternalMouseButtonToKey(button MouseButton) Key {
	return Key(C.igMouseButtonToKey(C.ImGuiMouseButton(button)))
}

func InternalNavClearPreferredPosForAxis(axis Axis) {
	C.igNavClearPreferredPosForAxis(C.ImGuiAxis(axis))
}

func InternalNavInitRequestApplyResult() {
	C.igNavInitRequestApplyResult()
}

func InternalNavInitWindow(window *Window, force_reinit bool) {
	windowArg, windowFin := window.handle()
	C.igNavInitWindow(windowArg, C.bool(force_reinit))

	windowFin()
}

func InternalNavMoveRequestApplyResult() {
	C.igNavMoveRequestApplyResult()
}

func InternalNavMoveRequestButNoResultYet() bool {
	return C.igNavMoveRequestButNoResultYet() == C.bool(true)
}

func InternalNavMoveRequestCancel() {
	C.igNavMoveRequestCancel()
}

func InternalNavMoveRequestForward(move_dir Dir, clip_dir Dir, move_flags NavMoveFlags, scroll_flags ScrollFlags) {
	C.igNavMoveRequestForward(C.ImGuiDir(move_dir), C.ImGuiDir(clip_dir), C.ImGuiNavMoveFlags(move_flags), C.ImGuiScrollFlags(scroll_flags))
}

func InternalNavMoveRequestResolveWithLastItem(result *NavItemData) {
	resultArg, resultFin := result.handle()
	C.igNavMoveRequestResolveWithLastItem(resultArg)

	resultFin()
}

func InternalNavMoveRequestResolveWithPastTreeNode(result *NavItemData, tree_node_data *NavTreeNodeData) {
	resultArg, resultFin := result.handle()
	tree_node_dataArg, tree_node_dataFin := tree_node_data.handle()
	C.igNavMoveRequestResolveWithPastTreeNode(resultArg, tree_node_dataArg)

	resultFin()
	tree_node_dataFin()
}

func InternalNavMoveRequestSubmit(move_dir Dir, clip_dir Dir, move_flags NavMoveFlags, scroll_flags ScrollFlags) {
	C.igNavMoveRequestSubmit(C.ImGuiDir(move_dir), C.ImGuiDir(clip_dir), C.ImGuiNavMoveFlags(move_flags), C.ImGuiScrollFlags(scroll_flags))
}

func InternalNavMoveRequestTryWrapping(window *Window, move_flags NavMoveFlags) {
	windowArg, windowFin := window.handle()
	C.igNavMoveRequestTryWrapping(windowArg, C.ImGuiNavMoveFlags(move_flags))

	windowFin()
}

func InternalNavRestoreHighlightAfterMove() {
	C.igNavRestoreHighlightAfterMove()
}

func InternalNavUpdateCurrentWindowIsScrollPushableX() {
	C.igNavUpdateCurrentWindowIsScrollPushableX()
}

// start a new Dear ImGui frame, you can submit any command from this point until Render()/EndFrame().
func NewFrame() {
	C.igNewFrame()
}

// undo a SameLine() or force a new line when in a horizontal-layout context.
func NewLine() {
	C.igNewLine()
}

// next column, defaults to current row or next row if the current row is finished
func NextColumn() {
	C.igNextColumn()
}

// InternalOpenPopupExV parameter default value hint:
// popup_flags: ImGuiPopupFlags_None
func InternalOpenPopupExV(id ID, popup_flags PopupFlags) {
	idArg, idFin := id.c()
	C.igOpenPopupEx(idArg, C.ImGuiPopupFlags(popup_flags))

	idFin()
}

// helper to open popup when clicked on last item. Default to ImGuiPopupFlags_MouseButtonRight == 1. (note: actually triggers on the mouse _released_ event to be consistent with popup behaviors)
// OpenPopupOnItemClickV parameter default value hint:
// str_id: NULL
// popup_flags: 1
func OpenPopupOnItemClickV(str_id string, popup_flags PopupFlags) {
	str_idArg, str_idFin := WrapString(str_id)
	C.igOpenPopupOnItemClick(str_idArg, C.ImGuiPopupFlags(popup_flags))

	str_idFin()
}

// id overload to facilitate calling from nested stacks
// OpenPopupIDV parameter default value hint:
// popup_flags: 0
func OpenPopupIDV(id ID, popup_flags PopupFlags) {
	idArg, idFin := id.c()
	C.igOpenPopup_ID(idArg, C.ImGuiPopupFlags(popup_flags))

	idFin()
}

// call to mark popup as open (don't call every frame!).
// OpenPopupStrV parameter default value hint:
// popup_flags: 0
func OpenPopupStrV(str_id string, popup_flags PopupFlags) {
	str_idArg, str_idFin := WrapString(str_id)
	C.igOpenPopup_Str(str_idArg, C.ImGuiPopupFlags(popup_flags))

	str_idFin()
}

// PlotHistogramFloatPtrV parameter default value hint:
// values_offset: 0
// overlay_text: NULL
// scale_min: FLT_MAX
// scale_max: FLT_MAX
// graph_size: ImVec2(0,0)
// stride: sizeof(float)
func PlotHistogramFloatPtrV(label string, values []float32, values_count int32, values_offset int32, overlay_text string, scale_min float32, scale_max float32, graph_size Vec2, stride int32) {
	labelArg, labelFin := WrapString(label)
	overlay_textArg, overlay_textFin := WrapString(overlay_text)
	C.igPlotHistogram_FloatPtr(labelArg, (*C.float)(&(values[0])), C.int(values_count), C.int(values_offset), overlay_textArg, C.float(scale_min), C.float(scale_max), graph_size.toC(), C.int(stride))

	labelFin()
	overlay_textFin()
}

// PlotLinesFloatPtrV parameter default value hint:
// values_offset: 0
// overlay_text: NULL
// scale_min: FLT_MAX
// scale_max: FLT_MAX
// graph_size: ImVec2(0,0)
// stride: sizeof(float)
func PlotLinesFloatPtrV(label string, values []float32, values_count int32, values_offset int32, overlay_text string, scale_min float32, scale_max float32, graph_size Vec2, stride int32) {
	labelArg, labelFin := WrapString(label)
	overlay_textArg, overlay_textFin := WrapString(overlay_text)
	C.igPlotLines_FloatPtr(labelArg, (*C.float)(&(values[0])), C.int(values_count), C.int(values_offset), overlay_textArg, C.float(scale_min), C.float(scale_max), graph_size.toC(), C.int(stride))

	labelFin()
	overlay_textFin()
}

func PopButtonRepeat() {
	C.igPopButtonRepeat()
}

func PopClipRect() {
	C.igPopClipRect()
}

func InternalPopColumnsBackground() {
	C.igPopColumnsBackground()
}

func InternalPopFocusScope() {
	C.igPopFocusScope()
}

func PopFont() {
	C.igPopFont()
}

// pop from the ID stack.
func PopID() {
	C.igPopID()
}

func InternalPopItemFlag() {
	C.igPopItemFlag()
}

func PopItemWidth() {
	C.igPopItemWidth()
}

// PopStyleColorV parameter default value hint:
// count: 1
func PopStyleColorV(count int32) {
	C.igPopStyleColor(C.int(count))
}

// PopStyleVarV parameter default value hint:
// count: 1
func PopStyleVarV(count int32) {
	C.igPopStyleVar(C.int(count))
}

func PopTabStop() {
	C.igPopTabStop()
}

func PopTextWrapPos() {
	C.igPopTextWrapPos()
}

// ProgressBarV parameter default value hint:
// size_arg: ImVec2(-FLT_MIN,0)
// overlay: NULL
func ProgressBarV(fraction float32, size_arg Vec2, overlay string) {
	overlayArg, overlayFin := WrapString(overlay)
	C.igProgressBar(C.float(fraction), size_arg.toC(), overlayArg)

	overlayFin()
}

// in 'repeat' mode, Button*() functions return repeated true in a typematic manner (using io.KeyRepeatDelay/io.KeyRepeatRate setting). Note that you can call IsItemActive() after any Button() to tell if the button is held in the current frame.
func PushButtonRepeat(repeat bool) {
	C.igPushButtonRepeat(C.bool(repeat))
}

func PushClipRect(clip_rect_min Vec2, clip_rect_max Vec2, intersect_with_current_clip_rect bool) {
	C.igPushClipRect(clip_rect_min.toC(), clip_rect_max.toC(), C.bool(intersect_with_current_clip_rect))
}

func InternalPushColumnClipRect(column_index int32) {
	C.igPushColumnClipRect(C.int(column_index))
}

func InternalPushColumnsBackground() {
	C.igPushColumnsBackground()
}

func InternalPushFocusScope(id ID) {
	idArg, idFin := id.c()
	C.igPushFocusScope(idArg)

	idFin()
}

// use NULL as a shortcut to push default font
func PushFont(font *Font) {
	fontArg, fontFin := font.handle()
	C.igPushFont(fontArg)

	fontFin()
}

// push integer into the ID stack (will hash integer).
func PushIDInt(int_id int32) {
	C.igPushID_Int(C.int(int_id))
}

// push pointer into the ID stack (will hash pointer).
func PushIDPtr(ptr_id unsafe.Pointer) {
	C.igPushID_Ptr((ptr_id))
}

// push string into the ID stack (will hash string).
func PushIDStr(str_id string) {
	str_idArg, str_idFin := WrapString(str_id)
	C.igPushID_Str(str_idArg)

	str_idFin()
}

// push string into the ID stack (will hash string).
func PushIDStrStr(str_id_begin string, str_id_end string) {
	str_id_beginArg, str_id_beginFin := WrapString(str_id_begin)
	str_id_endArg, str_id_endFin := WrapString(str_id_end)
	C.igPushID_StrStr(str_id_beginArg, str_id_endArg)

	str_id_beginFin()
	str_id_endFin()
}

func InternalPushItemFlag(option ItemFlags, enabled bool) {
	C.igPushItemFlag(C.ImGuiItemFlags(option), C.bool(enabled))
}

// push width of items for common large "item+label" widgets. >0.0f: width in pixels, <0.0f align xx pixels to the right of window (so -FLT_MIN always align width to the right side).
func PushItemWidth(item_width float32) {
	C.igPushItemWidth(C.float(item_width))
}

func InternalPushMultiItemsWidths(components int32, width_full float32) {
	C.igPushMultiItemsWidths(C.int(components), C.float(width_full))
}

// Push given value as-is at the top of the ID stack (whereas PushID combines old and new hashes)
func InternalPushOverrideID(id ID) {
	idArg, idFin := id.c()
	C.igPushOverrideID(idArg)

	idFin()
}

// modify a style color. always use this if you modify the style after NewFrame().
func PushStyleColorU32(idx Col, col uint32) {
	C.igPushStyleColor_U32(C.ImGuiCol(idx), C.ImU32(col))
}

func PushStyleColorVec4(idx Col, col Vec4) {
	C.igPushStyleColor_Vec4(C.ImGuiCol(idx), col.toC())
}

// modify a style float variable. always use this if you modify the style after NewFrame().
func PushStyleVarFloat(idx StyleVar, val float32) {
	C.igPushStyleVar_Float(C.ImGuiStyleVar(idx), C.float(val))
}

// modify a style ImVec2 variable. always use this if you modify the style after NewFrame().
func PushStyleVarVec2(idx StyleVar, val Vec2) {
	C.igPushStyleVar_Vec2(C.ImGuiStyleVar(idx), val.toC())
}

// == tab stop enable. Allow focusing using TAB/Shift-TAB, enabled by default but you can disable it for certain widgets
func PushTabStop(tab_stop bool) {
	C.igPushTabStop(C.bool(tab_stop))
}

// push word-wrapping position for Text*() commands. < 0.0f: no wrapping; 0.0f: wrap to end of window (or column); > 0.0f: wrap at 'wrap_pos_x' position in window local space
// PushTextWrapPosV parameter default value hint:
// wrap_local_pos_x: 0.0f
func PushTextWrapPosV(wrap_local_pos_x float32) {
	C.igPushTextWrapPos(C.float(wrap_local_pos_x))
}

// use with e.g. if (RadioButton("one", my_value==1))  my_value = 1;
func RadioButtonBool(label string, active bool) bool {
	labelArg, labelFin := WrapString(label)

	defer func() {
		labelFin()
	}()
	return C.igRadioButton_Bool(labelArg, C.bool(active)) == C.bool(true)
}

// shortcut to handle the above pattern when value is an integer
func RadioButtonIntPtr(label string, v *int32, v_button int32) bool {
	labelArg, labelFin := WrapString(label)
	vArg, vFin := WrapNumberPtr[C.int, int32](v)

	defer func() {
		labelFin()
		vFin()
	}()
	return C.igRadioButton_IntPtr(labelArg, vArg, C.int(v_button)) == C.bool(true)
}

func InternalRemoveContextHook(context *Context, hook_to_remove ID) {
	contextArg, contextFin := context.handle()
	hook_to_removeArg, hook_to_removeFin := hook_to_remove.c()
	C.igRemoveContextHook(contextArg, hook_to_removeArg)

	contextFin()
	hook_to_removeFin()
}

func InternalRemoveSettingsHandler(type_name string) {
	type_nameArg, type_nameFin := WrapString(type_name)
	C.igRemoveSettingsHandler(type_nameArg)

	type_nameFin()
}

// ends the Dear ImGui frame, finalize the draw data. You can then get call GetDrawData().
func Render() {
	C.igRender()
}

// InternalRenderArrowV parameter default value hint:
// scale: 1.0f
func InternalRenderArrowV(draw_list *DrawList, pos Vec2, col uint32, dir Dir, scale float32) {
	draw_listArg, draw_listFin := draw_list.handle()
	C.igRenderArrow(draw_listArg, pos.toC(), C.ImU32(col), C.ImGuiDir(dir), C.float(scale))

	draw_listFin()
}

func InternalRenderArrowDockMenu(draw_list *DrawList, p_min Vec2, sz float32, col uint32) {
	draw_listArg, draw_listFin := draw_list.handle()
	C.igRenderArrowDockMenu(draw_listArg, p_min.toC(), C.float(sz), C.ImU32(col))

	draw_listFin()
}

func InternalRenderArrowPointingAt(draw_list *DrawList, pos Vec2, half_sz Vec2, direction Dir, col uint32) {
	draw_listArg, draw_listFin := draw_list.handle()
	C.igRenderArrowPointingAt(draw_listArg, pos.toC(), half_sz.toC(), C.ImGuiDir(direction), C.ImU32(col))

	draw_listFin()
}

func InternalRenderBullet(draw_list *DrawList, pos Vec2, col uint32) {
	draw_listArg, draw_listFin := draw_list.handle()
	C.igRenderBullet(draw_listArg, pos.toC(), C.ImU32(col))

	draw_listFin()
}

func InternalRenderCheckMark(draw_list *DrawList, pos Vec2, col uint32, sz float32) {
	draw_listArg, draw_listFin := draw_list.handle()
	C.igRenderCheckMark(draw_listArg, pos.toC(), C.ImU32(col), C.float(sz))

	draw_listFin()
}

// InternalRenderColorRectWithAlphaCheckerboardV parameter default value hint:
// rounding: 0.0f
// flags: 0
func InternalRenderColorRectWithAlphaCheckerboardV(draw_list *DrawList, p_min Vec2, p_max Vec2, fill_col uint32, grid_step float32, grid_off Vec2, rounding float32, flags DrawFlags) {
	draw_listArg, draw_listFin := draw_list.handle()
	C.igRenderColorRectWithAlphaCheckerboard(draw_listArg, p_min.toC(), p_max.toC(), C.ImU32(fill_col), C.float(grid_step), grid_off.toC(), C.float(rounding), C.ImDrawFlags(flags))

	draw_listFin()
}

func InternalRenderDragDropTargetRect(bb Rect) {
	C.igRenderDragDropTargetRect(bb.toC())
}

// InternalRenderFrameV parameter default value hint:
// border: true
// rounding: 0.0f
func InternalRenderFrameV(p_min Vec2, p_max Vec2, fill_col uint32, border bool, rounding float32) {
	C.igRenderFrame(p_min.toC(), p_max.toC(), C.ImU32(fill_col), C.bool(border), C.float(rounding))
}

// InternalRenderFrameBorderV parameter default value hint:
// rounding: 0.0f
func InternalRenderFrameBorderV(p_min Vec2, p_max Vec2, rounding float32) {
	C.igRenderFrameBorder(p_min.toC(), p_max.toC(), C.float(rounding))
}

func InternalRenderMouseCursor(pos Vec2, scale float32, mouse_cursor MouseCursor, col_fill uint32, col_border uint32, col_shadow uint32) {
	C.igRenderMouseCursor(pos.toC(), C.float(scale), C.ImGuiMouseCursor(mouse_cursor), C.ImU32(col_fill), C.ImU32(col_border), C.ImU32(col_shadow))
}

// Navigation highlight
// InternalRenderNavHighlightV parameter default value hint:
// flags: ImGuiNavHighlightFlags_TypeDefault
func InternalRenderNavHighlightV(bb Rect, id ID, flags NavHighlightFlags) {
	idArg, idFin := id.c()
	C.igRenderNavHighlight(bb.toC(), idArg, C.ImGuiNavHighlightFlags(flags))

	idFin()
}

// call in main loop. will call RenderWindow/SwapBuffers platform functions for each secondary viewport which doesn't have the ImGuiViewportFlags_Minimized flag set. May be reimplemented by user for custom rendering needs.
// RenderPlatformWindowsDefaultV parameter default value hint:
// platform_render_arg: NULL
// renderer_render_arg: NULL
func RenderPlatformWindowsDefaultV(platform_render_arg unsafe.Pointer, renderer_render_arg unsafe.Pointer) {
	platform_render_argArg, platform_render_argFin := WrapVoidPtr(platform_render_arg)
	renderer_render_argArg, renderer_render_argFin := WrapVoidPtr(renderer_render_arg)
	C.igRenderPlatformWindowsDefault(platform_render_argArg, renderer_render_argArg)

	platform_render_argFin()
	renderer_render_argFin()
}

func InternalRenderRectFilledRangeH(draw_list *DrawList, rect Rect, col uint32, x_start_norm float32, x_end_norm float32, rounding float32) {
	draw_listArg, draw_listFin := draw_list.handle()
	C.igRenderRectFilledRangeH(draw_listArg, rect.toC(), C.ImU32(col), C.float(x_start_norm), C.float(x_end_norm), C.float(rounding))

	draw_listFin()
}

func InternalRenderRectFilledWithHole(draw_list *DrawList, outer Rect, inner Rect, col uint32, rounding float32) {
	draw_listArg, draw_listFin := draw_list.handle()
	C.igRenderRectFilledWithHole(draw_listArg, outer.toC(), inner.toC(), C.ImU32(col), C.float(rounding))

	draw_listFin()
}

// InternalRenderTextV parameter default value hint:
// hide_text_after_hash: true
func InternalRenderTextV(pos Vec2, text string, hide_text_after_hash bool) {
	textArg, textFin := WrapString(text)
	C.wrap_igRenderTextV(pos.toC(), textArg, C.bool(hide_text_after_hash))

	textFin()
}

// InternalRenderTextClippedV parameter default value hint:
// align: ImVec2(0,0)
// clip_rect: NULL
func InternalRenderTextClippedV(pos_min Vec2, pos_max Vec2, text string, text_size_if_known *Vec2, align Vec2, clip_rect *Rect) {
	textArg, textFin := WrapString(text)
	text_size_if_knownArg, text_size_if_knownFin := wrap[C.ImVec2, *Vec2](text_size_if_known)
	clip_rectArg, clip_rectFin := wrap[C.ImRect, *Rect](clip_rect)
	C.wrap_igRenderTextClippedV(pos_min.toC(), pos_max.toC(), textArg, text_size_if_knownArg, align.toC(), clip_rectArg)

	textFin()
	text_size_if_knownFin()
	clip_rectFin()
}

// InternalRenderTextClippedExV parameter default value hint:
// align: ImVec2(0,0)
// clip_rect: NULL
func InternalRenderTextClippedExV(draw_list *DrawList, pos_min Vec2, pos_max Vec2, text string, text_size_if_known *Vec2, align Vec2, clip_rect *Rect) {
	draw_listArg, draw_listFin := draw_list.handle()
	textArg, textFin := WrapString(text)
	text_size_if_knownArg, text_size_if_knownFin := wrap[C.ImVec2, *Vec2](text_size_if_known)
	clip_rectArg, clip_rectFin := wrap[C.ImRect, *Rect](clip_rect)
	C.wrap_igRenderTextClippedExV(draw_listArg, pos_min.toC(), pos_max.toC(), textArg, text_size_if_knownArg, align.toC(), clip_rectArg)

	draw_listFin()
	textFin()
	text_size_if_knownFin()
	clip_rectFin()
}

func InternalRenderTextEllipsis(draw_list *DrawList, pos_min Vec2, pos_max Vec2, clip_max_x float32, ellipsis_max_x float32, text string, text_size_if_known *Vec2) {
	draw_listArg, draw_listFin := draw_list.handle()
	textArg, textFin := WrapString(text)
	text_size_if_knownArg, text_size_if_knownFin := wrap[C.ImVec2, *Vec2](text_size_if_known)
	C.wrap_igRenderTextEllipsis(draw_listArg, pos_min.toC(), pos_max.toC(), C.float(clip_max_x), C.float(ellipsis_max_x), textArg, text_size_if_knownArg)

	draw_listFin()
	textFin()
	text_size_if_knownFin()
}

func InternalRenderTextWrapped(pos Vec2, text string, wrap_width float32) {
	textArg, textFin := WrapString(text)
	C.wrap_igRenderTextWrapped(pos.toC(), textArg, C.float(wrap_width))

	textFin()
}

// ResetMouseDragDeltaV parameter default value hint:
// button: 0
func ResetMouseDragDeltaV(button MouseButton) {
	C.igResetMouseDragDelta(C.ImGuiMouseButton(button))
}

// call between widgets or groups to layout them horizontally. X position given in window coordinates.
// SameLineV parameter default value hint:
// offset_from_start_x: 0.0f
// spacing: -1.0f
func SameLineV(offset_from_start_x float32, spacing float32) {
	C.igSameLine(C.float(offset_from_start_x), C.float(spacing))
}

// this is automatically called (if io.IniFilename is not empty) a few seconds after any modification that should be reflected in the .ini file (and also by DestroyContext).
func SaveIniSettingsToDisk(ini_filename string) {
	ini_filenameArg, ini_filenameFin := WrapString(ini_filename)
	C.igSaveIniSettingsToDisk(ini_filenameArg)

	ini_filenameFin()
}

// return a zero-terminated string with the .ini data which you can save by your own mean. call when io.WantSaveIniSettings is set, then save data by your own mean and clear io.WantSaveIniSettings.
// SaveIniSettingsToMemoryV parameter default value hint:
// out_ini_size: NULL
func SaveIniSettingsToMemoryV(out_ini_size *uint64) string {
	return C.GoString(C.igSaveIniSettingsToMemory((*C.xulong)(out_ini_size)))
}

func InternalScaleWindowsInViewport(viewport *ViewportP, scale float32) {
	viewportArg, viewportFin := viewport.handle()
	C.igScaleWindowsInViewport(viewportArg, C.float(scale))

	viewportFin()
}

func InternalScrollToBringRectIntoView(window *Window, rect Rect) {
	windowArg, windowFin := window.handle()
	C.igScrollToBringRectIntoView(windowArg, rect.toC())

	windowFin()
}

// InternalScrollToItemV parameter default value hint:
// flags: 0
func InternalScrollToItemV(flags ScrollFlags) {
	C.igScrollToItem(C.ImGuiScrollFlags(flags))
}

// InternalScrollToRectV parameter default value hint:
// flags: 0
func InternalScrollToRectV(window *Window, rect Rect, flags ScrollFlags) {
	windowArg, windowFin := window.handle()
	C.igScrollToRect(windowArg, rect.toC(), C.ImGuiScrollFlags(flags))

	windowFin()
}

// InternalScrollToRectExV parameter default value hint:
// flags: 0
func InternalScrollToRectExV(window *Window, rect Rect, flags ScrollFlags) Vec2 {
	pOut := new(Vec2)
	pOutArg, pOutFin := wrap[C.ImVec2, *Vec2](pOut)

	windowArg, windowFin := window.handle()
	C.igScrollToRectEx(pOutArg, windowArg, rect.toC(), C.ImGuiScrollFlags(flags))

	pOutFin()
	windowFin()

	return *pOut
}

func InternalScrollbar(axis Axis) {
	C.igScrollbar(C.ImGuiAxis(axis))
}

func InternalScrollbarEx(bb Rect, id ID, axis Axis, p_scroll_v *int64, avail_v int64, contents_v int64, flags DrawFlags) bool {
	idArg, idFin := id.c()
	p_scroll_vArg, p_scroll_vFin := WrapNumberPtr[C.ImS64, int64](p_scroll_v)

	defer func() {
		idFin()
		p_scroll_vFin()
	}()
	return C.igScrollbarEx(bb.toC(), idArg, C.ImGuiAxis(axis), p_scroll_vArg, C.ImS64(avail_v), C.ImS64(contents_v), C.ImDrawFlags(flags)) == C.bool(true)
}

// "bool selected" carry the selection state (read-only). Selectable() is clicked is returns true so you can modify your selection state. size.x==0.0: use remaining width, size.x>0.0: specify width. size.y==0.0: use label height, size.y>0.0: specify height
// SelectableBoolV parameter default value hint:
// selected: false
// flags: 0
// size: ImVec2(0,0)
func SelectableBoolV(label string, selected bool, flags SelectableFlags, size Vec2) bool {
	labelArg, labelFin := WrapString(label)

	defer func() {
		labelFin()
	}()
	return C.igSelectable_Bool(labelArg, C.bool(selected), C.ImGuiSelectableFlags(flags), size.toC()) == C.bool(true)
}

// "bool* p_selected" point to the selection state (read-write), as a convenient helper.
// SelectableBoolPtrV parameter default value hint:
// flags: 0
// size: ImVec2(0,0)
func SelectableBoolPtrV(label string, p_selected *bool, flags SelectableFlags, size Vec2) bool {
	labelArg, labelFin := WrapString(label)
	p_selectedArg, p_selectedFin := WrapBool(p_selected)

	defer func() {
		labelFin()
		p_selectedFin()
	}()
	return C.igSelectable_BoolPtr(labelArg, p_selectedArg, C.ImGuiSelectableFlags(flags), size.toC()) == C.bool(true)
}

// separator, generally horizontal. inside a menu bar or in horizontal layout mode, this becomes a vertical separator.
func Separator() {
	C.igSeparator()
}

// InternalSeparatorExV parameter default value hint:
// thickness: 1.0f
func InternalSeparatorExV(flags SeparatorFlags, thickness float32) {
	C.igSeparatorEx(C.ImGuiSeparatorFlags(flags), C.float(thickness))
}

// currently: formatted text with an horizontal line
func SeparatorText(label string) {
	labelArg, labelFin := WrapString(label)
	C.igSeparatorText(labelArg)

	labelFin()
}

func InternalSeparatorTextEx(id ID, label string, label_end string, extra_width float32) {
	idArg, idFin := id.c()
	labelArg, labelFin := WrapString(label)
	label_endArg, label_endFin := WrapString(label_end)
	C.igSeparatorTextEx(idArg, labelArg, label_endArg, C.float(extra_width))

	idFin()
	labelFin()
	label_endFin()
}

func InternalSetActiveID(id ID, window *Window) {
	idArg, idFin := id.c()
	windowArg, windowFin := window.handle()
	C.igSetActiveID(idArg, windowArg)

	idFin()
	windowFin()
}

func InternalSetActiveIdUsingAllKeyboardKeys() {
	C.igSetActiveIdUsingAllKeyboardKeys()
}

func SetClipboardText(text string) {
	textArg, textFin := WrapString(text)
	C.igSetClipboardText(textArg)

	textFin()
}

// initialize current options (generally on application startup) if you want to select a default format, picker type, etc. User will be able to change many settings, unless you pass the _NoOptions flag to your calls.
func SetColorEditOptions(flags ColorEditFlags) {
	C.igSetColorEditOptions(C.ImGuiColorEditFlags(flags))
}

// set position of column line (in pixels, from the left side of the contents region). pass -1 to use current column
func SetColumnOffset(column_index int32, offset_x float32) {
	C.igSetColumnOffset(C.int(column_index), C.float(offset_x))
}

// set column width (in pixels). pass -1 to use current column
func SetColumnWidth(column_index int32, width float32) {
	C.igSetColumnWidth(C.int(column_index), C.float(width))
}

func SetCurrentContext(ctx *Context) {
	ctxArg, ctxFin := ctx.handle()
	C.igSetCurrentContext(ctxArg)

	ctxFin()
}

func InternalSetCurrentFont(font *Font) {
	fontArg, fontFin := font.handle()
	C.igSetCurrentFont(fontArg)

	fontFin()
}

func InternalSetCurrentViewport(window *Window, viewport *ViewportP) {
	windowArg, windowFin := window.handle()
	viewportArg, viewportFin := viewport.handle()
	C.igSetCurrentViewport(windowArg, viewportArg)

	windowFin()
	viewportFin()
}

// are using the main, absolute coordinate system.
func SetCursorPos(local_pos Vec2) {
	C.igSetCursorPos(local_pos.toC())
}

// GetWindowPos() + GetCursorPos() == GetCursorScreenPos() etc.)
func SetCursorPosX(local_x float32) {
	C.igSetCursorPosX(C.float(local_x))
}

func SetCursorPosY(local_y float32) {
	C.igSetCursorPosY(C.float(local_y))
}

// cursor position in absolute coordinates
func SetCursorScreenPos(pos Vec2) {
	C.igSetCursorScreenPos(pos.toC())
}

// type is a user defined string of maximum 32 characters. Strings starting with '_' are reserved for dear imgui internal types. Data is copied and held by imgui. Return true when payload has been accepted.
// SetDragDropPayloadV parameter default value hint:
// cond: 0
func SetDragDropPayloadV(typeArg string, data unsafe.Pointer, sz uint64, cond Cond) bool {
	typeArgArg, typeArgFin := WrapString(typeArg)

	defer func() {
		typeArgFin()
	}()
	return C.igSetDragDropPayload(typeArgArg, (data), C.xulong(sz), C.ImGuiCond(cond)) == C.bool(true)
}

func InternalSetFocusID(id ID, window *Window) {
	idArg, idFin := id.c()
	windowArg, windowFin := window.handle()
	C.igSetFocusID(idArg, windowArg)

	idFin()
	windowFin()
}

func InternalSetHoveredID(id ID) {
	idArg, idFin := id.c()
	C.igSetHoveredID(idArg)

	idFin()
}

// make last item the default focused item of a window.
func SetItemDefaultFocus() {
	C.igSetItemDefaultFocus()
}

// Set key owner to last item if it is hovered or active. Equivalent to 'if (IsItemHovered() || IsItemActive())  SetKeyOwner(key, GetItemID());'.
// InternalSetItemKeyOwnerV parameter default value hint:
// flags: 0
func InternalSetItemKeyOwnerV(key Key, flags InputFlags) {
	C.igSetItemKeyOwner(C.ImGuiKey(key), C.ImGuiInputFlags(flags))
}

// set a text-only tooltip if preceeding item was hovered. override any previous call to SetTooltip().
func SetItemTooltip(fmt string) {
	fmtArg, fmtFin := WrapString(fmt)
	C.wrap_igSetItemTooltip(fmtArg)

	fmtFin()
}

// InternalSetKeyOwnerV parameter default value hint:
// flags: 0
func InternalSetKeyOwnerV(key Key, owner_id ID, flags InputFlags) {
	owner_idArg, owner_idFin := owner_id.c()
	C.igSetKeyOwner(C.ImGuiKey(key), owner_idArg, C.ImGuiInputFlags(flags))

	owner_idFin()
}

// InternalSetKeyOwnersForKeyChordV parameter default value hint:
// flags: 0
func InternalSetKeyOwnersForKeyChordV(key KeyChord, owner_id ID, flags InputFlags) {
	keyArg, keyFin := key.c()
	owner_idArg, owner_idFin := owner_id.c()
	C.igSetKeyOwnersForKeyChord(keyArg, owner_idArg, C.ImGuiInputFlags(flags))

	keyFin()
	owner_idFin()
}

// focus keyboard on the next widget. Use positive 'offset' to access sub components of a multiple component widget. Use -1 to access previous widget.
// SetKeyboardFocusHereV parameter default value hint:
// offset: 0
func SetKeyboardFocusHereV(offset int32) {
	C.igSetKeyboardFocusHere(C.int(offset))
}

func InternalSetLastItemData(item_id ID, in_flags ItemFlags, status_flags ItemStatusFlags, item_rect Rect) {
	item_idArg, item_idFin := item_id.c()
	C.igSetLastItemData(item_idArg, C.ImGuiItemFlags(in_flags), C.ImGuiItemStatusFlags(status_flags), item_rect.toC())

	item_idFin()
}

// set desired mouse cursor shape
func SetMouseCursor(cursor_type MouseCursor) {
	C.igSetMouseCursor(C.ImGuiMouseCursor(cursor_type))
}

func InternalSetNavID(id ID, nav_layer NavLayer, focus_scope_id ID, rect_rel Rect) {
	idArg, idFin := id.c()
	focus_scope_idArg, focus_scope_idFin := focus_scope_id.c()
	C.igSetNavID(idArg, C.ImGuiNavLayer(nav_layer), focus_scope_idArg, rect_rel.toC())

	idFin()
	focus_scope_idFin()
}

func InternalSetNavWindow(window *Window) {
	windowArg, windowFin := window.handle()
	C.igSetNavWindow(windowArg)

	windowFin()
}

// Override io.WantCaptureKeyboard flag next frame (said flag is left for your application to handle, typically when true it instructs your app to ignore inputs). e.g. force capture keyboard when your widget is being hovered. This is equivalent to setting "io.WantCaptureKeyboard = want_capture_keyboard"; after the next NewFrame() call.
func SetNextFrameWantCaptureKeyboard(want_capture_keyboard bool) {
	C.igSetNextFrameWantCaptureKeyboard(C.bool(want_capture_keyboard))
}

// Override io.WantCaptureMouse flag next frame (said flag is left for your application to handle, typical when true it instucts your app to ignore inputs). This is equivalent to setting "io.WantCaptureMouse = want_capture_mouse;" after the next NewFrame() call.
func SetNextFrameWantCaptureMouse(want_capture_mouse bool) {
	C.igSetNextFrameWantCaptureMouse(C.bool(want_capture_mouse))
}

// allow next item to be overlapped by a subsequent item. Useful with invisible buttons, selectable, treenode covering an area where subsequent items may need to be added. Note that both Selectable() and TreeNode() have dedicated flags doing this.
func SetNextItemAllowOverlap() {
	C.igSetNextItemAllowOverlap()
}

// set next TreeNode/CollapsingHeader open state.
// SetNextItemOpenV parameter default value hint:
// cond: 0
func SetNextItemOpenV(is_open bool, cond Cond) {
	C.igSetNextItemOpen(C.bool(is_open), C.ImGuiCond(cond))
}

// set width of the _next_ common large "item+label" widget. >0.0f: width in pixels, <0.0f align xx pixels to the right of window (so -FLT_MIN always align width to the right side)
func SetNextItemWidth(item_width float32) {
	C.igSetNextItemWidth(C.float(item_width))
}

// set next window background color alpha. helper to easily override the Alpha component of ImGuiCol_WindowBg/ChildBg/PopupBg. you may also use ImGuiWindowFlags_NoBackground.
func SetNextWindowBgAlpha(alpha float32) {
	C.igSetNextWindowBgAlpha(C.float(alpha))
}

// set next window class (control docking compatibility + provide hints to platform backend via custom viewport flags and platform parent/child relationship)
func SetNextWindowClass(window_class *WindowClass) {
	window_classArg, window_classFin := window_class.handle()
	C.igSetNextWindowClass(window_classArg)

	window_classFin()
}

// set next window collapsed state. call before Begin()
// SetNextWindowCollapsedV parameter default value hint:
// cond: 0
func SetNextWindowCollapsedV(collapsed bool, cond Cond) {
	C.igSetNextWindowCollapsed(C.bool(collapsed), C.ImGuiCond(cond))
}

// set next window content size (~ scrollable client area, which enforce the range of scrollbars). Not including window decorations (title bar, menu bar, etc.) nor WindowPadding. set an axis to 0.0f to leave it automatic. call before Begin()
func SetNextWindowContentSize(size Vec2) {
	C.igSetNextWindowContentSize(size.toC())
}

// set next window dock id
// SetNextWindowDockIDV parameter default value hint:
// cond: 0
func SetNextWindowDockIDV(dock_id ID, cond Cond) {
	dock_idArg, dock_idFin := dock_id.c()
	C.igSetNextWindowDockID(dock_idArg, C.ImGuiCond(cond))

	dock_idFin()
}

// set next window to be focused / top-most. call before Begin()
func SetNextWindowFocus() {
	C.igSetNextWindowFocus()
}

// set next window position. call before Begin(). use pivot=(0.5f,0.5f) to center on given point, etc.
// SetNextWindowPosV parameter default value hint:
// cond: 0
// pivot: ImVec2(0,0)
func SetNextWindowPosV(pos Vec2, cond Cond, pivot Vec2) {
	C.igSetNextWindowPos(pos.toC(), C.ImGuiCond(cond), pivot.toC())
}

// set next window scrolling value (use < 0.0f to not affect a given axis).
func SetNextWindowScroll(scroll Vec2) {
	C.igSetNextWindowScroll(scroll.toC())
}

// set next window size. set axis to 0.0f to force an auto-fit on this axis. call before Begin()
// SetNextWindowSizeV parameter default value hint:
// cond: 0
func SetNextWindowSizeV(size Vec2, cond Cond) {
	C.igSetNextWindowSize(size.toC(), C.ImGuiCond(cond))
}

// set next window viewport
func SetNextWindowViewport(viewport_id ID) {
	viewport_idArg, viewport_idFin := viewport_id.c()
	C.igSetNextWindowViewport(viewport_idArg)

	viewport_idFin()
}

// adjust scrolling amount to make given position visible. Generally GetCursorStartPos() + offset to compute a valid position.
// SetScrollFromPosXFloatV parameter default value hint:
// center_x_ratio: 0.5f
func SetScrollFromPosXFloatV(local_x float32, center_x_ratio float32) {
	C.igSetScrollFromPosX_Float(C.float(local_x), C.float(center_x_ratio))
}

func InternalSetScrollFromPosXWindowPtr(window *Window, local_x float32, center_x_ratio float32) {
	windowArg, windowFin := window.handle()
	C.igSetScrollFromPosX_WindowPtr(windowArg, C.float(local_x), C.float(center_x_ratio))

	windowFin()
}

// adjust scrolling amount to make given position visible. Generally GetCursorStartPos() + offset to compute a valid position.
// SetScrollFromPosYFloatV parameter default value hint:
// center_y_ratio: 0.5f
func SetScrollFromPosYFloatV(local_y float32, center_y_ratio float32) {
	C.igSetScrollFromPosY_Float(C.float(local_y), C.float(center_y_ratio))
}

func InternalSetScrollFromPosYWindowPtr(window *Window, local_y float32, center_y_ratio float32) {
	windowArg, windowFin := window.handle()
	C.igSetScrollFromPosY_WindowPtr(windowArg, C.float(local_y), C.float(center_y_ratio))

	windowFin()
}

// adjust scrolling amount to make current cursor position visible. center_x_ratio=0.0: left, 0.5: center, 1.0: right. When using to make a "default/current item" visible, consider using SetItemDefaultFocus() instead.
// SetScrollHereXV parameter default value hint:
// center_x_ratio: 0.5f
func SetScrollHereXV(center_x_ratio float32) {
	C.igSetScrollHereX(C.float(center_x_ratio))
}

// adjust scrolling amount to make current cursor position visible. center_y_ratio=0.0: top, 0.5: center, 1.0: bottom. When using to make a "default/current item" visible, consider using SetItemDefaultFocus() instead.
// SetScrollHereYV parameter default value hint:
// center_y_ratio: 0.5f
func SetScrollHereYV(center_y_ratio float32) {
	C.igSetScrollHereY(C.float(center_y_ratio))
}

// set scrolling amount [0 .. GetScrollMaxX()]
func SetScrollXFloat(scroll_x float32) {
	C.igSetScrollX_Float(C.float(scroll_x))
}

func InternalSetScrollXWindowPtr(window *Window, scroll_x float32) {
	windowArg, windowFin := window.handle()
	C.igSetScrollX_WindowPtr(windowArg, C.float(scroll_x))

	windowFin()
}

// set scrolling amount [0 .. GetScrollMaxY()]
func SetScrollYFloat(scroll_y float32) {
	C.igSetScrollY_Float(C.float(scroll_y))
}

func InternalSetScrollYWindowPtr(window *Window, scroll_y float32) {
	windowArg, windowFin := window.handle()
	C.igSetScrollY_WindowPtr(windowArg, C.float(scroll_y))

	windowFin()
}

// InternalSetShortcutRoutingV parameter default value hint:
// owner_id: 0
// flags: 0
func InternalSetShortcutRoutingV(key_chord KeyChord, owner_id ID, flags InputFlags) bool {
	key_chordArg, key_chordFin := key_chord.c()
	owner_idArg, owner_idFin := owner_id.c()

	defer func() {
		key_chordFin()
		owner_idFin()
	}()
	return C.igSetShortcutRouting(key_chordArg, owner_idArg, C.ImGuiInputFlags(flags)) == C.bool(true)
}

// replace current window storage with our own (if you want to manipulate it yourself, typically clear subsection of it)
func SetStateStorage(storage *Storage) {
	storageArg, storageFin := storage.handle()
	C.igSetStateStorage(storageArg)

	storageFin()
}

// notify TabBar or Docking system of a closed tab/window ahead (useful to reduce visual flicker on reorderable tab bars). For tab-bar: call after BeginTabBar() and before Tab submissions. Otherwise call with a window name.
func SetTabItemClosed(tab_or_docked_window_label string) {
	tab_or_docked_window_labelArg, tab_or_docked_window_labelFin := WrapString(tab_or_docked_window_label)
	C.igSetTabItemClosed(tab_or_docked_window_labelArg)

	tab_or_docked_window_labelFin()
}

// set a text-only tooltip. Often used after a ImGui::IsItemHovered() check. Override any previous call to SetTooltip().
func SetTooltip(fmt string) {
	fmtArg, fmtFin := WrapString(fmt)
	C.wrap_igSetTooltip(fmtArg)

	fmtFin()
}

func InternalSetWindowClipRectBeforeSetChannel(window *Window, clip_rect Rect) {
	windowArg, windowFin := window.handle()
	C.igSetWindowClipRectBeforeSetChannel(windowArg, clip_rect.toC())

	windowFin()
}

// (not recommended) set current window collapsed state. prefer using SetNextWindowCollapsed().
// SetWindowCollapsedBoolV parameter default value hint:
// cond: 0
func SetWindowCollapsedBoolV(collapsed bool, cond Cond) {
	C.igSetWindowCollapsed_Bool(C.bool(collapsed), C.ImGuiCond(cond))
}

// set named window collapsed state
// SetWindowCollapsedStrV parameter default value hint:
// cond: 0
func SetWindowCollapsedStrV(name string, collapsed bool, cond Cond) {
	nameArg, nameFin := WrapString(name)
	C.igSetWindowCollapsed_Str(nameArg, C.bool(collapsed), C.ImGuiCond(cond))

	nameFin()
}

// InternalSetWindowCollapsedWindowPtrV parameter default value hint:
// cond: 0
func InternalSetWindowCollapsedWindowPtrV(window *Window, collapsed bool, cond Cond) {
	windowArg, windowFin := window.handle()
	C.igSetWindowCollapsed_WindowPtr(windowArg, C.bool(collapsed), C.ImGuiCond(cond))

	windowFin()
}

func InternalSetWindowDock(window *Window, dock_id ID, cond Cond) {
	windowArg, windowFin := window.handle()
	dock_idArg, dock_idFin := dock_id.c()
	C.igSetWindowDock(windowArg, dock_idArg, C.ImGuiCond(cond))

	windowFin()
	dock_idFin()
}

// (not recommended) set current window to be focused / top-most. prefer using SetNextWindowFocus().
func SetWindowFocusNil() {
	C.igSetWindowFocus_Nil()
}

// set named window to be focused / top-most. use NULL to remove focus.
func SetWindowFocusStr(name string) {
	nameArg, nameFin := WrapString(name)
	C.igSetWindowFocus_Str(nameArg)

	nameFin()
}

// [OBSOLETE] set font scale. Adjust IO.FontGlobalScale if you want to scale all windows. This is an old API! For correct scaling, prefer to reload font + rebuild ImFontAtlas + call style.ScaleAllSizes().
func SetWindowFontScale(scale float32) {
	C.igSetWindowFontScale(C.float(scale))
}

func InternalSetWindowHiddendAndSkipItemsForCurrentFrame(window *Window) {
	windowArg, windowFin := window.handle()
	C.igSetWindowHiddendAndSkipItemsForCurrentFrame(windowArg)

	windowFin()
}

func InternalSetWindowHitTestHole(window *Window, pos Vec2, size Vec2) {
	windowArg, windowFin := window.handle()
	C.igSetWindowHitTestHole(windowArg, pos.toC(), size.toC())

	windowFin()
}

// set named window position.
// SetWindowPosStrV parameter default value hint:
// cond: 0
func SetWindowPosStrV(name string, pos Vec2, cond Cond) {
	nameArg, nameFin := WrapString(name)
	C.igSetWindowPos_Str(nameArg, pos.toC(), C.ImGuiCond(cond))

	nameFin()
}

// (not recommended) set current window position - call within Begin()/End(). prefer using SetNextWindowPos(), as this may incur tearing and side-effects.
// SetWindowPosVec2V parameter default value hint:
// cond: 0
func SetWindowPosVec2V(pos Vec2, cond Cond) {
	C.igSetWindowPos_Vec2(pos.toC(), C.ImGuiCond(cond))
}

// InternalSetWindowPosWindowPtrV parameter default value hint:
// cond: 0
func InternalSetWindowPosWindowPtrV(window *Window, pos Vec2, cond Cond) {
	windowArg, windowFin := window.handle()
	C.igSetWindowPos_WindowPtr(windowArg, pos.toC(), C.ImGuiCond(cond))

	windowFin()
}

// set named window size. set axis to 0.0f to force an auto-fit on this axis.
// SetWindowSizeStrV parameter default value hint:
// cond: 0
func SetWindowSizeStrV(name string, size Vec2, cond Cond) {
	nameArg, nameFin := WrapString(name)
	C.igSetWindowSize_Str(nameArg, size.toC(), C.ImGuiCond(cond))

	nameFin()
}

// (not recommended) set current window size - call within Begin()/End(). set to ImVec2(0, 0) to force an auto-fit. prefer using SetNextWindowSize(), as this may incur tearing and minor side-effects.
// SetWindowSizeVec2V parameter default value hint:
// cond: 0
func SetWindowSizeVec2V(size Vec2, cond Cond) {
	C.igSetWindowSize_Vec2(size.toC(), C.ImGuiCond(cond))
}

// InternalSetWindowSizeWindowPtrV parameter default value hint:
// cond: 0
func InternalSetWindowSizeWindowPtrV(window *Window, size Vec2, cond Cond) {
	windowArg, windowFin := window.handle()
	C.igSetWindowSize_WindowPtr(windowArg, size.toC(), C.ImGuiCond(cond))

	windowFin()
}

func InternalSetWindowViewport(window *Window, viewport *ViewportP) {
	windowArg, windowFin := window.handle()
	viewportArg, viewportFin := viewport.handle()
	C.igSetWindowViewport(windowArg, viewportArg)

	windowFin()
	viewportFin()
}

func InternalShadeVertsLinearColorGradientKeepAlpha(draw_list *DrawList, vert_start_idx int32, vert_end_idx int32, gradient_p0 Vec2, gradient_p1 Vec2, col0 uint32, col1 uint32) {
	draw_listArg, draw_listFin := draw_list.handle()
	C.igShadeVertsLinearColorGradientKeepAlpha(draw_listArg, C.int(vert_start_idx), C.int(vert_end_idx), gradient_p0.toC(), gradient_p1.toC(), C.ImU32(col0), C.ImU32(col1))

	draw_listFin()
}

func InternalShadeVertsLinearUV(draw_list *DrawList, vert_start_idx int32, vert_end_idx int32, a Vec2, b Vec2, uv_a Vec2, uv_b Vec2, clamp bool) {
	draw_listArg, draw_listFin := draw_list.handle()
	C.igShadeVertsLinearUV(draw_listArg, C.int(vert_start_idx), C.int(vert_end_idx), a.toC(), b.toC(), uv_a.toC(), uv_b.toC(), C.bool(clamp))

	draw_listFin()
}

// InternalShortcutV parameter default value hint:
// owner_id: 0
// flags: 0
func InternalShortcutV(key_chord KeyChord, owner_id ID, flags InputFlags) bool {
	key_chordArg, key_chordFin := key_chord.c()
	owner_idArg, owner_idFin := owner_id.c()

	defer func() {
		key_chordFin()
		owner_idFin()
	}()
	return C.igShortcut(key_chordArg, owner_idArg, C.ImGuiInputFlags(flags)) == C.bool(true)
}

// create About window. display Dear ImGui version, credits and build/system information.
// ShowAboutWindowV parameter default value hint:
// p_open: NULL
func ShowAboutWindowV(p_open *bool) {
	p_openArg, p_openFin := WrapBool(p_open)
	C.igShowAboutWindow(p_openArg)

	p_openFin()
}

// create Debug Log window. display a simplified log of important dear imgui events.
// ShowDebugLogWindowV parameter default value hint:
// p_open: NULL
func ShowDebugLogWindowV(p_open *bool) {
	p_openArg, p_openFin := WrapBool(p_open)
	C.igShowDebugLogWindow(p_openArg)

	p_openFin()
}

// create Demo window. demonstrate most ImGui features. call this to learn about the library! try to make it always available in your application!
// ShowDemoWindowV parameter default value hint:
// p_open: NULL
func ShowDemoWindowV(p_open *bool) {
	p_openArg, p_openFin := WrapBool(p_open)
	C.igShowDemoWindow(p_openArg)

	p_openFin()
}

func InternalShowFontAtlas(atlas *FontAtlas) {
	atlasArg, atlasFin := atlas.handle()
	C.igShowFontAtlas(atlasArg)

	atlasFin()
}

// add font selector block (not a window), essentially a combo listing the loaded fonts.
func ShowFontSelector(label string) {
	labelArg, labelFin := WrapString(label)
	C.igShowFontSelector(labelArg)

	labelFin()
}

// create Metrics/Debugger window. display Dear ImGui internals: windows, draw commands, various internal state, etc.
// ShowMetricsWindowV parameter default value hint:
// p_open: NULL
func ShowMetricsWindowV(p_open *bool) {
	p_openArg, p_openFin := WrapBool(p_open)
	C.igShowMetricsWindow(p_openArg)

	p_openFin()
}

// create Stack Tool window. hover items with mouse to query information about the source of their unique ID.
// ShowStackToolWindowV parameter default value hint:
// p_open: NULL
func ShowStackToolWindowV(p_open *bool) {
	p_openArg, p_openFin := WrapBool(p_open)
	C.igShowStackToolWindow(p_openArg)

	p_openFin()
}

// add style editor block (not a window). you can pass in a reference ImGuiStyle structure to compare to, revert to and save to (else it uses the default style)
// ShowStyleEditorV parameter default value hint:
// ref: NULL
func ShowStyleEditorV(ref *Style) {
	refArg, refFin := ref.handle()
	C.igShowStyleEditor(refArg)

	refFin()
}

// add style selector block (not a window), essentially a combo listing the default styles.
func ShowStyleSelector(label string) bool {
	labelArg, labelFin := WrapString(label)

	defer func() {
		labelFin()
	}()
	return C.igShowStyleSelector(labelArg) == C.bool(true)
}

// add basic help/info block (not a window): how to manipulate ImGui as an end-user (mouse/keyboard controls).
func ShowUserGuide() {
	C.igShowUserGuide()
}

func InternalShrinkWidths(items *ShrinkWidthItem, count int32, width_excess float32) {
	itemsArg, itemsFin := items.handle()
	C.igShrinkWidths(itemsArg, C.int(count), C.float(width_excess))

	itemsFin()
}

// Since 1.60 this is a _private_ function. You can call DestroyContext() to destroy the context created by CreateContext().
func InternalShutdown() {
	C.igShutdown()
}

// SliderAngleV parameter default value hint:
// v_degrees_min: -360.0f
// v_degrees_max: +360.0f
// format: "%.0f deg"
// flags: 0
func SliderAngleV(label string, v_rad *float32, v_degrees_min float32, v_degrees_max float32, format string, flags SliderFlags) bool {
	labelArg, labelFin := WrapString(label)
	v_radArg, v_radFin := WrapNumberPtr[C.float, float32](v_rad)
	formatArg, formatFin := WrapString(format)

	defer func() {
		labelFin()
		v_radFin()
		formatFin()
	}()
	return C.igSliderAngle(labelArg, v_radArg, C.float(v_degrees_min), C.float(v_degrees_max), formatArg, C.ImGuiSliderFlags(flags)) == C.bool(true)
}

func InternalSliderBehavior(bb Rect, id ID, data_type DataType, p_v unsafe.Pointer, p_min unsafe.Pointer, p_max unsafe.Pointer, format string, flags SliderFlags, out_grab_bb *Rect) bool {
	idArg, idFin := id.c()
	p_vArg, p_vFin := WrapVoidPtr(p_v)
	formatArg, formatFin := WrapString(format)
	out_grab_bbArg, out_grab_bbFin := wrap[C.ImRect, *Rect](out_grab_bb)

	defer func() {
		idFin()
		p_vFin()
		formatFin()
		out_grab_bbFin()
	}()
	return C.igSliderBehavior(bb.toC(), idArg, C.ImGuiDataType(data_type), p_vArg, (p_min), (p_max), formatArg, C.ImGuiSliderFlags(flags), out_grab_bbArg) == C.bool(true)
}

// adjust format to decorate the value with a prefix or a suffix for in-slider labels or unit display.
// SliderFloatV parameter default value hint:
// format: "%.3f"
// flags: 0
func SliderFloatV(label string, v *float32, v_min float32, v_max float32, format string, flags SliderFlags) bool {
	labelArg, labelFin := WrapString(label)
	vArg, vFin := WrapNumberPtr[C.float, float32](v)
	formatArg, formatFin := WrapString(format)

	defer func() {
		labelFin()
		vFin()
		formatFin()
	}()
	return C.igSliderFloat(labelArg, vArg, C.float(v_min), C.float(v_max), formatArg, C.ImGuiSliderFlags(flags)) == C.bool(true)
}

// SliderFloat2V parameter default value hint:
// format: "%.3f"
// flags: 0
func SliderFloat2V(label string, v *[2]float32, v_min float32, v_max float32, format string, flags SliderFlags) bool {
	labelArg, labelFin := WrapString(label)

	vArg := make([]C.float, len(v))
	for i, vV := range v {
		vArg[i] = C.float(vV)
	}
	formatArg, formatFin := WrapString(format)

	defer func() {
		labelFin()

		for i, vV := range vArg {
			(*v)[i] = float32(vV)
		}

		formatFin()
	}()
	return C.igSliderFloat2(labelArg, (*C.float)(&vArg[0]), C.float(v_min), C.float(v_max), formatArg, C.ImGuiSliderFlags(flags)) == C.bool(true)
}

// SliderFloat3V parameter default value hint:
// format: "%.3f"
// flags: 0
func SliderFloat3V(label string, v *[3]float32, v_min float32, v_max float32, format string, flags SliderFlags) bool {
	labelArg, labelFin := WrapString(label)

	vArg := make([]C.float, len(v))
	for i, vV := range v {
		vArg[i] = C.float(vV)
	}
	formatArg, formatFin := WrapString(format)

	defer func() {
		labelFin()

		for i, vV := range vArg {
			(*v)[i] = float32(vV)
		}

		formatFin()
	}()
	return C.igSliderFloat3(labelArg, (*C.float)(&vArg[0]), C.float(v_min), C.float(v_max), formatArg, C.ImGuiSliderFlags(flags)) == C.bool(true)
}

// SliderFloat4V parameter default value hint:
// format: "%.3f"
// flags: 0
func SliderFloat4V(label string, v *[4]float32, v_min float32, v_max float32, format string, flags SliderFlags) bool {
	labelArg, labelFin := WrapString(label)

	vArg := make([]C.float, len(v))
	for i, vV := range v {
		vArg[i] = C.float(vV)
	}
	formatArg, formatFin := WrapString(format)

	defer func() {
		labelFin()

		for i, vV := range vArg {
			(*v)[i] = float32(vV)
		}

		formatFin()
	}()
	return C.igSliderFloat4(labelArg, (*C.float)(&vArg[0]), C.float(v_min), C.float(v_max), formatArg, C.ImGuiSliderFlags(flags)) == C.bool(true)
}

// SliderIntV parameter default value hint:
// format: "%d"
// flags: 0
func SliderIntV(label string, v *int32, v_min int32, v_max int32, format string, flags SliderFlags) bool {
	labelArg, labelFin := WrapString(label)
	vArg, vFin := WrapNumberPtr[C.int, int32](v)
	formatArg, formatFin := WrapString(format)

	defer func() {
		labelFin()
		vFin()
		formatFin()
	}()
	return C.igSliderInt(labelArg, vArg, C.int(v_min), C.int(v_max), formatArg, C.ImGuiSliderFlags(flags)) == C.bool(true)
}

// SliderInt2V parameter default value hint:
// format: "%d"
// flags: 0
func SliderInt2V(label string, v *[2]int32, v_min int32, v_max int32, format string, flags SliderFlags) bool {
	labelArg, labelFin := WrapString(label)

	vArg := make([]C.int, len(v))
	for i, vV := range v {
		vArg[i] = C.int(vV)
	}
	formatArg, formatFin := WrapString(format)

	defer func() {
		labelFin()

		for i, vV := range vArg {
			(*v)[i] = int32(vV)
		}

		formatFin()
	}()
	return C.igSliderInt2(labelArg, (*C.int)(&vArg[0]), C.int(v_min), C.int(v_max), formatArg, C.ImGuiSliderFlags(flags)) == C.bool(true)
}

// SliderInt3V parameter default value hint:
// format: "%d"
// flags: 0
func SliderInt3V(label string, v *[3]int32, v_min int32, v_max int32, format string, flags SliderFlags) bool {
	labelArg, labelFin := WrapString(label)

	vArg := make([]C.int, len(v))
	for i, vV := range v {
		vArg[i] = C.int(vV)
	}
	formatArg, formatFin := WrapString(format)

	defer func() {
		labelFin()

		for i, vV := range vArg {
			(*v)[i] = int32(vV)
		}

		formatFin()
	}()
	return C.igSliderInt3(labelArg, (*C.int)(&vArg[0]), C.int(v_min), C.int(v_max), formatArg, C.ImGuiSliderFlags(flags)) == C.bool(true)
}

// SliderInt4V parameter default value hint:
// format: "%d"
// flags: 0
func SliderInt4V(label string, v *[4]int32, v_min int32, v_max int32, format string, flags SliderFlags) bool {
	labelArg, labelFin := WrapString(label)

	vArg := make([]C.int, len(v))
	for i, vV := range v {
		vArg[i] = C.int(vV)
	}
	formatArg, formatFin := WrapString(format)

	defer func() {
		labelFin()

		for i, vV := range vArg {
			(*v)[i] = int32(vV)
		}

		formatFin()
	}()
	return C.igSliderInt4(labelArg, (*C.int)(&vArg[0]), C.int(v_min), C.int(v_max), formatArg, C.ImGuiSliderFlags(flags)) == C.bool(true)
}

// SliderScalarV parameter default value hint:
// format: NULL
// flags: 0
func SliderScalarV(label string, data_type DataType, p_data unsafe.Pointer, p_min unsafe.Pointer, p_max unsafe.Pointer, format string, flags SliderFlags) bool {
	labelArg, labelFin := WrapString(label)
	p_dataArg, p_dataFin := WrapVoidPtr(p_data)
	formatArg, formatFin := WrapString(format)

	defer func() {
		labelFin()
		p_dataFin()
		formatFin()
	}()
	return C.igSliderScalar(labelArg, C.ImGuiDataType(data_type), p_dataArg, (p_min), (p_max), formatArg, C.ImGuiSliderFlags(flags)) == C.bool(true)
}

// SliderScalarNV parameter default value hint:
// format: NULL
// flags: 0
func SliderScalarNV(label string, data_type DataType, p_data unsafe.Pointer, components int32, p_min unsafe.Pointer, p_max unsafe.Pointer, format string, flags SliderFlags) bool {
	labelArg, labelFin := WrapString(label)
	p_dataArg, p_dataFin := WrapVoidPtr(p_data)
	formatArg, formatFin := WrapString(format)

	defer func() {
		labelFin()
		p_dataFin()
		formatFin()
	}()
	return C.igSliderScalarN(labelArg, C.ImGuiDataType(data_type), p_dataArg, C.int(components), (p_min), (p_max), formatArg, C.ImGuiSliderFlags(flags)) == C.bool(true)
}

// button with FramePadding=(0,0) to easily embed within text
func SmallButton(label string) bool {
	labelArg, labelFin := WrapString(label)

	defer func() {
		labelFin()
	}()
	return C.igSmallButton(labelArg) == C.bool(true)
}

// add vertical spacing.
func Spacing() {
	C.igSpacing()
}

// InternalSplitterBehaviorV parameter default value hint:
// hover_extend: 0.0f
// hover_visibility_delay: 0.0f
// bg_col: 0
func InternalSplitterBehaviorV(bb Rect, id ID, axis Axis, size1 *float32, size2 *float32, min_size1 float32, min_size2 float32, hover_extend float32, hover_visibility_delay float32, bg_col uint32) bool {
	idArg, idFin := id.c()
	size1Arg, size1Fin := WrapNumberPtr[C.float, float32](size1)
	size2Arg, size2Fin := WrapNumberPtr[C.float, float32](size2)

	defer func() {
		idFin()
		size1Fin()
		size2Fin()
	}()
	return C.igSplitterBehavior(bb.toC(), idArg, C.ImGuiAxis(axis), size1Arg, size2Arg, C.float(min_size1), C.float(min_size2), C.float(hover_extend), C.float(hover_visibility_delay), C.ImU32(bg_col)) == C.bool(true)
}

func InternalStartMouseMovingWindow(window *Window) {
	windowArg, windowFin := window.handle()
	C.igStartMouseMovingWindow(windowArg)

	windowFin()
}

func InternalStartMouseMovingWindowOrNode(window *Window, node *DockNode, undock_floating_node bool) {
	windowArg, windowFin := window.handle()
	nodeArg, nodeFin := node.handle()
	C.igStartMouseMovingWindowOrNode(windowArg, nodeArg, C.bool(undock_floating_node))

	windowFin()
	nodeFin()
}

// classic imgui style
// StyleColorsClassicV parameter default value hint:
// dst: NULL
func StyleColorsClassicV(dst *Style) {
	dstArg, dstFin := dst.handle()
	C.igStyleColorsClassic(dstArg)

	dstFin()
}

// new, recommended style (default)
// StyleColorsDarkV parameter default value hint:
// dst: NULL
func StyleColorsDarkV(dst *Style) {
	dstArg, dstFin := dst.handle()
	C.igStyleColorsDark(dstArg)

	dstFin()
}

// best used with borders and a custom, thicker font
// StyleColorsLightV parameter default value hint:
// dst: NULL
func StyleColorsLightV(dst *Style) {
	dstArg, dstFin := dst.handle()
	C.igStyleColorsLight(dstArg)

	dstFin()
}

func InternalTabBarAddTab(tab_bar *TabBar, tab_flags TabItemFlags, window *Window) {
	tab_barArg, tab_barFin := tab_bar.handle()
	windowArg, windowFin := window.handle()
	C.igTabBarAddTab(tab_barArg, C.ImGuiTabItemFlags(tab_flags), windowArg)

	tab_barFin()
	windowFin()
}

func InternalTabBarCloseTab(tab_bar *TabBar, tab *TabItem) {
	tab_barArg, tab_barFin := tab_bar.handle()
	tabArg, tabFin := tab.handle()
	C.igTabBarCloseTab(tab_barArg, tabArg)

	tab_barFin()
	tabFin()
}

func InternalTabBarFindMostRecentlySelectedTabForActiveWindow(tab_bar *TabBar) *TabItem {
	tab_barArg, tab_barFin := tab_bar.handle()

	defer func() {
		tab_barFin()
	}()
	return newTabItemFromC(C.igTabBarFindMostRecentlySelectedTabForActiveWindow(tab_barArg))
}

func InternalTabBarFindTabByID(tab_bar *TabBar, tab_id ID) *TabItem {
	tab_barArg, tab_barFin := tab_bar.handle()
	tab_idArg, tab_idFin := tab_id.c()

	defer func() {
		tab_barFin()
		tab_idFin()
	}()
	return newTabItemFromC(C.igTabBarFindTabByID(tab_barArg, tab_idArg))
}

func InternalTabBarFindTabByOrder(tab_bar *TabBar, order int32) *TabItem {
	tab_barArg, tab_barFin := tab_bar.handle()

	defer func() {
		tab_barFin()
	}()
	return newTabItemFromC(C.igTabBarFindTabByOrder(tab_barArg, C.int(order)))
}

func InternalTabBarGetCurrentTab(tab_bar *TabBar) *TabItem {
	tab_barArg, tab_barFin := tab_bar.handle()

	defer func() {
		tab_barFin()
	}()
	return newTabItemFromC(C.igTabBarGetCurrentTab(tab_barArg))
}

func InternalTabBarGetTabName(tab_bar *TabBar, tab *TabItem) string {
	tab_barArg, tab_barFin := tab_bar.handle()
	tabArg, tabFin := tab.handle()

	defer func() {
		tab_barFin()
		tabFin()
	}()
	return C.GoString(C.igTabBarGetTabName(tab_barArg, tabArg))
}

func InternalTabBarGetTabOrder(tab_bar *TabBar, tab *TabItem) int32 {
	tab_barArg, tab_barFin := tab_bar.handle()
	tabArg, tabFin := tab.handle()

	defer func() {
		tab_barFin()
		tabFin()
	}()
	return int32(C.igTabBarGetTabOrder(tab_barArg, tabArg))
}

func InternalTabBarProcessReorder(tab_bar *TabBar) bool {
	tab_barArg, tab_barFin := tab_bar.handle()

	defer func() {
		tab_barFin()
	}()
	return C.igTabBarProcessReorder(tab_barArg) == C.bool(true)
}

func InternalTabBarQueueFocus(tab_bar *TabBar, tab *TabItem) {
	tab_barArg, tab_barFin := tab_bar.handle()
	tabArg, tabFin := tab.handle()
	C.igTabBarQueueFocus(tab_barArg, tabArg)

	tab_barFin()
	tabFin()
}

func InternalTabBarQueueReorder(tab_bar *TabBar, tab *TabItem, offset int32) {
	tab_barArg, tab_barFin := tab_bar.handle()
	tabArg, tabFin := tab.handle()
	C.igTabBarQueueReorder(tab_barArg, tabArg, C.int(offset))

	tab_barFin()
	tabFin()
}

func InternalTabBarQueueReorderFromMousePos(tab_bar *TabBar, tab *TabItem, mouse_pos Vec2) {
	tab_barArg, tab_barFin := tab_bar.handle()
	tabArg, tabFin := tab.handle()
	C.igTabBarQueueReorderFromMousePos(tab_barArg, tabArg, mouse_pos.toC())

	tab_barFin()
	tabFin()
}

func InternalTabBarRemoveTab(tab_bar *TabBar, tab_id ID) {
	tab_barArg, tab_barFin := tab_bar.handle()
	tab_idArg, tab_idFin := tab_id.c()
	C.igTabBarRemoveTab(tab_barArg, tab_idArg)

	tab_barFin()
	tab_idFin()
}

func InternalTabItemBackground(draw_list *DrawList, bb Rect, flags TabItemFlags, col uint32) {
	draw_listArg, draw_listFin := draw_list.handle()
	C.igTabItemBackground(draw_listArg, bb.toC(), C.ImGuiTabItemFlags(flags), C.ImU32(col))

	draw_listFin()
}

// create a Tab behaving like a button. return true when clicked. cannot be selected in the tab bar.
// TabItemButtonV parameter default value hint:
// flags: 0
func TabItemButtonV(label string, flags TabItemFlags) bool {
	labelArg, labelFin := WrapString(label)

	defer func() {
		labelFin()
	}()
	return C.igTabItemButton(labelArg, C.ImGuiTabItemFlags(flags)) == C.bool(true)
}

func InternalTabItemCalcSizeStr(label string, has_close_button_or_unsaved_marker bool) Vec2 {
	pOut := new(Vec2)
	pOutArg, pOutFin := wrap[C.ImVec2, *Vec2](pOut)

	labelArg, labelFin := WrapString(label)
	C.igTabItemCalcSize_Str(pOutArg, labelArg, C.bool(has_close_button_or_unsaved_marker))

	pOutFin()
	labelFin()

	return *pOut
}

func InternalTabItemCalcSizeWindowPtr(window *Window) Vec2 {
	pOut := new(Vec2)
	pOutArg, pOutFin := wrap[C.ImVec2, *Vec2](pOut)

	windowArg, windowFin := window.handle()
	C.igTabItemCalcSize_WindowPtr(pOutArg, windowArg)

	pOutFin()
	windowFin()

	return *pOut
}

func InternalTabItemEx(tab_bar *TabBar, label string, p_open *bool, flags TabItemFlags, docked_window *Window) bool {
	tab_barArg, tab_barFin := tab_bar.handle()
	labelArg, labelFin := WrapString(label)
	p_openArg, p_openFin := WrapBool(p_open)
	docked_windowArg, docked_windowFin := docked_window.handle()

	defer func() {
		tab_barFin()
		labelFin()
		p_openFin()
		docked_windowFin()
	}()
	return C.igTabItemEx(tab_barArg, labelArg, p_openArg, C.ImGuiTabItemFlags(flags), docked_windowArg) == C.bool(true)
}

func InternalTabItemLabelAndCloseButton(draw_list *DrawList, bb Rect, flags TabItemFlags, frame_padding Vec2, label string, tab_id ID, close_button_id ID, is_contents_visible bool, out_just_closed *bool, out_text_clipped *bool) {
	draw_listArg, draw_listFin := draw_list.handle()
	labelArg, labelFin := WrapString(label)
	tab_idArg, tab_idFin := tab_id.c()
	close_button_idArg, close_button_idFin := close_button_id.c()
	out_just_closedArg, out_just_closedFin := WrapBool(out_just_closed)
	out_text_clippedArg, out_text_clippedFin := WrapBool(out_text_clipped)
	C.igTabItemLabelAndCloseButton(draw_listArg, bb.toC(), C.ImGuiTabItemFlags(flags), frame_padding.toC(), labelArg, tab_idArg, close_button_idArg, C.bool(is_contents_visible), out_just_closedArg, out_text_clippedArg)

	draw_listFin()
	labelFin()
	tab_idFin()
	close_button_idFin()
	out_just_closedFin()
	out_text_clippedFin()
}

func InternalTableBeginApplyRequests(table *Table) {
	tableArg, tableFin := table.handle()
	C.igTableBeginApplyRequests(tableArg)

	tableFin()
}

func InternalTableBeginCell(table *Table, column_n int32) {
	tableArg, tableFin := table.handle()
	C.igTableBeginCell(tableArg, C.int(column_n))

	tableFin()
}

func InternalTableBeginContextMenuPopup(table *Table) bool {
	tableArg, tableFin := table.handle()

	defer func() {
		tableFin()
	}()
	return C.igTableBeginContextMenuPopup(tableArg) == C.bool(true)
}

func InternalTableBeginInitMemory(table *Table, columns_count int32) {
	tableArg, tableFin := table.handle()
	C.igTableBeginInitMemory(tableArg, C.int(columns_count))

	tableFin()
}

func InternalTableBeginRow(table *Table) {
	tableArg, tableFin := table.handle()
	C.igTableBeginRow(tableArg)

	tableFin()
}

func InternalTableDrawBorders(table *Table) {
	tableArg, tableFin := table.handle()
	C.igTableDrawBorders(tableArg)

	tableFin()
}

func InternalTableDrawContextMenu(table *Table) {
	tableArg, tableFin := table.handle()
	C.igTableDrawContextMenu(tableArg)

	tableFin()
}

func InternalTableEndCell(table *Table) {
	tableArg, tableFin := table.handle()
	C.igTableEndCell(tableArg)

	tableFin()
}

func InternalTableEndRow(table *Table) {
	tableArg, tableFin := table.handle()
	C.igTableEndRow(tableArg)

	tableFin()
}

func InternalTableFindByID(id ID) *Table {
	idArg, idFin := id.c()

	defer func() {
		idFin()
	}()
	return newTableFromC(C.igTableFindByID(idArg))
}

func InternalTableFixColumnSortDirection(table *Table, column *TableColumn) {
	tableArg, tableFin := table.handle()
	columnArg, columnFin := column.handle()
	C.igTableFixColumnSortDirection(tableArg, columnArg)

	tableFin()
	columnFin()
}

func InternalTableGcCompactSettings() {
	C.igTableGcCompactSettings()
}

func InternalTableGcCompactTransientBuffersTablePtr(table *Table) {
	tableArg, tableFin := table.handle()
	C.igTableGcCompactTransientBuffers_TablePtr(tableArg)

	tableFin()
}

func InternalTableGcCompactTransientBuffersTableTempDataPtr(table *TableTempData) {
	tableArg, tableFin := table.handle()
	C.igTableGcCompactTransientBuffers_TableTempDataPtr(tableArg)

	tableFin()
}

func InternalTableGetBoundSettings(table *Table) *TableSettings {
	tableArg, tableFin := table.handle()

	defer func() {
		tableFin()
	}()
	return newTableSettingsFromC(C.igTableGetBoundSettings(tableArg))
}

func InternalTableGetCellBgRect(table *Table, column_n int32) Rect {
	pOut := new(Rect)
	pOutArg, pOutFin := wrap[C.ImRect, *Rect](pOut)

	tableArg, tableFin := table.handle()
	C.igTableGetCellBgRect(pOutArg, tableArg, C.int(column_n))

	pOutFin()
	tableFin()

	return *pOut
}

// return number of columns (value passed to BeginTable)
func TableGetColumnCount() int32 {
	return int32(C.igTableGetColumnCount())
}

// return column flags so you can query their Enabled/Visible/Sorted/Hovered status flags. Pass -1 to use current column.
// TableGetColumnFlagsV parameter default value hint:
// column_n: -1
func TableGetColumnFlagsV(column_n int32) TableColumnFlags {
	return TableColumnFlags(C.igTableGetColumnFlags(C.int(column_n)))
}

// return current column index.
func TableGetColumnIndex() int32 {
	return int32(C.igTableGetColumnIndex())
}

// return "" if column didn't have a name declared by TableSetupColumn(). Pass -1 to use current column.
// TableGetColumnNameIntV parameter default value hint:
// column_n: -1
func TableGetColumnNameIntV(column_n int32) string {
	return C.GoString(C.igTableGetColumnName_Int(C.int(column_n)))
}

func InternalTableGetColumnNameTablePtr(table *Table, column_n int32) string {
	tableArg, tableFin := table.handle()

	defer func() {
		tableFin()
	}()
	return C.GoString(C.igTableGetColumnName_TablePtr(tableArg, C.int(column_n)))
}

func InternalTableGetColumnNextSortDirection(column *TableColumn) SortDirection {
	columnArg, columnFin := column.handle()

	defer func() {
		columnFin()
	}()
	return SortDirection(C.igTableGetColumnNextSortDirection(columnArg))
}

// InternalTableGetColumnResizeIDV parameter default value hint:
// instance_no: 0
func InternalTableGetColumnResizeIDV(table *Table, column_n int32, instance_no int32) ID {
	tableArg, tableFin := table.handle()

	defer func() {
		tableFin()
	}()
	return *newIDFromC(func() *C.ImGuiID {
		result := C.igTableGetColumnResizeID(tableArg, C.int(column_n), C.int(instance_no))
		return &result
	}())
}

func InternalTableGetColumnWidthAuto(table *Table, column *TableColumn) float32 {
	tableArg, tableFin := table.handle()
	columnArg, columnFin := column.handle()

	defer func() {
		tableFin()
		columnFin()
	}()
	return float32(C.igTableGetColumnWidthAuto(tableArg, columnArg))
}

func InternalTableGetHeaderRowHeight() float32 {
	return float32(C.igTableGetHeaderRowHeight())
}

// May use (TableGetColumnFlags() & ImGuiTableColumnFlags_IsHovered) instead. Return hovered column. return -1 when table is not hovered. return columns_count if the unused space at the right of visible columns is hovered.
func InternalTableGetHoveredColumn() int32 {
	return int32(C.igTableGetHoveredColumn())
}

// Retrieve *PREVIOUS FRAME* hovered row. This difference with TableGetHoveredColumn() is the reason why this is not public yet.
func InternalTableGetHoveredRow() int32 {
	return int32(C.igTableGetHoveredRow())
}

func InternalTableGetInstanceData(table *Table, instance_no int32) *TableInstanceData {
	tableArg, tableFin := table.handle()

	defer func() {
		tableFin()
	}()
	return newTableInstanceDataFromC(C.igTableGetInstanceData(tableArg, C.int(instance_no)))
}

func InternalTableGetInstanceID(table *Table, instance_no int32) ID {
	tableArg, tableFin := table.handle()

	defer func() {
		tableFin()
	}()
	return *newIDFromC(func() *C.ImGuiID { result := C.igTableGetInstanceID(tableArg, C.int(instance_no)); return &result }())
}

func InternalTableGetMaxColumnWidth(table *Table, column_n int32) float32 {
	tableArg, tableFin := table.handle()

	defer func() {
		tableFin()
	}()
	return float32(C.igTableGetMaxColumnWidth(tableArg, C.int(column_n)))
}

// return current row index.
func TableGetRowIndex() int32 {
	return int32(C.igTableGetRowIndex())
}

// get latest sort specs for the table (NULL if not sorting).  Lifetime: don't hold on this pointer over multiple frames or past any subsequent call to BeginTable().
func TableGetSortSpecs() *TableSortSpecs {
	return newTableSortSpecsFromC(C.igTableGetSortSpecs())
}

// submit one header cell manually (rarely used)
func TableHeader(label string) {
	labelArg, labelFin := WrapString(label)
	C.igTableHeader(labelArg)

	labelFin()
}

// submit all headers cells based on data provided to TableSetupColumn() + submit context menu
func TableHeadersRow() {
	C.igTableHeadersRow()
}

func InternalTableLoadSettings(table *Table) {
	tableArg, tableFin := table.handle()
	C.igTableLoadSettings(tableArg)

	tableFin()
}

func InternalTableMergeDrawChannels(table *Table) {
	tableArg, tableFin := table.handle()
	C.igTableMergeDrawChannels(tableArg)

	tableFin()
}

// append into the next column (or first column of next row if currently in last column). Return true when column is visible.
func TableNextColumn() bool {
	return C.igTableNextColumn() == C.bool(true)
}

// append into the first cell of a new row.
// TableNextRowV parameter default value hint:
// row_flags: 0
// min_row_height: 0.0f
func TableNextRowV(row_flags TableRowFlags, min_row_height float32) {
	C.igTableNextRow(C.ImGuiTableRowFlags(row_flags), C.float(min_row_height))
}

// InternalTableOpenContextMenuV parameter default value hint:
// column_n: -1
func InternalTableOpenContextMenuV(column_n int32) {
	C.igTableOpenContextMenu(C.int(column_n))
}

func InternalTablePopBackgroundChannel() {
	C.igTablePopBackgroundChannel()
}

func InternalTablePushBackgroundChannel() {
	C.igTablePushBackgroundChannel()
}

func InternalTableRemove(table *Table) {
	tableArg, tableFin := table.handle()
	C.igTableRemove(tableArg)

	tableFin()
}

func InternalTableResetSettings(table *Table) {
	tableArg, tableFin := table.handle()
	C.igTableResetSettings(tableArg)

	tableFin()
}

func InternalTableSaveSettings(table *Table) {
	tableArg, tableFin := table.handle()
	C.igTableSaveSettings(tableArg)

	tableFin()
}

// change the color of a cell, row, or column. See ImGuiTableBgTarget_ flags for details.
// TableSetBgColorV parameter default value hint:
// column_n: -1
func TableSetBgColorV(target TableBgTarget, color uint32, column_n int32) {
	C.igTableSetBgColor(C.ImGuiTableBgTarget(target), C.ImU32(color), C.int(column_n))
}

// change user accessible enabled/disabled state of a column. Set to false to hide the column. User can use the context menu to change this themselves (right-click in headers, or right-click in columns body with ImGuiTableFlags_ContextMenuInBody)
func TableSetColumnEnabled(column_n int32, v bool) {
	C.igTableSetColumnEnabled(C.int(column_n), C.bool(v))
}

// append into the specified column. Return true when column is visible.
func TableSetColumnIndex(column_n int32) bool {
	return C.igTableSetColumnIndex(C.int(column_n)) == C.bool(true)
}

func InternalTableSetColumnSortDirection(column_n int32, sort_direction SortDirection, append_to_sort_specs bool) {
	C.igTableSetColumnSortDirection(C.int(column_n), C.ImGuiSortDirection(sort_direction), C.bool(append_to_sort_specs))
}

func InternalTableSetColumnWidth(column_n int32, width float32) {
	C.igTableSetColumnWidth(C.int(column_n), C.float(width))
}

func InternalTableSetColumnWidthAutoAll(table *Table) {
	tableArg, tableFin := table.handle()
	C.igTableSetColumnWidthAutoAll(tableArg)

	tableFin()
}

func InternalTableSetColumnWidthAutoSingle(table *Table, column_n int32) {
	tableArg, tableFin := table.handle()
	C.igTableSetColumnWidthAutoSingle(tableArg, C.int(column_n))

	tableFin()
}

func InternalTableSettingsAddSettingsHandler() {
	C.igTableSettingsAddSettingsHandler()
}

func InternalTableSettingsCreate(id ID, columns_count int32) *TableSettings {
	idArg, idFin := id.c()

	defer func() {
		idFin()
	}()
	return newTableSettingsFromC(C.igTableSettingsCreate(idArg, C.int(columns_count)))
}

func InternalTableSettingsFindByID(id ID) *TableSettings {
	idArg, idFin := id.c()

	defer func() {
		idFin()
	}()
	return newTableSettingsFromC(C.igTableSettingsFindByID(idArg))
}

// TableSetupColumnV parameter default value hint:
// flags: 0
// init_width_or_weight: 0.0f
// user_id: 0
func TableSetupColumnV(label string, flags TableColumnFlags, init_width_or_weight float32, user_id ID) {
	labelArg, labelFin := WrapString(label)
	user_idArg, user_idFin := user_id.c()
	C.igTableSetupColumn(labelArg, C.ImGuiTableColumnFlags(flags), C.float(init_width_or_weight), user_idArg)

	labelFin()
	user_idFin()
}

func InternalTableSetupDrawChannels(table *Table) {
	tableArg, tableFin := table.handle()
	C.igTableSetupDrawChannels(tableArg)

	tableFin()
}

// lock columns/rows so they stay visible when scrolled.
func TableSetupScrollFreeze(cols int32, rows int32) {
	C.igTableSetupScrollFreeze(C.int(cols), C.int(rows))
}

func InternalTableSortSpecsBuild(table *Table) {
	tableArg, tableFin := table.handle()
	C.igTableSortSpecsBuild(tableArg)

	tableFin()
}

func InternalTableSortSpecsSanitize(table *Table) {
	tableArg, tableFin := table.handle()
	C.igTableSortSpecsSanitize(tableArg)

	tableFin()
}

func InternalTableUpdateBorders(table *Table) {
	tableArg, tableFin := table.handle()
	C.igTableUpdateBorders(tableArg)

	tableFin()
}

func InternalTableUpdateColumnsWeightFromWidth(table *Table) {
	tableArg, tableFin := table.handle()
	C.igTableUpdateColumnsWeightFromWidth(tableArg)

	tableFin()
}

func InternalTableUpdateLayout(table *Table) {
	tableArg, tableFin := table.handle()
	C.igTableUpdateLayout(tableArg)

	tableFin()
}

func InternalTeleportMousePos(pos Vec2) {
	C.igTeleportMousePos(pos.toC())
}

func InternalTempInputIsActive(id ID) bool {
	idArg, idFin := id.c()

	defer func() {
		idFin()
	}()
	return C.igTempInputIsActive(idArg) == C.bool(true)
}

// InternalTempInputScalarV parameter default value hint:
// p_clamp_min: NULL
// p_clamp_max: NULL
func InternalTempInputScalarV(bb Rect, id ID, label string, data_type DataType, p_data unsafe.Pointer, format string, p_clamp_min unsafe.Pointer, p_clamp_max unsafe.Pointer) bool {
	idArg, idFin := id.c()
	labelArg, labelFin := WrapString(label)
	p_dataArg, p_dataFin := WrapVoidPtr(p_data)
	formatArg, formatFin := WrapString(format)

	defer func() {
		idFin()
		labelFin()
		p_dataFin()
		formatFin()
	}()
	return C.igTempInputScalar(bb.toC(), idArg, labelArg, C.ImGuiDataType(data_type), p_dataArg, formatArg, (p_clamp_min), (p_clamp_max)) == C.bool(true)
}

func InternalTempInputText(bb Rect, id ID, label string, buf string, buf_size int32, flags InputTextFlags) bool {
	idArg, idFin := id.c()
	labelArg, labelFin := WrapString(label)
	bufArg, bufFin := WrapString(buf)

	defer func() {
		idFin()
		labelFin()
		bufFin()
	}()
	return C.igTempInputText(bb.toC(), idArg, labelArg, bufArg, C.int(buf_size), C.ImGuiInputTextFlags(flags)) == C.bool(true)
}

// Test that key is either not owned, either owned by 'owner_id'
func InternalTestKeyOwner(key Key, owner_id ID) bool {
	owner_idArg, owner_idFin := owner_id.c()

	defer func() {
		owner_idFin()
	}()
	return C.igTestKeyOwner(C.ImGuiKey(key), owner_idArg) == C.bool(true)
}

func InternalTestShortcutRouting(key_chord KeyChord, owner_id ID) bool {
	key_chordArg, key_chordFin := key_chord.c()
	owner_idArg, owner_idFin := owner_id.c()

	defer func() {
		key_chordFin()
		owner_idFin()
	}()
	return C.igTestShortcutRouting(key_chordArg, owner_idArg) == C.bool(true)
}

// formatted text
func Text(fmt string) {
	fmtArg, fmtFin := WrapString(fmt)
	C.wrap_igText(fmtArg)

	fmtFin()
}

// shortcut for PushStyleColor(ImGuiCol_Text, col); Text(fmt, ...); PopStyleColor();
func TextColored(col Vec4, fmt string) {
	fmtArg, fmtFin := WrapString(fmt)
	C.wrap_igTextColored(col.toC(), fmtArg)

	fmtFin()
}

// shortcut for PushStyleColor(ImGuiCol_Text, style.Colors[ImGuiCol_TextDisabled]); Text(fmt, ...); PopStyleColor();
func TextDisabled(fmt string) {
	fmtArg, fmtFin := WrapString(fmt)
	C.wrap_igTextDisabled(fmtArg)

	fmtFin()
}

// InternalTextExV parameter default value hint:
// flags: 0
func InternalTextExV(text string, flags TextFlags) {
	textArg, textFin := WrapString(text)
	C.wrap_igTextExV(textArg, C.ImGuiTextFlags(flags))

	textFin()
}

// raw text without formatting. Roughly equivalent to Text("TextUnformattedV", text) but: A) doesn't require null terminated string if 'text_end' is specified, B) it's faster, no memory copy is done, no buffer size limits, recommended for long chunks of text.
// %s parameter default value hint:
func TextUnformattedV(text string) {
	textArg, textFin := WrapString(text)
	C.wrap_igTextUnformattedV(textArg)

	textFin()
}

// shortcut for PushTextWrapPos(0.0f); Text(fmt, ...); PopTextWrapPos();. Note that this won't work on an auto-resizing window if there's no other widgets to extend the window width, yoy may need to set a size using SetNextWindowSize().
func TextWrapped(fmt string) {
	fmtArg, fmtFin := WrapString(fmt)
	C.wrap_igTextWrapped(fmtArg)

	fmtFin()
}

func InternalTranslateWindowsInViewport(viewport *ViewportP, old_pos Vec2, new_pos Vec2) {
	viewportArg, viewportFin := viewport.handle()
	C.igTranslateWindowsInViewport(viewportArg, old_pos.toC(), new_pos.toC())

	viewportFin()
}

// InternalTreeNodeBehaviorV parameter default value hint:
// label_end: NULL
func InternalTreeNodeBehaviorV(id ID, flags TreeNodeFlags, label string, label_end string) bool {
	idArg, idFin := id.c()
	labelArg, labelFin := WrapString(label)
	label_endArg, label_endFin := WrapString(label_end)

	defer func() {
		idFin()
		labelFin()
		label_endFin()
	}()
	return C.igTreeNodeBehavior(idArg, C.ImGuiTreeNodeFlags(flags), labelArg, label_endArg) == C.bool(true)
}

func TreeNodeExPtr(ptr_id unsafe.Pointer, flags TreeNodeFlags, fmt string) bool {
	fmtArg, fmtFin := WrapString(fmt)

	defer func() {
		fmtFin()
	}()
	return C.wrap_igTreeNodeEx_Ptr((ptr_id), C.ImGuiTreeNodeFlags(flags), fmtArg) == C.bool(true)
}

// TreeNodeExStrV parameter default value hint:
// flags: 0
func TreeNodeExStrV(label string, flags TreeNodeFlags) bool {
	labelArg, labelFin := WrapString(label)

	defer func() {
		labelFin()
	}()
	return C.igTreeNodeEx_Str(labelArg, C.ImGuiTreeNodeFlags(flags)) == C.bool(true)
}

func TreeNodeExStrStr(str_id string, flags TreeNodeFlags, fmt string) bool {
	str_idArg, str_idFin := WrapString(str_id)
	fmtArg, fmtFin := WrapString(fmt)

	defer func() {
		str_idFin()
		fmtFin()
	}()
	return C.wrap_igTreeNodeEx_StrStr(str_idArg, C.ImGuiTreeNodeFlags(flags), fmtArg) == C.bool(true)
}

func InternalTreeNodeSetOpen(id ID, open bool) {
	idArg, idFin := id.c()
	C.igTreeNodeSetOpen(idArg, C.bool(open))

	idFin()
}

// Return open state. Consume previous SetNextItemOpen() data, if any. May return true when logging.
func InternalTreeNodeUpdateNextOpen(id ID, flags TreeNodeFlags) bool {
	idArg, idFin := id.c()

	defer func() {
		idFin()
	}()
	return C.igTreeNodeUpdateNextOpen(idArg, C.ImGuiTreeNodeFlags(flags)) == C.bool(true)
}

// "
func TreeNodePtr(ptr_id unsafe.Pointer, fmt string) bool {
	fmtArg, fmtFin := WrapString(fmt)

	defer func() {
		fmtFin()
	}()
	return C.wrap_igTreeNode_Ptr((ptr_id), fmtArg) == C.bool(true)
}

func TreeNodeStr(label string) bool {
	labelArg, labelFin := WrapString(label)

	defer func() {
		labelFin()
	}()
	return C.igTreeNode_Str(labelArg) == C.bool(true)
}

// helper variation to easily decorelate the id from the displayed string. Read the FAQ about why and how to use ID. to align arbitrary text at the same level as a TreeNode() you can use Bullet().
func TreeNodeStrStr(str_id string, fmt string) bool {
	str_idArg, str_idFin := WrapString(str_id)
	fmtArg, fmtFin := WrapString(fmt)

	defer func() {
		str_idFin()
		fmtFin()
	}()
	return C.wrap_igTreeNode_StrStr(str_idArg, fmtArg) == C.bool(true)
}

// ~ Unindent()+PopId()
func TreePop() {
	C.igTreePop()
}

func InternalTreePushOverrideID(id ID) {
	idArg, idFin := id.c()
	C.igTreePushOverrideID(idArg)

	idFin()
}

// "
func TreePushPtr(ptr_id unsafe.Pointer) {
	C.igTreePush_Ptr((ptr_id))
}

// ~ Indent()+PushId(). Already called by TreeNode() when returning true, but you can call TreePush/TreePop yourself if desired.
func TreePushStr(str_id string) {
	str_idArg, str_idFin := WrapString(str_id)
	C.igTreePush_Str(str_idArg)

	str_idFin()
}

// move content position back to the left, by indent_w, or style.IndentSpacing if indent_w <= 0
// UnindentV parameter default value hint:
// indent_w: 0.0f
func UnindentV(indent_w float32) {
	C.igUnindent(C.float(indent_w))
}

func InternalUpdateHoveredWindowAndCaptureFlags() {
	C.igUpdateHoveredWindowAndCaptureFlags()
}

func InternalUpdateInputEvents(trickle_fast_inputs bool) {
	C.igUpdateInputEvents(C.bool(trickle_fast_inputs))
}

func InternalUpdateMouseMovingWindowEndFrame() {
	C.igUpdateMouseMovingWindowEndFrame()
}

func InternalUpdateMouseMovingWindowNewFrame() {
	C.igUpdateMouseMovingWindowNewFrame()
}

// call in main loop. will call CreateWindow/ResizeWindow/etc. platform functions for each secondary viewport, and DestroyWindow for each inactive viewport.
func UpdatePlatformWindows() {
	C.igUpdatePlatformWindows()
}

func InternalUpdateWindowParentAndRootLinks(window *Window, flags WindowFlags, parent_window *Window) {
	windowArg, windowFin := window.handle()
	parent_windowArg, parent_windowFin := parent_window.handle()
	C.igUpdateWindowParentAndRootLinks(windowArg, C.ImGuiWindowFlags(flags), parent_windowArg)

	windowFin()
	parent_windowFin()
}

// VSliderFloatV parameter default value hint:
// format: "%.3f"
// flags: 0
func VSliderFloatV(label string, size Vec2, v *float32, v_min float32, v_max float32, format string, flags SliderFlags) bool {
	labelArg, labelFin := WrapString(label)
	vArg, vFin := WrapNumberPtr[C.float, float32](v)
	formatArg, formatFin := WrapString(format)

	defer func() {
		labelFin()
		vFin()
		formatFin()
	}()
	return C.igVSliderFloat(labelArg, size.toC(), vArg, C.float(v_min), C.float(v_max), formatArg, C.ImGuiSliderFlags(flags)) == C.bool(true)
}

// VSliderIntV parameter default value hint:
// format: "%d"
// flags: 0
func VSliderIntV(label string, size Vec2, v *int32, v_min int32, v_max int32, format string, flags SliderFlags) bool {
	labelArg, labelFin := WrapString(label)
	vArg, vFin := WrapNumberPtr[C.int, int32](v)
	formatArg, formatFin := WrapString(format)

	defer func() {
		labelFin()
		vFin()
		formatFin()
	}()
	return C.igVSliderInt(labelArg, size.toC(), vArg, C.int(v_min), C.int(v_max), formatArg, C.ImGuiSliderFlags(flags)) == C.bool(true)
}

// VSliderScalarV parameter default value hint:
// format: NULL
// flags: 0
func VSliderScalarV(label string, size Vec2, data_type DataType, p_data unsafe.Pointer, p_min unsafe.Pointer, p_max unsafe.Pointer, format string, flags SliderFlags) bool {
	labelArg, labelFin := WrapString(label)
	p_dataArg, p_dataFin := WrapVoidPtr(p_data)
	formatArg, formatFin := WrapString(format)

	defer func() {
		labelFin()
		p_dataFin()
		formatFin()
	}()
	return C.igVSliderScalar(labelArg, size.toC(), C.ImGuiDataType(data_type), p_dataArg, (p_min), (p_max), formatArg, C.ImGuiSliderFlags(flags)) == C.bool(true)
}

func ValueBool(prefix string, b bool) {
	prefixArg, prefixFin := WrapString(prefix)
	C.igValue_Bool(prefixArg, C.bool(b))

	prefixFin()
}

// ValueFloatV parameter default value hint:
// float_format: NULL
func ValueFloatV(prefix string, v float32, float_format string) {
	prefixArg, prefixFin := WrapString(prefix)
	float_formatArg, float_formatFin := WrapString(float_format)
	C.igValue_Float(prefixArg, C.float(v), float_formatArg)

	prefixFin()
	float_formatFin()
}

func ValueInt(prefix string, v int32) {
	prefixArg, prefixFin := WrapString(prefix)
	C.igValue_Int(prefixArg, C.int(v))

	prefixFin()
}

func ValueUint(prefix string, v uint32) {
	prefixArg, prefixFin := WrapString(prefix)
	C.igValue_Uint(prefixArg, C.uint(v))

	prefixFin()
}

func InternalWindowPosRelToAbs(window *Window, p Vec2) Vec2 {
	pOut := new(Vec2)
	pOutArg, pOutFin := wrap[C.ImVec2, *Vec2](pOut)

	windowArg, windowFin := window.handle()
	C.igWindowPosRelToAbs(pOutArg, windowArg, p.toC())

	pOutFin()
	windowFin()

	return *pOut
}

func InternalWindowRectAbsToRel(window *Window, r Rect) Rect {
	pOut := new(Rect)
	pOutArg, pOutFin := wrap[C.ImRect, *Rect](pOut)

	windowArg, windowFin := window.handle()
	C.igWindowRectAbsToRel(pOutArg, windowArg, r.toC())

	pOutFin()
	windowFin()

	return *pOut
}

func InternalWindowRectRelToAbs(window *Window, r Rect) Rect {
	pOut := new(Rect)
	pOutArg, pOutFin := wrap[C.ImRect, *Rect](pOut)

	windowArg, windowFin := window.handle()
	C.igWindowRectRelToAbs(pOutArg, windowArg, r.toC())

	pOutFin()
	windowFin()

	return *pOut
}

func ColorHSV(h float32, s float32, v float32) Color {
	pOut := new(Color)
	pOutArg, pOutFin := wrap[C.ImColor, *Color](pOut)

	C.wrap_ImColor_HSV(pOutArg, C.float(h), C.float(s), C.float(v))

	pOutFin()

	return *pOut
}

func (self *Color) SetHSV(h float32, s float32, v float32) {
	selfArg, selfFin := wrap[C.ImColor, *Color](self)
	C.wrap_ImColor_SetHSV(selfArg, C.float(h), C.float(s), C.float(v))

	selfFin()
}

func (self *DrawList) AddBezierCubic(p1 Vec2, p2 Vec2, p3 Vec2, p4 Vec2, col uint32, thickness float32) {
	selfArg, selfFin := self.handle()
	C.wrap_ImDrawList_AddBezierCubic(selfArg, p1.toC(), p2.toC(), p3.toC(), p4.toC(), C.ImU32(col), C.float(thickness))

	selfFin()
}

func (self *DrawList) AddBezierQuadratic(p1 Vec2, p2 Vec2, p3 Vec2, col uint32, thickness float32) {
	selfArg, selfFin := self.handle()
	C.wrap_ImDrawList_AddBezierQuadratic(selfArg, p1.toC(), p2.toC(), p3.toC(), C.ImU32(col), C.float(thickness))

	selfFin()
}

func (self *DrawList) AddCircle(center Vec2, radius float32, col uint32) {
	selfArg, selfFin := self.handle()
	C.wrap_ImDrawList_AddCircle(selfArg, center.toC(), C.float(radius), C.ImU32(col))

	selfFin()
}

func (self *DrawList) AddCircleFilled(center Vec2, radius float32, col uint32) {
	selfArg, selfFin := self.handle()
	C.wrap_ImDrawList_AddCircleFilled(selfArg, center.toC(), C.float(radius), C.ImU32(col))

	selfFin()
}

func (self *DrawList) AddEllipse(center Vec2, radius_x float32, radius_y float32, col uint32) {
	selfArg, selfFin := self.handle()
	C.wrap_ImDrawList_AddEllipse(selfArg, center.toC(), C.float(radius_x), C.float(radius_y), C.ImU32(col))

	selfFin()
}

func (self *DrawList) AddEllipseFilled(center Vec2, radius_x float32, radius_y float32, col uint32) {
	selfArg, selfFin := self.handle()
	C.wrap_ImDrawList_AddEllipseFilled(selfArg, center.toC(), C.float(radius_x), C.float(radius_y), C.ImU32(col))

	selfFin()
}

func (self *DrawList) AddImage(user_texture_id TextureID, p_min Vec2, p_max Vec2) {
	selfArg, selfFin := self.handle()
	user_texture_idArg, user_texture_idFin := user_texture_id.c()
	C.wrap_ImDrawList_AddImage(selfArg, user_texture_idArg, p_min.toC(), p_max.toC())

	selfFin()
	user_texture_idFin()
}

func (self *DrawList) AddImageQuad(user_texture_id TextureID, p1 Vec2, p2 Vec2, p3 Vec2, p4 Vec2) {
	selfArg, selfFin := self.handle()
	user_texture_idArg, user_texture_idFin := user_texture_id.c()
	C.wrap_ImDrawList_AddImageQuad(selfArg, user_texture_idArg, p1.toC(), p2.toC(), p3.toC(), p4.toC())

	selfFin()
	user_texture_idFin()
}

func (self *DrawList) AddImageRounded(user_texture_id TextureID, p_min Vec2, p_max Vec2, uv_min Vec2, uv_max Vec2, col uint32, rounding float32) {
	selfArg, selfFin := self.handle()
	user_texture_idArg, user_texture_idFin := user_texture_id.c()
	C.wrap_ImDrawList_AddImageRounded(selfArg, user_texture_idArg, p_min.toC(), p_max.toC(), uv_min.toC(), uv_max.toC(), C.ImU32(col), C.float(rounding))

	selfFin()
	user_texture_idFin()
}

func (self *DrawList) AddLine(p1 Vec2, p2 Vec2, col uint32) {
	selfArg, selfFin := self.handle()
	C.wrap_ImDrawList_AddLine(selfArg, p1.toC(), p2.toC(), C.ImU32(col))

	selfFin()
}

func (self *DrawList) AddNgon(center Vec2, radius float32, col uint32, num_segments int32) {
	selfArg, selfFin := self.handle()
	C.wrap_ImDrawList_AddNgon(selfArg, center.toC(), C.float(radius), C.ImU32(col), C.int(num_segments))

	selfFin()
}

func (self *DrawList) AddQuad(p1 Vec2, p2 Vec2, p3 Vec2, p4 Vec2, col uint32) {
	selfArg, selfFin := self.handle()
	C.wrap_ImDrawList_AddQuad(selfArg, p1.toC(), p2.toC(), p3.toC(), p4.toC(), C.ImU32(col))

	selfFin()
}

func (self *DrawList) AddRect(p_min Vec2, p_max Vec2, col uint32) {
	selfArg, selfFin := self.handle()
	C.wrap_ImDrawList_AddRect(selfArg, p_min.toC(), p_max.toC(), C.ImU32(col))

	selfFin()
}

func (self *DrawList) AddRectFilled(p_min Vec2, p_max Vec2, col uint32) {
	selfArg, selfFin := self.handle()
	C.wrap_ImDrawList_AddRectFilled(selfArg, p_min.toC(), p_max.toC(), C.ImU32(col))

	selfFin()
}

func (self *DrawList) AddTextFontPtr(font *Font, font_size float32, pos Vec2, col uint32, text_begin string) {
	selfArg, selfFin := self.handle()
	fontArg, fontFin := font.handle()
	text_beginArg, text_beginFin := WrapString(text_begin)
	C.wrap_ImDrawList_AddText_FontPtr(selfArg, fontArg, C.float(font_size), pos.toC(), C.ImU32(col), text_beginArg)

	selfFin()
	fontFin()
	text_beginFin()
}

func (self *DrawList) AddTextVec2(pos Vec2, col uint32, text_begin string) {
	selfArg, selfFin := self.handle()
	text_beginArg, text_beginFin := WrapString(text_begin)
	C.wrap_ImDrawList_AddText_Vec2(selfArg, pos.toC(), C.ImU32(col), text_beginArg)

	selfFin()
	text_beginFin()
}

func (self *DrawList) AddTriangle(p1 Vec2, p2 Vec2, p3 Vec2, col uint32) {
	selfArg, selfFin := self.handle()
	C.wrap_ImDrawList_AddTriangle(selfArg, p1.toC(), p2.toC(), p3.toC(), C.ImU32(col))

	selfFin()
}

func (self *DrawList) PathArcTo(center Vec2, radius float32, a_min float32, a_max float32) {
	selfArg, selfFin := self.handle()
	C.wrap_ImDrawList_PathArcTo(selfArg, center.toC(), C.float(radius), C.float(a_min), C.float(a_max))

	selfFin()
}

func (self *DrawList) PathBezierCubicCurveTo(p2 Vec2, p3 Vec2, p4 Vec2) {
	selfArg, selfFin := self.handle()
	C.wrap_ImDrawList_PathBezierCubicCurveTo(selfArg, p2.toC(), p3.toC(), p4.toC())

	selfFin()
}

func (self *DrawList) PathBezierQuadraticCurveTo(p2 Vec2, p3 Vec2) {
	selfArg, selfFin := self.handle()
	C.wrap_ImDrawList_PathBezierQuadraticCurveTo(selfArg, p2.toC(), p3.toC())

	selfFin()
}

func (self *DrawList) PathEllipticalArcTo(center Vec2, radius_x float32, radius_y float32, rot float32, a_min float32, a_max float32) {
	selfArg, selfFin := self.handle()
	C.wrap_ImDrawList_PathEllipticalArcTo(selfArg, center.toC(), C.float(radius_x), C.float(radius_y), C.float(rot), C.float(a_min), C.float(a_max))

	selfFin()
}

func (self *DrawList) PathRect(rect_min Vec2, rect_max Vec2) {
	selfArg, selfFin := self.handle()
	C.wrap_ImDrawList_PathRect(selfArg, rect_min.toC(), rect_max.toC())

	selfFin()
}

func (self *DrawList) PathStroke(col uint32) {
	selfArg, selfFin := self.handle()
	C.wrap_ImDrawList_PathStroke(selfArg, C.ImU32(col))

	selfFin()
}

func (self *DrawList) PushClipRect(clip_rect_min Vec2, clip_rect_max Vec2) {
	selfArg, selfFin := self.handle()
	C.wrap_ImDrawList_PushClipRect(selfArg, clip_rect_min.toC(), clip_rect_max.toC())

	selfFin()
}

func (self *FontAtlas) AddCustomRectFontGlyph(font *Font, id Wchar, width int32, height int32, advance_x float32) int32 {
	selfArg, selfFin := self.handle()
	fontArg, fontFin := font.handle()

	defer func() {
		selfFin()
		fontFin()
	}()
	return int32(C.wrap_ImFontAtlas_AddCustomRectFontGlyph(selfArg, fontArg, C.ImWchar(id), C.int(width), C.int(height), C.float(advance_x)))
}

func (self *FontAtlas) AddFontDefault() *Font {
	selfArg, selfFin := self.handle()

	defer func() {
		selfFin()
	}()
	return newFontFromC(C.wrap_ImFontAtlas_AddFontDefault(selfArg))
}

func (self *FontAtlas) AddFontFromFileTTF(filename string, size_pixels float32) *Font {
	selfArg, selfFin := self.handle()
	filenameArg, filenameFin := WrapString(filename)

	defer func() {
		selfFin()
		filenameFin()
	}()
	return newFontFromC(C.wrap_ImFontAtlas_AddFontFromFileTTF(selfArg, filenameArg, C.float(size_pixels)))
}

func (self *FontAtlas) AddFontFromMemoryCompressedBase85TTF(compressed_font_data_base85 string, size_pixels float32) *Font {
	selfArg, selfFin := self.handle()
	compressed_font_data_base85Arg, compressed_font_data_base85Fin := WrapString(compressed_font_data_base85)

	defer func() {
		selfFin()
		compressed_font_data_base85Fin()
	}()
	return newFontFromC(C.wrap_ImFontAtlas_AddFontFromMemoryCompressedBase85TTF(selfArg, compressed_font_data_base85Arg, C.float(size_pixels)))
}

func (self *FontAtlas) AddFontFromMemoryCompressedTTF(compressed_font_data unsafe.Pointer, compressed_font_data_size int32, size_pixels float32) *Font {
	selfArg, selfFin := self.handle()

	defer func() {
		selfFin()
	}()
	return newFontFromC(C.wrap_ImFontAtlas_AddFontFromMemoryCompressedTTF(selfArg, (compressed_font_data), C.int(compressed_font_data_size), C.float(size_pixels)))
}

func (self *FontAtlas) AddFontFromMemoryTTF(font_data unsafe.Pointer, font_data_size int32, size_pixels float32) *Font {
	selfArg, selfFin := self.handle()
	font_dataArg, font_dataFin := WrapVoidPtr(font_data)

	defer func() {
		selfFin()
		font_dataFin()
	}()
	return newFontFromC(C.wrap_ImFontAtlas_AddFontFromMemoryTTF(selfArg, font_dataArg, C.int(font_data_size), C.float(size_pixels)))
}

func (self *FontGlyphRangesBuilder) AddText(text string) {
	selfArg, selfFin := self.handle()
	textArg, textFin := WrapString(text)
	C.wrap_ImFontGlyphRangesBuilder_AddText(selfArg, textArg)

	selfFin()
	textFin()
}

func (self *Font) AddRemapChar(dst Wchar, src Wchar) {
	selfArg, selfFin := self.handle()
	C.wrap_ImFont_AddRemapChar(selfArg, C.ImWchar(dst), C.ImWchar(src))

	selfFin()
}

func (self *Font) CalcTextSizeA(size float32, max_width float32, wrap_width float32, text_begin string) Vec2 {
	pOut := new(Vec2)
	pOutArg, pOutFin := wrap[C.ImVec2, *Vec2](pOut)

	selfArg, selfFin := self.handle()
	text_beginArg, text_beginFin := WrapString(text_begin)
	C.wrap_ImFont_CalcTextSizeA(pOutArg, selfArg, C.float(size), C.float(max_width), C.float(wrap_width), text_beginArg)

	pOutFin()
	selfFin()
	text_beginFin()

	return *pOut
}

func (self *Font) RenderText(draw_list *DrawList, size float32, pos Vec2, col uint32, clip_rect Vec4, text_begin string) {
	selfArg, selfFin := self.handle()
	draw_listArg, draw_listFin := draw_list.handle()
	text_beginArg, text_beginFin := WrapString(text_begin)
	C.wrap_ImFont_RenderText(selfArg, draw_listArg, C.float(size), pos.toC(), C.ImU32(col), clip_rect.toC(), text_beginArg)

	selfFin()
	draw_listFin()
	text_beginFin()
}

func (self *IO) SetKeyEventNativeData(key Key, native_keycode int32, native_scancode int32) {
	selfArg, selfFin := self.handle()
	C.wrap_ImGuiIO_SetKeyEventNativeData(selfArg, C.ImGuiKey(key), C.int(native_keycode), C.int(native_scancode))

	selfFin()
}

func (self *InputTextCallbackData) InsertChars(pos int32, text string) {
	selfArg, selfFin := self.handle()
	textArg, textFin := WrapString(text)
	C.wrap_ImGuiInputTextCallbackData_InsertChars(selfArg, C.int(pos), textArg)

	selfFin()
	textFin()
}

func (self *ListClipper) Begin(items_count int32) {
	selfArg, selfFin := self.handle()
	C.wrap_ImGuiListClipper_Begin(selfArg, C.int(items_count))

	selfFin()
}

func (self *Storage) Bool(key ID) bool {
	selfArg, selfFin := self.handle()
	keyArg, keyFin := key.c()

	defer func() {
		selfFin()
		keyFin()
	}()
	return C.wrap_ImGuiStorage_GetBool(selfArg, keyArg) == C.bool(true)
}

func (self *Storage) Float(key ID) float32 {
	selfArg, selfFin := self.handle()
	keyArg, keyFin := key.c()

	defer func() {
		selfFin()
		keyFin()
	}()
	return float32(C.wrap_ImGuiStorage_GetFloat(selfArg, keyArg))
}

func (self *Storage) FloatRef(key ID) *float32 {
	selfArg, selfFin := self.handle()
	keyArg, keyFin := key.c()

	defer func() {
		selfFin()
		keyFin()
	}()
	return (*float32)(C.wrap_ImGuiStorage_GetFloatRef(selfArg, keyArg))
}

func (self *Storage) Int(key ID) int32 {
	selfArg, selfFin := self.handle()
	keyArg, keyFin := key.c()

	defer func() {
		selfFin()
		keyFin()
	}()
	return int32(C.wrap_ImGuiStorage_GetInt(selfArg, keyArg))
}

func (self *Storage) IntRef(key ID) *int32 {
	selfArg, selfFin := self.handle()
	keyArg, keyFin := key.c()

	defer func() {
		selfFin()
		keyFin()
	}()
	return (*int32)(C.wrap_ImGuiStorage_GetIntRef(selfArg, keyArg))
}

func (self *TextBuffer) Append(str string) {
	selfArg, selfFin := self.handle()
	strArg, strFin := WrapString(str)
	C.wrap_ImGuiTextBuffer_Append(selfArg, strArg)

	selfFin()
	strFin()
}

func (self *TextFilter) Draw() bool {
	selfArg, selfFin := self.handle()

	defer func() {
		selfFin()
	}()
	return C.wrap_ImGuiTextFilter_Draw(selfArg) == C.bool(true)
}

func (self *TextFilter) PassFilter(text string) bool {
	selfArg, selfFin := self.handle()
	textArg, textFin := WrapString(text)

	defer func() {
		selfFin()
		textFin()
	}()
	return C.wrap_ImGuiTextFilter_PassFilter(selfArg, textArg) == C.bool(true)
}

func (self *Window) InternalIDStr(str string) ID {
	selfArg, selfFin := self.handle()
	strArg, strFin := WrapString(str)

	defer func() {
		selfFin()
		strFin()
	}()
	return *newIDFromC(func() *C.ImGuiID { result := C.wrap_ImGuiWindow_GetID_Str(selfArg, strArg); return &result }())
}

func AcceptDragDropPayload(typeArg string) *Payload {
	typeArgArg, typeArgFin := WrapString(typeArg)

	defer func() {
		typeArgFin()
	}()
	return newPayloadFromC(C.wrap_igAcceptDragDropPayload(typeArgArg))
}

func InternalArrowButtonEx(str_id string, dir Dir, size_arg Vec2) bool {
	str_idArg, str_idFin := WrapString(str_id)

	defer func() {
		str_idFin()
	}()
	return C.wrap_igArrowButtonEx(str_idArg, C.ImGuiDir(dir), size_arg.toC()) == C.bool(true)
}

func Begin(name string) bool {
	nameArg, nameFin := WrapString(name)

	defer func() {
		nameFin()
	}()
	return C.wrap_igBegin(nameArg) == C.bool(true)
}

func BeginChildFrame(id ID, size Vec2) bool {
	idArg, idFin := id.c()

	defer func() {
		idFin()
	}()
	return C.wrap_igBeginChildFrame(idArg, size.toC()) == C.bool(true)
}

func BeginChildID(id ID) bool {
	idArg, idFin := id.c()

	defer func() {
		idFin()
	}()
	return C.wrap_igBeginChild_ID(idArg) == C.bool(true)
}

func BeginChildStr(str_id string) bool {
	str_idArg, str_idFin := WrapString(str_id)

	defer func() {
		str_idFin()
	}()
	return C.wrap_igBeginChild_Str(str_idArg) == C.bool(true)
}

func InternalBeginColumns(str_id string, count int32) {
	str_idArg, str_idFin := WrapString(str_id)
	C.wrap_igBeginColumns(str_idArg, C.int(count))

	str_idFin()
}

func BeginCombo(label string, preview_value string) bool {
	labelArg, labelFin := WrapString(label)
	preview_valueArg, preview_valueFin := WrapString(preview_value)

	defer func() {
		labelFin()
		preview_valueFin()
	}()
	return C.wrap_igBeginCombo(labelArg, preview_valueArg) == C.bool(true)
}

func BeginDisabled() {
	C.wrap_igBeginDisabled()
}

func BeginDragDropSource() bool {
	return C.wrap_igBeginDragDropSource() == C.bool(true)
}

func BeginListBox(label string) bool {
	labelArg, labelFin := WrapString(label)

	defer func() {
		labelFin()
	}()
	return C.wrap_igBeginListBox(labelArg) == C.bool(true)
}

func BeginMenu(label string) bool {
	labelArg, labelFin := WrapString(label)

	defer func() {
		labelFin()
	}()
	return C.wrap_igBeginMenu(labelArg) == C.bool(true)
}

func InternalBeginMenuEx(label string, icon string) bool {
	labelArg, labelFin := WrapString(label)
	iconArg, iconFin := WrapString(icon)

	defer func() {
		labelFin()
		iconFin()
	}()
	return C.wrap_igBeginMenuEx(labelArg, iconArg) == C.bool(true)
}

func BeginPopup(str_id string) bool {
	str_idArg, str_idFin := WrapString(str_id)

	defer func() {
		str_idFin()
	}()
	return C.wrap_igBeginPopup(str_idArg) == C.bool(true)
}

func BeginPopupContextItem() bool {
	return C.wrap_igBeginPopupContextItem() == C.bool(true)
}

func BeginPopupContextVoid() bool {
	return C.wrap_igBeginPopupContextVoid() == C.bool(true)
}

func BeginPopupContextWindow() bool {
	return C.wrap_igBeginPopupContextWindow() == C.bool(true)
}

func BeginPopupModal(name string) bool {
	nameArg, nameFin := WrapString(name)

	defer func() {
		nameFin()
	}()
	return C.wrap_igBeginPopupModal(nameArg) == C.bool(true)
}

func BeginTabBar(str_id string) bool {
	str_idArg, str_idFin := WrapString(str_id)

	defer func() {
		str_idFin()
	}()
	return C.wrap_igBeginTabBar(str_idArg) == C.bool(true)
}

func BeginTabItem(label string) bool {
	labelArg, labelFin := WrapString(label)

	defer func() {
		labelFin()
	}()
	return C.wrap_igBeginTabItem(labelArg) == C.bool(true)
}

func BeginTable(str_id string, column int32) bool {
	str_idArg, str_idFin := WrapString(str_id)

	defer func() {
		str_idFin()
	}()
	return C.wrap_igBeginTable(str_idArg, C.int(column)) == C.bool(true)
}

func InternalBeginTableEx(name string, id ID, columns_count int32) bool {
	nameArg, nameFin := WrapString(name)
	idArg, idFin := id.c()

	defer func() {
		nameFin()
		idFin()
	}()
	return C.wrap_igBeginTableEx(nameArg, idArg, C.int(columns_count)) == C.bool(true)
}

func Button(label string) bool {
	labelArg, labelFin := WrapString(label)

	defer func() {
		labelFin()
	}()
	return C.wrap_igButton(labelArg) == C.bool(true)
}

func InternalButtonBehavior(bb Rect, id ID, out_hovered *bool, out_held *bool) bool {
	idArg, idFin := id.c()
	out_hoveredArg, out_hoveredFin := WrapBool(out_hovered)
	out_heldArg, out_heldFin := WrapBool(out_held)

	defer func() {
		idFin()
		out_hoveredFin()
		out_heldFin()
	}()
	return C.wrap_igButtonBehavior(bb.toC(), idArg, out_hoveredArg, out_heldArg) == C.bool(true)
}

func InternalButtonEx(label string) bool {
	labelArg, labelFin := WrapString(label)

	defer func() {
		labelFin()
	}()
	return C.wrap_igButtonEx(labelArg) == C.bool(true)
}

func CalcTextSize(text string) Vec2 {
	pOut := new(Vec2)
	pOutArg, pOutFin := wrap[C.ImVec2, *Vec2](pOut)

	textArg, textFin := WrapString(text)
	C.wrap_igCalcTextSize(pOutArg, textArg)

	pOutFin()
	textFin()

	return *pOut
}

func CollapsingHeaderBoolPtr(label string, p_visible *bool) bool {
	labelArg, labelFin := WrapString(label)
	p_visibleArg, p_visibleFin := WrapBool(p_visible)

	defer func() {
		labelFin()
		p_visibleFin()
	}()
	return C.wrap_igCollapsingHeader_BoolPtr(labelArg, p_visibleArg) == C.bool(true)
}

func CollapsingHeaderTreeNodeFlags(label string) bool {
	labelArg, labelFin := WrapString(label)

	defer func() {
		labelFin()
	}()
	return C.wrap_igCollapsingHeader_TreeNodeFlags(labelArg) == C.bool(true)
}

func ColorButton(desc_id string, col Vec4) bool {
	desc_idArg, desc_idFin := WrapString(desc_id)

	defer func() {
		desc_idFin()
	}()
	return C.wrap_igColorButton(desc_idArg, col.toC()) == C.bool(true)
}

func ColorEdit3(label string, col *[3]float32) bool {
	labelArg, labelFin := WrapString(label)

	colArg := make([]C.float, len(col))
	for i, colV := range col {
		colArg[i] = C.float(colV)
	}

	defer func() {
		labelFin()

		for i, colV := range colArg {
			(*col)[i] = float32(colV)
		}
	}()
	return C.wrap_igColorEdit3(labelArg, (*C.float)(&colArg[0])) == C.bool(true)
}

func ColorEdit4(label string, col *[4]float32) bool {
	labelArg, labelFin := WrapString(label)

	colArg := make([]C.float, len(col))
	for i, colV := range col {
		colArg[i] = C.float(colV)
	}

	defer func() {
		labelFin()

		for i, colV := range colArg {
			(*col)[i] = float32(colV)
		}
	}()
	return C.wrap_igColorEdit4(labelArg, (*C.float)(&colArg[0])) == C.bool(true)
}

func ColorPicker3(label string, col *[3]float32) bool {
	labelArg, labelFin := WrapString(label)

	colArg := make([]C.float, len(col))
	for i, colV := range col {
		colArg[i] = C.float(colV)
	}

	defer func() {
		labelFin()

		for i, colV := range colArg {
			(*col)[i] = float32(colV)
		}
	}()
	return C.wrap_igColorPicker3(labelArg, (*C.float)(&colArg[0])) == C.bool(true)
}

func ColorPicker4(label string, col *[4]float32) bool {
	labelArg, labelFin := WrapString(label)

	colArg := make([]C.float, len(col))
	for i, colV := range col {
		colArg[i] = C.float(colV)
	}

	defer func() {
		labelFin()

		for i, colV := range colArg {
			(*col)[i] = float32(colV)
		}
	}()
	return C.wrap_igColorPicker4(labelArg, (*C.float)(&colArg[0])) == C.bool(true)
}

func Columns() {
	C.wrap_igColumns()
}

func ComboStr(label string, current_item *int32, items_separated_by_zeros string) bool {
	labelArg, labelFin := WrapString(label)
	current_itemArg, current_itemFin := WrapNumberPtr[C.int, int32](current_item)
	items_separated_by_zerosArg, items_separated_by_zerosFin := WrapString(items_separated_by_zeros)

	defer func() {
		labelFin()
		current_itemFin()
		items_separated_by_zerosFin()
	}()
	return C.wrap_igCombo_Str(labelArg, current_itemArg, items_separated_by_zerosArg) == C.bool(true)
}

func ComboStrarr(label string, current_item *int32, items []string, items_count int32) bool {
	labelArg, labelFin := WrapString(label)
	current_itemArg, current_itemFin := WrapNumberPtr[C.int, int32](current_item)
	itemsArg, itemsFin := WrapStringList(items)

	defer func() {
		labelFin()
		current_itemFin()
		itemsFin()
	}()
	return C.wrap_igCombo_Str_arr(labelArg, current_itemArg, itemsArg, C.int(items_count)) == C.bool(true)
}

func CreateContext() *Context {
	return newContextFromC(C.wrap_igCreateContext())
}

func InternalDebugDrawCursorPos() {
	C.wrap_igDebugDrawCursorPos()
}

func InternalDebugDrawItemRect() {
	C.wrap_igDebugDrawItemRect()
}

func InternalDebugDrawLineExtents() {
	C.wrap_igDebugDrawLineExtents()
}

func DestroyContext() {
	C.wrap_igDestroyContext()
}

func InternalDockBuilderAddNode() ID {
	return *newIDFromC(func() *C.ImGuiID { result := C.wrap_igDockBuilderAddNode(); return &result }())
}

func InternalDockBuilderRemoveNodeDockedWindows(node_id ID) {
	node_idArg, node_idFin := node_id.c()
	C.wrap_igDockBuilderRemoveNodeDockedWindows(node_idArg)

	node_idFin()
}

func InternalDockContextProcessUndockWindow(ctx *Context, window *Window) {
	ctxArg, ctxFin := ctx.handle()
	windowArg, windowFin := window.handle()
	C.wrap_igDockContextProcessUndockWindow(ctxArg, windowArg)

	ctxFin()
	windowFin()
}

func DockSpace(id ID) ID {
	idArg, idFin := id.c()

	defer func() {
		idFin()
	}()
	return *newIDFromC(func() *C.ImGuiID { result := C.wrap_igDockSpace(idArg); return &result }())
}

func DockSpaceOverViewport() ID {
	return *newIDFromC(func() *C.ImGuiID { result := C.wrap_igDockSpaceOverViewport(); return &result }())
}

func DragFloat(label string, v *float32) bool {
	labelArg, labelFin := WrapString(label)
	vArg, vFin := WrapNumberPtr[C.float, float32](v)

	defer func() {
		labelFin()
		vFin()
	}()
	return C.wrap_igDragFloat(labelArg, vArg) == C.bool(true)
}

func DragFloat2(label string, v *[2]float32) bool {
	labelArg, labelFin := WrapString(label)

	vArg := make([]C.float, len(v))
	for i, vV := range v {
		vArg[i] = C.float(vV)
	}

	defer func() {
		labelFin()

		for i, vV := range vArg {
			(*v)[i] = float32(vV)
		}
	}()
	return C.wrap_igDragFloat2(labelArg, (*C.float)(&vArg[0])) == C.bool(true)
}

func DragFloat3(label string, v *[3]float32) bool {
	labelArg, labelFin := WrapString(label)

	vArg := make([]C.float, len(v))
	for i, vV := range v {
		vArg[i] = C.float(vV)
	}

	defer func() {
		labelFin()

		for i, vV := range vArg {
			(*v)[i] = float32(vV)
		}
	}()
	return C.wrap_igDragFloat3(labelArg, (*C.float)(&vArg[0])) == C.bool(true)
}

func DragFloat4(label string, v *[4]float32) bool {
	labelArg, labelFin := WrapString(label)

	vArg := make([]C.float, len(v))
	for i, vV := range v {
		vArg[i] = C.float(vV)
	}

	defer func() {
		labelFin()

		for i, vV := range vArg {
			(*v)[i] = float32(vV)
		}
	}()
	return C.wrap_igDragFloat4(labelArg, (*C.float)(&vArg[0])) == C.bool(true)
}

func DragFloatRange2(label string, v_current_min *float32, v_current_max *float32) bool {
	labelArg, labelFin := WrapString(label)
	v_current_minArg, v_current_minFin := WrapNumberPtr[C.float, float32](v_current_min)
	v_current_maxArg, v_current_maxFin := WrapNumberPtr[C.float, float32](v_current_max)

	defer func() {
		labelFin()
		v_current_minFin()
		v_current_maxFin()
	}()
	return C.wrap_igDragFloatRange2(labelArg, v_current_minArg, v_current_maxArg) == C.bool(true)
}

func DragInt(label string, v *int32) bool {
	labelArg, labelFin := WrapString(label)
	vArg, vFin := WrapNumberPtr[C.int, int32](v)

	defer func() {
		labelFin()
		vFin()
	}()
	return C.wrap_igDragInt(labelArg, vArg) == C.bool(true)
}

func DragInt2(label string, v *[2]int32) bool {
	labelArg, labelFin := WrapString(label)

	vArg := make([]C.int, len(v))
	for i, vV := range v {
		vArg[i] = C.int(vV)
	}

	defer func() {
		labelFin()

		for i, vV := range vArg {
			(*v)[i] = int32(vV)
		}
	}()
	return C.wrap_igDragInt2(labelArg, (*C.int)(&vArg[0])) == C.bool(true)
}

func DragInt3(label string, v *[3]int32) bool {
	labelArg, labelFin := WrapString(label)

	vArg := make([]C.int, len(v))
	for i, vV := range v {
		vArg[i] = C.int(vV)
	}

	defer func() {
		labelFin()

		for i, vV := range vArg {
			(*v)[i] = int32(vV)
		}
	}()
	return C.wrap_igDragInt3(labelArg, (*C.int)(&vArg[0])) == C.bool(true)
}

func DragInt4(label string, v *[4]int32) bool {
	labelArg, labelFin := WrapString(label)

	vArg := make([]C.int, len(v))
	for i, vV := range v {
		vArg[i] = C.int(vV)
	}

	defer func() {
		labelFin()

		for i, vV := range vArg {
			(*v)[i] = int32(vV)
		}
	}()
	return C.wrap_igDragInt4(labelArg, (*C.int)(&vArg[0])) == C.bool(true)
}

func DragIntRange2(label string, v_current_min *int32, v_current_max *int32) bool {
	labelArg, labelFin := WrapString(label)
	v_current_minArg, v_current_minFin := WrapNumberPtr[C.int, int32](v_current_min)
	v_current_maxArg, v_current_maxFin := WrapNumberPtr[C.int, int32](v_current_max)

	defer func() {
		labelFin()
		v_current_minFin()
		v_current_maxFin()
	}()
	return C.wrap_igDragIntRange2(labelArg, v_current_minArg, v_current_maxArg) == C.bool(true)
}

func DragScalar(label string, data_type DataType, p_data unsafe.Pointer) bool {
	labelArg, labelFin := WrapString(label)
	p_dataArg, p_dataFin := WrapVoidPtr(p_data)

	defer func() {
		labelFin()
		p_dataFin()
	}()
	return C.wrap_igDragScalar(labelArg, C.ImGuiDataType(data_type), p_dataArg) == C.bool(true)
}

func DragScalarN(label string, data_type DataType, p_data unsafe.Pointer, components int32) bool {
	labelArg, labelFin := WrapString(label)
	p_dataArg, p_dataFin := WrapVoidPtr(p_data)

	defer func() {
		labelFin()
		p_dataFin()
	}()
	return C.wrap_igDragScalarN(labelArg, C.ImGuiDataType(data_type), p_dataArg, C.int(components)) == C.bool(true)
}

func InternalFindRenderedTextEnd(text string) string {
	textArg, textFin := WrapString(text)

	defer func() {
		textFin()
	}()
	return C.GoString(C.wrap_igFindRenderedTextEnd(textArg))
}

func InternalFocusWindow(window *Window) {
	windowArg, windowFin := window.handle()
	C.wrap_igFocusWindow(windowArg)

	windowFin()
}

func ColorU32Col(idx Col) uint32 {
	return uint32(C.wrap_igGetColorU32_Col(C.ImGuiCol(idx)))
}

func ColumnOffset() float32 {
	return float32(C.wrap_igGetColumnOffset())
}

func ColumnWidth() float32 {
	return float32(C.wrap_igGetColumnWidth())
}

func MouseDragDelta() Vec2 {
	pOut := new(Vec2)
	pOutArg, pOutFin := wrap[C.ImVec2, *Vec2](pOut)

	C.wrap_igGetMouseDragDelta(pOutArg)

	pOutFin()

	return *pOut
}

func InternalTypingSelectRequest() *TypingSelectRequest {
	return newTypingSelectRequestFromC(C.wrap_igGetTypingSelectRequest())
}

func InternalImFileLoadToMemory(filename string, mode string) unsafe.Pointer {
	filenameArg, filenameFin := WrapString(filename)
	modeArg, modeFin := WrapString(mode)

	defer func() {
		filenameFin()
		modeFin()
	}()
	return unsafe.Pointer(C.wrap_igImFileLoadToMemory(filenameArg, modeArg))
}

func InternalImHashData(data unsafe.Pointer, data_size uint64) ID {
	return *newIDFromC(func() *C.ImGuiID { result := C.wrap_igImHashData((data), C.xulong(data_size)); return &result }())
}

func InternalImHashStr(data string) ID {
	dataArg, dataFin := WrapString(data)

	defer func() {
		dataFin()
	}()
	return *newIDFromC(func() *C.ImGuiID { result := C.wrap_igImHashStr(dataArg); return &result }())
}

func InternalImTextStrFromUtf8(out_buf *Wchar, out_buf_size int32, in_text string, in_text_end string) int32 {
	in_textArg, in_textFin := WrapString(in_text)
	in_text_endArg, in_text_endFin := WrapString(in_text_end)

	defer func() {
		in_textFin()
		in_text_endFin()
	}()
	return int32(C.wrap_igImTextStrFromUtf8((*C.ImWchar)(out_buf), C.int(out_buf_size), in_textArg, in_text_endArg))
}

func Image(user_texture_id TextureID, size Vec2) {
	user_texture_idArg, user_texture_idFin := user_texture_id.c()
	C.wrap_igImage(user_texture_idArg, size.toC())

	user_texture_idFin()
}

func ImageButton(str_id string, user_texture_id TextureID, size Vec2) bool {
	str_idArg, str_idFin := WrapString(str_id)
	user_texture_idArg, user_texture_idFin := user_texture_id.c()

	defer func() {
		str_idFin()
		user_texture_idFin()
	}()
	return C.wrap_igImageButton(str_idArg, user_texture_idArg, size.toC()) == C.bool(true)
}

func InternalImageButtonEx(id ID, texture_id TextureID, size Vec2, uv0 Vec2, uv1 Vec2, bg_col Vec4, tint_col Vec4) bool {
	idArg, idFin := id.c()
	texture_idArg, texture_idFin := texture_id.c()

	defer func() {
		idFin()
		texture_idFin()
	}()
	return C.wrap_igImageButtonEx(idArg, texture_idArg, size.toC(), uv0.toC(), uv1.toC(), bg_col.toC(), tint_col.toC()) == C.bool(true)
}

func Indent() {
	C.wrap_igIndent()
}

func InputDouble(label string, v *float64) bool {
	labelArg, labelFin := WrapString(label)
	vArg, vFin := WrapNumberPtr[C.double, float64](v)

	defer func() {
		labelFin()
		vFin()
	}()
	return C.wrap_igInputDouble(labelArg, vArg) == C.bool(true)
}

func InputFloat(label string, v *float32) bool {
	labelArg, labelFin := WrapString(label)
	vArg, vFin := WrapNumberPtr[C.float, float32](v)

	defer func() {
		labelFin()
		vFin()
	}()
	return C.wrap_igInputFloat(labelArg, vArg) == C.bool(true)
}

func InputFloat2(label string, v *[2]float32) bool {
	labelArg, labelFin := WrapString(label)

	vArg := make([]C.float, len(v))
	for i, vV := range v {
		vArg[i] = C.float(vV)
	}

	defer func() {
		labelFin()

		for i, vV := range vArg {
			(*v)[i] = float32(vV)
		}
	}()
	return C.wrap_igInputFloat2(labelArg, (*C.float)(&vArg[0])) == C.bool(true)
}

func InputFloat3(label string, v *[3]float32) bool {
	labelArg, labelFin := WrapString(label)

	vArg := make([]C.float, len(v))
	for i, vV := range v {
		vArg[i] = C.float(vV)
	}

	defer func() {
		labelFin()

		for i, vV := range vArg {
			(*v)[i] = float32(vV)
		}
	}()
	return C.wrap_igInputFloat3(labelArg, (*C.float)(&vArg[0])) == C.bool(true)
}

func InputFloat4(label string, v *[4]float32) bool {
	labelArg, labelFin := WrapString(label)

	vArg := make([]C.float, len(v))
	for i, vV := range v {
		vArg[i] = C.float(vV)
	}

	defer func() {
		labelFin()

		for i, vV := range vArg {
			(*v)[i] = float32(vV)
		}
	}()
	return C.wrap_igInputFloat4(labelArg, (*C.float)(&vArg[0])) == C.bool(true)
}

func InputInt(label string, v *int32) bool {
	labelArg, labelFin := WrapString(label)
	vArg, vFin := WrapNumberPtr[C.int, int32](v)

	defer func() {
		labelFin()
		vFin()
	}()
	return C.wrap_igInputInt(labelArg, vArg) == C.bool(true)
}

func InputInt2(label string, v *[2]int32) bool {
	labelArg, labelFin := WrapString(label)

	vArg := make([]C.int, len(v))
	for i, vV := range v {
		vArg[i] = C.int(vV)
	}

	defer func() {
		labelFin()

		for i, vV := range vArg {
			(*v)[i] = int32(vV)
		}
	}()
	return C.wrap_igInputInt2(labelArg, (*C.int)(&vArg[0])) == C.bool(true)
}

func InputInt3(label string, v *[3]int32) bool {
	labelArg, labelFin := WrapString(label)

	vArg := make([]C.int, len(v))
	for i, vV := range v {
		vArg[i] = C.int(vV)
	}

	defer func() {
		labelFin()

		for i, vV := range vArg {
			(*v)[i] = int32(vV)
		}
	}()
	return C.wrap_igInputInt3(labelArg, (*C.int)(&vArg[0])) == C.bool(true)
}

func InputInt4(label string, v *[4]int32) bool {
	labelArg, labelFin := WrapString(label)

	vArg := make([]C.int, len(v))
	for i, vV := range v {
		vArg[i] = C.int(vV)
	}

	defer func() {
		labelFin()

		for i, vV := range vArg {
			(*v)[i] = int32(vV)
		}
	}()
	return C.wrap_igInputInt4(labelArg, (*C.int)(&vArg[0])) == C.bool(true)
}

func InputScalar(label string, data_type DataType, p_data unsafe.Pointer) bool {
	labelArg, labelFin := WrapString(label)
	p_dataArg, p_dataFin := WrapVoidPtr(p_data)

	defer func() {
		labelFin()
		p_dataFin()
	}()
	return C.wrap_igInputScalar(labelArg, C.ImGuiDataType(data_type), p_dataArg) == C.bool(true)
}

func InputScalarN(label string, data_type DataType, p_data unsafe.Pointer, components int32) bool {
	labelArg, labelFin := WrapString(label)
	p_dataArg, p_dataFin := WrapVoidPtr(p_data)

	defer func() {
		labelFin()
		p_dataFin()
	}()
	return C.wrap_igInputScalarN(labelArg, C.ImGuiDataType(data_type), p_dataArg, C.int(components)) == C.bool(true)
}

func InternalInputTextEx(label string, hint string, buf string, buf_size int32, size_arg Vec2, flags InputTextFlags) bool {
	labelArg, labelFin := WrapString(label)
	hintArg, hintFin := WrapString(hint)
	bufArg, bufFin := WrapString(buf)

	defer func() {
		labelFin()
		hintFin()
		bufFin()
	}()
	return C.wrap_igInputTextEx(labelArg, hintArg, bufArg, C.int(buf_size), size_arg.toC(), C.ImGuiInputTextFlags(flags)) == C.bool(true)
}

func InvisibleButton(str_id string, size Vec2) bool {
	str_idArg, str_idFin := WrapString(str_id)

	defer func() {
		str_idFin()
	}()
	return C.wrap_igInvisibleButton(str_idArg, size.toC()) == C.bool(true)
}

func IsItemClicked() bool {
	return C.wrap_igIsItemClicked() == C.bool(true)
}

func IsItemHovered() bool {
	return C.wrap_igIsItemHovered() == C.bool(true)
}

func InternalIsKeyPressedMap(key Key) bool {
	return C.wrap_igIsKeyPressedMap(C.ImGuiKey(key)) == C.bool(true)
}

func IsKeyPressedBool(key Key) bool {
	return C.wrap_igIsKeyPressed_Bool(C.ImGuiKey(key)) == C.bool(true)
}

func InternalIsKeyPressedID(key Key, owner_id ID) bool {
	owner_idArg, owner_idFin := owner_id.c()

	defer func() {
		owner_idFin()
	}()
	return C.wrap_igIsKeyPressed_ID(C.ImGuiKey(key), owner_idArg) == C.bool(true)
}

func IsMouseClickedBool(button MouseButton) bool {
	return C.wrap_igIsMouseClicked_Bool(C.ImGuiMouseButton(button)) == C.bool(true)
}

func InternalIsMouseClickedID(button MouseButton, owner_id ID) bool {
	owner_idArg, owner_idFin := owner_id.c()

	defer func() {
		owner_idFin()
	}()
	return C.wrap_igIsMouseClicked_ID(C.ImGuiMouseButton(button), owner_idArg) == C.bool(true)
}

func InternalIsMouseDragPastThreshold(button MouseButton) bool {
	return C.wrap_igIsMouseDragPastThreshold(C.ImGuiMouseButton(button)) == C.bool(true)
}

func IsMouseDragging(button MouseButton) bool {
	return C.wrap_igIsMouseDragging(C.ImGuiMouseButton(button)) == C.bool(true)
}

func IsMouseHoveringRect(r_min Vec2, r_max Vec2) bool {
	return C.wrap_igIsMouseHoveringRect(r_min.toC(), r_max.toC()) == C.bool(true)
}

func IsMousePosValid() bool {
	return C.wrap_igIsMousePosValid() == C.bool(true)
}

func IsPopupOpenStr(str_id string) bool {
	str_idArg, str_idFin := WrapString(str_id)

	defer func() {
		str_idFin()
	}()
	return C.wrap_igIsPopupOpen_Str(str_idArg) == C.bool(true)
}

func InternalIsWindowContentHoverable(window *Window) bool {
	windowArg, windowFin := window.handle()

	defer func() {
		windowFin()
	}()
	return C.wrap_igIsWindowContentHoverable(windowArg) == C.bool(true)
}

func IsWindowFocused() bool {
	return C.wrap_igIsWindowFocused() == C.bool(true)
}

func IsWindowHovered() bool {
	return C.wrap_igIsWindowHovered() == C.bool(true)
}

func InternalItemAdd(bb Rect, id ID) bool {
	idArg, idFin := id.c()

	defer func() {
		idFin()
	}()
	return C.wrap_igItemAdd(bb.toC(), idArg) == C.bool(true)
}

func InternalItemSizeRect(bb Rect) {
	C.wrap_igItemSize_Rect(bb.toC())
}

func InternalItemSizeVec2(size Vec2) {
	C.wrap_igItemSize_Vec2(size.toC())
}

func ListBoxStrarr(label string, current_item *int32, items []string, items_count int32) bool {
	labelArg, labelFin := WrapString(label)
	current_itemArg, current_itemFin := WrapNumberPtr[C.int, int32](current_item)
	itemsArg, itemsFin := WrapStringList(items)

	defer func() {
		labelFin()
		current_itemFin()
		itemsFin()
	}()
	return C.wrap_igListBox_Str_arr(labelArg, current_itemArg, itemsArg, C.int(items_count)) == C.bool(true)
}

func LoadIniSettingsFromMemory(ini_data string) {
	ini_dataArg, ini_dataFin := WrapString(ini_data)
	C.wrap_igLoadIniSettingsFromMemory(ini_dataArg)

	ini_dataFin()
}

func InternalLogRenderedText(ref_pos *Vec2, text string) {
	ref_posArg, ref_posFin := wrap[C.ImVec2, *Vec2](ref_pos)
	textArg, textFin := WrapString(text)
	C.wrap_igLogRenderedText(ref_posArg, textArg)

	ref_posFin()
	textFin()
}

func InternalLogToBuffer() {
	C.wrap_igLogToBuffer()
}

func LogToClipboard() {
	C.wrap_igLogToClipboard()
}

func LogToFile() {
	C.wrap_igLogToFile()
}

func LogToTTY() {
	C.wrap_igLogToTTY()
}

func InternalMenuItemEx(label string, icon string) bool {
	labelArg, labelFin := WrapString(label)
	iconArg, iconFin := WrapString(icon)

	defer func() {
		labelFin()
		iconFin()
	}()
	return C.wrap_igMenuItemEx(labelArg, iconArg) == C.bool(true)
}

func MenuItemBool(label string) bool {
	labelArg, labelFin := WrapString(label)

	defer func() {
		labelFin()
	}()
	return C.wrap_igMenuItem_Bool(labelArg) == C.bool(true)
}

func MenuItemBoolPtr(label string, shortcut string, p_selected *bool) bool {
	labelArg, labelFin := WrapString(label)
	shortcutArg, shortcutFin := WrapString(shortcut)
	p_selectedArg, p_selectedFin := WrapBool(p_selected)

	defer func() {
		labelFin()
		shortcutFin()
		p_selectedFin()
	}()
	return C.wrap_igMenuItem_BoolPtr(labelArg, shortcutArg, p_selectedArg) == C.bool(true)
}

func InternalOpenPopupEx(id ID) {
	idArg, idFin := id.c()
	C.wrap_igOpenPopupEx(idArg)

	idFin()
}

func OpenPopupOnItemClick() {
	C.wrap_igOpenPopupOnItemClick()
}

func OpenPopupID(id ID) {
	idArg, idFin := id.c()
	C.wrap_igOpenPopup_ID(idArg)

	idFin()
}

func OpenPopupStr(str_id string) {
	str_idArg, str_idFin := WrapString(str_id)
	C.wrap_igOpenPopup_Str(str_idArg)

	str_idFin()
}

func PlotHistogramFloatPtr(label string, values []float32, values_count int32) {
	labelArg, labelFin := WrapString(label)
	C.wrap_igPlotHistogram_FloatPtr(labelArg, (*C.float)(&(values[0])), C.int(values_count))

	labelFin()
}

func PlotLinesFloatPtr(label string, values []float32, values_count int32) {
	labelArg, labelFin := WrapString(label)
	C.wrap_igPlotLines_FloatPtr(labelArg, (*C.float)(&(values[0])), C.int(values_count))

	labelFin()
}

func PopStyleColor() {
	C.wrap_igPopStyleColor()
}

func PopStyleVar() {
	C.wrap_igPopStyleVar()
}

func ProgressBar(fraction float32) {
	C.wrap_igProgressBar(C.float(fraction))
}

func PushTextWrapPos() {
	C.wrap_igPushTextWrapPos()
}

func InternalRenderArrow(draw_list *DrawList, pos Vec2, col uint32, dir Dir) {
	draw_listArg, draw_listFin := draw_list.handle()
	C.wrap_igRenderArrow(draw_listArg, pos.toC(), C.ImU32(col), C.ImGuiDir(dir))

	draw_listFin()
}

func InternalRenderColorRectWithAlphaCheckerboard(draw_list *DrawList, p_min Vec2, p_max Vec2, fill_col uint32, grid_step float32, grid_off Vec2) {
	draw_listArg, draw_listFin := draw_list.handle()
	C.wrap_igRenderColorRectWithAlphaCheckerboard(draw_listArg, p_min.toC(), p_max.toC(), C.ImU32(fill_col), C.float(grid_step), grid_off.toC())

	draw_listFin()
}

func InternalRenderFrame(p_min Vec2, p_max Vec2, fill_col uint32) {
	C.wrap_igRenderFrame(p_min.toC(), p_max.toC(), C.ImU32(fill_col))
}

func InternalRenderFrameBorder(p_min Vec2, p_max Vec2) {
	C.wrap_igRenderFrameBorder(p_min.toC(), p_max.toC())
}

func InternalRenderNavHighlight(bb Rect, id ID) {
	idArg, idFin := id.c()
	C.wrap_igRenderNavHighlight(bb.toC(), idArg)

	idFin()
}

func RenderPlatformWindowsDefault() {
	C.wrap_igRenderPlatformWindowsDefault()
}

func InternalRenderText(pos Vec2, text string) {
	textArg, textFin := WrapString(text)
	C.wrap_igRenderText(pos.toC(), textArg)

	textFin()
}

func InternalRenderTextClipped(pos_min Vec2, pos_max Vec2, text string, text_size_if_known *Vec2) {
	textArg, textFin := WrapString(text)
	text_size_if_knownArg, text_size_if_knownFin := wrap[C.ImVec2, *Vec2](text_size_if_known)
	C.wrap_igRenderTextClipped(pos_min.toC(), pos_max.toC(), textArg, text_size_if_knownArg)

	textFin()
	text_size_if_knownFin()
}

func InternalRenderTextClippedEx(draw_list *DrawList, pos_min Vec2, pos_max Vec2, text string, text_size_if_known *Vec2) {
	draw_listArg, draw_listFin := draw_list.handle()
	textArg, textFin := WrapString(text)
	text_size_if_knownArg, text_size_if_knownFin := wrap[C.ImVec2, *Vec2](text_size_if_known)
	C.wrap_igRenderTextClippedEx(draw_listArg, pos_min.toC(), pos_max.toC(), textArg, text_size_if_knownArg)

	draw_listFin()
	textFin()
	text_size_if_knownFin()
}

func ResetMouseDragDelta() {
	C.wrap_igResetMouseDragDelta()
}

func SameLine() {
	C.wrap_igSameLine()
}

func SaveIniSettingsToMemory() string {
	return C.GoString(C.wrap_igSaveIniSettingsToMemory())
}

func InternalScrollToItem() {
	C.wrap_igScrollToItem()
}

func InternalScrollToRect(window *Window, rect Rect) {
	windowArg, windowFin := window.handle()
	C.wrap_igScrollToRect(windowArg, rect.toC())

	windowFin()
}

func InternalScrollToRectEx(window *Window, rect Rect) Vec2 {
	pOut := new(Vec2)
	pOutArg, pOutFin := wrap[C.ImVec2, *Vec2](pOut)

	windowArg, windowFin := window.handle()
	C.wrap_igScrollToRectEx(pOutArg, windowArg, rect.toC())

	pOutFin()
	windowFin()

	return *pOut
}

func SelectableBool(label string) bool {
	labelArg, labelFin := WrapString(label)

	defer func() {
		labelFin()
	}()
	return C.wrap_igSelectable_Bool(labelArg) == C.bool(true)
}

func SelectableBoolPtr(label string, p_selected *bool) bool {
	labelArg, labelFin := WrapString(label)
	p_selectedArg, p_selectedFin := WrapBool(p_selected)

	defer func() {
		labelFin()
		p_selectedFin()
	}()
	return C.wrap_igSelectable_BoolPtr(labelArg, p_selectedArg) == C.bool(true)
}

func InternalSeparatorEx(flags SeparatorFlags) {
	C.wrap_igSeparatorEx(C.ImGuiSeparatorFlags(flags))
}

func SetDragDropPayload(typeArg string, data unsafe.Pointer, sz uint64) bool {
	typeArgArg, typeArgFin := WrapString(typeArg)

	defer func() {
		typeArgFin()
	}()
	return C.wrap_igSetDragDropPayload(typeArgArg, (data), C.xulong(sz)) == C.bool(true)
}

func InternalSetItemKeyOwner(key Key) {
	C.wrap_igSetItemKeyOwner(C.ImGuiKey(key))
}

func InternalSetKeyOwner(key Key, owner_id ID) {
	owner_idArg, owner_idFin := owner_id.c()
	C.wrap_igSetKeyOwner(C.ImGuiKey(key), owner_idArg)

	owner_idFin()
}

func InternalSetKeyOwnersForKeyChord(key KeyChord, owner_id ID) {
	keyArg, keyFin := key.c()
	owner_idArg, owner_idFin := owner_id.c()
	C.wrap_igSetKeyOwnersForKeyChord(keyArg, owner_idArg)

	keyFin()
	owner_idFin()
}

func SetKeyboardFocusHere() {
	C.wrap_igSetKeyboardFocusHere()
}

func SetNextItemOpen(is_open bool) {
	C.wrap_igSetNextItemOpen(C.bool(is_open))
}

func SetNextWindowCollapsed(collapsed bool) {
	C.wrap_igSetNextWindowCollapsed(C.bool(collapsed))
}

func SetNextWindowDockID(dock_id ID) {
	dock_idArg, dock_idFin := dock_id.c()
	C.wrap_igSetNextWindowDockID(dock_idArg)

	dock_idFin()
}

func SetNextWindowPos(pos Vec2) {
	C.wrap_igSetNextWindowPos(pos.toC())
}

func SetNextWindowSize(size Vec2) {
	C.wrap_igSetNextWindowSize(size.toC())
}

func SetNextWindowSizeConstraints(size_min Vec2, size_max Vec2) {
	C.wrap_igSetNextWindowSizeConstraints(size_min.toC(), size_max.toC())
}

func SetScrollFromPosXFloat(local_x float32) {
	C.wrap_igSetScrollFromPosX_Float(C.float(local_x))
}

func SetScrollFromPosYFloat(local_y float32) {
	C.wrap_igSetScrollFromPosY_Float(C.float(local_y))
}

func SetScrollHereX() {
	C.wrap_igSetScrollHereX()
}

func SetScrollHereY() {
	C.wrap_igSetScrollHereY()
}

func InternalSetShortcutRouting(key_chord KeyChord) bool {
	key_chordArg, key_chordFin := key_chord.c()

	defer func() {
		key_chordFin()
	}()
	return C.wrap_igSetShortcutRouting(key_chordArg) == C.bool(true)
}

func SetWindowCollapsedBool(collapsed bool) {
	C.wrap_igSetWindowCollapsed_Bool(C.bool(collapsed))
}

func SetWindowCollapsedStr(name string, collapsed bool) {
	nameArg, nameFin := WrapString(name)
	C.wrap_igSetWindowCollapsed_Str(nameArg, C.bool(collapsed))

	nameFin()
}

func InternalSetWindowCollapsedWindowPtr(window *Window, collapsed bool) {
	windowArg, windowFin := window.handle()
	C.wrap_igSetWindowCollapsed_WindowPtr(windowArg, C.bool(collapsed))

	windowFin()
}

func SetWindowPosStr(name string, pos Vec2) {
	nameArg, nameFin := WrapString(name)
	C.wrap_igSetWindowPos_Str(nameArg, pos.toC())

	nameFin()
}

func SetWindowPosVec2(pos Vec2) {
	C.wrap_igSetWindowPos_Vec2(pos.toC())
}

func InternalSetWindowPosWindowPtr(window *Window, pos Vec2) {
	windowArg, windowFin := window.handle()
	C.wrap_igSetWindowPos_WindowPtr(windowArg, pos.toC())

	windowFin()
}

func SetWindowSizeStr(name string, size Vec2) {
	nameArg, nameFin := WrapString(name)
	C.wrap_igSetWindowSize_Str(nameArg, size.toC())

	nameFin()
}

func SetWindowSizeVec2(size Vec2) {
	C.wrap_igSetWindowSize_Vec2(size.toC())
}

func InternalSetWindowSizeWindowPtr(window *Window, size Vec2) {
	windowArg, windowFin := window.handle()
	C.wrap_igSetWindowSize_WindowPtr(windowArg, size.toC())

	windowFin()
}

func InternalShortcut(key_chord KeyChord) bool {
	key_chordArg, key_chordFin := key_chord.c()

	defer func() {
		key_chordFin()
	}()
	return C.wrap_igShortcut(key_chordArg) == C.bool(true)
}

func ShowAboutWindow() {
	C.wrap_igShowAboutWindow()
}

func ShowDebugLogWindow() {
	C.wrap_igShowDebugLogWindow()
}

func ShowDemoWindow() {
	C.wrap_igShowDemoWindow()
}

func ShowMetricsWindow() {
	C.wrap_igShowMetricsWindow()
}

func ShowStackToolWindow() {
	C.wrap_igShowStackToolWindow()
}

func ShowStyleEditor() {
	C.wrap_igShowStyleEditor()
}

func SliderAngle(label string, v_rad *float32) bool {
	labelArg, labelFin := WrapString(label)
	v_radArg, v_radFin := WrapNumberPtr[C.float, float32](v_rad)

	defer func() {
		labelFin()
		v_radFin()
	}()
	return C.wrap_igSliderAngle(labelArg, v_radArg) == C.bool(true)
}

func SliderFloat(label string, v *float32, v_min float32, v_max float32) bool {
	labelArg, labelFin := WrapString(label)
	vArg, vFin := WrapNumberPtr[C.float, float32](v)

	defer func() {
		labelFin()
		vFin()
	}()
	return C.wrap_igSliderFloat(labelArg, vArg, C.float(v_min), C.float(v_max)) == C.bool(true)
}

func SliderFloat2(label string, v *[2]float32, v_min float32, v_max float32) bool {
	labelArg, labelFin := WrapString(label)

	vArg := make([]C.float, len(v))
	for i, vV := range v {
		vArg[i] = C.float(vV)
	}

	defer func() {
		labelFin()

		for i, vV := range vArg {
			(*v)[i] = float32(vV)
		}
	}()
	return C.wrap_igSliderFloat2(labelArg, (*C.float)(&vArg[0]), C.float(v_min), C.float(v_max)) == C.bool(true)
}

func SliderFloat3(label string, v *[3]float32, v_min float32, v_max float32) bool {
	labelArg, labelFin := WrapString(label)

	vArg := make([]C.float, len(v))
	for i, vV := range v {
		vArg[i] = C.float(vV)
	}

	defer func() {
		labelFin()

		for i, vV := range vArg {
			(*v)[i] = float32(vV)
		}
	}()
	return C.wrap_igSliderFloat3(labelArg, (*C.float)(&vArg[0]), C.float(v_min), C.float(v_max)) == C.bool(true)
}

func SliderFloat4(label string, v *[4]float32, v_min float32, v_max float32) bool {
	labelArg, labelFin := WrapString(label)

	vArg := make([]C.float, len(v))
	for i, vV := range v {
		vArg[i] = C.float(vV)
	}

	defer func() {
		labelFin()

		for i, vV := range vArg {
			(*v)[i] = float32(vV)
		}
	}()
	return C.wrap_igSliderFloat4(labelArg, (*C.float)(&vArg[0]), C.float(v_min), C.float(v_max)) == C.bool(true)
}

func SliderInt(label string, v *int32, v_min int32, v_max int32) bool {
	labelArg, labelFin := WrapString(label)
	vArg, vFin := WrapNumberPtr[C.int, int32](v)

	defer func() {
		labelFin()
		vFin()
	}()
	return C.wrap_igSliderInt(labelArg, vArg, C.int(v_min), C.int(v_max)) == C.bool(true)
}

func SliderInt2(label string, v *[2]int32, v_min int32, v_max int32) bool {
	labelArg, labelFin := WrapString(label)

	vArg := make([]C.int, len(v))
	for i, vV := range v {
		vArg[i] = C.int(vV)
	}

	defer func() {
		labelFin()

		for i, vV := range vArg {
			(*v)[i] = int32(vV)
		}
	}()
	return C.wrap_igSliderInt2(labelArg, (*C.int)(&vArg[0]), C.int(v_min), C.int(v_max)) == C.bool(true)
}

func SliderInt3(label string, v *[3]int32, v_min int32, v_max int32) bool {
	labelArg, labelFin := WrapString(label)

	vArg := make([]C.int, len(v))
	for i, vV := range v {
		vArg[i] = C.int(vV)
	}

	defer func() {
		labelFin()

		for i, vV := range vArg {
			(*v)[i] = int32(vV)
		}
	}()
	return C.wrap_igSliderInt3(labelArg, (*C.int)(&vArg[0]), C.int(v_min), C.int(v_max)) == C.bool(true)
}

func SliderInt4(label string, v *[4]int32, v_min int32, v_max int32) bool {
	labelArg, labelFin := WrapString(label)

	vArg := make([]C.int, len(v))
	for i, vV := range v {
		vArg[i] = C.int(vV)
	}

	defer func() {
		labelFin()

		for i, vV := range vArg {
			(*v)[i] = int32(vV)
		}
	}()
	return C.wrap_igSliderInt4(labelArg, (*C.int)(&vArg[0]), C.int(v_min), C.int(v_max)) == C.bool(true)
}

func SliderScalar(label string, data_type DataType, p_data unsafe.Pointer, p_min unsafe.Pointer, p_max unsafe.Pointer) bool {
	labelArg, labelFin := WrapString(label)
	p_dataArg, p_dataFin := WrapVoidPtr(p_data)

	defer func() {
		labelFin()
		p_dataFin()
	}()
	return C.wrap_igSliderScalar(labelArg, C.ImGuiDataType(data_type), p_dataArg, (p_min), (p_max)) == C.bool(true)
}

func SliderScalarN(label string, data_type DataType, p_data unsafe.Pointer, components int32, p_min unsafe.Pointer, p_max unsafe.Pointer) bool {
	labelArg, labelFin := WrapString(label)
	p_dataArg, p_dataFin := WrapVoidPtr(p_data)

	defer func() {
		labelFin()
		p_dataFin()
	}()
	return C.wrap_igSliderScalarN(labelArg, C.ImGuiDataType(data_type), p_dataArg, C.int(components), (p_min), (p_max)) == C.bool(true)
}

func InternalSplitterBehavior(bb Rect, id ID, axis Axis, size1 *float32, size2 *float32, min_size1 float32, min_size2 float32) bool {
	idArg, idFin := id.c()
	size1Arg, size1Fin := WrapNumberPtr[C.float, float32](size1)
	size2Arg, size2Fin := WrapNumberPtr[C.float, float32](size2)

	defer func() {
		idFin()
		size1Fin()
		size2Fin()
	}()
	return C.wrap_igSplitterBehavior(bb.toC(), idArg, C.ImGuiAxis(axis), size1Arg, size2Arg, C.float(min_size1), C.float(min_size2)) == C.bool(true)
}

func StyleColorsClassic() {
	C.wrap_igStyleColorsClassic()
}

func StyleColorsDark() {
	C.wrap_igStyleColorsDark()
}

func StyleColorsLight() {
	C.wrap_igStyleColorsLight()
}

func TabItemButton(label string) bool {
	labelArg, labelFin := WrapString(label)

	defer func() {
		labelFin()
	}()
	return C.wrap_igTabItemButton(labelArg) == C.bool(true)
}

func TableGetColumnFlags() TableColumnFlags {
	return TableColumnFlags(C.wrap_igTableGetColumnFlags())
}

func TableGetColumnNameInt() string {
	return C.GoString(C.wrap_igTableGetColumnName_Int())
}

func InternalTableGetColumnResizeID(table *Table, column_n int32) ID {
	tableArg, tableFin := table.handle()

	defer func() {
		tableFin()
	}()
	return *newIDFromC(func() *C.ImGuiID {
		result := C.wrap_igTableGetColumnResizeID(tableArg, C.int(column_n))
		return &result
	}())
}

func TableNextRow() {
	C.wrap_igTableNextRow()
}

func InternalTableOpenContextMenu() {
	C.wrap_igTableOpenContextMenu()
}

func TableSetBgColor(target TableBgTarget, color uint32) {
	C.wrap_igTableSetBgColor(C.ImGuiTableBgTarget(target), C.ImU32(color))
}

func TableSetupColumn(label string) {
	labelArg, labelFin := WrapString(label)
	C.wrap_igTableSetupColumn(labelArg)

	labelFin()
}

func InternalTempInputScalar(bb Rect, id ID, label string, data_type DataType, p_data unsafe.Pointer, format string) bool {
	idArg, idFin := id.c()
	labelArg, labelFin := WrapString(label)
	p_dataArg, p_dataFin := WrapVoidPtr(p_data)
	formatArg, formatFin := WrapString(format)

	defer func() {
		idFin()
		labelFin()
		p_dataFin()
		formatFin()
	}()
	return C.wrap_igTempInputScalar(bb.toC(), idArg, labelArg, C.ImGuiDataType(data_type), p_dataArg, formatArg) == C.bool(true)
}

func InternalTextEx(text string) {
	textArg, textFin := WrapString(text)
	C.wrap_igTextEx(textArg)

	textFin()
}

func TextUnformatted(text string) {
	textArg, textFin := WrapString(text)
	C.wrap_igTextUnformatted(textArg)

	textFin()
}

func InternalTreeNodeBehavior(id ID, flags TreeNodeFlags, label string) bool {
	idArg, idFin := id.c()
	labelArg, labelFin := WrapString(label)

	defer func() {
		idFin()
		labelFin()
	}()
	return C.wrap_igTreeNodeBehavior(idArg, C.ImGuiTreeNodeFlags(flags), labelArg) == C.bool(true)
}

func TreeNodeExStr(label string) bool {
	labelArg, labelFin := WrapString(label)

	defer func() {
		labelFin()
	}()
	return C.wrap_igTreeNodeEx_Str(labelArg) == C.bool(true)
}

func Unindent() {
	C.wrap_igUnindent()
}

func VSliderFloat(label string, size Vec2, v *float32, v_min float32, v_max float32) bool {
	labelArg, labelFin := WrapString(label)
	vArg, vFin := WrapNumberPtr[C.float, float32](v)

	defer func() {
		labelFin()
		vFin()
	}()
	return C.wrap_igVSliderFloat(labelArg, size.toC(), vArg, C.float(v_min), C.float(v_max)) == C.bool(true)
}

func VSliderInt(label string, size Vec2, v *int32, v_min int32, v_max int32) bool {
	labelArg, labelFin := WrapString(label)
	vArg, vFin := WrapNumberPtr[C.int, int32](v)

	defer func() {
		labelFin()
		vFin()
	}()
	return C.wrap_igVSliderInt(labelArg, size.toC(), vArg, C.int(v_min), C.int(v_max)) == C.bool(true)
}

func VSliderScalar(label string, size Vec2, data_type DataType, p_data unsafe.Pointer, p_min unsafe.Pointer, p_max unsafe.Pointer) bool {
	labelArg, labelFin := WrapString(label)
	p_dataArg, p_dataFin := WrapVoidPtr(p_data)

	defer func() {
		labelFin()
		p_dataFin()
	}()
	return C.wrap_igVSliderScalar(labelArg, size.toC(), C.ImGuiDataType(data_type), p_dataArg, (p_min), (p_max)) == C.bool(true)
}

func ValueFloat(prefix string, v float32) {
	prefixArg, prefixFin := WrapString(prefix)
	C.wrap_igValue_Float(prefixArg, C.float(v))

	prefixFin()
}

func (self BitVector) SetStorage(v Vector[*uint32]) {
	vData := v.Data
	vDataArg, _ := WrapNumberPtr[C.ImU32, uint32](vData)
	vVecArg := new(C.ImVector_ImU32)
	vVecArg.Size = C.int(v.Size)
	vVecArg.Capacity = C.int(v.Capacity)
	vVecArg.Data = vDataArg
	v.pinner.Pin(vVecArg.Data)

	selfArg, selfFin := self.handle()
	defer selfFin()
	C.wrap_ImBitVector_SetStorage(selfArg, *vVecArg)
}

func (self *BitVector) Storage() Vector[*uint32] {
	selfArg, selfFin := self.handle()

	defer func() {
		selfFin()
	}()
	return newVectorFromC(C.wrap_ImBitVector_GetStorage(selfArg).Size, C.wrap_ImBitVector_GetStorage(selfArg).Capacity, (*uint32)(C.wrap_ImBitVector_GetStorage(selfArg).Data))
}

func (self *Color) Value() Vec4 {
	selfArg, selfFin := wrap[C.ImColor, *Color](self)

	defer func() {
		selfFin()
	}()
	return *(&Vec4{}).fromC(C.wrap_ImColor_GetValue(selfArg))
}

func (self DrawChannel) SetCmdBuffer(v Vector[*DrawCmd]) {
	vData := v.Data
	vDataArg, _ := vData.handle()
	vVecArg := new(C.ImVector_ImDrawCmd)
	vVecArg.Size = C.int(v.Size)
	vVecArg.Capacity = C.int(v.Capacity)
	vVecArg.Data = vDataArg
	v.pinner.Pin(vVecArg.Data)

	selfArg, selfFin := self.handle()
	defer selfFin()
	C.wrap_ImDrawChannel_Set_CmdBuffer(selfArg, *vVecArg)
}

func (self *DrawChannel) CmdBuffer() Vector[*DrawCmd] {
	selfArg, selfFin := self.handle()

	defer func() {
		selfFin()
	}()
	return newVectorFromC(C.wrap_ImDrawChannel_Get_CmdBuffer(selfArg).Size, C.wrap_ImDrawChannel_Get_CmdBuffer(selfArg).Capacity, newDrawCmdFromC(C.wrap_ImDrawChannel_Get_CmdBuffer(selfArg).Data))
}

func (self DrawCmd) SetClipRect(v Vec4) {
	selfArg, selfFin := self.handle()
	defer selfFin()
	C.wrap_ImDrawCmd_SetClipRect(selfArg, v.toC())
}

func (self *DrawCmd) ClipRect() Vec4 {
	selfArg, selfFin := self.handle()

	defer func() {
		selfFin()
	}()
	return *(&Vec4{}).fromC(C.wrap_ImDrawCmd_GetClipRect(selfArg))
}

func (self DrawCmd) SetTextureId(v TextureID) {
	vArg, _ := v.c()

	selfArg, selfFin := self.handle()
	defer selfFin()
	C.wrap_ImDrawCmd_SetTextureId(selfArg, vArg)
}

func (self *DrawCmd) TextureId() TextureID {
	selfArg, selfFin := self.handle()

	defer func() {
		selfFin()
	}()

	result := C.wrap_ImDrawCmd_GetTextureId(selfArg)
	return *newTextureIDFromC(func() *C.ImTextureID { result := result; return &result }())
}

func (self DrawCmd) SetVtxOffset(v uint32) {
	selfArg, selfFin := self.handle()
	defer selfFin()
	C.wrap_ImDrawCmd_SetVtxOffset(selfArg, C.uint(v))
}

func (self *DrawCmd) VtxOffset() uint32 {
	selfArg, selfFin := self.handle()

	defer func() {
		selfFin()
	}()
	return uint32(C.wrap_ImDrawCmd_GetVtxOffset(selfArg))
}

func (self DrawCmd) SetIdxOffset(v uint32) {
	selfArg, selfFin := self.handle()
	defer selfFin()
	C.wrap_ImDrawCmd_SetIdxOffset(selfArg, C.uint(v))
}

func (self *DrawCmd) IdxOffset() uint32 {
	selfArg, selfFin := self.handle()

	defer func() {
		selfFin()
	}()
	return uint32(C.wrap_ImDrawCmd_GetIdxOffset(selfArg))
}

func (self DrawCmd) SetElemCount(v uint32) {
	selfArg, selfFin := self.handle()
	defer selfFin()
	C.wrap_ImDrawCmd_SetElemCount(selfArg, C.uint(v))
}

func (self *DrawCmd) ElemCount() uint32 {
	selfArg, selfFin := self.handle()

	defer func() {
		selfFin()
	}()
	return uint32(C.wrap_ImDrawCmd_GetElemCount(selfArg))
}

func (self DrawCmd) SetUserCallbackData(v unsafe.Pointer) {
	vArg, _ := WrapVoidPtr(v)

	selfArg, selfFin := self.handle()
	defer selfFin()
	C.wrap_ImDrawCmd_SetUserCallbackData(selfArg, vArg)
}

func (self *DrawCmd) UserCallbackData() unsafe.Pointer {
	selfArg, selfFin := self.handle()

	defer func() {
		selfFin()
	}()
	return unsafe.Pointer(C.wrap_ImDrawCmd_GetUserCallbackData(selfArg))
}

func (self DrawCmdHeader) SetClipRect(v Vec4) {
	selfArg, selfFin := self.handle()
	defer selfFin()
	C.wrap_ImDrawCmdHeader_SetClipRect(selfArg, v.toC())
}

func (self *DrawCmdHeader) ClipRect() Vec4 {
	selfArg, selfFin := self.handle()

	defer func() {
		selfFin()
	}()
	return *(&Vec4{}).fromC(C.wrap_ImDrawCmdHeader_GetClipRect(selfArg))
}

func (self DrawCmdHeader) SetTextureId(v TextureID) {
	vArg, _ := v.c()

	selfArg, selfFin := self.handle()
	defer selfFin()
	C.wrap_ImDrawCmdHeader_SetTextureId(selfArg, vArg)
}

func (self *DrawCmdHeader) TextureId() TextureID {
	selfArg, selfFin := self.handle()

	defer func() {
		selfFin()
	}()

	result := C.wrap_ImDrawCmdHeader_GetTextureId(selfArg)
	return *newTextureIDFromC(func() *C.ImTextureID { result := result; return &result }())
}

func (self DrawCmdHeader) SetVtxOffset(v uint32) {
	selfArg, selfFin := self.handle()
	defer selfFin()
	C.wrap_ImDrawCmdHeader_SetVtxOffset(selfArg, C.uint(v))
}

func (self *DrawCmdHeader) VtxOffset() uint32 {
	selfArg, selfFin := self.handle()

	defer func() {
		selfFin()
	}()
	return uint32(C.wrap_ImDrawCmdHeader_GetVtxOffset(selfArg))
}

func (self DrawData) SetValid(v bool) {
	selfArg, selfFin := self.handle()
	defer selfFin()
	C.wrap_ImDrawData_SetValid(selfArg, C.bool(v))
}

func (self *DrawData) Valid() bool {
	selfArg, selfFin := self.handle()

	defer func() {
		selfFin()
	}()
	return C.wrap_ImDrawData_GetValid(selfArg) == C.bool(true)
}

func (self DrawData) SetCmdListsCount(v int32) {
	selfArg, selfFin := self.handle()
	defer selfFin()
	C.wrap_ImDrawData_SetCmdListsCount(selfArg, C.int(v))
}

func (self *DrawData) CmdListsCount() int32 {
	selfArg, selfFin := self.handle()

	defer func() {
		selfFin()
	}()
	return int32(C.wrap_ImDrawData_GetCmdListsCount(selfArg))
}

func (self DrawData) SetTotalIdxCount(v int32) {
	selfArg, selfFin := self.handle()
	defer selfFin()
	C.wrap_ImDrawData_SetTotalIdxCount(selfArg, C.int(v))
}

func (self *DrawData) TotalIdxCount() int32 {
	selfArg, selfFin := self.handle()

	defer func() {
		selfFin()
	}()
	return int32(C.wrap_ImDrawData_GetTotalIdxCount(selfArg))
}

func (self DrawData) SetTotalVtxCount(v int32) {
	selfArg, selfFin := self.handle()
	defer selfFin()
	C.wrap_ImDrawData_SetTotalVtxCount(selfArg, C.int(v))
}

func (self *DrawData) TotalVtxCount() int32 {
	selfArg, selfFin := self.handle()

	defer func() {
		selfFin()
	}()
	return int32(C.wrap_ImDrawData_GetTotalVtxCount(selfArg))
}

func (self DrawData) SetDisplayPos(v Vec2) {
	selfArg, selfFin := self.handle()
	defer selfFin()
	C.wrap_ImDrawData_SetDisplayPos(selfArg, v.toC())
}

func (self *DrawData) DisplayPos() Vec2 {
	selfArg, selfFin := self.handle()

	defer func() {
		selfFin()
	}()
	return *(&Vec2{}).fromC(C.wrap_ImDrawData_GetDisplayPos(selfArg))
}

func (self DrawData) SetDisplaySize(v Vec2) {
	selfArg, selfFin := self.handle()
	defer selfFin()
	C.wrap_ImDrawData_SetDisplaySize(selfArg, v.toC())
}

func (self *DrawData) DisplaySize() Vec2 {
	selfArg, selfFin := self.handle()

	defer func() {
		selfFin()
	}()
	return *(&Vec2{}).fromC(C.wrap_ImDrawData_GetDisplaySize(selfArg))
}

func (self DrawData) SetFramebufferScale(v Vec2) {
	selfArg, selfFin := self.handle()
	defer selfFin()
	C.wrap_ImDrawData_SetFramebufferScale(selfArg, v.toC())
}

func (self *DrawData) FramebufferScale() Vec2 {
	selfArg, selfFin := self.handle()

	defer func() {
		selfFin()
	}()
	return *(&Vec2{}).fromC(C.wrap_ImDrawData_GetFramebufferScale(selfArg))
}

func (self DrawData) SetOwnerViewport(v *Viewport) {
	vArg, _ := v.handle()

	selfArg, selfFin := self.handle()
	defer selfFin()
	C.wrap_ImDrawData_SetOwnerViewport(selfArg, vArg)
}

func (self *DrawData) OwnerViewport() *Viewport {
	selfArg, selfFin := self.handle()

	defer func() {
		selfFin()
	}()
	return newViewportFromC(C.wrap_ImDrawData_GetOwnerViewport(selfArg))
}

func (self DrawList) SetCmdBuffer(v Vector[*DrawCmd]) {
	vData := v.Data
	vDataArg, _ := vData.handle()
	vVecArg := new(C.ImVector_ImDrawCmd)
	vVecArg.Size = C.int(v.Size)
	vVecArg.Capacity = C.int(v.Capacity)
	vVecArg.Data = vDataArg
	v.pinner.Pin(vVecArg.Data)

	selfArg, selfFin := self.handle()
	defer selfFin()
	C.wrap_ImDrawList_SetCmdBuffer(selfArg, *vVecArg)
}

func (self *DrawList) CmdBuffer() Vector[*DrawCmd] {
	selfArg, selfFin := self.handle()

	defer func() {
		selfFin()
	}()
	return newVectorFromC(C.wrap_ImDrawList_GetCmdBuffer(selfArg).Size, C.wrap_ImDrawList_GetCmdBuffer(selfArg).Capacity, newDrawCmdFromC(C.wrap_ImDrawList_GetCmdBuffer(selfArg).Data))
}

func (self DrawList) SetVtxBuffer(v Vector[*DrawVert]) {
	vData := v.Data
	vDataArg, _ := vData.handle()
	vVecArg := new(C.ImVector_ImDrawVert)
	vVecArg.Size = C.int(v.Size)
	vVecArg.Capacity = C.int(v.Capacity)
	vVecArg.Data = vDataArg
	v.pinner.Pin(vVecArg.Data)

	selfArg, selfFin := self.handle()
	defer selfFin()
	C.wrap_ImDrawList_SetVtxBuffer(selfArg, *vVecArg)
}

func (self *DrawList) VtxBuffer() Vector[*DrawVert] {
	selfArg, selfFin := self.handle()

	defer func() {
		selfFin()
	}()
	return newVectorFromC(C.wrap_ImDrawList_GetVtxBuffer(selfArg).Size, C.wrap_ImDrawList_GetVtxBuffer(selfArg).Capacity, newDrawVertFromC(C.wrap_ImDrawList_GetVtxBuffer(selfArg).Data))
}

func (self DrawList) SetFlags(v DrawListFlags) {
	selfArg, selfFin := self.handle()
	defer selfFin()
	C.wrap_ImDrawList_SetFlags(selfArg, C.ImDrawListFlags(v))
}

func (self *DrawList) Flags() DrawListFlags {
	selfArg, selfFin := self.handle()

	defer func() {
		selfFin()
	}()
	return DrawListFlags(C.wrap_ImDrawList_GetFlags(selfArg))
}

func (self DrawList) SetVtxCurrentIdx(v uint32) {
	selfArg, selfFin := self.handle()
	defer selfFin()
	C.wrap_ImDrawList_Set_VtxCurrentIdx(selfArg, C.uint(v))
}

func (self *DrawList) VtxCurrentIdx() uint32 {
	selfArg, selfFin := self.handle()

	defer func() {
		selfFin()
	}()
	return uint32(C.wrap_ImDrawList_Get_VtxCurrentIdx(selfArg))
}

func (self DrawList) SetData(v *DrawListSharedData) {
	vArg, _ := v.handle()

	selfArg, selfFin := self.handle()
	defer selfFin()
	C.wrap_ImDrawList_Set_Data(selfArg, vArg)
}

func (self *DrawList) Data() *DrawListSharedData {
	selfArg, selfFin := self.handle()

	defer func() {
		selfFin()
	}()
	return newDrawListSharedDataFromC(C.wrap_ImDrawList_Get_Data(selfArg))
}

func (self DrawList) SetOwnerName(v string) {
	vArg, _ := WrapString(v)

	selfArg, selfFin := self.handle()
	defer selfFin()
	C.wrap_ImDrawList_Set_OwnerName(selfArg, vArg)
}

func (self *DrawList) OwnerName() string {
	selfArg, selfFin := self.handle()

	defer func() {
		selfFin()
	}()
	return C.GoString(C.wrap_ImDrawList_Get_OwnerName(selfArg))
}

func (self DrawList) SetVtxWritePtr(v *DrawVert) {
	vArg, _ := v.handle()

	selfArg, selfFin := self.handle()
	defer selfFin()
	C.wrap_ImDrawList_Set_VtxWritePtr(selfArg, vArg)
}

func (self *DrawList) VtxWritePtr() *DrawVert {
	selfArg, selfFin := self.handle()

	defer func() {
		selfFin()
	}()
	return newDrawVertFromC(C.wrap_ImDrawList_Get_VtxWritePtr(selfArg))
}

func (self DrawList) SetClipRectStack(v Vector[*Vec4]) {
	vData := v.Data
	vDataArg, _ := wrap[C.ImVec4, *Vec4](vData)
	vVecArg := new(C.ImVector_ImVec4)
	vVecArg.Size = C.int(v.Size)
	vVecArg.Capacity = C.int(v.Capacity)
	vVecArg.Data = vDataArg
	v.pinner.Pin(vVecArg.Data)

	selfArg, selfFin := self.handle()
	defer selfFin()
	C.wrap_ImDrawList_Set_ClipRectStack(selfArg, *vVecArg)
}

func (self DrawList) SetTextureIdStack(v Vector[*TextureID]) {
	vData := v.Data
	vDataArg, _ := vData.handle()
	vVecArg := new(C.ImVector_ImTextureID)
	vVecArg.Size = C.int(v.Size)
	vVecArg.Capacity = C.int(v.Capacity)
	vVecArg.Data = vDataArg
	v.pinner.Pin(vVecArg.Data)

	selfArg, selfFin := self.handle()
	defer selfFin()
	C.wrap_ImDrawList_Set_TextureIdStack(selfArg, *vVecArg)
}

func (self *DrawList) TextureIdStack() Vector[*TextureID] {
	selfArg, selfFin := self.handle()

	defer func() {
		selfFin()
	}()
	return newVectorFromC(C.wrap_ImDrawList_Get_TextureIdStack(selfArg).Size, C.wrap_ImDrawList_Get_TextureIdStack(selfArg).Capacity, newTextureIDFromC(C.wrap_ImDrawList_Get_TextureIdStack(selfArg).Data))
}

func (self DrawList) SetPath(v Vector[*Vec2]) {
	vData := v.Data
	vDataArg, _ := wrap[C.ImVec2, *Vec2](vData)
	vVecArg := new(C.ImVector_ImVec2)
	vVecArg.Size = C.int(v.Size)
	vVecArg.Capacity = C.int(v.Capacity)
	vVecArg.Data = vDataArg
	v.pinner.Pin(vVecArg.Data)

	selfArg, selfFin := self.handle()
	defer selfFin()
	C.wrap_ImDrawList_Set_Path(selfArg, *vVecArg)
}

func (self DrawList) SetCmdHeader(v DrawCmdHeader) {
	vArg, _ := v.c()

	selfArg, selfFin := self.handle()
	defer selfFin()
	C.wrap_ImDrawList_Set_CmdHeader(selfArg, vArg)
}

func (self *DrawList) CmdHeader() DrawCmdHeader {
	selfArg, selfFin := self.handle()

	defer func() {
		selfFin()
	}()

	result := C.wrap_ImDrawList_Get_CmdHeader(selfArg)
	return *newDrawCmdHeaderFromC(func() *C.ImDrawCmdHeader { result := result; return &result }())
}

func (self DrawList) SetSplitter(v DrawListSplitter) {
	vArg, _ := v.c()

	selfArg, selfFin := self.handle()
	defer selfFin()
	C.wrap_ImDrawList_Set_Splitter(selfArg, vArg)
}

func (self *DrawList) Splitter() DrawListSplitter {
	selfArg, selfFin := self.handle()

	defer func() {
		selfFin()
	}()

	result := C.wrap_ImDrawList_Get_Splitter(selfArg)
	return *newDrawListSplitterFromC(func() *C.ImDrawListSplitter { result := result; return &result }())
}

func (self DrawList) SetFringeScale(v float32) {
	selfArg, selfFin := self.handle()
	defer selfFin()
	C.wrap_ImDrawList_Set_FringeScale(selfArg, C.float(v))
}

func (self *DrawList) FringeScale() float32 {
	selfArg, selfFin := self.handle()

	defer func() {
		selfFin()
	}()
	return float32(C.wrap_ImDrawList_Get_FringeScale(selfArg))
}

func (self DrawListSharedData) SetTexUvWhitePixel(v Vec2) {
	selfArg, selfFin := self.handle()
	defer selfFin()
	C.wrap_ImDrawListSharedData_SetTexUvWhitePixel(selfArg, v.toC())
}

func (self *DrawListSharedData) TexUvWhitePixel() Vec2 {
	selfArg, selfFin := self.handle()

	defer func() {
		selfFin()
	}()
	return *(&Vec2{}).fromC(C.wrap_ImDrawListSharedData_GetTexUvWhitePixel(selfArg))
}

func (self DrawListSharedData) SetFont(v *Font) {
	vArg, _ := v.handle()

	selfArg, selfFin := self.handle()
	defer selfFin()
	C.wrap_ImDrawListSharedData_SetFont(selfArg, vArg)
}

func (self *DrawListSharedData) Font() *Font {
	selfArg, selfFin := self.handle()

	defer func() {
		selfFin()
	}()
	return newFontFromC(C.wrap_ImDrawListSharedData_GetFont(selfArg))
}

func (self DrawListSharedData) SetFontSize(v float32) {
	selfArg, selfFin := self.handle()
	defer selfFin()
	C.wrap_ImDrawListSharedData_SetFontSize(selfArg, C.float(v))
}

func (self *DrawListSharedData) FontSize() float32 {
	selfArg, selfFin := self.handle()

	defer func() {
		selfFin()
	}()
	return float32(C.wrap_ImDrawListSharedData_GetFontSize(selfArg))
}

func (self DrawListSharedData) SetCurveTessellationTol(v float32) {
	selfArg, selfFin := self.handle()
	defer selfFin()
	C.wrap_ImDrawListSharedData_SetCurveTessellationTol(selfArg, C.float(v))
}

func (self *DrawListSharedData) CurveTessellationTol() float32 {
	selfArg, selfFin := self.handle()

	defer func() {
		selfFin()
	}()
	return float32(C.wrap_ImDrawListSharedData_GetCurveTessellationTol(selfArg))
}

func (self DrawListSharedData) SetCircleSegmentMaxError(v float32) {
	selfArg, selfFin := self.handle()
	defer selfFin()
	C.wrap_ImDrawListSharedData_SetCircleSegmentMaxError(selfArg, C.float(v))
}

func (self *DrawListSharedData) CircleSegmentMaxError() float32 {
	selfArg, selfFin := self.handle()

	defer func() {
		selfFin()
	}()
	return float32(C.wrap_ImDrawListSharedData_GetCircleSegmentMaxError(selfArg))
}

func (self DrawListSharedData) SetClipRectFullscreen(v Vec4) {
	selfArg, selfFin := self.handle()
	defer selfFin()
	C.wrap_ImDrawListSharedData_SetClipRectFullscreen(selfArg, v.toC())
}

func (self *DrawListSharedData) ClipRectFullscreen() Vec4 {
	selfArg, selfFin := self.handle()

	defer func() {
		selfFin()
	}()
	return *(&Vec4{}).fromC(C.wrap_ImDrawListSharedData_GetClipRectFullscreen(selfArg))
}

func (self DrawListSharedData) SetInitialFlags(v DrawListFlags) {
	selfArg, selfFin := self.handle()
	defer selfFin()
	C.wrap_ImDrawListSharedData_SetInitialFlags(selfArg, C.ImDrawListFlags(v))
}

func (self *DrawListSharedData) InitialFlags() DrawListFlags {
	selfArg, selfFin := self.handle()

	defer func() {
		selfFin()
	}()
	return DrawListFlags(C.wrap_ImDrawListSharedData_GetInitialFlags(selfArg))
}

func (self DrawListSharedData) SetTempBuffer(v Vector[*Vec2]) {
	vData := v.Data
	vDataArg, _ := wrap[C.ImVec2, *Vec2](vData)
	vVecArg := new(C.ImVector_ImVec2)
	vVecArg.Size = C.int(v.Size)
	vVecArg.Capacity = C.int(v.Capacity)
	vVecArg.Data = vDataArg
	v.pinner.Pin(vVecArg.Data)

	selfArg, selfFin := self.handle()
	defer selfFin()
	C.wrap_ImDrawListSharedData_SetTempBuffer(selfArg, *vVecArg)
}

func (self DrawListSharedData) SetArcFastRadiusCutoff(v float32) {
	selfArg, selfFin := self.handle()
	defer selfFin()
	C.wrap_ImDrawListSharedData_SetArcFastRadiusCutoff(selfArg, C.float(v))
}

func (self *DrawListSharedData) ArcFastRadiusCutoff() float32 {
	selfArg, selfFin := self.handle()

	defer func() {
		selfFin()
	}()
	return float32(C.wrap_ImDrawListSharedData_GetArcFastRadiusCutoff(selfArg))
}

func (self DrawListSharedData) SetTexUvLines(v *Vec4) {
	vArg, _ := wrap[C.ImVec4, *Vec4](v)

	selfArg, selfFin := self.handle()
	defer selfFin()
	C.wrap_ImDrawListSharedData_SetTexUvLines(selfArg, vArg)
}

func (self *DrawListSharedData) TexUvLines() *Vec4 {
	selfArg, selfFin := self.handle()

	defer func() {
		selfFin()
	}()
	return (&Vec4{}).fromC(*C.wrap_ImDrawListSharedData_GetTexUvLines(selfArg))
}

func (self DrawListSplitter) SetCurrent(v int32) {
	selfArg, selfFin := self.handle()
	defer selfFin()
	C.wrap_ImDrawListSplitter_Set_Current(selfArg, C.int(v))
}

func (self *DrawListSplitter) Current() int32 {
	selfArg, selfFin := self.handle()

	defer func() {
		selfFin()
	}()
	return int32(C.wrap_ImDrawListSplitter_Get_Current(selfArg))
}

func (self DrawListSplitter) SetCount(v int32) {
	selfArg, selfFin := self.handle()
	defer selfFin()
	C.wrap_ImDrawListSplitter_Set_Count(selfArg, C.int(v))
}

func (self *DrawListSplitter) Count() int32 {
	selfArg, selfFin := self.handle()

	defer func() {
		selfFin()
	}()
	return int32(C.wrap_ImDrawListSplitter_Get_Count(selfArg))
}

func (self DrawListSplitter) SetChannels(v Vector[*DrawChannel]) {
	vData := v.Data
	vDataArg, _ := vData.handle()
	vVecArg := new(C.ImVector_ImDrawChannel)
	vVecArg.Size = C.int(v.Size)
	vVecArg.Capacity = C.int(v.Capacity)
	vVecArg.Data = vDataArg
	v.pinner.Pin(vVecArg.Data)

	selfArg, selfFin := self.handle()
	defer selfFin()
	C.wrap_ImDrawListSplitter_Set_Channels(selfArg, *vVecArg)
}

func (self *DrawListSplitter) Channels() Vector[*DrawChannel] {
	selfArg, selfFin := self.handle()

	defer func() {
		selfFin()
	}()
	return newVectorFromC(C.wrap_ImDrawListSplitter_Get_Channels(selfArg).Size, C.wrap_ImDrawListSplitter_Get_Channels(selfArg).Capacity, newDrawChannelFromC(C.wrap_ImDrawListSplitter_Get_Channels(selfArg).Data))
}

func (self DrawVert) SetPos(v Vec2) {
	selfArg, selfFin := self.handle()
	defer selfFin()
	C.wrap_ImDrawVert_SetPos(selfArg, v.toC())
}

func (self *DrawVert) Pos() Vec2 {
	selfArg, selfFin := self.handle()

	defer func() {
		selfFin()
	}()
	return *(&Vec2{}).fromC(C.wrap_ImDrawVert_GetPos(selfArg))
}

func (self DrawVert) SetUv(v Vec2) {
	selfArg, selfFin := self.handle()
	defer selfFin()
	C.wrap_ImDrawVert_SetUv(selfArg, v.toC())
}

func (self *DrawVert) Uv() Vec2 {
	selfArg, selfFin := self.handle()

	defer func() {
		selfFin()
	}()
	return *(&Vec2{}).fromC(C.wrap_ImDrawVert_GetUv(selfArg))
}

func (self DrawVert) SetCol(v uint32) {
	selfArg, selfFin := self.handle()
	defer selfFin()
	C.wrap_ImDrawVert_SetCol(selfArg, C.ImU32(v))
}

func (self *DrawVert) Col() uint32 {
	selfArg, selfFin := self.handle()

	defer func() {
		selfFin()
	}()
	return uint32(C.wrap_ImDrawVert_GetCol(selfArg))
}

func (self Font) SetIndexAdvanceX(v Vector[*float32]) {
	vData := v.Data
	vDataArg, _ := WrapNumberPtr[C.float, float32](vData)
	vVecArg := new(C.ImVector_float)
	vVecArg.Size = C.int(v.Size)
	vVecArg.Capacity = C.int(v.Capacity)
	vVecArg.Data = vDataArg
	v.pinner.Pin(vVecArg.Data)

	selfArg, selfFin := self.handle()
	defer selfFin()
	C.wrap_ImFont_SetIndexAdvanceX(selfArg, *vVecArg)
}

func (self *Font) IndexAdvanceX() Vector[*float32] {
	selfArg, selfFin := self.handle()

	defer func() {
		selfFin()
	}()
	return newVectorFromC(C.wrap_ImFont_GetIndexAdvanceX(selfArg).Size, C.wrap_ImFont_GetIndexAdvanceX(selfArg).Capacity, (*float32)(C.wrap_ImFont_GetIndexAdvanceX(selfArg).Data))
}

func (self Font) SetFallbackAdvanceX(v float32) {
	selfArg, selfFin := self.handle()
	defer selfFin()
	C.wrap_ImFont_SetFallbackAdvanceX(selfArg, C.float(v))
}

func (self *Font) FallbackAdvanceX() float32 {
	selfArg, selfFin := self.handle()

	defer func() {
		selfFin()
	}()
	return float32(C.wrap_ImFont_GetFallbackAdvanceX(selfArg))
}

func (self Font) SetFontSize(v float32) {
	selfArg, selfFin := self.handle()
	defer selfFin()
	C.wrap_ImFont_SetFontSize(selfArg, C.float(v))
}

func (self *Font) FontSize() float32 {
	selfArg, selfFin := self.handle()

	defer func() {
		selfFin()
	}()
	return float32(C.wrap_ImFont_GetFontSize(selfArg))
}

func (self Font) SetIndexLookup(v Vector[(*Wchar)]) {
	vData := v.Data

	vVecArg := new(C.ImVector_ImWchar)
	vVecArg.Size = C.int(v.Size)
	vVecArg.Capacity = C.int(v.Capacity)
	vVecArg.Data = (*C.ImWchar)(vData)
	v.pinner.Pin(vVecArg.Data)

	selfArg, selfFin := self.handle()
	defer selfFin()
	C.wrap_ImFont_SetIndexLookup(selfArg, *vVecArg)
}

func (self *Font) IndexLookup() Vector[(*Wchar)] {
	selfArg, selfFin := self.handle()

	defer func() {
		selfFin()
	}()
	return newVectorFromC(C.wrap_ImFont_GetIndexLookup(selfArg).Size, C.wrap_ImFont_GetIndexLookup(selfArg).Capacity, (*Wchar)(C.wrap_ImFont_GetIndexLookup(selfArg).Data))
}

func (self Font) SetGlyphs(v Vector[*FontGlyph]) {
	vData := v.Data
	vDataArg, _ := vData.handle()
	vVecArg := new(C.ImVector_ImFontGlyph)
	vVecArg.Size = C.int(v.Size)
	vVecArg.Capacity = C.int(v.Capacity)
	vVecArg.Data = vDataArg
	v.pinner.Pin(vVecArg.Data)

	selfArg, selfFin := self.handle()
	defer selfFin()
	C.wrap_ImFont_SetGlyphs(selfArg, *vVecArg)
}

func (self *Font) Glyphs() Vector[*FontGlyph] {
	selfArg, selfFin := self.handle()

	defer func() {
		selfFin()
	}()
	return newVectorFromC(C.wrap_ImFont_GetGlyphs(selfArg).Size, C.wrap_ImFont_GetGlyphs(selfArg).Capacity, newFontGlyphFromC(C.wrap_ImFont_GetGlyphs(selfArg).Data))
}

func (self Font) SetFallbackGlyph(v *FontGlyph) {
	vArg, _ := v.handle()

	selfArg, selfFin := self.handle()
	defer selfFin()
	C.wrap_ImFont_SetFallbackGlyph(selfArg, vArg)
}

func (self *Font) FallbackGlyph() *FontGlyph {
	selfArg, selfFin := self.handle()

	defer func() {
		selfFin()
	}()
	return newFontGlyphFromC(C.wrap_ImFont_GetFallbackGlyph(selfArg))
}

func (self Font) SetContainerAtlas(v *FontAtlas) {
	vArg, _ := v.handle()

	selfArg, selfFin := self.handle()
	defer selfFin()
	C.wrap_ImFont_SetContainerAtlas(selfArg, vArg)
}

func (self *Font) ContainerAtlas() *FontAtlas {
	selfArg, selfFin := self.handle()

	defer func() {
		selfFin()
	}()
	return newFontAtlasFromC(C.wrap_ImFont_GetContainerAtlas(selfArg))
}

func (self Font) SetConfigData(v *FontConfig) {
	vArg, _ := v.handle()

	selfArg, selfFin := self.handle()
	defer selfFin()
	C.wrap_ImFont_SetConfigData(selfArg, vArg)
}

func (self *Font) ConfigData() *FontConfig {
	selfArg, selfFin := self.handle()

	defer func() {
		selfFin()
	}()
	return newFontConfigFromC(C.wrap_ImFont_GetConfigData(selfArg))
}

func (self Font) SetConfigDataCount(v int16) {
	selfArg, selfFin := self.handle()
	defer selfFin()
	C.wrap_ImFont_SetConfigDataCount(selfArg, C.short(v))
}

func (self *Font) ConfigDataCount() int16 {
	selfArg, selfFin := self.handle()

	defer func() {
		selfFin()
	}()
	return int16(C.wrap_ImFont_GetConfigDataCount(selfArg))
}

func (self Font) SetFallbackChar(v Wchar) {
	selfArg, selfFin := self.handle()
	defer selfFin()
	C.wrap_ImFont_SetFallbackChar(selfArg, C.ImWchar(v))
}

func (self *Font) FallbackChar() Wchar {
	selfArg, selfFin := self.handle()

	defer func() {
		selfFin()
	}()
	return Wchar(C.wrap_ImFont_GetFallbackChar(selfArg))
}

func (self Font) SetEllipsisChar(v Wchar) {
	selfArg, selfFin := self.handle()
	defer selfFin()
	C.wrap_ImFont_SetEllipsisChar(selfArg, C.ImWchar(v))
}

func (self *Font) EllipsisChar() Wchar {
	selfArg, selfFin := self.handle()

	defer func() {
		selfFin()
	}()
	return Wchar(C.wrap_ImFont_GetEllipsisChar(selfArg))
}

func (self Font) SetEllipsisCharCount(v int16) {
	selfArg, selfFin := self.handle()
	defer selfFin()
	C.wrap_ImFont_SetEllipsisCharCount(selfArg, C.short(v))
}

func (self *Font) EllipsisCharCount() int16 {
	selfArg, selfFin := self.handle()

	defer func() {
		selfFin()
	}()
	return int16(C.wrap_ImFont_GetEllipsisCharCount(selfArg))
}

func (self Font) SetEllipsisWidth(v float32) {
	selfArg, selfFin := self.handle()
	defer selfFin()
	C.wrap_ImFont_SetEllipsisWidth(selfArg, C.float(v))
}

func (self *Font) EllipsisWidth() float32 {
	selfArg, selfFin := self.handle()

	defer func() {
		selfFin()
	}()
	return float32(C.wrap_ImFont_GetEllipsisWidth(selfArg))
}

func (self Font) SetEllipsisCharStep(v float32) {
	selfArg, selfFin := self.handle()
	defer selfFin()
	C.wrap_ImFont_SetEllipsisCharStep(selfArg, C.float(v))
}

func (self *Font) EllipsisCharStep() float32 {
	selfArg, selfFin := self.handle()

	defer func() {
		selfFin()
	}()
	return float32(C.wrap_ImFont_GetEllipsisCharStep(selfArg))
}

func (self Font) SetDirtyLookupTables(v bool) {
	selfArg, selfFin := self.handle()
	defer selfFin()
	C.wrap_ImFont_SetDirtyLookupTables(selfArg, C.bool(v))
}

func (self *Font) DirtyLookupTables() bool {
	selfArg, selfFin := self.handle()

	defer func() {
		selfFin()
	}()
	return C.wrap_ImFont_GetDirtyLookupTables(selfArg) == C.bool(true)
}

func (self Font) SetScale(v float32) {
	selfArg, selfFin := self.handle()
	defer selfFin()
	C.wrap_ImFont_SetScale(selfArg, C.float(v))
}

func (self *Font) Scale() float32 {
	selfArg, selfFin := self.handle()

	defer func() {
		selfFin()
	}()
	return float32(C.wrap_ImFont_GetScale(selfArg))
}

func (self Font) SetAscent(v float32) {
	selfArg, selfFin := self.handle()
	defer selfFin()
	C.wrap_ImFont_SetAscent(selfArg, C.float(v))
}

func (self *Font) Ascent() float32 {
	selfArg, selfFin := self.handle()

	defer func() {
		selfFin()
	}()
	return float32(C.wrap_ImFont_GetAscent(selfArg))
}

func (self Font) SetDescent(v float32) {
	selfArg, selfFin := self.handle()
	defer selfFin()
	C.wrap_ImFont_SetDescent(selfArg, C.float(v))
}

func (self *Font) Descent() float32 {
	selfArg, selfFin := self.handle()

	defer func() {
		selfFin()
	}()
	return float32(C.wrap_ImFont_GetDescent(selfArg))
}

func (self Font) SetMetricsTotalSurface(v int32) {
	selfArg, selfFin := self.handle()
	defer selfFin()
	C.wrap_ImFont_SetMetricsTotalSurface(selfArg, C.int(v))
}

func (self *Font) MetricsTotalSurface() int32 {
	selfArg, selfFin := self.handle()

	defer func() {
		selfFin()
	}()
	return int32(C.wrap_ImFont_GetMetricsTotalSurface(selfArg))
}

func (self FontAtlas) SetFlags(v FontAtlasFlags) {
	selfArg, selfFin := self.handle()
	defer selfFin()
	C.wrap_ImFontAtlas_SetFlags(selfArg, C.ImFontAtlasFlags(v))
}

func (self *FontAtlas) Flags() FontAtlasFlags {
	selfArg, selfFin := self.handle()

	defer func() {
		selfFin()
	}()
	return FontAtlasFlags(C.wrap_ImFontAtlas_GetFlags(selfArg))
}

func (self FontAtlas) SetTexDesiredWidth(v int32) {
	selfArg, selfFin := self.handle()
	defer selfFin()
	C.wrap_ImFontAtlas_SetTexDesiredWidth(selfArg, C.int(v))
}

func (self *FontAtlas) TexDesiredWidth() int32 {
	selfArg, selfFin := self.handle()

	defer func() {
		selfFin()
	}()
	return int32(C.wrap_ImFontAtlas_GetTexDesiredWidth(selfArg))
}

func (self FontAtlas) SetTexGlyphPadding(v int32) {
	selfArg, selfFin := self.handle()
	defer selfFin()
	C.wrap_ImFontAtlas_SetTexGlyphPadding(selfArg, C.int(v))
}

func (self *FontAtlas) TexGlyphPadding() int32 {
	selfArg, selfFin := self.handle()

	defer func() {
		selfFin()
	}()
	return int32(C.wrap_ImFontAtlas_GetTexGlyphPadding(selfArg))
}

func (self FontAtlas) SetLocked(v bool) {
	selfArg, selfFin := self.handle()
	defer selfFin()
	C.wrap_ImFontAtlas_SetLocked(selfArg, C.bool(v))
}

func (self *FontAtlas) Locked() bool {
	selfArg, selfFin := self.handle()

	defer func() {
		selfFin()
	}()
	return C.wrap_ImFontAtlas_GetLocked(selfArg) == C.bool(true)
}

func (self FontAtlas) SetUserData(v unsafe.Pointer) {
	vArg, _ := WrapVoidPtr(v)

	selfArg, selfFin := self.handle()
	defer selfFin()
	C.wrap_ImFontAtlas_SetUserData(selfArg, vArg)
}

func (self *FontAtlas) UserData() unsafe.Pointer {
	selfArg, selfFin := self.handle()

	defer func() {
		selfFin()
	}()
	return unsafe.Pointer(C.wrap_ImFontAtlas_GetUserData(selfArg))
}

func (self FontAtlas) SetTexReady(v bool) {
	selfArg, selfFin := self.handle()
	defer selfFin()
	C.wrap_ImFontAtlas_SetTexReady(selfArg, C.bool(v))
}

func (self *FontAtlas) TexReady() bool {
	selfArg, selfFin := self.handle()

	defer func() {
		selfFin()
	}()
	return C.wrap_ImFontAtlas_GetTexReady(selfArg) == C.bool(true)
}

func (self FontAtlas) SetTexPixelsUseColors(v bool) {
	selfArg, selfFin := self.handle()
	defer selfFin()
	C.wrap_ImFontAtlas_SetTexPixelsUseColors(selfArg, C.bool(v))
}

func (self *FontAtlas) TexPixelsUseColors() bool {
	selfArg, selfFin := self.handle()

	defer func() {
		selfFin()
	}()
	return C.wrap_ImFontAtlas_GetTexPixelsUseColors(selfArg) == C.bool(true)
}

func (self FontAtlas) SetTexPixelsAlpha8(v *uint) {
	vArg, _ := WrapNumberPtr[C.uchar, uint](v)

	selfArg, selfFin := self.handle()
	defer selfFin()
	C.wrap_ImFontAtlas_SetTexPixelsAlpha8(selfArg, vArg)
}

func (self *FontAtlas) TexPixelsAlpha8() *uint {
	selfArg, selfFin := self.handle()

	defer func() {
		selfFin()
	}()
	return (*uint)(unsafe.Pointer(C.wrap_ImFontAtlas_GetTexPixelsAlpha8(selfArg)))
}

func (self FontAtlas) SetTexPixelsRGBA32(v *uint32) {
	vArg, _ := WrapNumberPtr[C.uint, uint32](v)

	selfArg, selfFin := self.handle()
	defer selfFin()
	C.wrap_ImFontAtlas_SetTexPixelsRGBA32(selfArg, vArg)
}

func (self *FontAtlas) TexPixelsRGBA32() *uint32 {
	selfArg, selfFin := self.handle()

	defer func() {
		selfFin()
	}()
	return (*uint32)(C.wrap_ImFontAtlas_GetTexPixelsRGBA32(selfArg))
}

func (self FontAtlas) SetTexWidth(v int32) {
	selfArg, selfFin := self.handle()
	defer selfFin()
	C.wrap_ImFontAtlas_SetTexWidth(selfArg, C.int(v))
}

func (self *FontAtlas) TexWidth() int32 {
	selfArg, selfFin := self.handle()

	defer func() {
		selfFin()
	}()
	return int32(C.wrap_ImFontAtlas_GetTexWidth(selfArg))
}

func (self FontAtlas) SetTexHeight(v int32) {
	selfArg, selfFin := self.handle()
	defer selfFin()
	C.wrap_ImFontAtlas_SetTexHeight(selfArg, C.int(v))
}

func (self *FontAtlas) TexHeight() int32 {
	selfArg, selfFin := self.handle()

	defer func() {
		selfFin()
	}()
	return int32(C.wrap_ImFontAtlas_GetTexHeight(selfArg))
}

func (self FontAtlas) SetTexUvScale(v Vec2) {
	selfArg, selfFin := self.handle()
	defer selfFin()
	C.wrap_ImFontAtlas_SetTexUvScale(selfArg, v.toC())
}

func (self *FontAtlas) TexUvScale() Vec2 {
	selfArg, selfFin := self.handle()

	defer func() {
		selfFin()
	}()
	return *(&Vec2{}).fromC(C.wrap_ImFontAtlas_GetTexUvScale(selfArg))
}

func (self FontAtlas) SetTexUvWhitePixel(v Vec2) {
	selfArg, selfFin := self.handle()
	defer selfFin()
	C.wrap_ImFontAtlas_SetTexUvWhitePixel(selfArg, v.toC())
}

func (self *FontAtlas) TexUvWhitePixel() Vec2 {
	selfArg, selfFin := self.handle()

	defer func() {
		selfFin()
	}()
	return *(&Vec2{}).fromC(C.wrap_ImFontAtlas_GetTexUvWhitePixel(selfArg))
}

func (self FontAtlas) SetCustomRects(v Vector[*FontAtlasCustomRect]) {
	vData := v.Data
	vDataArg, _ := vData.handle()
	vVecArg := new(C.ImVector_ImFontAtlasCustomRect)
	vVecArg.Size = C.int(v.Size)
	vVecArg.Capacity = C.int(v.Capacity)
	vVecArg.Data = vDataArg
	v.pinner.Pin(vVecArg.Data)

	selfArg, selfFin := self.handle()
	defer selfFin()
	C.wrap_ImFontAtlas_SetCustomRects(selfArg, *vVecArg)
}

func (self *FontAtlas) CustomRects() Vector[*FontAtlasCustomRect] {
	selfArg, selfFin := self.handle()

	defer func() {
		selfFin()
	}()
	return newVectorFromC(C.wrap_ImFontAtlas_GetCustomRects(selfArg).Size, C.wrap_ImFontAtlas_GetCustomRects(selfArg).Capacity, newFontAtlasCustomRectFromC(C.wrap_ImFontAtlas_GetCustomRects(selfArg).Data))
}

func (self FontAtlas) SetConfigData(v Vector[*FontConfig]) {
	vData := v.Data
	vDataArg, _ := vData.handle()
	vVecArg := new(C.ImVector_ImFontConfig)
	vVecArg.Size = C.int(v.Size)
	vVecArg.Capacity = C.int(v.Capacity)
	vVecArg.Data = vDataArg
	v.pinner.Pin(vVecArg.Data)

	selfArg, selfFin := self.handle()
	defer selfFin()
	C.wrap_ImFontAtlas_SetConfigData(selfArg, *vVecArg)
}

func (self *FontAtlas) ConfigData() Vector[*FontConfig] {
	selfArg, selfFin := self.handle()

	defer func() {
		selfFin()
	}()
	return newVectorFromC(C.wrap_ImFontAtlas_GetConfigData(selfArg).Size, C.wrap_ImFontAtlas_GetConfigData(selfArg).Capacity, newFontConfigFromC(C.wrap_ImFontAtlas_GetConfigData(selfArg).Data))
}

func (self FontAtlas) SetFontBuilderIO(v *FontBuilderIO) {
	vArg, _ := v.handle()

	selfArg, selfFin := self.handle()
	defer selfFin()
	C.wrap_ImFontAtlas_SetFontBuilderIO(selfArg, vArg)
}

func (self *FontAtlas) FontBuilderIO() *FontBuilderIO {
	selfArg, selfFin := self.handle()

	defer func() {
		selfFin()
	}()
	return newFontBuilderIOFromC(C.wrap_ImFontAtlas_GetFontBuilderIO(selfArg))
}

func (self FontAtlas) SetFontBuilderFlags(v uint32) {
	selfArg, selfFin := self.handle()
	defer selfFin()
	C.wrap_ImFontAtlas_SetFontBuilderFlags(selfArg, C.uint(v))
}

func (self *FontAtlas) FontBuilderFlags() uint32 {
	selfArg, selfFin := self.handle()

	defer func() {
		selfFin()
	}()
	return uint32(C.wrap_ImFontAtlas_GetFontBuilderFlags(selfArg))
}

func (self FontAtlas) SetPackIdMouseCursors(v int32) {
	selfArg, selfFin := self.handle()
	defer selfFin()
	C.wrap_ImFontAtlas_SetPackIdMouseCursors(selfArg, C.int(v))
}

func (self *FontAtlas) PackIdMouseCursors() int32 {
	selfArg, selfFin := self.handle()

	defer func() {
		selfFin()
	}()
	return int32(C.wrap_ImFontAtlas_GetPackIdMouseCursors(selfArg))
}

func (self FontAtlas) SetPackIdLines(v int32) {
	selfArg, selfFin := self.handle()
	defer selfFin()
	C.wrap_ImFontAtlas_SetPackIdLines(selfArg, C.int(v))
}

func (self *FontAtlas) PackIdLines() int32 {
	selfArg, selfFin := self.handle()

	defer func() {
		selfFin()
	}()
	return int32(C.wrap_ImFontAtlas_GetPackIdLines(selfArg))
}

func (self FontAtlasCustomRect) SetWidth(v uint16) {
	selfArg, selfFin := self.handle()
	defer selfFin()
	C.wrap_ImFontAtlasCustomRect_SetWidth(selfArg, C.ushort(v))
}

func (self *FontAtlasCustomRect) Width() uint16 {
	selfArg, selfFin := self.handle()

	defer func() {
		selfFin()
	}()
	return uint16(C.wrap_ImFontAtlasCustomRect_GetWidth(selfArg))
}

func (self FontAtlasCustomRect) SetHeight(v uint16) {
	selfArg, selfFin := self.handle()
	defer selfFin()
	C.wrap_ImFontAtlasCustomRect_SetHeight(selfArg, C.ushort(v))
}

func (self *FontAtlasCustomRect) Height() uint16 {
	selfArg, selfFin := self.handle()

	defer func() {
		selfFin()
	}()
	return uint16(C.wrap_ImFontAtlasCustomRect_GetHeight(selfArg))
}

func (self FontAtlasCustomRect) SetX(v uint16) {
	selfArg, selfFin := self.handle()
	defer selfFin()
	C.wrap_ImFontAtlasCustomRect_SetX(selfArg, C.ushort(v))
}

func (self *FontAtlasCustomRect) X() uint16 {
	selfArg, selfFin := self.handle()

	defer func() {
		selfFin()
	}()
	return uint16(C.wrap_ImFontAtlasCustomRect_GetX(selfArg))
}

func (self FontAtlasCustomRect) SetY(v uint16) {
	selfArg, selfFin := self.handle()
	defer selfFin()
	C.wrap_ImFontAtlasCustomRect_SetY(selfArg, C.ushort(v))
}

func (self *FontAtlasCustomRect) Y() uint16 {
	selfArg, selfFin := self.handle()

	defer func() {
		selfFin()
	}()
	return uint16(C.wrap_ImFontAtlasCustomRect_GetY(selfArg))
}

func (self FontAtlasCustomRect) SetGlyphID(v uint32) {
	selfArg, selfFin := self.handle()
	defer selfFin()
	C.wrap_ImFontAtlasCustomRect_SetGlyphID(selfArg, C.uint(v))
}

func (self *FontAtlasCustomRect) GlyphID() uint32 {
	selfArg, selfFin := self.handle()

	defer func() {
		selfFin()
	}()
	return uint32(C.wrap_ImFontAtlasCustomRect_GetGlyphID(selfArg))
}

func (self FontAtlasCustomRect) SetGlyphAdvanceX(v float32) {
	selfArg, selfFin := self.handle()
	defer selfFin()
	C.wrap_ImFontAtlasCustomRect_SetGlyphAdvanceX(selfArg, C.float(v))
}

func (self *FontAtlasCustomRect) GlyphAdvanceX() float32 {
	selfArg, selfFin := self.handle()

	defer func() {
		selfFin()
	}()
	return float32(C.wrap_ImFontAtlasCustomRect_GetGlyphAdvanceX(selfArg))
}

func (self FontAtlasCustomRect) SetGlyphOffset(v Vec2) {
	selfArg, selfFin := self.handle()
	defer selfFin()
	C.wrap_ImFontAtlasCustomRect_SetGlyphOffset(selfArg, v.toC())
}

func (self *FontAtlasCustomRect) GlyphOffset() Vec2 {
	selfArg, selfFin := self.handle()

	defer func() {
		selfFin()
	}()
	return *(&Vec2{}).fromC(C.wrap_ImFontAtlasCustomRect_GetGlyphOffset(selfArg))
}

func (self FontAtlasCustomRect) SetFont(v *Font) {
	vArg, _ := v.handle()

	selfArg, selfFin := self.handle()
	defer selfFin()
	C.wrap_ImFontAtlasCustomRect_SetFont(selfArg, vArg)
}

func (self *FontAtlasCustomRect) Font() *Font {
	selfArg, selfFin := self.handle()

	defer func() {
		selfFin()
	}()
	return newFontFromC(C.wrap_ImFontAtlasCustomRect_GetFont(selfArg))
}

func (self FontConfig) SetFontData(v unsafe.Pointer) {
	vArg, _ := WrapVoidPtr(v)

	selfArg, selfFin := self.handle()
	defer selfFin()
	C.wrap_ImFontConfig_SetFontData(selfArg, vArg)
}

func (self *FontConfig) FontData() unsafe.Pointer {
	selfArg, selfFin := self.handle()

	defer func() {
		selfFin()
	}()
	return unsafe.Pointer(C.wrap_ImFontConfig_GetFontData(selfArg))
}

func (self FontConfig) SetFontDataSize(v int32) {
	selfArg, selfFin := self.handle()
	defer selfFin()
	C.wrap_ImFontConfig_SetFontDataSize(selfArg, C.int(v))
}

func (self *FontConfig) FontDataSize() int32 {
	selfArg, selfFin := self.handle()

	defer func() {
		selfFin()
	}()
	return int32(C.wrap_ImFontConfig_GetFontDataSize(selfArg))
}

func (self FontConfig) SetFontDataOwnedByAtlas(v bool) {
	selfArg, selfFin := self.handle()
	defer selfFin()
	C.wrap_ImFontConfig_SetFontDataOwnedByAtlas(selfArg, C.bool(v))
}

func (self *FontConfig) FontDataOwnedByAtlas() bool {
	selfArg, selfFin := self.handle()

	defer func() {
		selfFin()
	}()
	return C.wrap_ImFontConfig_GetFontDataOwnedByAtlas(selfArg) == C.bool(true)
}

func (self FontConfig) SetFontNo(v int32) {
	selfArg, selfFin := self.handle()
	defer selfFin()
	C.wrap_ImFontConfig_SetFontNo(selfArg, C.int(v))
}

func (self *FontConfig) FontNo() int32 {
	selfArg, selfFin := self.handle()

	defer func() {
		selfFin()
	}()
	return int32(C.wrap_ImFontConfig_GetFontNo(selfArg))
}

func (self FontConfig) SetSizePixels(v float32) {
	selfArg, selfFin := self.handle()
	defer selfFin()
	C.wrap_ImFontConfig_SetSizePixels(selfArg, C.float(v))
}

func (self *FontConfig) SizePixels() float32 {
	selfArg, selfFin := self.handle()

	defer func() {
		selfFin()
	}()
	return float32(C.wrap_ImFontConfig_GetSizePixels(selfArg))
}

func (self FontConfig) SetOversampleH(v int32) {
	selfArg, selfFin := self.handle()
	defer selfFin()
	C.wrap_ImFontConfig_SetOversampleH(selfArg, C.int(v))
}

func (self *FontConfig) OversampleH() int32 {
	selfArg, selfFin := self.handle()

	defer func() {
		selfFin()
	}()
	return int32(C.wrap_ImFontConfig_GetOversampleH(selfArg))
}

func (self FontConfig) SetOversampleV(v int32) {
	selfArg, selfFin := self.handle()
	defer selfFin()
	C.wrap_ImFontConfig_SetOversampleV(selfArg, C.int(v))
}

func (self *FontConfig) OversampleV() int32 {
	selfArg, selfFin := self.handle()

	defer func() {
		selfFin()
	}()
	return int32(C.wrap_ImFontConfig_GetOversampleV(selfArg))
}

func (self FontConfig) SetPixelSnapH(v bool) {
	selfArg, selfFin := self.handle()
	defer selfFin()
	C.wrap_ImFontConfig_SetPixelSnapH(selfArg, C.bool(v))
}

func (self *FontConfig) PixelSnapH() bool {
	selfArg, selfFin := self.handle()

	defer func() {
		selfFin()
	}()
	return C.wrap_ImFontConfig_GetPixelSnapH(selfArg) == C.bool(true)
}

func (self FontConfig) SetGlyphExtraSpacing(v Vec2) {
	selfArg, selfFin := self.handle()
	defer selfFin()
	C.wrap_ImFontConfig_SetGlyphExtraSpacing(selfArg, v.toC())
}

func (self *FontConfig) GlyphExtraSpacing() Vec2 {
	selfArg, selfFin := self.handle()

	defer func() {
		selfFin()
	}()
	return *(&Vec2{}).fromC(C.wrap_ImFontConfig_GetGlyphExtraSpacing(selfArg))
}

func (self FontConfig) SetGlyphOffset(v Vec2) {
	selfArg, selfFin := self.handle()
	defer selfFin()
	C.wrap_ImFontConfig_SetGlyphOffset(selfArg, v.toC())
}

func (self *FontConfig) GlyphOffset() Vec2 {
	selfArg, selfFin := self.handle()

	defer func() {
		selfFin()
	}()
	return *(&Vec2{}).fromC(C.wrap_ImFontConfig_GetGlyphOffset(selfArg))
}

func (self FontConfig) SetGlyphRanges(v *Wchar) {
	selfArg, selfFin := self.handle()
	defer selfFin()
	C.wrap_ImFontConfig_SetGlyphRanges(selfArg, (*C.ImWchar)(v))
}

func (self *FontConfig) GlyphRanges() *Wchar {
	selfArg, selfFin := self.handle()

	defer func() {
		selfFin()
	}()
	return (*Wchar)(C.wrap_ImFontConfig_GetGlyphRanges(selfArg))
}

func (self FontConfig) SetGlyphMinAdvanceX(v float32) {
	selfArg, selfFin := self.handle()
	defer selfFin()
	C.wrap_ImFontConfig_SetGlyphMinAdvanceX(selfArg, C.float(v))
}

func (self *FontConfig) GlyphMinAdvanceX() float32 {
	selfArg, selfFin := self.handle()

	defer func() {
		selfFin()
	}()
	return float32(C.wrap_ImFontConfig_GetGlyphMinAdvanceX(selfArg))
}

func (self FontConfig) SetGlyphMaxAdvanceX(v float32) {
	selfArg, selfFin := self.handle()
	defer selfFin()
	C.wrap_ImFontConfig_SetGlyphMaxAdvanceX(selfArg, C.float(v))
}

func (self *FontConfig) GlyphMaxAdvanceX() float32 {
	selfArg, selfFin := self.handle()

	defer func() {
		selfFin()
	}()
	return float32(C.wrap_ImFontConfig_GetGlyphMaxAdvanceX(selfArg))
}

func (self FontConfig) SetMergeMode(v bool) {
	selfArg, selfFin := self.handle()
	defer selfFin()
	C.wrap_ImFontConfig_SetMergeMode(selfArg, C.bool(v))
}

func (self *FontConfig) MergeMode() bool {
	selfArg, selfFin := self.handle()

	defer func() {
		selfFin()
	}()
	return C.wrap_ImFontConfig_GetMergeMode(selfArg) == C.bool(true)
}

func (self FontConfig) SetFontBuilderFlags(v uint32) {
	selfArg, selfFin := self.handle()
	defer selfFin()
	C.wrap_ImFontConfig_SetFontBuilderFlags(selfArg, C.uint(v))
}

func (self *FontConfig) FontBuilderFlags() uint32 {
	selfArg, selfFin := self.handle()

	defer func() {
		selfFin()
	}()
	return uint32(C.wrap_ImFontConfig_GetFontBuilderFlags(selfArg))
}

func (self FontConfig) SetRasterizerMultiply(v float32) {
	selfArg, selfFin := self.handle()
	defer selfFin()
	C.wrap_ImFontConfig_SetRasterizerMultiply(selfArg, C.float(v))
}

func (self *FontConfig) RasterizerMultiply() float32 {
	selfArg, selfFin := self.handle()

	defer func() {
		selfFin()
	}()
	return float32(C.wrap_ImFontConfig_GetRasterizerMultiply(selfArg))
}

func (self FontConfig) SetEllipsisChar(v Wchar) {
	selfArg, selfFin := self.handle()
	defer selfFin()
	C.wrap_ImFontConfig_SetEllipsisChar(selfArg, C.ImWchar(v))
}

func (self *FontConfig) EllipsisChar() Wchar {
	selfArg, selfFin := self.handle()

	defer func() {
		selfFin()
	}()
	return Wchar(C.wrap_ImFontConfig_GetEllipsisChar(selfArg))
}

func (self FontConfig) SetDstFont(v *Font) {
	vArg, _ := v.handle()

	selfArg, selfFin := self.handle()
	defer selfFin()
	C.wrap_ImFontConfig_SetDstFont(selfArg, vArg)
}

func (self *FontConfig) DstFont() *Font {
	selfArg, selfFin := self.handle()

	defer func() {
		selfFin()
	}()
	return newFontFromC(C.wrap_ImFontConfig_GetDstFont(selfArg))
}

func (self FontGlyph) SetColored(v uint32) {
	selfArg, selfFin := self.handle()
	defer selfFin()
	C.wrap_ImFontGlyph_SetColored(selfArg, C.uint(v))
}

func (self *FontGlyph) Colored() uint32 {
	selfArg, selfFin := self.handle()

	defer func() {
		selfFin()
	}()
	return uint32(C.wrap_ImFontGlyph_GetColored(selfArg))
}

func (self FontGlyph) SetVisible(v uint32) {
	selfArg, selfFin := self.handle()
	defer selfFin()
	C.wrap_ImFontGlyph_SetVisible(selfArg, C.uint(v))
}

func (self *FontGlyph) Visible() uint32 {
	selfArg, selfFin := self.handle()

	defer func() {
		selfFin()
	}()
	return uint32(C.wrap_ImFontGlyph_GetVisible(selfArg))
}

func (self FontGlyph) SetCodepoint(v uint32) {
	selfArg, selfFin := self.handle()
	defer selfFin()
	C.wrap_ImFontGlyph_SetCodepoint(selfArg, C.uint(v))
}

func (self *FontGlyph) Codepoint() uint32 {
	selfArg, selfFin := self.handle()

	defer func() {
		selfFin()
	}()
	return uint32(C.wrap_ImFontGlyph_GetCodepoint(selfArg))
}

func (self FontGlyph) SetAdvanceX(v float32) {
	selfArg, selfFin := self.handle()
	defer selfFin()
	C.wrap_ImFontGlyph_SetAdvanceX(selfArg, C.float(v))
}

func (self *FontGlyph) AdvanceX() float32 {
	selfArg, selfFin := self.handle()

	defer func() {
		selfFin()
	}()
	return float32(C.wrap_ImFontGlyph_GetAdvanceX(selfArg))
}

func (self FontGlyph) SetX0(v float32) {
	selfArg, selfFin := self.handle()
	defer selfFin()
	C.wrap_ImFontGlyph_SetX0(selfArg, C.float(v))
}

func (self *FontGlyph) X0() float32 {
	selfArg, selfFin := self.handle()

	defer func() {
		selfFin()
	}()
	return float32(C.wrap_ImFontGlyph_GetX0(selfArg))
}

func (self FontGlyph) SetY0(v float32) {
	selfArg, selfFin := self.handle()
	defer selfFin()
	C.wrap_ImFontGlyph_SetY0(selfArg, C.float(v))
}

func (self *FontGlyph) Y0() float32 {
	selfArg, selfFin := self.handle()

	defer func() {
		selfFin()
	}()
	return float32(C.wrap_ImFontGlyph_GetY0(selfArg))
}

func (self FontGlyph) SetX1(v float32) {
	selfArg, selfFin := self.handle()
	defer selfFin()
	C.wrap_ImFontGlyph_SetX1(selfArg, C.float(v))
}

func (self *FontGlyph) X1() float32 {
	selfArg, selfFin := self.handle()

	defer func() {
		selfFin()
	}()
	return float32(C.wrap_ImFontGlyph_GetX1(selfArg))
}

func (self FontGlyph) SetY1(v float32) {
	selfArg, selfFin := self.handle()
	defer selfFin()
	C.wrap_ImFontGlyph_SetY1(selfArg, C.float(v))
}

func (self *FontGlyph) Y1() float32 {
	selfArg, selfFin := self.handle()

	defer func() {
		selfFin()
	}()
	return float32(C.wrap_ImFontGlyph_GetY1(selfArg))
}

func (self FontGlyph) SetU0(v float32) {
	selfArg, selfFin := self.handle()
	defer selfFin()
	C.wrap_ImFontGlyph_SetU0(selfArg, C.float(v))
}

func (self *FontGlyph) U0() float32 {
	selfArg, selfFin := self.handle()

	defer func() {
		selfFin()
	}()
	return float32(C.wrap_ImFontGlyph_GetU0(selfArg))
}

func (self FontGlyph) SetV0(v float32) {
	selfArg, selfFin := self.handle()
	defer selfFin()
	C.wrap_ImFontGlyph_SetV0(selfArg, C.float(v))
}

func (self *FontGlyph) V0() float32 {
	selfArg, selfFin := self.handle()

	defer func() {
		selfFin()
	}()
	return float32(C.wrap_ImFontGlyph_GetV0(selfArg))
}

func (self FontGlyph) SetU1(v float32) {
	selfArg, selfFin := self.handle()
	defer selfFin()
	C.wrap_ImFontGlyph_SetU1(selfArg, C.float(v))
}

func (self *FontGlyph) U1() float32 {
	selfArg, selfFin := self.handle()

	defer func() {
		selfFin()
	}()
	return float32(C.wrap_ImFontGlyph_GetU1(selfArg))
}

func (self FontGlyph) SetV1(v float32) {
	selfArg, selfFin := self.handle()
	defer selfFin()
	C.wrap_ImFontGlyph_SetV1(selfArg, C.float(v))
}

func (self *FontGlyph) V1() float32 {
	selfArg, selfFin := self.handle()

	defer func() {
		selfFin()
	}()
	return float32(C.wrap_ImFontGlyph_GetV1(selfArg))
}

func (self FontGlyphRangesBuilder) SetUsedChars(v Vector[*uint32]) {
	vData := v.Data
	vDataArg, _ := WrapNumberPtr[C.ImU32, uint32](vData)
	vVecArg := new(C.ImVector_ImU32)
	vVecArg.Size = C.int(v.Size)
	vVecArg.Capacity = C.int(v.Capacity)
	vVecArg.Data = vDataArg
	v.pinner.Pin(vVecArg.Data)

	selfArg, selfFin := self.handle()
	defer selfFin()
	C.wrap_ImFontGlyphRangesBuilder_SetUsedChars(selfArg, *vVecArg)
}

func (self *FontGlyphRangesBuilder) UsedChars() Vector[*uint32] {
	selfArg, selfFin := self.handle()

	defer func() {
		selfFin()
	}()
	return newVectorFromC(C.wrap_ImFontGlyphRangesBuilder_GetUsedChars(selfArg).Size, C.wrap_ImFontGlyphRangesBuilder_GetUsedChars(selfArg).Capacity, (*uint32)(C.wrap_ImFontGlyphRangesBuilder_GetUsedChars(selfArg).Data))
}

func (self ColorMod) SetCol(v Col) {
	selfArg, selfFin := self.handle()
	defer selfFin()
	C.wrap_ImGuiColorMod_SetCol(selfArg, C.ImGuiCol(v))
}

func (self *ColorMod) Col() Col {
	selfArg, selfFin := self.handle()

	defer func() {
		selfFin()
	}()
	return Col(C.wrap_ImGuiColorMod_GetCol(selfArg))
}

func (self ColorMod) SetBackupValue(v Vec4) {
	selfArg, selfFin := self.handle()
	defer selfFin()
	C.wrap_ImGuiColorMod_SetBackupValue(selfArg, v.toC())
}

func (self *ColorMod) BackupValue() Vec4 {
	selfArg, selfFin := self.handle()

	defer func() {
		selfFin()
	}()
	return *(&Vec4{}).fromC(C.wrap_ImGuiColorMod_GetBackupValue(selfArg))
}

func (self ComboPreviewData) SetPreviewRect(v Rect) {
	selfArg, selfFin := self.handle()
	defer selfFin()
	C.wrap_ImGuiComboPreviewData_SetPreviewRect(selfArg, v.toC())
}

func (self *ComboPreviewData) PreviewRect() Rect {
	selfArg, selfFin := self.handle()

	defer func() {
		selfFin()
	}()
	return *(&Rect{}).fromC(C.wrap_ImGuiComboPreviewData_GetPreviewRect(selfArg))
}

func (self ComboPreviewData) SetBackupCursorPos(v Vec2) {
	selfArg, selfFin := self.handle()
	defer selfFin()
	C.wrap_ImGuiComboPreviewData_SetBackupCursorPos(selfArg, v.toC())
}

func (self *ComboPreviewData) BackupCursorPos() Vec2 {
	selfArg, selfFin := self.handle()

	defer func() {
		selfFin()
	}()
	return *(&Vec2{}).fromC(C.wrap_ImGuiComboPreviewData_GetBackupCursorPos(selfArg))
}

func (self ComboPreviewData) SetBackupCursorMaxPos(v Vec2) {
	selfArg, selfFin := self.handle()
	defer selfFin()
	C.wrap_ImGuiComboPreviewData_SetBackupCursorMaxPos(selfArg, v.toC())
}

func (self *ComboPreviewData) BackupCursorMaxPos() Vec2 {
	selfArg, selfFin := self.handle()

	defer func() {
		selfFin()
	}()
	return *(&Vec2{}).fromC(C.wrap_ImGuiComboPreviewData_GetBackupCursorMaxPos(selfArg))
}

func (self ComboPreviewData) SetBackupCursorPosPrevLine(v Vec2) {
	selfArg, selfFin := self.handle()
	defer selfFin()
	C.wrap_ImGuiComboPreviewData_SetBackupCursorPosPrevLine(selfArg, v.toC())
}

func (self *ComboPreviewData) BackupCursorPosPrevLine() Vec2 {
	selfArg, selfFin := self.handle()

	defer func() {
		selfFin()
	}()
	return *(&Vec2{}).fromC(C.wrap_ImGuiComboPreviewData_GetBackupCursorPosPrevLine(selfArg))
}

func (self ComboPreviewData) SetBackupPrevLineTextBaseOffset(v float32) {
	selfArg, selfFin := self.handle()
	defer selfFin()
	C.wrap_ImGuiComboPreviewData_SetBackupPrevLineTextBaseOffset(selfArg, C.float(v))
}

func (self *ComboPreviewData) BackupPrevLineTextBaseOffset() float32 {
	selfArg, selfFin := self.handle()

	defer func() {
		selfFin()
	}()
	return float32(C.wrap_ImGuiComboPreviewData_GetBackupPrevLineTextBaseOffset(selfArg))
}

func (self ComboPreviewData) SetBackupLayout(v LayoutType) {
	selfArg, selfFin := self.handle()
	defer selfFin()
	C.wrap_ImGuiComboPreviewData_SetBackupLayout(selfArg, C.ImGuiLayoutType(v))
}

func (self *ComboPreviewData) BackupLayout() LayoutType {
	selfArg, selfFin := self.handle()

	defer func() {
		selfFin()
	}()
	return LayoutType(C.wrap_ImGuiComboPreviewData_GetBackupLayout(selfArg))
}

func (self Context) SetInitialized(v bool) {
	selfArg, selfFin := self.handle()
	defer selfFin()
	C.wrap_ImGuiContext_SetInitialized(selfArg, C.bool(v))
}

func (self *Context) Initialized() bool {
	selfArg, selfFin := self.handle()

	defer func() {
		selfFin()
	}()
	return C.wrap_ImGuiContext_GetInitialized(selfArg) == C.bool(true)
}

func (self Context) SetFontAtlasOwnedByContext(v bool) {
	selfArg, selfFin := self.handle()
	defer selfFin()
	C.wrap_ImGuiContext_SetFontAtlasOwnedByContext(selfArg, C.bool(v))
}

func (self *Context) FontAtlasOwnedByContext() bool {
	selfArg, selfFin := self.handle()

	defer func() {
		selfFin()
	}()
	return C.wrap_ImGuiContext_GetFontAtlasOwnedByContext(selfArg) == C.bool(true)
}

func (self Context) SetIO(v IO) {
	vArg, _ := v.c()

	selfArg, selfFin := self.handle()
	defer selfFin()
	C.wrap_ImGuiContext_SetIO(selfArg, vArg)
}

func (self *Context) IO() IO {
	selfArg, selfFin := self.handle()

	defer func() {
		selfFin()
	}()

	result := C.wrap_ImGuiContext_GetIO(selfArg)
	return *newIOFromC(func() *C.ImGuiIO { result := result; return &result }())
}

func (self Context) SetPlatformIO(v PlatformIO) {
	vArg, _ := v.c()

	selfArg, selfFin := self.handle()
	defer selfFin()
	C.wrap_ImGuiContext_SetPlatformIO(selfArg, vArg)
}

func (self *Context) PlatformIO() PlatformIO {
	selfArg, selfFin := self.handle()

	defer func() {
		selfFin()
	}()

	result := C.wrap_ImGuiContext_GetPlatformIO(selfArg)
	return *newPlatformIOFromC(func() *C.ImGuiPlatformIO { result := result; return &result }())
}

func (self Context) SetStyle(v Style) {
	vArg, _ := v.c()

	selfArg, selfFin := self.handle()
	defer selfFin()
	C.wrap_ImGuiContext_SetStyle(selfArg, vArg)
}

func (self *Context) Style() Style {
	selfArg, selfFin := self.handle()

	defer func() {
		selfFin()
	}()

	result := C.wrap_ImGuiContext_GetStyle(selfArg)
	return *newStyleFromC(func() *C.ImGuiStyle { result := result; return &result }())
}

func (self Context) SetConfigFlagsCurrFrame(v ConfigFlags) {
	selfArg, selfFin := self.handle()
	defer selfFin()
	C.wrap_ImGuiContext_SetConfigFlagsCurrFrame(selfArg, C.ImGuiConfigFlags(v))
}

func (self *Context) ConfigFlagsCurrFrame() ConfigFlags {
	selfArg, selfFin := self.handle()

	defer func() {
		selfFin()
	}()
	return ConfigFlags(C.wrap_ImGuiContext_GetConfigFlagsCurrFrame(selfArg))
}

func (self Context) SetConfigFlagsLastFrame(v ConfigFlags) {
	selfArg, selfFin := self.handle()
	defer selfFin()
	C.wrap_ImGuiContext_SetConfigFlagsLastFrame(selfArg, C.ImGuiConfigFlags(v))
}

func (self *Context) ConfigFlagsLastFrame() ConfigFlags {
	selfArg, selfFin := self.handle()

	defer func() {
		selfFin()
	}()
	return ConfigFlags(C.wrap_ImGuiContext_GetConfigFlagsLastFrame(selfArg))
}

func (self Context) SetFont(v *Font) {
	vArg, _ := v.handle()

	selfArg, selfFin := self.handle()
	defer selfFin()
	C.wrap_ImGuiContext_SetFont(selfArg, vArg)
}

func (self *Context) Font() *Font {
	selfArg, selfFin := self.handle()

	defer func() {
		selfFin()
	}()
	return newFontFromC(C.wrap_ImGuiContext_GetFont(selfArg))
}

func (self Context) SetFontSize(v float32) {
	selfArg, selfFin := self.handle()
	defer selfFin()
	C.wrap_ImGuiContext_SetFontSize(selfArg, C.float(v))
}

func (self *Context) FontSize() float32 {
	selfArg, selfFin := self.handle()

	defer func() {
		selfFin()
	}()
	return float32(C.wrap_ImGuiContext_GetFontSize(selfArg))
}

func (self Context) SetFontBaseSize(v float32) {
	selfArg, selfFin := self.handle()
	defer selfFin()
	C.wrap_ImGuiContext_SetFontBaseSize(selfArg, C.float(v))
}

func (self *Context) FontBaseSize() float32 {
	selfArg, selfFin := self.handle()

	defer func() {
		selfFin()
	}()
	return float32(C.wrap_ImGuiContext_GetFontBaseSize(selfArg))
}

func (self Context) SetDrawListSharedData(v DrawListSharedData) {
	vArg, _ := v.c()

	selfArg, selfFin := self.handle()
	defer selfFin()
	C.wrap_ImGuiContext_SetDrawListSharedData(selfArg, vArg)
}

func (self *Context) DrawListSharedData() DrawListSharedData {
	selfArg, selfFin := self.handle()

	defer func() {
		selfFin()
	}()

	result := C.wrap_ImGuiContext_GetDrawListSharedData(selfArg)
	return *newDrawListSharedDataFromC(func() *C.ImDrawListSharedData { result := result; return &result }())
}

func (self Context) SetTime(v float64) {
	selfArg, selfFin := self.handle()
	defer selfFin()
	C.wrap_ImGuiContext_SetTime(selfArg, C.double(v))
}

func (self *Context) Time() float64 {
	selfArg, selfFin := self.handle()

	defer func() {
		selfFin()
	}()
	return float64(C.wrap_ImGuiContext_GetTime(selfArg))
}

func (self Context) SetFrameCount(v int32) {
	selfArg, selfFin := self.handle()
	defer selfFin()
	C.wrap_ImGuiContext_SetFrameCount(selfArg, C.int(v))
}

func (self *Context) FrameCount() int32 {
	selfArg, selfFin := self.handle()

	defer func() {
		selfFin()
	}()
	return int32(C.wrap_ImGuiContext_GetFrameCount(selfArg))
}

func (self Context) SetFrameCountEnded(v int32) {
	selfArg, selfFin := self.handle()
	defer selfFin()
	C.wrap_ImGuiContext_SetFrameCountEnded(selfArg, C.int(v))
}

func (self *Context) FrameCountEnded() int32 {
	selfArg, selfFin := self.handle()

	defer func() {
		selfFin()
	}()
	return int32(C.wrap_ImGuiContext_GetFrameCountEnded(selfArg))
}

func (self Context) SetFrameCountPlatformEnded(v int32) {
	selfArg, selfFin := self.handle()
	defer selfFin()
	C.wrap_ImGuiContext_SetFrameCountPlatformEnded(selfArg, C.int(v))
}

func (self *Context) FrameCountPlatformEnded() int32 {
	selfArg, selfFin := self.handle()

	defer func() {
		selfFin()
	}()
	return int32(C.wrap_ImGuiContext_GetFrameCountPlatformEnded(selfArg))
}

func (self Context) SetFrameCountRendered(v int32) {
	selfArg, selfFin := self.handle()
	defer selfFin()
	C.wrap_ImGuiContext_SetFrameCountRendered(selfArg, C.int(v))
}

func (self *Context) FrameCountRendered() int32 {
	selfArg, selfFin := self.handle()

	defer func() {
		selfFin()
	}()
	return int32(C.wrap_ImGuiContext_GetFrameCountRendered(selfArg))
}

func (self Context) SetWithinFrameScope(v bool) {
	selfArg, selfFin := self.handle()
	defer selfFin()
	C.wrap_ImGuiContext_SetWithinFrameScope(selfArg, C.bool(v))
}

func (self *Context) WithinFrameScope() bool {
	selfArg, selfFin := self.handle()

	defer func() {
		selfFin()
	}()
	return C.wrap_ImGuiContext_GetWithinFrameScope(selfArg) == C.bool(true)
}

func (self Context) SetWithinFrameScopeWithImplicitWindow(v bool) {
	selfArg, selfFin := self.handle()
	defer selfFin()
	C.wrap_ImGuiContext_SetWithinFrameScopeWithImplicitWindow(selfArg, C.bool(v))
}

func (self *Context) WithinFrameScopeWithImplicitWindow() bool {
	selfArg, selfFin := self.handle()

	defer func() {
		selfFin()
	}()
	return C.wrap_ImGuiContext_GetWithinFrameScopeWithImplicitWindow(selfArg) == C.bool(true)
}

func (self Context) SetWithinEndChild(v bool) {
	selfArg, selfFin := self.handle()
	defer selfFin()
	C.wrap_ImGuiContext_SetWithinEndChild(selfArg, C.bool(v))
}

func (self *Context) WithinEndChild() bool {
	selfArg, selfFin := self.handle()

	defer func() {
		selfFin()
	}()
	return C.wrap_ImGuiContext_GetWithinEndChild(selfArg) == C.bool(true)
}

func (self Context) SetGcCompactAll(v bool) {
	selfArg, selfFin := self.handle()
	defer selfFin()
	C.wrap_ImGuiContext_SetGcCompactAll(selfArg, C.bool(v))
}

func (self *Context) GcCompactAll() bool {
	selfArg, selfFin := self.handle()

	defer func() {
		selfFin()
	}()
	return C.wrap_ImGuiContext_GetGcCompactAll(selfArg) == C.bool(true)
}

func (self Context) SetTestEngineHookItems(v bool) {
	selfArg, selfFin := self.handle()
	defer selfFin()
	C.wrap_ImGuiContext_SetTestEngineHookItems(selfArg, C.bool(v))
}

func (self *Context) TestEngineHookItems() bool {
	selfArg, selfFin := self.handle()

	defer func() {
		selfFin()
	}()
	return C.wrap_ImGuiContext_GetTestEngineHookItems(selfArg) == C.bool(true)
}

func (self Context) SetTestEngine(v unsafe.Pointer) {
	vArg, _ := WrapVoidPtr(v)

	selfArg, selfFin := self.handle()
	defer selfFin()
	C.wrap_ImGuiContext_SetTestEngine(selfArg, vArg)
}

func (self *Context) TestEngine() unsafe.Pointer {
	selfArg, selfFin := self.handle()

	defer func() {
		selfFin()
	}()
	return unsafe.Pointer(C.wrap_ImGuiContext_GetTestEngine(selfArg))
}

func (self Context) SetInputEventsQueue(v Vector[*InputEvent]) {
	vData := v.Data
	vDataArg, _ := vData.handle()
	vVecArg := new(C.ImVector_ImGuiInputEvent)
	vVecArg.Size = C.int(v.Size)
	vVecArg.Capacity = C.int(v.Capacity)
	vVecArg.Data = vDataArg
	v.pinner.Pin(vVecArg.Data)

	selfArg, selfFin := self.handle()
	defer selfFin()
	C.wrap_ImGuiContext_SetInputEventsQueue(selfArg, *vVecArg)
}

func (self *Context) InputEventsQueue() Vector[*InputEvent] {
	selfArg, selfFin := self.handle()

	defer func() {
		selfFin()
	}()
	return newVectorFromC(C.wrap_ImGuiContext_GetInputEventsQueue(selfArg).Size, C.wrap_ImGuiContext_GetInputEventsQueue(selfArg).Capacity, newInputEventFromC(C.wrap_ImGuiContext_GetInputEventsQueue(selfArg).Data))
}

func (self Context) SetInputEventsTrail(v Vector[*InputEvent]) {
	vData := v.Data
	vDataArg, _ := vData.handle()
	vVecArg := new(C.ImVector_ImGuiInputEvent)
	vVecArg.Size = C.int(v.Size)
	vVecArg.Capacity = C.int(v.Capacity)
	vVecArg.Data = vDataArg
	v.pinner.Pin(vVecArg.Data)

	selfArg, selfFin := self.handle()
	defer selfFin()
	C.wrap_ImGuiContext_SetInputEventsTrail(selfArg, *vVecArg)
}

func (self *Context) InputEventsTrail() Vector[*InputEvent] {
	selfArg, selfFin := self.handle()

	defer func() {
		selfFin()
	}()
	return newVectorFromC(C.wrap_ImGuiContext_GetInputEventsTrail(selfArg).Size, C.wrap_ImGuiContext_GetInputEventsTrail(selfArg).Capacity, newInputEventFromC(C.wrap_ImGuiContext_GetInputEventsTrail(selfArg).Data))
}

func (self Context) SetInputEventsNextMouseSource(v MouseSource) {
	selfArg, selfFin := self.handle()
	defer selfFin()
	C.wrap_ImGuiContext_SetInputEventsNextMouseSource(selfArg, C.ImGuiMouseSource(v))
}

func (self *Context) InputEventsNextMouseSource() MouseSource {
	selfArg, selfFin := self.handle()

	defer func() {
		selfFin()
	}()
	return MouseSource(C.wrap_ImGuiContext_GetInputEventsNextMouseSource(selfArg))
}

func (self Context) SetInputEventsNextEventId(v uint32) {
	selfArg, selfFin := self.handle()
	defer selfFin()
	C.wrap_ImGuiContext_SetInputEventsNextEventId(selfArg, C.ImU32(v))
}

func (self *Context) InputEventsNextEventId() uint32 {
	selfArg, selfFin := self.handle()

	defer func() {
		selfFin()
	}()
	return uint32(C.wrap_ImGuiContext_GetInputEventsNextEventId(selfArg))
}

func (self Context) SetCurrentWindowStack(v Vector[*WindowStackData]) {
	vData := v.Data
	vDataArg, _ := vData.handle()
	vVecArg := new(C.ImVector_ImGuiWindowStackData)
	vVecArg.Size = C.int(v.Size)
	vVecArg.Capacity = C.int(v.Capacity)
	vVecArg.Data = vDataArg
	v.pinner.Pin(vVecArg.Data)

	selfArg, selfFin := self.handle()
	defer selfFin()
	C.wrap_ImGuiContext_SetCurrentWindowStack(selfArg, *vVecArg)
}

func (self *Context) CurrentWindowStack() Vector[*WindowStackData] {
	selfArg, selfFin := self.handle()

	defer func() {
		selfFin()
	}()
	return newVectorFromC(C.wrap_ImGuiContext_GetCurrentWindowStack(selfArg).Size, C.wrap_ImGuiContext_GetCurrentWindowStack(selfArg).Capacity, newWindowStackDataFromC(C.wrap_ImGuiContext_GetCurrentWindowStack(selfArg).Data))
}

func (self Context) SetWindowsById(v Storage) {
	vArg, _ := v.c()

	selfArg, selfFin := self.handle()
	defer selfFin()
	C.wrap_ImGuiContext_SetWindowsById(selfArg, vArg)
}

func (self *Context) WindowsById() Storage {
	selfArg, selfFin := self.handle()

	defer func() {
		selfFin()
	}()

	result := C.wrap_ImGuiContext_GetWindowsById(selfArg)
	return *newStorageFromC(func() *C.ImGuiStorage { result := result; return &result }())
}

func (self Context) SetWindowsActiveCount(v int32) {
	selfArg, selfFin := self.handle()
	defer selfFin()
	C.wrap_ImGuiContext_SetWindowsActiveCount(selfArg, C.int(v))
}

func (self *Context) WindowsActiveCount() int32 {
	selfArg, selfFin := self.handle()

	defer func() {
		selfFin()
	}()
	return int32(C.wrap_ImGuiContext_GetWindowsActiveCount(selfArg))
}

func (self Context) SetWindowsHoverPadding(v Vec2) {
	selfArg, selfFin := self.handle()
	defer selfFin()
	C.wrap_ImGuiContext_SetWindowsHoverPadding(selfArg, v.toC())
}

func (self *Context) WindowsHoverPadding() Vec2 {
	selfArg, selfFin := self.handle()

	defer func() {
		selfFin()
	}()
	return *(&Vec2{}).fromC(C.wrap_ImGuiContext_GetWindowsHoverPadding(selfArg))
}

func (self Context) SetCurrentWindow(v *Window) {
	vArg, _ := v.handle()

	selfArg, selfFin := self.handle()
	defer selfFin()
	C.wrap_ImGuiContext_SetCurrentWindow(selfArg, vArg)
}

func (self *Context) CurrentWindow() *Window {
	selfArg, selfFin := self.handle()

	defer func() {
		selfFin()
	}()
	return newWindowFromC(C.wrap_ImGuiContext_GetCurrentWindow(selfArg))
}

func (self Context) SetHoveredWindow(v *Window) {
	vArg, _ := v.handle()

	selfArg, selfFin := self.handle()
	defer selfFin()
	C.wrap_ImGuiContext_SetHoveredWindow(selfArg, vArg)
}

func (self *Context) HoveredWindow() *Window {
	selfArg, selfFin := self.handle()

	defer func() {
		selfFin()
	}()
	return newWindowFromC(C.wrap_ImGuiContext_GetHoveredWindow(selfArg))
}

func (self Context) SetHoveredWindowUnderMovingWindow(v *Window) {
	vArg, _ := v.handle()

	selfArg, selfFin := self.handle()
	defer selfFin()
	C.wrap_ImGuiContext_SetHoveredWindowUnderMovingWindow(selfArg, vArg)
}

func (self *Context) HoveredWindowUnderMovingWindow() *Window {
	selfArg, selfFin := self.handle()

	defer func() {
		selfFin()
	}()
	return newWindowFromC(C.wrap_ImGuiContext_GetHoveredWindowUnderMovingWindow(selfArg))
}

func (self Context) SetMovingWindow(v *Window) {
	vArg, _ := v.handle()

	selfArg, selfFin := self.handle()
	defer selfFin()
	C.wrap_ImGuiContext_SetMovingWindow(selfArg, vArg)
}

func (self *Context) MovingWindow() *Window {
	selfArg, selfFin := self.handle()

	defer func() {
		selfFin()
	}()
	return newWindowFromC(C.wrap_ImGuiContext_GetMovingWindow(selfArg))
}

func (self Context) SetWheelingWindow(v *Window) {
	vArg, _ := v.handle()

	selfArg, selfFin := self.handle()
	defer selfFin()
	C.wrap_ImGuiContext_SetWheelingWindow(selfArg, vArg)
}

func (self *Context) WheelingWindow() *Window {
	selfArg, selfFin := self.handle()

	defer func() {
		selfFin()
	}()
	return newWindowFromC(C.wrap_ImGuiContext_GetWheelingWindow(selfArg))
}

func (self Context) SetWheelingWindowRefMousePos(v Vec2) {
	selfArg, selfFin := self.handle()
	defer selfFin()
	C.wrap_ImGuiContext_SetWheelingWindowRefMousePos(selfArg, v.toC())
}

func (self *Context) WheelingWindowRefMousePos() Vec2 {
	selfArg, selfFin := self.handle()

	defer func() {
		selfFin()
	}()
	return *(&Vec2{}).fromC(C.wrap_ImGuiContext_GetWheelingWindowRefMousePos(selfArg))
}

func (self Context) SetWheelingWindowStartFrame(v int32) {
	selfArg, selfFin := self.handle()
	defer selfFin()
	C.wrap_ImGuiContext_SetWheelingWindowStartFrame(selfArg, C.int(v))
}

func (self *Context) WheelingWindowStartFrame() int32 {
	selfArg, selfFin := self.handle()

	defer func() {
		selfFin()
	}()
	return int32(C.wrap_ImGuiContext_GetWheelingWindowStartFrame(selfArg))
}

func (self Context) SetWheelingWindowReleaseTimer(v float32) {
	selfArg, selfFin := self.handle()
	defer selfFin()
	C.wrap_ImGuiContext_SetWheelingWindowReleaseTimer(selfArg, C.float(v))
}

func (self *Context) WheelingWindowReleaseTimer() float32 {
	selfArg, selfFin := self.handle()

	defer func() {
		selfFin()
	}()
	return float32(C.wrap_ImGuiContext_GetWheelingWindowReleaseTimer(selfArg))
}

func (self Context) SetWheelingWindowWheelRemainder(v Vec2) {
	selfArg, selfFin := self.handle()
	defer selfFin()
	C.wrap_ImGuiContext_SetWheelingWindowWheelRemainder(selfArg, v.toC())
}

func (self *Context) WheelingWindowWheelRemainder() Vec2 {
	selfArg, selfFin := self.handle()

	defer func() {
		selfFin()
	}()
	return *(&Vec2{}).fromC(C.wrap_ImGuiContext_GetWheelingWindowWheelRemainder(selfArg))
}

func (self Context) SetWheelingAxisAvg(v Vec2) {
	selfArg, selfFin := self.handle()
	defer selfFin()
	C.wrap_ImGuiContext_SetWheelingAxisAvg(selfArg, v.toC())
}

func (self *Context) WheelingAxisAvg() Vec2 {
	selfArg, selfFin := self.handle()

	defer func() {
		selfFin()
	}()
	return *(&Vec2{}).fromC(C.wrap_ImGuiContext_GetWheelingAxisAvg(selfArg))
}

func (self Context) SetDebugHookIdInfo(v ID) {
	vArg, _ := v.c()

	selfArg, selfFin := self.handle()
	defer selfFin()
	C.wrap_ImGuiContext_SetDebugHookIdInfo(selfArg, vArg)
}

func (self *Context) DebugHookIdInfo() ID {
	selfArg, selfFin := self.handle()

	defer func() {
		selfFin()
	}()

	result := C.wrap_ImGuiContext_GetDebugHookIdInfo(selfArg)
	return *newIDFromC(func() *C.ImGuiID { result := result; return &result }())
}

func (self Context) SetHoveredId(v ID) {
	vArg, _ := v.c()

	selfArg, selfFin := self.handle()
	defer selfFin()
	C.wrap_ImGuiContext_SetHoveredId(selfArg, vArg)
}

func (self *Context) HoveredId() ID {
	selfArg, selfFin := self.handle()

	defer func() {
		selfFin()
	}()

	result := C.wrap_ImGuiContext_GetHoveredId(selfArg)
	return *newIDFromC(func() *C.ImGuiID { result := result; return &result }())
}

func (self Context) SetHoveredIdPreviousFrame(v ID) {
	vArg, _ := v.c()

	selfArg, selfFin := self.handle()
	defer selfFin()
	C.wrap_ImGuiContext_SetHoveredIdPreviousFrame(selfArg, vArg)
}

func (self *Context) HoveredIdPreviousFrame() ID {
	selfArg, selfFin := self.handle()

	defer func() {
		selfFin()
	}()

	result := C.wrap_ImGuiContext_GetHoveredIdPreviousFrame(selfArg)
	return *newIDFromC(func() *C.ImGuiID { result := result; return &result }())
}

func (self Context) SetHoveredIdAllowOverlap(v bool) {
	selfArg, selfFin := self.handle()
	defer selfFin()
	C.wrap_ImGuiContext_SetHoveredIdAllowOverlap(selfArg, C.bool(v))
}

func (self *Context) HoveredIdAllowOverlap() bool {
	selfArg, selfFin := self.handle()

	defer func() {
		selfFin()
	}()
	return C.wrap_ImGuiContext_GetHoveredIdAllowOverlap(selfArg) == C.bool(true)
}

func (self Context) SetHoveredIdDisabled(v bool) {
	selfArg, selfFin := self.handle()
	defer selfFin()
	C.wrap_ImGuiContext_SetHoveredIdDisabled(selfArg, C.bool(v))
}

func (self *Context) HoveredIdDisabled() bool {
	selfArg, selfFin := self.handle()

	defer func() {
		selfFin()
	}()
	return C.wrap_ImGuiContext_GetHoveredIdDisabled(selfArg) == C.bool(true)
}

func (self Context) SetHoveredIdTimer(v float32) {
	selfArg, selfFin := self.handle()
	defer selfFin()
	C.wrap_ImGuiContext_SetHoveredIdTimer(selfArg, C.float(v))
}

func (self *Context) HoveredIdTimer() float32 {
	selfArg, selfFin := self.handle()

	defer func() {
		selfFin()
	}()
	return float32(C.wrap_ImGuiContext_GetHoveredIdTimer(selfArg))
}

func (self Context) SetHoveredIdNotActiveTimer(v float32) {
	selfArg, selfFin := self.handle()
	defer selfFin()
	C.wrap_ImGuiContext_SetHoveredIdNotActiveTimer(selfArg, C.float(v))
}

func (self *Context) HoveredIdNotActiveTimer() float32 {
	selfArg, selfFin := self.handle()

	defer func() {
		selfFin()
	}()
	return float32(C.wrap_ImGuiContext_GetHoveredIdNotActiveTimer(selfArg))
}

func (self Context) SetActiveId(v ID) {
	vArg, _ := v.c()

	selfArg, selfFin := self.handle()
	defer selfFin()
	C.wrap_ImGuiContext_SetActiveId(selfArg, vArg)
}

func (self *Context) ActiveId() ID {
	selfArg, selfFin := self.handle()

	defer func() {
		selfFin()
	}()

	result := C.wrap_ImGuiContext_GetActiveId(selfArg)
	return *newIDFromC(func() *C.ImGuiID { result := result; return &result }())
}

func (self Context) SetActiveIdIsAlive(v ID) {
	vArg, _ := v.c()

	selfArg, selfFin := self.handle()
	defer selfFin()
	C.wrap_ImGuiContext_SetActiveIdIsAlive(selfArg, vArg)
}

func (self *Context) ActiveIdIsAlive() ID {
	selfArg, selfFin := self.handle()

	defer func() {
		selfFin()
	}()

	result := C.wrap_ImGuiContext_GetActiveIdIsAlive(selfArg)
	return *newIDFromC(func() *C.ImGuiID { result := result; return &result }())
}

func (self Context) SetActiveIdTimer(v float32) {
	selfArg, selfFin := self.handle()
	defer selfFin()
	C.wrap_ImGuiContext_SetActiveIdTimer(selfArg, C.float(v))
}

func (self *Context) ActiveIdTimer() float32 {
	selfArg, selfFin := self.handle()

	defer func() {
		selfFin()
	}()
	return float32(C.wrap_ImGuiContext_GetActiveIdTimer(selfArg))
}

func (self Context) SetActiveIdIsJustActivated(v bool) {
	selfArg, selfFin := self.handle()
	defer selfFin()
	C.wrap_ImGuiContext_SetActiveIdIsJustActivated(selfArg, C.bool(v))
}

func (self *Context) ActiveIdIsJustActivated() bool {
	selfArg, selfFin := self.handle()

	defer func() {
		selfFin()
	}()
	return C.wrap_ImGuiContext_GetActiveIdIsJustActivated(selfArg) == C.bool(true)
}

func (self Context) SetActiveIdAllowOverlap(v bool) {
	selfArg, selfFin := self.handle()
	defer selfFin()
	C.wrap_ImGuiContext_SetActiveIdAllowOverlap(selfArg, C.bool(v))
}

func (self *Context) ActiveIdAllowOverlap() bool {
	selfArg, selfFin := self.handle()

	defer func() {
		selfFin()
	}()
	return C.wrap_ImGuiContext_GetActiveIdAllowOverlap(selfArg) == C.bool(true)
}

func (self Context) SetActiveIdNoClearOnFocusLoss(v bool) {
	selfArg, selfFin := self.handle()
	defer selfFin()
	C.wrap_ImGuiContext_SetActiveIdNoClearOnFocusLoss(selfArg, C.bool(v))
}

func (self *Context) ActiveIdNoClearOnFocusLoss() bool {
	selfArg, selfFin := self.handle()

	defer func() {
		selfFin()
	}()
	return C.wrap_ImGuiContext_GetActiveIdNoClearOnFocusLoss(selfArg) == C.bool(true)
}

func (self Context) SetActiveIdHasBeenPressedBefore(v bool) {
	selfArg, selfFin := self.handle()
	defer selfFin()
	C.wrap_ImGuiContext_SetActiveIdHasBeenPressedBefore(selfArg, C.bool(v))
}

func (self *Context) ActiveIdHasBeenPressedBefore() bool {
	selfArg, selfFin := self.handle()

	defer func() {
		selfFin()
	}()
	return C.wrap_ImGuiContext_GetActiveIdHasBeenPressedBefore(selfArg) == C.bool(true)
}

func (self Context) SetActiveIdHasBeenEditedBefore(v bool) {
	selfArg, selfFin := self.handle()
	defer selfFin()
	C.wrap_ImGuiContext_SetActiveIdHasBeenEditedBefore(selfArg, C.bool(v))
}

func (self *Context) ActiveIdHasBeenEditedBefore() bool {
	selfArg, selfFin := self.handle()

	defer func() {
		selfFin()
	}()
	return C.wrap_ImGuiContext_GetActiveIdHasBeenEditedBefore(selfArg) == C.bool(true)
}

func (self Context) SetActiveIdHasBeenEditedThisFrame(v bool) {
	selfArg, selfFin := self.handle()
	defer selfFin()
	C.wrap_ImGuiContext_SetActiveIdHasBeenEditedThisFrame(selfArg, C.bool(v))
}

func (self *Context) ActiveIdHasBeenEditedThisFrame() bool {
	selfArg, selfFin := self.handle()

	defer func() {
		selfFin()
	}()
	return C.wrap_ImGuiContext_GetActiveIdHasBeenEditedThisFrame(selfArg) == C.bool(true)
}

func (self Context) SetActiveIdClickOffset(v Vec2) {
	selfArg, selfFin := self.handle()
	defer selfFin()
	C.wrap_ImGuiContext_SetActiveIdClickOffset(selfArg, v.toC())
}

func (self *Context) ActiveIdClickOffset() Vec2 {
	selfArg, selfFin := self.handle()

	defer func() {
		selfFin()
	}()
	return *(&Vec2{}).fromC(C.wrap_ImGuiContext_GetActiveIdClickOffset(selfArg))
}

func (self Context) SetActiveIdWindow(v *Window) {
	vArg, _ := v.handle()

	selfArg, selfFin := self.handle()
	defer selfFin()
	C.wrap_ImGuiContext_SetActiveIdWindow(selfArg, vArg)
}

func (self *Context) ActiveIdWindow() *Window {
	selfArg, selfFin := self.handle()

	defer func() {
		selfFin()
	}()
	return newWindowFromC(C.wrap_ImGuiContext_GetActiveIdWindow(selfArg))
}

func (self Context) SetActiveIdSource(v InputSource) {
	selfArg, selfFin := self.handle()
	defer selfFin()
	C.wrap_ImGuiContext_SetActiveIdSource(selfArg, C.ImGuiInputSource(v))
}

func (self *Context) ActiveIdSource() InputSource {
	selfArg, selfFin := self.handle()

	defer func() {
		selfFin()
	}()
	return InputSource(C.wrap_ImGuiContext_GetActiveIdSource(selfArg))
}

func (self Context) SetActiveIdMouseButton(v int32) {
	selfArg, selfFin := self.handle()
	defer selfFin()
	C.wrap_ImGuiContext_SetActiveIdMouseButton(selfArg, C.int(v))
}

func (self *Context) ActiveIdMouseButton() int32 {
	selfArg, selfFin := self.handle()

	defer func() {
		selfFin()
	}()
	return int32(C.wrap_ImGuiContext_GetActiveIdMouseButton(selfArg))
}

func (self Context) SetActiveIdPreviousFrame(v ID) {
	vArg, _ := v.c()

	selfArg, selfFin := self.handle()
	defer selfFin()
	C.wrap_ImGuiContext_SetActiveIdPreviousFrame(selfArg, vArg)
}

func (self *Context) ActiveIdPreviousFrame() ID {
	selfArg, selfFin := self.handle()

	defer func() {
		selfFin()
	}()

	result := C.wrap_ImGuiContext_GetActiveIdPreviousFrame(selfArg)
	return *newIDFromC(func() *C.ImGuiID { result := result; return &result }())
}

func (self Context) SetActiveIdPreviousFrameIsAlive(v bool) {
	selfArg, selfFin := self.handle()
	defer selfFin()
	C.wrap_ImGuiContext_SetActiveIdPreviousFrameIsAlive(selfArg, C.bool(v))
}

func (self *Context) ActiveIdPreviousFrameIsAlive() bool {
	selfArg, selfFin := self.handle()

	defer func() {
		selfFin()
	}()
	return C.wrap_ImGuiContext_GetActiveIdPreviousFrameIsAlive(selfArg) == C.bool(true)
}

func (self Context) SetActiveIdPreviousFrameHasBeenEditedBefore(v bool) {
	selfArg, selfFin := self.handle()
	defer selfFin()
	C.wrap_ImGuiContext_SetActiveIdPreviousFrameHasBeenEditedBefore(selfArg, C.bool(v))
}

func (self *Context) ActiveIdPreviousFrameHasBeenEditedBefore() bool {
	selfArg, selfFin := self.handle()

	defer func() {
		selfFin()
	}()
	return C.wrap_ImGuiContext_GetActiveIdPreviousFrameHasBeenEditedBefore(selfArg) == C.bool(true)
}

func (self Context) SetActiveIdPreviousFrameWindow(v *Window) {
	vArg, _ := v.handle()

	selfArg, selfFin := self.handle()
	defer selfFin()
	C.wrap_ImGuiContext_SetActiveIdPreviousFrameWindow(selfArg, vArg)
}

func (self *Context) ActiveIdPreviousFrameWindow() *Window {
	selfArg, selfFin := self.handle()

	defer func() {
		selfFin()
	}()
	return newWindowFromC(C.wrap_ImGuiContext_GetActiveIdPreviousFrameWindow(selfArg))
}

func (self Context) SetLastActiveId(v ID) {
	vArg, _ := v.c()

	selfArg, selfFin := self.handle()
	defer selfFin()
	C.wrap_ImGuiContext_SetLastActiveId(selfArg, vArg)
}

func (self *Context) LastActiveId() ID {
	selfArg, selfFin := self.handle()

	defer func() {
		selfFin()
	}()

	result := C.wrap_ImGuiContext_GetLastActiveId(selfArg)
	return *newIDFromC(func() *C.ImGuiID { result := result; return &result }())
}

func (self Context) SetLastActiveIdTimer(v float32) {
	selfArg, selfFin := self.handle()
	defer selfFin()
	C.wrap_ImGuiContext_SetLastActiveIdTimer(selfArg, C.float(v))
}

func (self *Context) LastActiveIdTimer() float32 {
	selfArg, selfFin := self.handle()

	defer func() {
		selfFin()
	}()
	return float32(C.wrap_ImGuiContext_GetLastActiveIdTimer(selfArg))
}

func (self Context) SetKeysRoutingTable(v KeyRoutingTable) {
	vArg, _ := v.c()

	selfArg, selfFin := self.handle()
	defer selfFin()
	C.wrap_ImGuiContext_SetKeysRoutingTable(selfArg, vArg)
}

func (self *Context) KeysRoutingTable() KeyRoutingTable {
	selfArg, selfFin := self.handle()

	defer func() {
		selfFin()
	}()

	result := C.wrap_ImGuiContext_GetKeysRoutingTable(selfArg)
	return *newKeyRoutingTableFromC(func() *C.ImGuiKeyRoutingTable { result := result; return &result }())
}

func (self Context) SetActiveIdUsingNavDirMask(v uint32) {
	selfArg, selfFin := self.handle()
	defer selfFin()
	C.wrap_ImGuiContext_SetActiveIdUsingNavDirMask(selfArg, C.ImU32(v))
}

func (self *Context) ActiveIdUsingNavDirMask() uint32 {
	selfArg, selfFin := self.handle()

	defer func() {
		selfFin()
	}()
	return uint32(C.wrap_ImGuiContext_GetActiveIdUsingNavDirMask(selfArg))
}

func (self Context) SetActiveIdUsingAllKeyboardKeys(v bool) {
	selfArg, selfFin := self.handle()
	defer selfFin()
	C.wrap_ImGuiContext_SetActiveIdUsingAllKeyboardKeys(selfArg, C.bool(v))
}

func (self *Context) ActiveIdUsingAllKeyboardKeys() bool {
	selfArg, selfFin := self.handle()

	defer func() {
		selfFin()
	}()
	return C.wrap_ImGuiContext_GetActiveIdUsingAllKeyboardKeys(selfArg) == C.bool(true)
}

func (self Context) SetActiveIdUsingNavInputMask(v uint32) {
	selfArg, selfFin := self.handle()
	defer selfFin()
	C.wrap_ImGuiContext_SetActiveIdUsingNavInputMask(selfArg, C.ImU32(v))
}

func (self *Context) ActiveIdUsingNavInputMask() uint32 {
	selfArg, selfFin := self.handle()

	defer func() {
		selfFin()
	}()
	return uint32(C.wrap_ImGuiContext_GetActiveIdUsingNavInputMask(selfArg))
}

func (self Context) SetCurrentFocusScopeId(v ID) {
	vArg, _ := v.c()

	selfArg, selfFin := self.handle()
	defer selfFin()
	C.wrap_ImGuiContext_SetCurrentFocusScopeId(selfArg, vArg)
}

func (self *Context) CurrentFocusScopeId() ID {
	selfArg, selfFin := self.handle()

	defer func() {
		selfFin()
	}()

	result := C.wrap_ImGuiContext_GetCurrentFocusScopeId(selfArg)
	return *newIDFromC(func() *C.ImGuiID { result := result; return &result }())
}

func (self Context) SetCurrentItemFlags(v ItemFlags) {
	selfArg, selfFin := self.handle()
	defer selfFin()
	C.wrap_ImGuiContext_SetCurrentItemFlags(selfArg, C.ImGuiItemFlags(v))
}

func (self *Context) CurrentItemFlags() ItemFlags {
	selfArg, selfFin := self.handle()

	defer func() {
		selfFin()
	}()
	return ItemFlags(C.wrap_ImGuiContext_GetCurrentItemFlags(selfArg))
}

func (self Context) SetDebugLocateId(v ID) {
	vArg, _ := v.c()

	selfArg, selfFin := self.handle()
	defer selfFin()
	C.wrap_ImGuiContext_SetDebugLocateId(selfArg, vArg)
}

func (self *Context) DebugLocateId() ID {
	selfArg, selfFin := self.handle()

	defer func() {
		selfFin()
	}()

	result := C.wrap_ImGuiContext_GetDebugLocateId(selfArg)
	return *newIDFromC(func() *C.ImGuiID { result := result; return &result }())
}

func (self Context) SetNextItemData(v NextItemData) {
	vArg, _ := v.c()

	selfArg, selfFin := self.handle()
	defer selfFin()
	C.wrap_ImGuiContext_SetNextItemData(selfArg, vArg)
}

func (self *Context) NextItemData() NextItemData {
	selfArg, selfFin := self.handle()

	defer func() {
		selfFin()
	}()

	result := C.wrap_ImGuiContext_GetNextItemData(selfArg)
	return *newNextItemDataFromC(func() *C.ImGuiNextItemData { result := result; return &result }())
}

func (self Context) SetLastItemData(v LastItemData) {
	vArg, _ := v.c()

	selfArg, selfFin := self.handle()
	defer selfFin()
	C.wrap_ImGuiContext_SetLastItemData(selfArg, vArg)
}

func (self *Context) LastItemData() LastItemData {
	selfArg, selfFin := self.handle()

	defer func() {
		selfFin()
	}()

	result := C.wrap_ImGuiContext_GetLastItemData(selfArg)
	return *newLastItemDataFromC(func() *C.ImGuiLastItemData { result := result; return &result }())
}

func (self Context) SetNextWindowData(v NextWindowData) {
	vArg, _ := v.c()

	selfArg, selfFin := self.handle()
	defer selfFin()
	C.wrap_ImGuiContext_SetNextWindowData(selfArg, vArg)
}

func (self *Context) NextWindowData() NextWindowData {
	selfArg, selfFin := self.handle()

	defer func() {
		selfFin()
	}()

	result := C.wrap_ImGuiContext_GetNextWindowData(selfArg)
	return *newNextWindowDataFromC(func() *C.ImGuiNextWindowData { result := result; return &result }())
}

func (self Context) SetColorStack(v Vector[*ColorMod]) {
	vData := v.Data
	vDataArg, _ := vData.handle()
	vVecArg := new(C.ImVector_ImGuiColorMod)
	vVecArg.Size = C.int(v.Size)
	vVecArg.Capacity = C.int(v.Capacity)
	vVecArg.Data = vDataArg
	v.pinner.Pin(vVecArg.Data)

	selfArg, selfFin := self.handle()
	defer selfFin()
	C.wrap_ImGuiContext_SetColorStack(selfArg, *vVecArg)
}

func (self *Context) ColorStack() Vector[*ColorMod] {
	selfArg, selfFin := self.handle()

	defer func() {
		selfFin()
	}()
	return newVectorFromC(C.wrap_ImGuiContext_GetColorStack(selfArg).Size, C.wrap_ImGuiContext_GetColorStack(selfArg).Capacity, newColorModFromC(C.wrap_ImGuiContext_GetColorStack(selfArg).Data))
}

func (self Context) SetStyleVarStack(v Vector[*StyleMod]) {
	vData := v.Data
	vDataArg, _ := vData.handle()
	vVecArg := new(C.ImVector_ImGuiStyleMod)
	vVecArg.Size = C.int(v.Size)
	vVecArg.Capacity = C.int(v.Capacity)
	vVecArg.Data = vDataArg
	v.pinner.Pin(vVecArg.Data)

	selfArg, selfFin := self.handle()
	defer selfFin()
	C.wrap_ImGuiContext_SetStyleVarStack(selfArg, *vVecArg)
}

func (self *Context) StyleVarStack() Vector[*StyleMod] {
	selfArg, selfFin := self.handle()

	defer func() {
		selfFin()
	}()
	return newVectorFromC(C.wrap_ImGuiContext_GetStyleVarStack(selfArg).Size, C.wrap_ImGuiContext_GetStyleVarStack(selfArg).Capacity, newStyleModFromC(C.wrap_ImGuiContext_GetStyleVarStack(selfArg).Data))
}

func (self Context) SetFocusScopeStack(v Vector[*ID]) {
	vData := v.Data
	vDataArg, _ := vData.handle()
	vVecArg := new(C.ImVector_ImGuiID)
	vVecArg.Size = C.int(v.Size)
	vVecArg.Capacity = C.int(v.Capacity)
	vVecArg.Data = vDataArg
	v.pinner.Pin(vVecArg.Data)

	selfArg, selfFin := self.handle()
	defer selfFin()
	C.wrap_ImGuiContext_SetFocusScopeStack(selfArg, *vVecArg)
}

func (self *Context) FocusScopeStack() Vector[*ID] {
	selfArg, selfFin := self.handle()

	defer func() {
		selfFin()
	}()
	return newVectorFromC(C.wrap_ImGuiContext_GetFocusScopeStack(selfArg).Size, C.wrap_ImGuiContext_GetFocusScopeStack(selfArg).Capacity, newIDFromC(C.wrap_ImGuiContext_GetFocusScopeStack(selfArg).Data))
}

func (self *Context) ItemFlagsStack() Vector[*ItemFlags] {
	selfArg, selfFin := self.handle()

	defer func() {
		selfFin()
	}()
	return newVectorFromC(C.wrap_ImGuiContext_GetItemFlagsStack(selfArg).Size, C.wrap_ImGuiContext_GetItemFlagsStack(selfArg).Capacity, (*ItemFlags)(C.wrap_ImGuiContext_GetItemFlagsStack(selfArg).Data))
}

func (self Context) SetGroupStack(v Vector[*GroupData]) {
	vData := v.Data
	vDataArg, _ := vData.handle()
	vVecArg := new(C.ImVector_ImGuiGroupData)
	vVecArg.Size = C.int(v.Size)
	vVecArg.Capacity = C.int(v.Capacity)
	vVecArg.Data = vDataArg
	v.pinner.Pin(vVecArg.Data)

	selfArg, selfFin := self.handle()
	defer selfFin()
	C.wrap_ImGuiContext_SetGroupStack(selfArg, *vVecArg)
}

func (self *Context) GroupStack() Vector[*GroupData] {
	selfArg, selfFin := self.handle()

	defer func() {
		selfFin()
	}()
	return newVectorFromC(C.wrap_ImGuiContext_GetGroupStack(selfArg).Size, C.wrap_ImGuiContext_GetGroupStack(selfArg).Capacity, newGroupDataFromC(C.wrap_ImGuiContext_GetGroupStack(selfArg).Data))
}

func (self Context) SetOpenPopupStack(v Vector[*PopupData]) {
	vData := v.Data
	vDataArg, _ := vData.handle()
	vVecArg := new(C.ImVector_ImGuiPopupData)
	vVecArg.Size = C.int(v.Size)
	vVecArg.Capacity = C.int(v.Capacity)
	vVecArg.Data = vDataArg
	v.pinner.Pin(vVecArg.Data)

	selfArg, selfFin := self.handle()
	defer selfFin()
	C.wrap_ImGuiContext_SetOpenPopupStack(selfArg, *vVecArg)
}

func (self *Context) OpenPopupStack() Vector[*PopupData] {
	selfArg, selfFin := self.handle()

	defer func() {
		selfFin()
	}()
	return newVectorFromC(C.wrap_ImGuiContext_GetOpenPopupStack(selfArg).Size, C.wrap_ImGuiContext_GetOpenPopupStack(selfArg).Capacity, newPopupDataFromC(C.wrap_ImGuiContext_GetOpenPopupStack(selfArg).Data))
}

func (self Context) SetBeginPopupStack(v Vector[*PopupData]) {
	vData := v.Data
	vDataArg, _ := vData.handle()
	vVecArg := new(C.ImVector_ImGuiPopupData)
	vVecArg.Size = C.int(v.Size)
	vVecArg.Capacity = C.int(v.Capacity)
	vVecArg.Data = vDataArg
	v.pinner.Pin(vVecArg.Data)

	selfArg, selfFin := self.handle()
	defer selfFin()
	C.wrap_ImGuiContext_SetBeginPopupStack(selfArg, *vVecArg)
}

func (self *Context) BeginPopupStack() Vector[*PopupData] {
	selfArg, selfFin := self.handle()

	defer func() {
		selfFin()
	}()
	return newVectorFromC(C.wrap_ImGuiContext_GetBeginPopupStack(selfArg).Size, C.wrap_ImGuiContext_GetBeginPopupStack(selfArg).Capacity, newPopupDataFromC(C.wrap_ImGuiContext_GetBeginPopupStack(selfArg).Data))
}

func (self Context) SetNavTreeNodeStack(v Vector[*NavTreeNodeData]) {
	vData := v.Data
	vDataArg, _ := vData.handle()
	vVecArg := new(C.ImVector_ImGuiNavTreeNodeData)
	vVecArg.Size = C.int(v.Size)
	vVecArg.Capacity = C.int(v.Capacity)
	vVecArg.Data = vDataArg
	v.pinner.Pin(vVecArg.Data)

	selfArg, selfFin := self.handle()
	defer selfFin()
	C.wrap_ImGuiContext_SetNavTreeNodeStack(selfArg, *vVecArg)
}

func (self *Context) NavTreeNodeStack() Vector[*NavTreeNodeData] {
	selfArg, selfFin := self.handle()

	defer func() {
		selfFin()
	}()
	return newVectorFromC(C.wrap_ImGuiContext_GetNavTreeNodeStack(selfArg).Size, C.wrap_ImGuiContext_GetNavTreeNodeStack(selfArg).Capacity, newNavTreeNodeDataFromC(C.wrap_ImGuiContext_GetNavTreeNodeStack(selfArg).Data))
}

func (self Context) SetBeginMenuCount(v int32) {
	selfArg, selfFin := self.handle()
	defer selfFin()
	C.wrap_ImGuiContext_SetBeginMenuCount(selfArg, C.int(v))
}

func (self *Context) BeginMenuCount() int32 {
	selfArg, selfFin := self.handle()

	defer func() {
		selfFin()
	}()
	return int32(C.wrap_ImGuiContext_GetBeginMenuCount(selfArg))
}

func (self Context) SetCurrentDpiScale(v float32) {
	selfArg, selfFin := self.handle()
	defer selfFin()
	C.wrap_ImGuiContext_SetCurrentDpiScale(selfArg, C.float(v))
}

func (self *Context) CurrentDpiScale() float32 {
	selfArg, selfFin := self.handle()

	defer func() {
		selfFin()
	}()
	return float32(C.wrap_ImGuiContext_GetCurrentDpiScale(selfArg))
}

func (self Context) SetCurrentViewport(v *ViewportP) {
	vArg, _ := v.handle()

	selfArg, selfFin := self.handle()
	defer selfFin()
	C.wrap_ImGuiContext_SetCurrentViewport(selfArg, vArg)
}

func (self *Context) CurrentViewport() *ViewportP {
	selfArg, selfFin := self.handle()

	defer func() {
		selfFin()
	}()
	return newViewportPFromC(C.wrap_ImGuiContext_GetCurrentViewport(selfArg))
}

func (self Context) SetMouseViewport(v *ViewportP) {
	vArg, _ := v.handle()

	selfArg, selfFin := self.handle()
	defer selfFin()
	C.wrap_ImGuiContext_SetMouseViewport(selfArg, vArg)
}

func (self *Context) MouseViewport() *ViewportP {
	selfArg, selfFin := self.handle()

	defer func() {
		selfFin()
	}()
	return newViewportPFromC(C.wrap_ImGuiContext_GetMouseViewport(selfArg))
}

func (self Context) SetMouseLastHoveredViewport(v *ViewportP) {
	vArg, _ := v.handle()

	selfArg, selfFin := self.handle()
	defer selfFin()
	C.wrap_ImGuiContext_SetMouseLastHoveredViewport(selfArg, vArg)
}

func (self *Context) MouseLastHoveredViewport() *ViewportP {
	selfArg, selfFin := self.handle()

	defer func() {
		selfFin()
	}()
	return newViewportPFromC(C.wrap_ImGuiContext_GetMouseLastHoveredViewport(selfArg))
}

func (self Context) SetPlatformLastFocusedViewportId(v ID) {
	vArg, _ := v.c()

	selfArg, selfFin := self.handle()
	defer selfFin()
	C.wrap_ImGuiContext_SetPlatformLastFocusedViewportId(selfArg, vArg)
}

func (self *Context) PlatformLastFocusedViewportId() ID {
	selfArg, selfFin := self.handle()

	defer func() {
		selfFin()
	}()

	result := C.wrap_ImGuiContext_GetPlatformLastFocusedViewportId(selfArg)
	return *newIDFromC(func() *C.ImGuiID { result := result; return &result }())
}

func (self Context) SetFallbackMonitor(v PlatformMonitor) {
	vArg, _ := v.c()

	selfArg, selfFin := self.handle()
	defer selfFin()
	C.wrap_ImGuiContext_SetFallbackMonitor(selfArg, vArg)
}

func (self *Context) FallbackMonitor() PlatformMonitor {
	selfArg, selfFin := self.handle()

	defer func() {
		selfFin()
	}()

	result := C.wrap_ImGuiContext_GetFallbackMonitor(selfArg)
	return *newPlatformMonitorFromC(func() *C.ImGuiPlatformMonitor { result := result; return &result }())
}

func (self Context) SetViewportCreatedCount(v int32) {
	selfArg, selfFin := self.handle()
	defer selfFin()
	C.wrap_ImGuiContext_SetViewportCreatedCount(selfArg, C.int(v))
}

func (self *Context) ViewportCreatedCount() int32 {
	selfArg, selfFin := self.handle()

	defer func() {
		selfFin()
	}()
	return int32(C.wrap_ImGuiContext_GetViewportCreatedCount(selfArg))
}

func (self Context) SetPlatformWindowsCreatedCount(v int32) {
	selfArg, selfFin := self.handle()
	defer selfFin()
	C.wrap_ImGuiContext_SetPlatformWindowsCreatedCount(selfArg, C.int(v))
}

func (self *Context) PlatformWindowsCreatedCount() int32 {
	selfArg, selfFin := self.handle()

	defer func() {
		selfFin()
	}()
	return int32(C.wrap_ImGuiContext_GetPlatformWindowsCreatedCount(selfArg))
}

func (self Context) SetViewportFocusedStampCount(v int32) {
	selfArg, selfFin := self.handle()
	defer selfFin()
	C.wrap_ImGuiContext_SetViewportFocusedStampCount(selfArg, C.int(v))
}

func (self *Context) ViewportFocusedStampCount() int32 {
	selfArg, selfFin := self.handle()

	defer func() {
		selfFin()
	}()
	return int32(C.wrap_ImGuiContext_GetViewportFocusedStampCount(selfArg))
}

func (self Context) SetNavWindow(v *Window) {
	vArg, _ := v.handle()

	selfArg, selfFin := self.handle()
	defer selfFin()
	C.wrap_ImGuiContext_SetNavWindow(selfArg, vArg)
}

func (self *Context) NavWindow() *Window {
	selfArg, selfFin := self.handle()

	defer func() {
		selfFin()
	}()
	return newWindowFromC(C.wrap_ImGuiContext_GetNavWindow(selfArg))
}

func (self Context) SetNavId(v ID) {
	vArg, _ := v.c()

	selfArg, selfFin := self.handle()
	defer selfFin()
	C.wrap_ImGuiContext_SetNavId(selfArg, vArg)
}

func (self *Context) NavId() ID {
	selfArg, selfFin := self.handle()

	defer func() {
		selfFin()
	}()

	result := C.wrap_ImGuiContext_GetNavId(selfArg)
	return *newIDFromC(func() *C.ImGuiID { result := result; return &result }())
}

func (self Context) SetNavFocusScopeId(v ID) {
	vArg, _ := v.c()

	selfArg, selfFin := self.handle()
	defer selfFin()
	C.wrap_ImGuiContext_SetNavFocusScopeId(selfArg, vArg)
}

func (self *Context) NavFocusScopeId() ID {
	selfArg, selfFin := self.handle()

	defer func() {
		selfFin()
	}()

	result := C.wrap_ImGuiContext_GetNavFocusScopeId(selfArg)
	return *newIDFromC(func() *C.ImGuiID { result := result; return &result }())
}

func (self Context) SetNavActivateId(v ID) {
	vArg, _ := v.c()

	selfArg, selfFin := self.handle()
	defer selfFin()
	C.wrap_ImGuiContext_SetNavActivateId(selfArg, vArg)
}

func (self *Context) NavActivateId() ID {
	selfArg, selfFin := self.handle()

	defer func() {
		selfFin()
	}()

	result := C.wrap_ImGuiContext_GetNavActivateId(selfArg)
	return *newIDFromC(func() *C.ImGuiID { result := result; return &result }())
}

func (self Context) SetNavActivateDownId(v ID) {
	vArg, _ := v.c()

	selfArg, selfFin := self.handle()
	defer selfFin()
	C.wrap_ImGuiContext_SetNavActivateDownId(selfArg, vArg)
}

func (self *Context) NavActivateDownId() ID {
	selfArg, selfFin := self.handle()

	defer func() {
		selfFin()
	}()

	result := C.wrap_ImGuiContext_GetNavActivateDownId(selfArg)
	return *newIDFromC(func() *C.ImGuiID { result := result; return &result }())
}

func (self Context) SetNavActivatePressedId(v ID) {
	vArg, _ := v.c()

	selfArg, selfFin := self.handle()
	defer selfFin()
	C.wrap_ImGuiContext_SetNavActivatePressedId(selfArg, vArg)
}

func (self *Context) NavActivatePressedId() ID {
	selfArg, selfFin := self.handle()

	defer func() {
		selfFin()
	}()

	result := C.wrap_ImGuiContext_GetNavActivatePressedId(selfArg)
	return *newIDFromC(func() *C.ImGuiID { result := result; return &result }())
}

func (self Context) SetNavActivateFlags(v ActivateFlags) {
	selfArg, selfFin := self.handle()
	defer selfFin()
	C.wrap_ImGuiContext_SetNavActivateFlags(selfArg, C.ImGuiActivateFlags(v))
}

func (self *Context) NavActivateFlags() ActivateFlags {
	selfArg, selfFin := self.handle()

	defer func() {
		selfFin()
	}()
	return ActivateFlags(C.wrap_ImGuiContext_GetNavActivateFlags(selfArg))
}

func (self Context) SetNavJustMovedToId(v ID) {
	vArg, _ := v.c()

	selfArg, selfFin := self.handle()
	defer selfFin()
	C.wrap_ImGuiContext_SetNavJustMovedToId(selfArg, vArg)
}

func (self *Context) NavJustMovedToId() ID {
	selfArg, selfFin := self.handle()

	defer func() {
		selfFin()
	}()

	result := C.wrap_ImGuiContext_GetNavJustMovedToId(selfArg)
	return *newIDFromC(func() *C.ImGuiID { result := result; return &result }())
}

func (self Context) SetNavJustMovedToFocusScopeId(v ID) {
	vArg, _ := v.c()

	selfArg, selfFin := self.handle()
	defer selfFin()
	C.wrap_ImGuiContext_SetNavJustMovedToFocusScopeId(selfArg, vArg)
}

func (self *Context) NavJustMovedToFocusScopeId() ID {
	selfArg, selfFin := self.handle()

	defer func() {
		selfFin()
	}()

	result := C.wrap_ImGuiContext_GetNavJustMovedToFocusScopeId(selfArg)
	return *newIDFromC(func() *C.ImGuiID { result := result; return &result }())
}

func (self Context) SetNavJustMovedToKeyMods(v KeyChord) {
	vArg, _ := v.c()

	selfArg, selfFin := self.handle()
	defer selfFin()
	C.wrap_ImGuiContext_SetNavJustMovedToKeyMods(selfArg, vArg)
}

func (self *Context) NavJustMovedToKeyMods() KeyChord {
	selfArg, selfFin := self.handle()

	defer func() {
		selfFin()
	}()

	result := C.wrap_ImGuiContext_GetNavJustMovedToKeyMods(selfArg)
	return *newKeyChordFromC(func() *C.ImGuiKeyChord { result := result; return &result }())
}

func (self Context) SetNavNextActivateId(v ID) {
	vArg, _ := v.c()

	selfArg, selfFin := self.handle()
	defer selfFin()
	C.wrap_ImGuiContext_SetNavNextActivateId(selfArg, vArg)
}

func (self *Context) NavNextActivateId() ID {
	selfArg, selfFin := self.handle()

	defer func() {
		selfFin()
	}()

	result := C.wrap_ImGuiContext_GetNavNextActivateId(selfArg)
	return *newIDFromC(func() *C.ImGuiID { result := result; return &result }())
}

func (self Context) SetNavNextActivateFlags(v ActivateFlags) {
	selfArg, selfFin := self.handle()
	defer selfFin()
	C.wrap_ImGuiContext_SetNavNextActivateFlags(selfArg, C.ImGuiActivateFlags(v))
}

func (self *Context) NavNextActivateFlags() ActivateFlags {
	selfArg, selfFin := self.handle()

	defer func() {
		selfFin()
	}()
	return ActivateFlags(C.wrap_ImGuiContext_GetNavNextActivateFlags(selfArg))
}

func (self Context) SetNavInputSource(v InputSource) {
	selfArg, selfFin := self.handle()
	defer selfFin()
	C.wrap_ImGuiContext_SetNavInputSource(selfArg, C.ImGuiInputSource(v))
}

func (self *Context) NavInputSource() InputSource {
	selfArg, selfFin := self.handle()

	defer func() {
		selfFin()
	}()
	return InputSource(C.wrap_ImGuiContext_GetNavInputSource(selfArg))
}

func (self Context) SetNavLayer(v NavLayer) {
	selfArg, selfFin := self.handle()
	defer selfFin()
	C.wrap_ImGuiContext_SetNavLayer(selfArg, C.ImGuiNavLayer(v))
}

func (self *Context) NavLayer() NavLayer {
	selfArg, selfFin := self.handle()

	defer func() {
		selfFin()
	}()
	return NavLayer(C.wrap_ImGuiContext_GetNavLayer(selfArg))
}

func (self Context) SetNavIdIsAlive(v bool) {
	selfArg, selfFin := self.handle()
	defer selfFin()
	C.wrap_ImGuiContext_SetNavIdIsAlive(selfArg, C.bool(v))
}

func (self *Context) NavIdIsAlive() bool {
	selfArg, selfFin := self.handle()

	defer func() {
		selfFin()
	}()
	return C.wrap_ImGuiContext_GetNavIdIsAlive(selfArg) == C.bool(true)
}

func (self Context) SetNavMousePosDirty(v bool) {
	selfArg, selfFin := self.handle()
	defer selfFin()
	C.wrap_ImGuiContext_SetNavMousePosDirty(selfArg, C.bool(v))
}

func (self *Context) NavMousePosDirty() bool {
	selfArg, selfFin := self.handle()

	defer func() {
		selfFin()
	}()
	return C.wrap_ImGuiContext_GetNavMousePosDirty(selfArg) == C.bool(true)
}

func (self Context) SetNavDisableHighlight(v bool) {
	selfArg, selfFin := self.handle()
	defer selfFin()
	C.wrap_ImGuiContext_SetNavDisableHighlight(selfArg, C.bool(v))
}

func (self *Context) NavDisableHighlight() bool {
	selfArg, selfFin := self.handle()

	defer func() {
		selfFin()
	}()
	return C.wrap_ImGuiContext_GetNavDisableHighlight(selfArg) == C.bool(true)
}

func (self Context) SetNavDisableMouseHover(v bool) {
	selfArg, selfFin := self.handle()
	defer selfFin()
	C.wrap_ImGuiContext_SetNavDisableMouseHover(selfArg, C.bool(v))
}

func (self *Context) NavDisableMouseHover() bool {
	selfArg, selfFin := self.handle()

	defer func() {
		selfFin()
	}()
	return C.wrap_ImGuiContext_GetNavDisableMouseHover(selfArg) == C.bool(true)
}

func (self Context) SetNavAnyRequest(v bool) {
	selfArg, selfFin := self.handle()
	defer selfFin()
	C.wrap_ImGuiContext_SetNavAnyRequest(selfArg, C.bool(v))
}

func (self *Context) NavAnyRequest() bool {
	selfArg, selfFin := self.handle()

	defer func() {
		selfFin()
	}()
	return C.wrap_ImGuiContext_GetNavAnyRequest(selfArg) == C.bool(true)
}

func (self Context) SetNavInitRequest(v bool) {
	selfArg, selfFin := self.handle()
	defer selfFin()
	C.wrap_ImGuiContext_SetNavInitRequest(selfArg, C.bool(v))
}

func (self *Context) NavInitRequest() bool {
	selfArg, selfFin := self.handle()

	defer func() {
		selfFin()
	}()
	return C.wrap_ImGuiContext_GetNavInitRequest(selfArg) == C.bool(true)
}

func (self Context) SetNavInitRequestFromMove(v bool) {
	selfArg, selfFin := self.handle()
	defer selfFin()
	C.wrap_ImGuiContext_SetNavInitRequestFromMove(selfArg, C.bool(v))
}

func (self *Context) NavInitRequestFromMove() bool {
	selfArg, selfFin := self.handle()

	defer func() {
		selfFin()
	}()
	return C.wrap_ImGuiContext_GetNavInitRequestFromMove(selfArg) == C.bool(true)
}

func (self Context) SetNavInitResult(v NavItemData) {
	vArg, _ := v.c()

	selfArg, selfFin := self.handle()
	defer selfFin()
	C.wrap_ImGuiContext_SetNavInitResult(selfArg, vArg)
}

func (self *Context) NavInitResult() NavItemData {
	selfArg, selfFin := self.handle()

	defer func() {
		selfFin()
	}()

	result := C.wrap_ImGuiContext_GetNavInitResult(selfArg)
	return *newNavItemDataFromC(func() *C.ImGuiNavItemData { result := result; return &result }())
}

func (self Context) SetNavMoveSubmitted(v bool) {
	selfArg, selfFin := self.handle()
	defer selfFin()
	C.wrap_ImGuiContext_SetNavMoveSubmitted(selfArg, C.bool(v))
}

func (self *Context) NavMoveSubmitted() bool {
	selfArg, selfFin := self.handle()

	defer func() {
		selfFin()
	}()
	return C.wrap_ImGuiContext_GetNavMoveSubmitted(selfArg) == C.bool(true)
}

func (self Context) SetNavMoveScoringItems(v bool) {
	selfArg, selfFin := self.handle()
	defer selfFin()
	C.wrap_ImGuiContext_SetNavMoveScoringItems(selfArg, C.bool(v))
}

func (self *Context) NavMoveScoringItems() bool {
	selfArg, selfFin := self.handle()

	defer func() {
		selfFin()
	}()
	return C.wrap_ImGuiContext_GetNavMoveScoringItems(selfArg) == C.bool(true)
}

func (self Context) SetNavMoveForwardToNextFrame(v bool) {
	selfArg, selfFin := self.handle()
	defer selfFin()
	C.wrap_ImGuiContext_SetNavMoveForwardToNextFrame(selfArg, C.bool(v))
}

func (self *Context) NavMoveForwardToNextFrame() bool {
	selfArg, selfFin := self.handle()

	defer func() {
		selfFin()
	}()
	return C.wrap_ImGuiContext_GetNavMoveForwardToNextFrame(selfArg) == C.bool(true)
}

func (self Context) SetNavMoveFlags(v NavMoveFlags) {
	selfArg, selfFin := self.handle()
	defer selfFin()
	C.wrap_ImGuiContext_SetNavMoveFlags(selfArg, C.ImGuiNavMoveFlags(v))
}

func (self *Context) NavMoveFlags() NavMoveFlags {
	selfArg, selfFin := self.handle()

	defer func() {
		selfFin()
	}()
	return NavMoveFlags(C.wrap_ImGuiContext_GetNavMoveFlags(selfArg))
}

func (self Context) SetNavMoveScrollFlags(v ScrollFlags) {
	selfArg, selfFin := self.handle()
	defer selfFin()
	C.wrap_ImGuiContext_SetNavMoveScrollFlags(selfArg, C.ImGuiScrollFlags(v))
}

func (self *Context) NavMoveScrollFlags() ScrollFlags {
	selfArg, selfFin := self.handle()

	defer func() {
		selfFin()
	}()
	return ScrollFlags(C.wrap_ImGuiContext_GetNavMoveScrollFlags(selfArg))
}

func (self Context) SetNavMoveKeyMods(v KeyChord) {
	vArg, _ := v.c()

	selfArg, selfFin := self.handle()
	defer selfFin()
	C.wrap_ImGuiContext_SetNavMoveKeyMods(selfArg, vArg)
}

func (self *Context) NavMoveKeyMods() KeyChord {
	selfArg, selfFin := self.handle()

	defer func() {
		selfFin()
	}()

	result := C.wrap_ImGuiContext_GetNavMoveKeyMods(selfArg)
	return *newKeyChordFromC(func() *C.ImGuiKeyChord { result := result; return &result }())
}

func (self Context) SetNavMoveDir(v Dir) {
	selfArg, selfFin := self.handle()
	defer selfFin()
	C.wrap_ImGuiContext_SetNavMoveDir(selfArg, C.ImGuiDir(v))
}

func (self *Context) NavMoveDir() Dir {
	selfArg, selfFin := self.handle()

	defer func() {
		selfFin()
	}()
	return Dir(C.wrap_ImGuiContext_GetNavMoveDir(selfArg))
}

func (self Context) SetNavMoveDirForDebug(v Dir) {
	selfArg, selfFin := self.handle()
	defer selfFin()
	C.wrap_ImGuiContext_SetNavMoveDirForDebug(selfArg, C.ImGuiDir(v))
}

func (self *Context) NavMoveDirForDebug() Dir {
	selfArg, selfFin := self.handle()

	defer func() {
		selfFin()
	}()
	return Dir(C.wrap_ImGuiContext_GetNavMoveDirForDebug(selfArg))
}

func (self Context) SetNavMoveClipDir(v Dir) {
	selfArg, selfFin := self.handle()
	defer selfFin()
	C.wrap_ImGuiContext_SetNavMoveClipDir(selfArg, C.ImGuiDir(v))
}

func (self *Context) NavMoveClipDir() Dir {
	selfArg, selfFin := self.handle()

	defer func() {
		selfFin()
	}()
	return Dir(C.wrap_ImGuiContext_GetNavMoveClipDir(selfArg))
}

func (self Context) SetNavScoringRect(v Rect) {
	selfArg, selfFin := self.handle()
	defer selfFin()
	C.wrap_ImGuiContext_SetNavScoringRect(selfArg, v.toC())
}

func (self *Context) NavScoringRect() Rect {
	selfArg, selfFin := self.handle()

	defer func() {
		selfFin()
	}()
	return *(&Rect{}).fromC(C.wrap_ImGuiContext_GetNavScoringRect(selfArg))
}

func (self Context) SetNavScoringNoClipRect(v Rect) {
	selfArg, selfFin := self.handle()
	defer selfFin()
	C.wrap_ImGuiContext_SetNavScoringNoClipRect(selfArg, v.toC())
}

func (self *Context) NavScoringNoClipRect() Rect {
	selfArg, selfFin := self.handle()

	defer func() {
		selfFin()
	}()
	return *(&Rect{}).fromC(C.wrap_ImGuiContext_GetNavScoringNoClipRect(selfArg))
}

func (self Context) SetNavScoringDebugCount(v int32) {
	selfArg, selfFin := self.handle()
	defer selfFin()
	C.wrap_ImGuiContext_SetNavScoringDebugCount(selfArg, C.int(v))
}

func (self *Context) NavScoringDebugCount() int32 {
	selfArg, selfFin := self.handle()

	defer func() {
		selfFin()
	}()
	return int32(C.wrap_ImGuiContext_GetNavScoringDebugCount(selfArg))
}

func (self Context) SetNavTabbingDir(v int32) {
	selfArg, selfFin := self.handle()
	defer selfFin()
	C.wrap_ImGuiContext_SetNavTabbingDir(selfArg, C.int(v))
}

func (self *Context) NavTabbingDir() int32 {
	selfArg, selfFin := self.handle()

	defer func() {
		selfFin()
	}()
	return int32(C.wrap_ImGuiContext_GetNavTabbingDir(selfArg))
}

func (self Context) SetNavTabbingCounter(v int32) {
	selfArg, selfFin := self.handle()
	defer selfFin()
	C.wrap_ImGuiContext_SetNavTabbingCounter(selfArg, C.int(v))
}

func (self *Context) NavTabbingCounter() int32 {
	selfArg, selfFin := self.handle()

	defer func() {
		selfFin()
	}()
	return int32(C.wrap_ImGuiContext_GetNavTabbingCounter(selfArg))
}

func (self Context) SetNavMoveResultLocal(v NavItemData) {
	vArg, _ := v.c()

	selfArg, selfFin := self.handle()
	defer selfFin()
	C.wrap_ImGuiContext_SetNavMoveResultLocal(selfArg, vArg)
}

func (self *Context) NavMoveResultLocal() NavItemData {
	selfArg, selfFin := self.handle()

	defer func() {
		selfFin()
	}()

	result := C.wrap_ImGuiContext_GetNavMoveResultLocal(selfArg)
	return *newNavItemDataFromC(func() *C.ImGuiNavItemData { result := result; return &result }())
}

func (self Context) SetNavMoveResultLocalVisible(v NavItemData) {
	vArg, _ := v.c()

	selfArg, selfFin := self.handle()
	defer selfFin()
	C.wrap_ImGuiContext_SetNavMoveResultLocalVisible(selfArg, vArg)
}

func (self *Context) NavMoveResultLocalVisible() NavItemData {
	selfArg, selfFin := self.handle()

	defer func() {
		selfFin()
	}()

	result := C.wrap_ImGuiContext_GetNavMoveResultLocalVisible(selfArg)
	return *newNavItemDataFromC(func() *C.ImGuiNavItemData { result := result; return &result }())
}

func (self Context) SetNavMoveResultOther(v NavItemData) {
	vArg, _ := v.c()

	selfArg, selfFin := self.handle()
	defer selfFin()
	C.wrap_ImGuiContext_SetNavMoveResultOther(selfArg, vArg)
}

func (self *Context) NavMoveResultOther() NavItemData {
	selfArg, selfFin := self.handle()

	defer func() {
		selfFin()
	}()

	result := C.wrap_ImGuiContext_GetNavMoveResultOther(selfArg)
	return *newNavItemDataFromC(func() *C.ImGuiNavItemData { result := result; return &result }())
}

func (self Context) SetNavTabbingResultFirst(v NavItemData) {
	vArg, _ := v.c()

	selfArg, selfFin := self.handle()
	defer selfFin()
	C.wrap_ImGuiContext_SetNavTabbingResultFirst(selfArg, vArg)
}

func (self *Context) NavTabbingResultFirst() NavItemData {
	selfArg, selfFin := self.handle()

	defer func() {
		selfFin()
	}()

	result := C.wrap_ImGuiContext_GetNavTabbingResultFirst(selfArg)
	return *newNavItemDataFromC(func() *C.ImGuiNavItemData { result := result; return &result }())
}

func (self Context) SetConfigNavWindowingKeyNext(v KeyChord) {
	vArg, _ := v.c()

	selfArg, selfFin := self.handle()
	defer selfFin()
	C.wrap_ImGuiContext_SetConfigNavWindowingKeyNext(selfArg, vArg)
}

func (self *Context) ConfigNavWindowingKeyNext() KeyChord {
	selfArg, selfFin := self.handle()

	defer func() {
		selfFin()
	}()

	result := C.wrap_ImGuiContext_GetConfigNavWindowingKeyNext(selfArg)
	return *newKeyChordFromC(func() *C.ImGuiKeyChord { result := result; return &result }())
}

func (self Context) SetConfigNavWindowingKeyPrev(v KeyChord) {
	vArg, _ := v.c()

	selfArg, selfFin := self.handle()
	defer selfFin()
	C.wrap_ImGuiContext_SetConfigNavWindowingKeyPrev(selfArg, vArg)
}

func (self *Context) ConfigNavWindowingKeyPrev() KeyChord {
	selfArg, selfFin := self.handle()

	defer func() {
		selfFin()
	}()

	result := C.wrap_ImGuiContext_GetConfigNavWindowingKeyPrev(selfArg)
	return *newKeyChordFromC(func() *C.ImGuiKeyChord { result := result; return &result }())
}

func (self Context) SetNavWindowingTarget(v *Window) {
	vArg, _ := v.handle()

	selfArg, selfFin := self.handle()
	defer selfFin()
	C.wrap_ImGuiContext_SetNavWindowingTarget(selfArg, vArg)
}

func (self *Context) NavWindowingTarget() *Window {
	selfArg, selfFin := self.handle()

	defer func() {
		selfFin()
	}()
	return newWindowFromC(C.wrap_ImGuiContext_GetNavWindowingTarget(selfArg))
}

func (self Context) SetNavWindowingTargetAnim(v *Window) {
	vArg, _ := v.handle()

	selfArg, selfFin := self.handle()
	defer selfFin()
	C.wrap_ImGuiContext_SetNavWindowingTargetAnim(selfArg, vArg)
}

func (self *Context) NavWindowingTargetAnim() *Window {
	selfArg, selfFin := self.handle()

	defer func() {
		selfFin()
	}()
	return newWindowFromC(C.wrap_ImGuiContext_GetNavWindowingTargetAnim(selfArg))
}

func (self Context) SetNavWindowingListWindow(v *Window) {
	vArg, _ := v.handle()

	selfArg, selfFin := self.handle()
	defer selfFin()
	C.wrap_ImGuiContext_SetNavWindowingListWindow(selfArg, vArg)
}

func (self *Context) NavWindowingListWindow() *Window {
	selfArg, selfFin := self.handle()

	defer func() {
		selfFin()
	}()
	return newWindowFromC(C.wrap_ImGuiContext_GetNavWindowingListWindow(selfArg))
}

func (self Context) SetNavWindowingTimer(v float32) {
	selfArg, selfFin := self.handle()
	defer selfFin()
	C.wrap_ImGuiContext_SetNavWindowingTimer(selfArg, C.float(v))
}

func (self *Context) NavWindowingTimer() float32 {
	selfArg, selfFin := self.handle()

	defer func() {
		selfFin()
	}()
	return float32(C.wrap_ImGuiContext_GetNavWindowingTimer(selfArg))
}

func (self Context) SetNavWindowingHighlightAlpha(v float32) {
	selfArg, selfFin := self.handle()
	defer selfFin()
	C.wrap_ImGuiContext_SetNavWindowingHighlightAlpha(selfArg, C.float(v))
}

func (self *Context) NavWindowingHighlightAlpha() float32 {
	selfArg, selfFin := self.handle()

	defer func() {
		selfFin()
	}()
	return float32(C.wrap_ImGuiContext_GetNavWindowingHighlightAlpha(selfArg))
}

func (self Context) SetNavWindowingToggleLayer(v bool) {
	selfArg, selfFin := self.handle()
	defer selfFin()
	C.wrap_ImGuiContext_SetNavWindowingToggleLayer(selfArg, C.bool(v))
}

func (self *Context) NavWindowingToggleLayer() bool {
	selfArg, selfFin := self.handle()

	defer func() {
		selfFin()
	}()
	return C.wrap_ImGuiContext_GetNavWindowingToggleLayer(selfArg) == C.bool(true)
}

func (self Context) SetNavWindowingAccumDeltaPos(v Vec2) {
	selfArg, selfFin := self.handle()
	defer selfFin()
	C.wrap_ImGuiContext_SetNavWindowingAccumDeltaPos(selfArg, v.toC())
}

func (self *Context) NavWindowingAccumDeltaPos() Vec2 {
	selfArg, selfFin := self.handle()

	defer func() {
		selfFin()
	}()
	return *(&Vec2{}).fromC(C.wrap_ImGuiContext_GetNavWindowingAccumDeltaPos(selfArg))
}

func (self Context) SetNavWindowingAccumDeltaSize(v Vec2) {
	selfArg, selfFin := self.handle()
	defer selfFin()
	C.wrap_ImGuiContext_SetNavWindowingAccumDeltaSize(selfArg, v.toC())
}

func (self *Context) NavWindowingAccumDeltaSize() Vec2 {
	selfArg, selfFin := self.handle()

	defer func() {
		selfFin()
	}()
	return *(&Vec2{}).fromC(C.wrap_ImGuiContext_GetNavWindowingAccumDeltaSize(selfArg))
}

func (self Context) SetDimBgRatio(v float32) {
	selfArg, selfFin := self.handle()
	defer selfFin()
	C.wrap_ImGuiContext_SetDimBgRatio(selfArg, C.float(v))
}

func (self *Context) DimBgRatio() float32 {
	selfArg, selfFin := self.handle()

	defer func() {
		selfFin()
	}()
	return float32(C.wrap_ImGuiContext_GetDimBgRatio(selfArg))
}

func (self Context) SetDragDropActive(v bool) {
	selfArg, selfFin := self.handle()
	defer selfFin()
	C.wrap_ImGuiContext_SetDragDropActive(selfArg, C.bool(v))
}

func (self *Context) DragDropActive() bool {
	selfArg, selfFin := self.handle()

	defer func() {
		selfFin()
	}()
	return C.wrap_ImGuiContext_GetDragDropActive(selfArg) == C.bool(true)
}

func (self Context) SetDragDropWithinSource(v bool) {
	selfArg, selfFin := self.handle()
	defer selfFin()
	C.wrap_ImGuiContext_SetDragDropWithinSource(selfArg, C.bool(v))
}

func (self *Context) DragDropWithinSource() bool {
	selfArg, selfFin := self.handle()

	defer func() {
		selfFin()
	}()
	return C.wrap_ImGuiContext_GetDragDropWithinSource(selfArg) == C.bool(true)
}

func (self Context) SetDragDropWithinTarget(v bool) {
	selfArg, selfFin := self.handle()
	defer selfFin()
	C.wrap_ImGuiContext_SetDragDropWithinTarget(selfArg, C.bool(v))
}

func (self *Context) DragDropWithinTarget() bool {
	selfArg, selfFin := self.handle()

	defer func() {
		selfFin()
	}()
	return C.wrap_ImGuiContext_GetDragDropWithinTarget(selfArg) == C.bool(true)
}

func (self Context) SetDragDropSourceFlags(v DragDropFlags) {
	selfArg, selfFin := self.handle()
	defer selfFin()
	C.wrap_ImGuiContext_SetDragDropSourceFlags(selfArg, C.ImGuiDragDropFlags(v))
}

func (self *Context) DragDropSourceFlags() DragDropFlags {
	selfArg, selfFin := self.handle()

	defer func() {
		selfFin()
	}()
	return DragDropFlags(C.wrap_ImGuiContext_GetDragDropSourceFlags(selfArg))
}

func (self Context) SetDragDropSourceFrameCount(v int32) {
	selfArg, selfFin := self.handle()
	defer selfFin()
	C.wrap_ImGuiContext_SetDragDropSourceFrameCount(selfArg, C.int(v))
}

func (self *Context) DragDropSourceFrameCount() int32 {
	selfArg, selfFin := self.handle()

	defer func() {
		selfFin()
	}()
	return int32(C.wrap_ImGuiContext_GetDragDropSourceFrameCount(selfArg))
}

func (self Context) SetDragDropMouseButton(v int32) {
	selfArg, selfFin := self.handle()
	defer selfFin()
	C.wrap_ImGuiContext_SetDragDropMouseButton(selfArg, C.int(v))
}

func (self *Context) DragDropMouseButton() int32 {
	selfArg, selfFin := self.handle()

	defer func() {
		selfFin()
	}()
	return int32(C.wrap_ImGuiContext_GetDragDropMouseButton(selfArg))
}

func (self Context) SetDragDropPayload(v Payload) {
	vArg, _ := v.c()

	selfArg, selfFin := self.handle()
	defer selfFin()
	C.wrap_ImGuiContext_SetDragDropPayload(selfArg, vArg)
}

func (self *Context) DragDropPayload() Payload {
	selfArg, selfFin := self.handle()

	defer func() {
		selfFin()
	}()

	result := C.wrap_ImGuiContext_GetDragDropPayload(selfArg)
	return *newPayloadFromC(func() *C.ImGuiPayload { result := result; return &result }())
}

func (self Context) SetDragDropTargetRect(v Rect) {
	selfArg, selfFin := self.handle()
	defer selfFin()
	C.wrap_ImGuiContext_SetDragDropTargetRect(selfArg, v.toC())
}

func (self *Context) DragDropTargetRect() Rect {
	selfArg, selfFin := self.handle()

	defer func() {
		selfFin()
	}()
	return *(&Rect{}).fromC(C.wrap_ImGuiContext_GetDragDropTargetRect(selfArg))
}

func (self Context) SetDragDropTargetId(v ID) {
	vArg, _ := v.c()

	selfArg, selfFin := self.handle()
	defer selfFin()
	C.wrap_ImGuiContext_SetDragDropTargetId(selfArg, vArg)
}

func (self *Context) DragDropTargetId() ID {
	selfArg, selfFin := self.handle()

	defer func() {
		selfFin()
	}()

	result := C.wrap_ImGuiContext_GetDragDropTargetId(selfArg)
	return *newIDFromC(func() *C.ImGuiID { result := result; return &result }())
}

func (self Context) SetDragDropAcceptFlags(v DragDropFlags) {
	selfArg, selfFin := self.handle()
	defer selfFin()
	C.wrap_ImGuiContext_SetDragDropAcceptFlags(selfArg, C.ImGuiDragDropFlags(v))
}

func (self *Context) DragDropAcceptFlags() DragDropFlags {
	selfArg, selfFin := self.handle()

	defer func() {
		selfFin()
	}()
	return DragDropFlags(C.wrap_ImGuiContext_GetDragDropAcceptFlags(selfArg))
}

func (self Context) SetDragDropAcceptIdCurrRectSurface(v float32) {
	selfArg, selfFin := self.handle()
	defer selfFin()
	C.wrap_ImGuiContext_SetDragDropAcceptIdCurrRectSurface(selfArg, C.float(v))
}

func (self *Context) DragDropAcceptIdCurrRectSurface() float32 {
	selfArg, selfFin := self.handle()

	defer func() {
		selfFin()
	}()
	return float32(C.wrap_ImGuiContext_GetDragDropAcceptIdCurrRectSurface(selfArg))
}

func (self Context) SetDragDropAcceptIdCurr(v ID) {
	vArg, _ := v.c()

	selfArg, selfFin := self.handle()
	defer selfFin()
	C.wrap_ImGuiContext_SetDragDropAcceptIdCurr(selfArg, vArg)
}

func (self *Context) DragDropAcceptIdCurr() ID {
	selfArg, selfFin := self.handle()

	defer func() {
		selfFin()
	}()

	result := C.wrap_ImGuiContext_GetDragDropAcceptIdCurr(selfArg)
	return *newIDFromC(func() *C.ImGuiID { result := result; return &result }())
}

func (self Context) SetDragDropAcceptIdPrev(v ID) {
	vArg, _ := v.c()

	selfArg, selfFin := self.handle()
	defer selfFin()
	C.wrap_ImGuiContext_SetDragDropAcceptIdPrev(selfArg, vArg)
}

func (self *Context) DragDropAcceptIdPrev() ID {
	selfArg, selfFin := self.handle()

	defer func() {
		selfFin()
	}()

	result := C.wrap_ImGuiContext_GetDragDropAcceptIdPrev(selfArg)
	return *newIDFromC(func() *C.ImGuiID { result := result; return &result }())
}

func (self Context) SetDragDropAcceptFrameCount(v int32) {
	selfArg, selfFin := self.handle()
	defer selfFin()
	C.wrap_ImGuiContext_SetDragDropAcceptFrameCount(selfArg, C.int(v))
}

func (self *Context) DragDropAcceptFrameCount() int32 {
	selfArg, selfFin := self.handle()

	defer func() {
		selfFin()
	}()
	return int32(C.wrap_ImGuiContext_GetDragDropAcceptFrameCount(selfArg))
}

func (self Context) SetDragDropHoldJustPressedId(v ID) {
	vArg, _ := v.c()

	selfArg, selfFin := self.handle()
	defer selfFin()
	C.wrap_ImGuiContext_SetDragDropHoldJustPressedId(selfArg, vArg)
}

func (self *Context) DragDropHoldJustPressedId() ID {
	selfArg, selfFin := self.handle()

	defer func() {
		selfFin()
	}()

	result := C.wrap_ImGuiContext_GetDragDropHoldJustPressedId(selfArg)
	return *newIDFromC(func() *C.ImGuiID { result := result; return &result }())
}

func (self Context) SetClipperTempDataStacked(v int32) {
	selfArg, selfFin := self.handle()
	defer selfFin()
	C.wrap_ImGuiContext_SetClipperTempDataStacked(selfArg, C.int(v))
}

func (self *Context) ClipperTempDataStacked() int32 {
	selfArg, selfFin := self.handle()

	defer func() {
		selfFin()
	}()
	return int32(C.wrap_ImGuiContext_GetClipperTempDataStacked(selfArg))
}

func (self Context) SetClipperTempData(v Vector[*ListClipperData]) {
	vData := v.Data
	vDataArg, _ := vData.handle()
	vVecArg := new(C.ImVector_ImGuiListClipperData)
	vVecArg.Size = C.int(v.Size)
	vVecArg.Capacity = C.int(v.Capacity)
	vVecArg.Data = vDataArg
	v.pinner.Pin(vVecArg.Data)

	selfArg, selfFin := self.handle()
	defer selfFin()
	C.wrap_ImGuiContext_SetClipperTempData(selfArg, *vVecArg)
}

func (self *Context) ClipperTempData() Vector[*ListClipperData] {
	selfArg, selfFin := self.handle()

	defer func() {
		selfFin()
	}()
	return newVectorFromC(C.wrap_ImGuiContext_GetClipperTempData(selfArg).Size, C.wrap_ImGuiContext_GetClipperTempData(selfArg).Capacity, newListClipperDataFromC(C.wrap_ImGuiContext_GetClipperTempData(selfArg).Data))
}

func (self Context) SetCurrentTable(v *Table) {
	vArg, _ := v.handle()

	selfArg, selfFin := self.handle()
	defer selfFin()
	C.wrap_ImGuiContext_SetCurrentTable(selfArg, vArg)
}

func (self *Context) CurrentTable() *Table {
	selfArg, selfFin := self.handle()

	defer func() {
		selfFin()
	}()
	return newTableFromC(C.wrap_ImGuiContext_GetCurrentTable(selfArg))
}

func (self Context) SetTablesTempDataStacked(v int32) {
	selfArg, selfFin := self.handle()
	defer selfFin()
	C.wrap_ImGuiContext_SetTablesTempDataStacked(selfArg, C.int(v))
}

func (self *Context) TablesTempDataStacked() int32 {
	selfArg, selfFin := self.handle()

	defer func() {
		selfFin()
	}()
	return int32(C.wrap_ImGuiContext_GetTablesTempDataStacked(selfArg))
}

func (self Context) SetTablesTempData(v Vector[*TableTempData]) {
	vData := v.Data
	vDataArg, _ := vData.handle()
	vVecArg := new(C.ImVector_ImGuiTableTempData)
	vVecArg.Size = C.int(v.Size)
	vVecArg.Capacity = C.int(v.Capacity)
	vVecArg.Data = vDataArg
	v.pinner.Pin(vVecArg.Data)

	selfArg, selfFin := self.handle()
	defer selfFin()
	C.wrap_ImGuiContext_SetTablesTempData(selfArg, *vVecArg)
}

func (self *Context) TablesTempData() Vector[*TableTempData] {
	selfArg, selfFin := self.handle()

	defer func() {
		selfFin()
	}()
	return newVectorFromC(C.wrap_ImGuiContext_GetTablesTempData(selfArg).Size, C.wrap_ImGuiContext_GetTablesTempData(selfArg).Capacity, newTableTempDataFromC(C.wrap_ImGuiContext_GetTablesTempData(selfArg).Data))
}

func (self Context) SetTablesLastTimeActive(v Vector[*float32]) {
	vData := v.Data
	vDataArg, _ := WrapNumberPtr[C.float, float32](vData)
	vVecArg := new(C.ImVector_float)
	vVecArg.Size = C.int(v.Size)
	vVecArg.Capacity = C.int(v.Capacity)
	vVecArg.Data = vDataArg
	v.pinner.Pin(vVecArg.Data)

	selfArg, selfFin := self.handle()
	defer selfFin()
	C.wrap_ImGuiContext_SetTablesLastTimeActive(selfArg, *vVecArg)
}

func (self *Context) TablesLastTimeActive() Vector[*float32] {
	selfArg, selfFin := self.handle()

	defer func() {
		selfFin()
	}()
	return newVectorFromC(C.wrap_ImGuiContext_GetTablesLastTimeActive(selfArg).Size, C.wrap_ImGuiContext_GetTablesLastTimeActive(selfArg).Capacity, (*float32)(C.wrap_ImGuiContext_GetTablesLastTimeActive(selfArg).Data))
}

func (self Context) SetDrawChannelsTempMergeBuffer(v Vector[*DrawChannel]) {
	vData := v.Data
	vDataArg, _ := vData.handle()
	vVecArg := new(C.ImVector_ImDrawChannel)
	vVecArg.Size = C.int(v.Size)
	vVecArg.Capacity = C.int(v.Capacity)
	vVecArg.Data = vDataArg
	v.pinner.Pin(vVecArg.Data)

	selfArg, selfFin := self.handle()
	defer selfFin()
	C.wrap_ImGuiContext_SetDrawChannelsTempMergeBuffer(selfArg, *vVecArg)
}

func (self *Context) DrawChannelsTempMergeBuffer() Vector[*DrawChannel] {
	selfArg, selfFin := self.handle()

	defer func() {
		selfFin()
	}()
	return newVectorFromC(C.wrap_ImGuiContext_GetDrawChannelsTempMergeBuffer(selfArg).Size, C.wrap_ImGuiContext_GetDrawChannelsTempMergeBuffer(selfArg).Capacity, newDrawChannelFromC(C.wrap_ImGuiContext_GetDrawChannelsTempMergeBuffer(selfArg).Data))
}

func (self Context) SetCurrentTabBar(v *TabBar) {
	vArg, _ := v.handle()

	selfArg, selfFin := self.handle()
	defer selfFin()
	C.wrap_ImGuiContext_SetCurrentTabBar(selfArg, vArg)
}

func (self *Context) CurrentTabBar() *TabBar {
	selfArg, selfFin := self.handle()

	defer func() {
		selfFin()
	}()
	return newTabBarFromC(C.wrap_ImGuiContext_GetCurrentTabBar(selfArg))
}

func (self Context) SetCurrentTabBarStack(v Vector[*PtrOrIndex]) {
	vData := v.Data
	vDataArg, _ := vData.handle()
	vVecArg := new(C.ImVector_ImGuiPtrOrIndex)
	vVecArg.Size = C.int(v.Size)
	vVecArg.Capacity = C.int(v.Capacity)
	vVecArg.Data = vDataArg
	v.pinner.Pin(vVecArg.Data)

	selfArg, selfFin := self.handle()
	defer selfFin()
	C.wrap_ImGuiContext_SetCurrentTabBarStack(selfArg, *vVecArg)
}

func (self *Context) CurrentTabBarStack() Vector[*PtrOrIndex] {
	selfArg, selfFin := self.handle()

	defer func() {
		selfFin()
	}()
	return newVectorFromC(C.wrap_ImGuiContext_GetCurrentTabBarStack(selfArg).Size, C.wrap_ImGuiContext_GetCurrentTabBarStack(selfArg).Capacity, newPtrOrIndexFromC(C.wrap_ImGuiContext_GetCurrentTabBarStack(selfArg).Data))
}

func (self Context) SetShrinkWidthBuffer(v Vector[*ShrinkWidthItem]) {
	vData := v.Data
	vDataArg, _ := vData.handle()
	vVecArg := new(C.ImVector_ImGuiShrinkWidthItem)
	vVecArg.Size = C.int(v.Size)
	vVecArg.Capacity = C.int(v.Capacity)
	vVecArg.Data = vDataArg
	v.pinner.Pin(vVecArg.Data)

	selfArg, selfFin := self.handle()
	defer selfFin()
	C.wrap_ImGuiContext_SetShrinkWidthBuffer(selfArg, *vVecArg)
}

func (self *Context) ShrinkWidthBuffer() Vector[*ShrinkWidthItem] {
	selfArg, selfFin := self.handle()

	defer func() {
		selfFin()
	}()
	return newVectorFromC(C.wrap_ImGuiContext_GetShrinkWidthBuffer(selfArg).Size, C.wrap_ImGuiContext_GetShrinkWidthBuffer(selfArg).Capacity, newShrinkWidthItemFromC(C.wrap_ImGuiContext_GetShrinkWidthBuffer(selfArg).Data))
}

func (self Context) SetHoverItemDelayId(v ID) {
	vArg, _ := v.c()

	selfArg, selfFin := self.handle()
	defer selfFin()
	C.wrap_ImGuiContext_SetHoverItemDelayId(selfArg, vArg)
}

func (self *Context) HoverItemDelayId() ID {
	selfArg, selfFin := self.handle()

	defer func() {
		selfFin()
	}()

	result := C.wrap_ImGuiContext_GetHoverItemDelayId(selfArg)
	return *newIDFromC(func() *C.ImGuiID { result := result; return &result }())
}

func (self Context) SetHoverItemDelayIdPreviousFrame(v ID) {
	vArg, _ := v.c()

	selfArg, selfFin := self.handle()
	defer selfFin()
	C.wrap_ImGuiContext_SetHoverItemDelayIdPreviousFrame(selfArg, vArg)
}

func (self *Context) HoverItemDelayIdPreviousFrame() ID {
	selfArg, selfFin := self.handle()

	defer func() {
		selfFin()
	}()

	result := C.wrap_ImGuiContext_GetHoverItemDelayIdPreviousFrame(selfArg)
	return *newIDFromC(func() *C.ImGuiID { result := result; return &result }())
}

func (self Context) SetHoverItemDelayTimer(v float32) {
	selfArg, selfFin := self.handle()
	defer selfFin()
	C.wrap_ImGuiContext_SetHoverItemDelayTimer(selfArg, C.float(v))
}

func (self *Context) HoverItemDelayTimer() float32 {
	selfArg, selfFin := self.handle()

	defer func() {
		selfFin()
	}()
	return float32(C.wrap_ImGuiContext_GetHoverItemDelayTimer(selfArg))
}

func (self Context) SetHoverItemDelayClearTimer(v float32) {
	selfArg, selfFin := self.handle()
	defer selfFin()
	C.wrap_ImGuiContext_SetHoverItemDelayClearTimer(selfArg, C.float(v))
}

func (self *Context) HoverItemDelayClearTimer() float32 {
	selfArg, selfFin := self.handle()

	defer func() {
		selfFin()
	}()
	return float32(C.wrap_ImGuiContext_GetHoverItemDelayClearTimer(selfArg))
}

func (self Context) SetHoverItemUnlockedStationaryId(v ID) {
	vArg, _ := v.c()

	selfArg, selfFin := self.handle()
	defer selfFin()
	C.wrap_ImGuiContext_SetHoverItemUnlockedStationaryId(selfArg, vArg)
}

func (self *Context) HoverItemUnlockedStationaryId() ID {
	selfArg, selfFin := self.handle()

	defer func() {
		selfFin()
	}()

	result := C.wrap_ImGuiContext_GetHoverItemUnlockedStationaryId(selfArg)
	return *newIDFromC(func() *C.ImGuiID { result := result; return &result }())
}

func (self Context) SetHoverWindowUnlockedStationaryId(v ID) {
	vArg, _ := v.c()

	selfArg, selfFin := self.handle()
	defer selfFin()
	C.wrap_ImGuiContext_SetHoverWindowUnlockedStationaryId(selfArg, vArg)
}

func (self *Context) HoverWindowUnlockedStationaryId() ID {
	selfArg, selfFin := self.handle()

	defer func() {
		selfFin()
	}()

	result := C.wrap_ImGuiContext_GetHoverWindowUnlockedStationaryId(selfArg)
	return *newIDFromC(func() *C.ImGuiID { result := result; return &result }())
}

func (self Context) SetMouseCursor(v MouseCursor) {
	selfArg, selfFin := self.handle()
	defer selfFin()
	C.wrap_ImGuiContext_SetMouseCursor(selfArg, C.ImGuiMouseCursor(v))
}

func (self *Context) MouseCursor() MouseCursor {
	selfArg, selfFin := self.handle()

	defer func() {
		selfFin()
	}()
	return MouseCursor(C.wrap_ImGuiContext_GetMouseCursor(selfArg))
}

func (self Context) SetMouseStationaryTimer(v float32) {
	selfArg, selfFin := self.handle()
	defer selfFin()
	C.wrap_ImGuiContext_SetMouseStationaryTimer(selfArg, C.float(v))
}

func (self *Context) MouseStationaryTimer() float32 {
	selfArg, selfFin := self.handle()

	defer func() {
		selfFin()
	}()
	return float32(C.wrap_ImGuiContext_GetMouseStationaryTimer(selfArg))
}

func (self Context) SetMouseLastValidPos(v Vec2) {
	selfArg, selfFin := self.handle()
	defer selfFin()
	C.wrap_ImGuiContext_SetMouseLastValidPos(selfArg, v.toC())
}

func (self *Context) MouseLastValidPos() Vec2 {
	selfArg, selfFin := self.handle()

	defer func() {
		selfFin()
	}()
	return *(&Vec2{}).fromC(C.wrap_ImGuiContext_GetMouseLastValidPos(selfArg))
}

func (self Context) SetInputTextState(v InputTextState) {
	vArg, _ := v.c()

	selfArg, selfFin := self.handle()
	defer selfFin()
	C.wrap_ImGuiContext_SetInputTextState(selfArg, vArg)
}

func (self *Context) InputTextState() InputTextState {
	selfArg, selfFin := self.handle()

	defer func() {
		selfFin()
	}()

	result := C.wrap_ImGuiContext_GetInputTextState(selfArg)
	return *newInputTextStateFromC(func() *C.ImGuiInputTextState { result := result; return &result }())
}

func (self Context) SetInputTextDeactivatedState(v InputTextDeactivatedState) {
	vArg, _ := v.c()

	selfArg, selfFin := self.handle()
	defer selfFin()
	C.wrap_ImGuiContext_SetInputTextDeactivatedState(selfArg, vArg)
}

func (self *Context) InputTextDeactivatedState() InputTextDeactivatedState {
	selfArg, selfFin := self.handle()

	defer func() {
		selfFin()
	}()

	result := C.wrap_ImGuiContext_GetInputTextDeactivatedState(selfArg)
	return *newInputTextDeactivatedStateFromC(func() *C.ImGuiInputTextDeactivatedState { result := result; return &result }())
}

func (self Context) SetInputTextPasswordFont(v Font) {
	vArg, _ := v.c()

	selfArg, selfFin := self.handle()
	defer selfFin()
	C.wrap_ImGuiContext_SetInputTextPasswordFont(selfArg, vArg)
}

func (self *Context) InputTextPasswordFont() Font {
	selfArg, selfFin := self.handle()

	defer func() {
		selfFin()
	}()

	result := C.wrap_ImGuiContext_GetInputTextPasswordFont(selfArg)
	return *newFontFromC(func() *C.ImFont { result := result; return &result }())
}

func (self Context) SetTempInputId(v ID) {
	vArg, _ := v.c()

	selfArg, selfFin := self.handle()
	defer selfFin()
	C.wrap_ImGuiContext_SetTempInputId(selfArg, vArg)
}

func (self *Context) TempInputId() ID {
	selfArg, selfFin := self.handle()

	defer func() {
		selfFin()
	}()

	result := C.wrap_ImGuiContext_GetTempInputId(selfArg)
	return *newIDFromC(func() *C.ImGuiID { result := result; return &result }())
}

func (self Context) SetColorEditOptions(v ColorEditFlags) {
	selfArg, selfFin := self.handle()
	defer selfFin()
	C.wrap_ImGuiContext_SetColorEditOptions(selfArg, C.ImGuiColorEditFlags(v))
}

func (self *Context) ColorEditOptions() ColorEditFlags {
	selfArg, selfFin := self.handle()

	defer func() {
		selfFin()
	}()
	return ColorEditFlags(C.wrap_ImGuiContext_GetColorEditOptions(selfArg))
}

func (self Context) SetColorEditCurrentID(v ID) {
	vArg, _ := v.c()

	selfArg, selfFin := self.handle()
	defer selfFin()
	C.wrap_ImGuiContext_SetColorEditCurrentID(selfArg, vArg)
}

func (self *Context) ColorEditCurrentID() ID {
	selfArg, selfFin := self.handle()

	defer func() {
		selfFin()
	}()

	result := C.wrap_ImGuiContext_GetColorEditCurrentID(selfArg)
	return *newIDFromC(func() *C.ImGuiID { result := result; return &result }())
}

func (self Context) SetColorEditSavedID(v ID) {
	vArg, _ := v.c()

	selfArg, selfFin := self.handle()
	defer selfFin()
	C.wrap_ImGuiContext_SetColorEditSavedID(selfArg, vArg)
}

func (self *Context) ColorEditSavedID() ID {
	selfArg, selfFin := self.handle()

	defer func() {
		selfFin()
	}()

	result := C.wrap_ImGuiContext_GetColorEditSavedID(selfArg)
	return *newIDFromC(func() *C.ImGuiID { result := result; return &result }())
}

func (self Context) SetColorEditSavedHue(v float32) {
	selfArg, selfFin := self.handle()
	defer selfFin()
	C.wrap_ImGuiContext_SetColorEditSavedHue(selfArg, C.float(v))
}

func (self *Context) ColorEditSavedHue() float32 {
	selfArg, selfFin := self.handle()

	defer func() {
		selfFin()
	}()
	return float32(C.wrap_ImGuiContext_GetColorEditSavedHue(selfArg))
}

func (self Context) SetColorEditSavedSat(v float32) {
	selfArg, selfFin := self.handle()
	defer selfFin()
	C.wrap_ImGuiContext_SetColorEditSavedSat(selfArg, C.float(v))
}

func (self *Context) ColorEditSavedSat() float32 {
	selfArg, selfFin := self.handle()

	defer func() {
		selfFin()
	}()
	return float32(C.wrap_ImGuiContext_GetColorEditSavedSat(selfArg))
}

func (self Context) SetColorEditSavedColor(v uint32) {
	selfArg, selfFin := self.handle()
	defer selfFin()
	C.wrap_ImGuiContext_SetColorEditSavedColor(selfArg, C.ImU32(v))
}

func (self *Context) ColorEditSavedColor() uint32 {
	selfArg, selfFin := self.handle()

	defer func() {
		selfFin()
	}()
	return uint32(C.wrap_ImGuiContext_GetColorEditSavedColor(selfArg))
}

func (self Context) SetColorPickerRef(v Vec4) {
	selfArg, selfFin := self.handle()
	defer selfFin()
	C.wrap_ImGuiContext_SetColorPickerRef(selfArg, v.toC())
}

func (self *Context) ColorPickerRef() Vec4 {
	selfArg, selfFin := self.handle()

	defer func() {
		selfFin()
	}()
	return *(&Vec4{}).fromC(C.wrap_ImGuiContext_GetColorPickerRef(selfArg))
}

func (self Context) SetComboPreviewData(v ComboPreviewData) {
	vArg, _ := v.c()

	selfArg, selfFin := self.handle()
	defer selfFin()
	C.wrap_ImGuiContext_SetComboPreviewData(selfArg, vArg)
}

func (self *Context) ComboPreviewData() ComboPreviewData {
	selfArg, selfFin := self.handle()

	defer func() {
		selfFin()
	}()

	result := C.wrap_ImGuiContext_GetComboPreviewData(selfArg)
	return *newComboPreviewDataFromC(func() *C.ImGuiComboPreviewData { result := result; return &result }())
}

func (self Context) SetSliderGrabClickOffset(v float32) {
	selfArg, selfFin := self.handle()
	defer selfFin()
	C.wrap_ImGuiContext_SetSliderGrabClickOffset(selfArg, C.float(v))
}

func (self *Context) SliderGrabClickOffset() float32 {
	selfArg, selfFin := self.handle()

	defer func() {
		selfFin()
	}()
	return float32(C.wrap_ImGuiContext_GetSliderGrabClickOffset(selfArg))
}

func (self Context) SetSliderCurrentAccum(v float32) {
	selfArg, selfFin := self.handle()
	defer selfFin()
	C.wrap_ImGuiContext_SetSliderCurrentAccum(selfArg, C.float(v))
}

func (self *Context) SliderCurrentAccum() float32 {
	selfArg, selfFin := self.handle()

	defer func() {
		selfFin()
	}()
	return float32(C.wrap_ImGuiContext_GetSliderCurrentAccum(selfArg))
}

func (self Context) SetSliderCurrentAccumDirty(v bool) {
	selfArg, selfFin := self.handle()
	defer selfFin()
	C.wrap_ImGuiContext_SetSliderCurrentAccumDirty(selfArg, C.bool(v))
}

func (self *Context) SliderCurrentAccumDirty() bool {
	selfArg, selfFin := self.handle()

	defer func() {
		selfFin()
	}()
	return C.wrap_ImGuiContext_GetSliderCurrentAccumDirty(selfArg) == C.bool(true)
}

func (self Context) SetDragCurrentAccumDirty(v bool) {
	selfArg, selfFin := self.handle()
	defer selfFin()
	C.wrap_ImGuiContext_SetDragCurrentAccumDirty(selfArg, C.bool(v))
}

func (self *Context) DragCurrentAccumDirty() bool {
	selfArg, selfFin := self.handle()

	defer func() {
		selfFin()
	}()
	return C.wrap_ImGuiContext_GetDragCurrentAccumDirty(selfArg) == C.bool(true)
}

func (self Context) SetDragCurrentAccum(v float32) {
	selfArg, selfFin := self.handle()
	defer selfFin()
	C.wrap_ImGuiContext_SetDragCurrentAccum(selfArg, C.float(v))
}

func (self *Context) DragCurrentAccum() float32 {
	selfArg, selfFin := self.handle()

	defer func() {
		selfFin()
	}()
	return float32(C.wrap_ImGuiContext_GetDragCurrentAccum(selfArg))
}

func (self Context) SetDragSpeedDefaultRatio(v float32) {
	selfArg, selfFin := self.handle()
	defer selfFin()
	C.wrap_ImGuiContext_SetDragSpeedDefaultRatio(selfArg, C.float(v))
}

func (self *Context) DragSpeedDefaultRatio() float32 {
	selfArg, selfFin := self.handle()

	defer func() {
		selfFin()
	}()
	return float32(C.wrap_ImGuiContext_GetDragSpeedDefaultRatio(selfArg))
}

func (self Context) SetScrollbarClickDeltaToGrabCenter(v float32) {
	selfArg, selfFin := self.handle()
	defer selfFin()
	C.wrap_ImGuiContext_SetScrollbarClickDeltaToGrabCenter(selfArg, C.float(v))
}

func (self *Context) ScrollbarClickDeltaToGrabCenter() float32 {
	selfArg, selfFin := self.handle()

	defer func() {
		selfFin()
	}()
	return float32(C.wrap_ImGuiContext_GetScrollbarClickDeltaToGrabCenter(selfArg))
}

func (self Context) SetDisabledAlphaBackup(v float32) {
	selfArg, selfFin := self.handle()
	defer selfFin()
	C.wrap_ImGuiContext_SetDisabledAlphaBackup(selfArg, C.float(v))
}

func (self *Context) DisabledAlphaBackup() float32 {
	selfArg, selfFin := self.handle()

	defer func() {
		selfFin()
	}()
	return float32(C.wrap_ImGuiContext_GetDisabledAlphaBackup(selfArg))
}

func (self Context) SetDisabledStackSize(v int16) {
	selfArg, selfFin := self.handle()
	defer selfFin()
	C.wrap_ImGuiContext_SetDisabledStackSize(selfArg, C.short(v))
}

func (self *Context) DisabledStackSize() int16 {
	selfArg, selfFin := self.handle()

	defer func() {
		selfFin()
	}()
	return int16(C.wrap_ImGuiContext_GetDisabledStackSize(selfArg))
}

func (self Context) SetLockMarkEdited(v int16) {
	selfArg, selfFin := self.handle()
	defer selfFin()
	C.wrap_ImGuiContext_SetLockMarkEdited(selfArg, C.short(v))
}

func (self *Context) LockMarkEdited() int16 {
	selfArg, selfFin := self.handle()

	defer func() {
		selfFin()
	}()
	return int16(C.wrap_ImGuiContext_GetLockMarkEdited(selfArg))
}

func (self Context) SetTooltipOverrideCount(v int16) {
	selfArg, selfFin := self.handle()
	defer selfFin()
	C.wrap_ImGuiContext_SetTooltipOverrideCount(selfArg, C.short(v))
}

func (self *Context) TooltipOverrideCount() int16 {
	selfArg, selfFin := self.handle()

	defer func() {
		selfFin()
	}()
	return int16(C.wrap_ImGuiContext_GetTooltipOverrideCount(selfArg))
}

func (self Context) SetClipboardHandlerData(v Vector[string]) {
	vData := v.Data
	vDataArg, _ := WrapString(vData)
	vVecArg := new(C.ImVector_char)
	vVecArg.Size = C.int(v.Size)
	vVecArg.Capacity = C.int(v.Capacity)
	vVecArg.Data = vDataArg
	v.pinner.Pin(vVecArg.Data)

	selfArg, selfFin := self.handle()
	defer selfFin()
	C.wrap_ImGuiContext_SetClipboardHandlerData(selfArg, *vVecArg)
}

func (self *Context) ClipboardHandlerData() Vector[string] {
	selfArg, selfFin := self.handle()

	defer func() {
		selfFin()
	}()
	return newVectorFromC(C.wrap_ImGuiContext_GetClipboardHandlerData(selfArg).Size, C.wrap_ImGuiContext_GetClipboardHandlerData(selfArg).Capacity, C.GoString(C.wrap_ImGuiContext_GetClipboardHandlerData(selfArg).Data))
}

func (self Context) SetMenusIdSubmittedThisFrame(v Vector[*ID]) {
	vData := v.Data
	vDataArg, _ := vData.handle()
	vVecArg := new(C.ImVector_ImGuiID)
	vVecArg.Size = C.int(v.Size)
	vVecArg.Capacity = C.int(v.Capacity)
	vVecArg.Data = vDataArg
	v.pinner.Pin(vVecArg.Data)

	selfArg, selfFin := self.handle()
	defer selfFin()
	C.wrap_ImGuiContext_SetMenusIdSubmittedThisFrame(selfArg, *vVecArg)
}

func (self *Context) MenusIdSubmittedThisFrame() Vector[*ID] {
	selfArg, selfFin := self.handle()

	defer func() {
		selfFin()
	}()
	return newVectorFromC(C.wrap_ImGuiContext_GetMenusIdSubmittedThisFrame(selfArg).Size, C.wrap_ImGuiContext_GetMenusIdSubmittedThisFrame(selfArg).Capacity, newIDFromC(C.wrap_ImGuiContext_GetMenusIdSubmittedThisFrame(selfArg).Data))
}

func (self Context) SetTypingSelectState(v TypingSelectState) {
	vArg, _ := v.c()

	selfArg, selfFin := self.handle()
	defer selfFin()
	C.wrap_ImGuiContext_SetTypingSelectState(selfArg, vArg)
}

func (self *Context) TypingSelectState() TypingSelectState {
	selfArg, selfFin := self.handle()

	defer func() {
		selfFin()
	}()

	result := C.wrap_ImGuiContext_GetTypingSelectState(selfArg)
	return *newTypingSelectStateFromC(func() *C.ImGuiTypingSelectState { result := result; return &result }())
}

func (self Context) SetPlatformImeData(v PlatformImeData) {
	vArg, _ := v.c()

	selfArg, selfFin := self.handle()
	defer selfFin()
	C.wrap_ImGuiContext_SetPlatformImeData(selfArg, vArg)
}

func (self *Context) PlatformImeData() PlatformImeData {
	selfArg, selfFin := self.handle()

	defer func() {
		selfFin()
	}()

	result := C.wrap_ImGuiContext_GetPlatformImeData(selfArg)
	return *newPlatformImeDataFromC(func() *C.ImGuiPlatformImeData { result := result; return &result }())
}

func (self Context) SetPlatformImeDataPrev(v PlatformImeData) {
	vArg, _ := v.c()

	selfArg, selfFin := self.handle()
	defer selfFin()
	C.wrap_ImGuiContext_SetPlatformImeDataPrev(selfArg, vArg)
}

func (self *Context) PlatformImeDataPrev() PlatformImeData {
	selfArg, selfFin := self.handle()

	defer func() {
		selfFin()
	}()

	result := C.wrap_ImGuiContext_GetPlatformImeDataPrev(selfArg)
	return *newPlatformImeDataFromC(func() *C.ImGuiPlatformImeData { result := result; return &result }())
}

func (self Context) SetPlatformImeViewport(v ID) {
	vArg, _ := v.c()

	selfArg, selfFin := self.handle()
	defer selfFin()
	C.wrap_ImGuiContext_SetPlatformImeViewport(selfArg, vArg)
}

func (self *Context) PlatformImeViewport() ID {
	selfArg, selfFin := self.handle()

	defer func() {
		selfFin()
	}()

	result := C.wrap_ImGuiContext_GetPlatformImeViewport(selfArg)
	return *newIDFromC(func() *C.ImGuiID { result := result; return &result }())
}

func (self Context) SetDockContext(v DockContext) {
	vArg, _ := v.c()

	selfArg, selfFin := self.handle()
	defer selfFin()
	C.wrap_ImGuiContext_SetDockContext(selfArg, vArg)
}

func (self *Context) DockContext() DockContext {
	selfArg, selfFin := self.handle()

	defer func() {
		selfFin()
	}()

	result := C.wrap_ImGuiContext_GetDockContext(selfArg)
	return *newDockContextFromC(func() *C.ImGuiDockContext { result := result; return &result }())
}

func (self Context) SetSettingsLoaded(v bool) {
	selfArg, selfFin := self.handle()
	defer selfFin()
	C.wrap_ImGuiContext_SetSettingsLoaded(selfArg, C.bool(v))
}

func (self *Context) SettingsLoaded() bool {
	selfArg, selfFin := self.handle()

	defer func() {
		selfFin()
	}()
	return C.wrap_ImGuiContext_GetSettingsLoaded(selfArg) == C.bool(true)
}

func (self Context) SetSettingsDirtyTimer(v float32) {
	selfArg, selfFin := self.handle()
	defer selfFin()
	C.wrap_ImGuiContext_SetSettingsDirtyTimer(selfArg, C.float(v))
}

func (self *Context) SettingsDirtyTimer() float32 {
	selfArg, selfFin := self.handle()

	defer func() {
		selfFin()
	}()
	return float32(C.wrap_ImGuiContext_GetSettingsDirtyTimer(selfArg))
}

func (self Context) SetSettingsIniData(v TextBuffer) {
	vArg, _ := v.c()

	selfArg, selfFin := self.handle()
	defer selfFin()
	C.wrap_ImGuiContext_SetSettingsIniData(selfArg, vArg)
}

func (self *Context) SettingsIniData() TextBuffer {
	selfArg, selfFin := self.handle()

	defer func() {
		selfFin()
	}()

	result := C.wrap_ImGuiContext_GetSettingsIniData(selfArg)
	return *newTextBufferFromC(func() *C.ImGuiTextBuffer { result := result; return &result }())
}

func (self Context) SetSettingsHandlers(v Vector[*SettingsHandler]) {
	vData := v.Data
	vDataArg, _ := vData.handle()
	vVecArg := new(C.ImVector_ImGuiSettingsHandler)
	vVecArg.Size = C.int(v.Size)
	vVecArg.Capacity = C.int(v.Capacity)
	vVecArg.Data = vDataArg
	v.pinner.Pin(vVecArg.Data)

	selfArg, selfFin := self.handle()
	defer selfFin()
	C.wrap_ImGuiContext_SetSettingsHandlers(selfArg, *vVecArg)
}

func (self *Context) SettingsHandlers() Vector[*SettingsHandler] {
	selfArg, selfFin := self.handle()

	defer func() {
		selfFin()
	}()
	return newVectorFromC(C.wrap_ImGuiContext_GetSettingsHandlers(selfArg).Size, C.wrap_ImGuiContext_GetSettingsHandlers(selfArg).Capacity, newSettingsHandlerFromC(C.wrap_ImGuiContext_GetSettingsHandlers(selfArg).Data))
}

func (self Context) SetHooks(v Vector[*ContextHook]) {
	vData := v.Data
	vDataArg, _ := vData.handle()
	vVecArg := new(C.ImVector_ImGuiContextHook)
	vVecArg.Size = C.int(v.Size)
	vVecArg.Capacity = C.int(v.Capacity)
	vVecArg.Data = vDataArg
	v.pinner.Pin(vVecArg.Data)

	selfArg, selfFin := self.handle()
	defer selfFin()
	C.wrap_ImGuiContext_SetHooks(selfArg, *vVecArg)
}

func (self *Context) Hooks() Vector[*ContextHook] {
	selfArg, selfFin := self.handle()

	defer func() {
		selfFin()
	}()
	return newVectorFromC(C.wrap_ImGuiContext_GetHooks(selfArg).Size, C.wrap_ImGuiContext_GetHooks(selfArg).Capacity, newContextHookFromC(C.wrap_ImGuiContext_GetHooks(selfArg).Data))
}

func (self Context) SetHookIdNext(v ID) {
	vArg, _ := v.c()

	selfArg, selfFin := self.handle()
	defer selfFin()
	C.wrap_ImGuiContext_SetHookIdNext(selfArg, vArg)
}

func (self *Context) HookIdNext() ID {
	selfArg, selfFin := self.handle()

	defer func() {
		selfFin()
	}()

	result := C.wrap_ImGuiContext_GetHookIdNext(selfArg)
	return *newIDFromC(func() *C.ImGuiID { result := result; return &result }())
}

func (self Context) SetLogEnabled(v bool) {
	selfArg, selfFin := self.handle()
	defer selfFin()
	C.wrap_ImGuiContext_SetLogEnabled(selfArg, C.bool(v))
}

func (self *Context) LogEnabled() bool {
	selfArg, selfFin := self.handle()

	defer func() {
		selfFin()
	}()
	return C.wrap_ImGuiContext_GetLogEnabled(selfArg) == C.bool(true)
}

func (self Context) SetLogType(v LogType) {
	selfArg, selfFin := self.handle()
	defer selfFin()
	C.wrap_ImGuiContext_SetLogType(selfArg, C.ImGuiLogType(v))
}

func (self *Context) LogType() LogType {
	selfArg, selfFin := self.handle()

	defer func() {
		selfFin()
	}()
	return LogType(C.wrap_ImGuiContext_GetLogType(selfArg))
}

func (self Context) SetLogBuffer(v TextBuffer) {
	vArg, _ := v.c()

	selfArg, selfFin := self.handle()
	defer selfFin()
	C.wrap_ImGuiContext_SetLogBuffer(selfArg, vArg)
}

func (self *Context) LogBuffer() TextBuffer {
	selfArg, selfFin := self.handle()

	defer func() {
		selfFin()
	}()

	result := C.wrap_ImGuiContext_GetLogBuffer(selfArg)
	return *newTextBufferFromC(func() *C.ImGuiTextBuffer { result := result; return &result }())
}

func (self Context) SetLogNextPrefix(v string) {
	vArg, _ := WrapString(v)

	selfArg, selfFin := self.handle()
	defer selfFin()
	C.wrap_ImGuiContext_SetLogNextPrefix(selfArg, vArg)
}

func (self *Context) LogNextPrefix() string {
	selfArg, selfFin := self.handle()

	defer func() {
		selfFin()
	}()
	return C.GoString(C.wrap_ImGuiContext_GetLogNextPrefix(selfArg))
}

func (self Context) SetLogNextSuffix(v string) {
	vArg, _ := WrapString(v)

	selfArg, selfFin := self.handle()
	defer selfFin()
	C.wrap_ImGuiContext_SetLogNextSuffix(selfArg, vArg)
}

func (self *Context) LogNextSuffix() string {
	selfArg, selfFin := self.handle()

	defer func() {
		selfFin()
	}()
	return C.GoString(C.wrap_ImGuiContext_GetLogNextSuffix(selfArg))
}

func (self Context) SetLogLinePosY(v float32) {
	selfArg, selfFin := self.handle()
	defer selfFin()
	C.wrap_ImGuiContext_SetLogLinePosY(selfArg, C.float(v))
}

func (self *Context) LogLinePosY() float32 {
	selfArg, selfFin := self.handle()

	defer func() {
		selfFin()
	}()
	return float32(C.wrap_ImGuiContext_GetLogLinePosY(selfArg))
}

func (self Context) SetLogLineFirstItem(v bool) {
	selfArg, selfFin := self.handle()
	defer selfFin()
	C.wrap_ImGuiContext_SetLogLineFirstItem(selfArg, C.bool(v))
}

func (self *Context) LogLineFirstItem() bool {
	selfArg, selfFin := self.handle()

	defer func() {
		selfFin()
	}()
	return C.wrap_ImGuiContext_GetLogLineFirstItem(selfArg) == C.bool(true)
}

func (self Context) SetLogDepthRef(v int32) {
	selfArg, selfFin := self.handle()
	defer selfFin()
	C.wrap_ImGuiContext_SetLogDepthRef(selfArg, C.int(v))
}

func (self *Context) LogDepthRef() int32 {
	selfArg, selfFin := self.handle()

	defer func() {
		selfFin()
	}()
	return int32(C.wrap_ImGuiContext_GetLogDepthRef(selfArg))
}

func (self Context) SetLogDepthToExpand(v int32) {
	selfArg, selfFin := self.handle()
	defer selfFin()
	C.wrap_ImGuiContext_SetLogDepthToExpand(selfArg, C.int(v))
}

func (self *Context) LogDepthToExpand() int32 {
	selfArg, selfFin := self.handle()

	defer func() {
		selfFin()
	}()
	return int32(C.wrap_ImGuiContext_GetLogDepthToExpand(selfArg))
}

func (self Context) SetLogDepthToExpandDefault(v int32) {
	selfArg, selfFin := self.handle()
	defer selfFin()
	C.wrap_ImGuiContext_SetLogDepthToExpandDefault(selfArg, C.int(v))
}

func (self *Context) LogDepthToExpandDefault() int32 {
	selfArg, selfFin := self.handle()

	defer func() {
		selfFin()
	}()
	return int32(C.wrap_ImGuiContext_GetLogDepthToExpandDefault(selfArg))
}

func (self Context) SetDebugLogFlags(v DebugLogFlags) {
	selfArg, selfFin := self.handle()
	defer selfFin()
	C.wrap_ImGuiContext_SetDebugLogFlags(selfArg, C.ImGuiDebugLogFlags(v))
}

func (self *Context) DebugLogFlags() DebugLogFlags {
	selfArg, selfFin := self.handle()

	defer func() {
		selfFin()
	}()
	return DebugLogFlags(C.wrap_ImGuiContext_GetDebugLogFlags(selfArg))
}

func (self Context) SetDebugLogBuf(v TextBuffer) {
	vArg, _ := v.c()

	selfArg, selfFin := self.handle()
	defer selfFin()
	C.wrap_ImGuiContext_SetDebugLogBuf(selfArg, vArg)
}

func (self *Context) DebugLogBuf() TextBuffer {
	selfArg, selfFin := self.handle()

	defer func() {
		selfFin()
	}()

	result := C.wrap_ImGuiContext_GetDebugLogBuf(selfArg)
	return *newTextBufferFromC(func() *C.ImGuiTextBuffer { result := result; return &result }())
}

func (self Context) SetDebugLogIndex(v TextIndex) {
	vArg, _ := v.c()

	selfArg, selfFin := self.handle()
	defer selfFin()
	C.wrap_ImGuiContext_SetDebugLogIndex(selfArg, vArg)
}

func (self *Context) DebugLogIndex() TextIndex {
	selfArg, selfFin := self.handle()

	defer func() {
		selfFin()
	}()

	result := C.wrap_ImGuiContext_GetDebugLogIndex(selfArg)
	return *newTextIndexFromC(func() *C.ImGuiTextIndex { result := result; return &result }())
}

func (self Context) SetDebugLogClipperAutoDisableFrames(v byte) {
	selfArg, selfFin := self.handle()
	defer selfFin()
	C.wrap_ImGuiContext_SetDebugLogClipperAutoDisableFrames(selfArg, C.ImU8(v))
}

func (self *Context) DebugLogClipperAutoDisableFrames() byte {
	selfArg, selfFin := self.handle()

	defer func() {
		selfFin()
	}()
	return byte(C.wrap_ImGuiContext_GetDebugLogClipperAutoDisableFrames(selfArg))
}

func (self Context) SetDebugLocateFrames(v byte) {
	selfArg, selfFin := self.handle()
	defer selfFin()
	C.wrap_ImGuiContext_SetDebugLocateFrames(selfArg, C.ImU8(v))
}

func (self *Context) DebugLocateFrames() byte {
	selfArg, selfFin := self.handle()

	defer func() {
		selfFin()
	}()
	return byte(C.wrap_ImGuiContext_GetDebugLocateFrames(selfArg))
}

func (self Context) SetDebugBeginReturnValueCullDepth(v int) {
	selfArg, selfFin := self.handle()
	defer selfFin()
	C.wrap_ImGuiContext_SetDebugBeginReturnValueCullDepth(selfArg, C.ImS8(v))
}

func (self *Context) DebugBeginReturnValueCullDepth() int {
	selfArg, selfFin := self.handle()

	defer func() {
		selfFin()
	}()
	return int(C.wrap_ImGuiContext_GetDebugBeginReturnValueCullDepth(selfArg))
}

func (self Context) SetDebugItemPickerActive(v bool) {
	selfArg, selfFin := self.handle()
	defer selfFin()
	C.wrap_ImGuiContext_SetDebugItemPickerActive(selfArg, C.bool(v))
}

func (self *Context) DebugItemPickerActive() bool {
	selfArg, selfFin := self.handle()

	defer func() {
		selfFin()
	}()
	return C.wrap_ImGuiContext_GetDebugItemPickerActive(selfArg) == C.bool(true)
}

func (self Context) SetDebugItemPickerMouseButton(v byte) {
	selfArg, selfFin := self.handle()
	defer selfFin()
	C.wrap_ImGuiContext_SetDebugItemPickerMouseButton(selfArg, C.ImU8(v))
}

func (self *Context) DebugItemPickerMouseButton() byte {
	selfArg, selfFin := self.handle()

	defer func() {
		selfFin()
	}()
	return byte(C.wrap_ImGuiContext_GetDebugItemPickerMouseButton(selfArg))
}

func (self Context) SetDebugItemPickerBreakId(v ID) {
	vArg, _ := v.c()

	selfArg, selfFin := self.handle()
	defer selfFin()
	C.wrap_ImGuiContext_SetDebugItemPickerBreakId(selfArg, vArg)
}

func (self *Context) DebugItemPickerBreakId() ID {
	selfArg, selfFin := self.handle()

	defer func() {
		selfFin()
	}()

	result := C.wrap_ImGuiContext_GetDebugItemPickerBreakId(selfArg)
	return *newIDFromC(func() *C.ImGuiID { result := result; return &result }())
}

func (self Context) SetDebugMetricsConfig(v MetricsConfig) {
	vArg, _ := v.c()

	selfArg, selfFin := self.handle()
	defer selfFin()
	C.wrap_ImGuiContext_SetDebugMetricsConfig(selfArg, vArg)
}

func (self *Context) DebugMetricsConfig() MetricsConfig {
	selfArg, selfFin := self.handle()

	defer func() {
		selfFin()
	}()

	result := C.wrap_ImGuiContext_GetDebugMetricsConfig(selfArg)
	return *newMetricsConfigFromC(func() *C.ImGuiMetricsConfig { result := result; return &result }())
}

func (self Context) SetDebugStackTool(v StackTool) {
	vArg, _ := v.c()

	selfArg, selfFin := self.handle()
	defer selfFin()
	C.wrap_ImGuiContext_SetDebugStackTool(selfArg, vArg)
}

func (self *Context) DebugStackTool() StackTool {
	selfArg, selfFin := self.handle()

	defer func() {
		selfFin()
	}()

	result := C.wrap_ImGuiContext_GetDebugStackTool(selfArg)
	return *newStackToolFromC(func() *C.ImGuiStackTool { result := result; return &result }())
}

func (self Context) SetDebugHoveredDockNode(v *DockNode) {
	vArg, _ := v.handle()

	selfArg, selfFin := self.handle()
	defer selfFin()
	C.wrap_ImGuiContext_SetDebugHoveredDockNode(selfArg, vArg)
}

func (self *Context) DebugHoveredDockNode() *DockNode {
	selfArg, selfFin := self.handle()

	defer func() {
		selfFin()
	}()
	return newDockNodeFromC(C.wrap_ImGuiContext_GetDebugHoveredDockNode(selfArg))
}

func (self Context) SetFramerateSecPerFrameIdx(v int32) {
	selfArg, selfFin := self.handle()
	defer selfFin()
	C.wrap_ImGuiContext_SetFramerateSecPerFrameIdx(selfArg, C.int(v))
}

func (self *Context) FramerateSecPerFrameIdx() int32 {
	selfArg, selfFin := self.handle()

	defer func() {
		selfFin()
	}()
	return int32(C.wrap_ImGuiContext_GetFramerateSecPerFrameIdx(selfArg))
}

func (self Context) SetFramerateSecPerFrameCount(v int32) {
	selfArg, selfFin := self.handle()
	defer selfFin()
	C.wrap_ImGuiContext_SetFramerateSecPerFrameCount(selfArg, C.int(v))
}

func (self *Context) FramerateSecPerFrameCount() int32 {
	selfArg, selfFin := self.handle()

	defer func() {
		selfFin()
	}()
	return int32(C.wrap_ImGuiContext_GetFramerateSecPerFrameCount(selfArg))
}

func (self Context) SetFramerateSecPerFrameAccum(v float32) {
	selfArg, selfFin := self.handle()
	defer selfFin()
	C.wrap_ImGuiContext_SetFramerateSecPerFrameAccum(selfArg, C.float(v))
}

func (self *Context) FramerateSecPerFrameAccum() float32 {
	selfArg, selfFin := self.handle()

	defer func() {
		selfFin()
	}()
	return float32(C.wrap_ImGuiContext_GetFramerateSecPerFrameAccum(selfArg))
}

func (self Context) SetWantCaptureMouseNextFrame(v int32) {
	selfArg, selfFin := self.handle()
	defer selfFin()
	C.wrap_ImGuiContext_SetWantCaptureMouseNextFrame(selfArg, C.int(v))
}

func (self *Context) WantCaptureMouseNextFrame() int32 {
	selfArg, selfFin := self.handle()

	defer func() {
		selfFin()
	}()
	return int32(C.wrap_ImGuiContext_GetWantCaptureMouseNextFrame(selfArg))
}

func (self Context) SetWantCaptureKeyboardNextFrame(v int32) {
	selfArg, selfFin := self.handle()
	defer selfFin()
	C.wrap_ImGuiContext_SetWantCaptureKeyboardNextFrame(selfArg, C.int(v))
}

func (self *Context) WantCaptureKeyboardNextFrame() int32 {
	selfArg, selfFin := self.handle()

	defer func() {
		selfFin()
	}()
	return int32(C.wrap_ImGuiContext_GetWantCaptureKeyboardNextFrame(selfArg))
}

func (self Context) SetWantTextInputNextFrame(v int32) {
	selfArg, selfFin := self.handle()
	defer selfFin()
	C.wrap_ImGuiContext_SetWantTextInputNextFrame(selfArg, C.int(v))
}

func (self *Context) WantTextInputNextFrame() int32 {
	selfArg, selfFin := self.handle()

	defer func() {
		selfFin()
	}()
	return int32(C.wrap_ImGuiContext_GetWantTextInputNextFrame(selfArg))
}

func (self Context) SetTempBuffer(v Vector[string]) {
	vData := v.Data
	vDataArg, _ := WrapString(vData)
	vVecArg := new(C.ImVector_char)
	vVecArg.Size = C.int(v.Size)
	vVecArg.Capacity = C.int(v.Capacity)
	vVecArg.Data = vDataArg
	v.pinner.Pin(vVecArg.Data)

	selfArg, selfFin := self.handle()
	defer selfFin()
	C.wrap_ImGuiContext_SetTempBuffer(selfArg, *vVecArg)
}

func (self *Context) TempBuffer() Vector[string] {
	selfArg, selfFin := self.handle()

	defer func() {
		selfFin()
	}()
	return newVectorFromC(C.wrap_ImGuiContext_GetTempBuffer(selfArg).Size, C.wrap_ImGuiContext_GetTempBuffer(selfArg).Capacity, C.GoString(C.wrap_ImGuiContext_GetTempBuffer(selfArg).Data))
}

func (self ContextHook) SetHookId(v ID) {
	vArg, _ := v.c()

	selfArg, selfFin := self.handle()
	defer selfFin()
	C.wrap_ImGuiContextHook_SetHookId(selfArg, vArg)
}

func (self *ContextHook) HookId() ID {
	selfArg, selfFin := self.handle()

	defer func() {
		selfFin()
	}()

	result := C.wrap_ImGuiContextHook_GetHookId(selfArg)
	return *newIDFromC(func() *C.ImGuiID { result := result; return &result }())
}

func (self ContextHook) SetType(v ContextHookType) {
	selfArg, selfFin := self.handle()
	defer selfFin()
	C.wrap_ImGuiContextHook_SetType(selfArg, C.ImGuiContextHookType(v))
}

func (self *ContextHook) Type() ContextHookType {
	selfArg, selfFin := self.handle()

	defer func() {
		selfFin()
	}()
	return ContextHookType(C.wrap_ImGuiContextHook_GetType(selfArg))
}

func (self ContextHook) SetOwner(v ID) {
	vArg, _ := v.c()

	selfArg, selfFin := self.handle()
	defer selfFin()
	C.wrap_ImGuiContextHook_SetOwner(selfArg, vArg)
}

func (self *ContextHook) Owner() ID {
	selfArg, selfFin := self.handle()

	defer func() {
		selfFin()
	}()

	result := C.wrap_ImGuiContextHook_GetOwner(selfArg)
	return *newIDFromC(func() *C.ImGuiID { result := result; return &result }())
}

func (self ContextHook) SetUserData(v unsafe.Pointer) {
	vArg, _ := WrapVoidPtr(v)

	selfArg, selfFin := self.handle()
	defer selfFin()
	C.wrap_ImGuiContextHook_SetUserData(selfArg, vArg)
}

func (self *ContextHook) UserData() unsafe.Pointer {
	selfArg, selfFin := self.handle()

	defer func() {
		selfFin()
	}()
	return unsafe.Pointer(C.wrap_ImGuiContextHook_GetUserData(selfArg))
}

func (self DataTypeInfo) SetSize(v uint64) {
	selfArg, selfFin := self.handle()
	defer selfFin()
	C.wrap_ImGuiDataTypeInfo_SetSize(selfArg, C.xulong(v))
}

func (self *DataTypeInfo) Size() uint64 {
	selfArg, selfFin := self.handle()

	defer func() {
		selfFin()
	}()
	return uint64(C.wrap_ImGuiDataTypeInfo_GetSize(selfArg))
}

func (self DataTypeInfo) SetName(v string) {
	vArg, _ := WrapString(v)

	selfArg, selfFin := self.handle()
	defer selfFin()
	C.wrap_ImGuiDataTypeInfo_SetName(selfArg, vArg)
}

func (self *DataTypeInfo) Name() string {
	selfArg, selfFin := self.handle()

	defer func() {
		selfFin()
	}()
	return C.GoString(C.wrap_ImGuiDataTypeInfo_GetName(selfArg))
}

func (self DataTypeInfo) SetPrintFmt(v string) {
	vArg, _ := WrapString(v)

	selfArg, selfFin := self.handle()
	defer selfFin()
	C.wrap_ImGuiDataTypeInfo_SetPrintFmt(selfArg, vArg)
}

func (self *DataTypeInfo) PrintFmt() string {
	selfArg, selfFin := self.handle()

	defer func() {
		selfFin()
	}()
	return C.GoString(C.wrap_ImGuiDataTypeInfo_GetPrintFmt(selfArg))
}

func (self DataTypeInfo) SetScanFmt(v string) {
	vArg, _ := WrapString(v)

	selfArg, selfFin := self.handle()
	defer selfFin()
	C.wrap_ImGuiDataTypeInfo_SetScanFmt(selfArg, vArg)
}

func (self *DataTypeInfo) ScanFmt() string {
	selfArg, selfFin := self.handle()

	defer func() {
		selfFin()
	}()
	return C.GoString(C.wrap_ImGuiDataTypeInfo_GetScanFmt(selfArg))
}

func (self DataVarInfo) SetType(v DataType) {
	selfArg, selfFin := self.handle()
	defer selfFin()
	C.wrap_ImGuiDataVarInfo_SetType(selfArg, C.ImGuiDataType(v))
}

func (self *DataVarInfo) Type() DataType {
	selfArg, selfFin := self.handle()

	defer func() {
		selfFin()
	}()
	return DataType(C.wrap_ImGuiDataVarInfo_GetType(selfArg))
}

func (self DataVarInfo) SetCount(v uint32) {
	selfArg, selfFin := self.handle()
	defer selfFin()
	C.wrap_ImGuiDataVarInfo_SetCount(selfArg, C.ImU32(v))
}

func (self *DataVarInfo) Count() uint32 {
	selfArg, selfFin := self.handle()

	defer func() {
		selfFin()
	}()
	return uint32(C.wrap_ImGuiDataVarInfo_GetCount(selfArg))
}

func (self DataVarInfo) SetOffset(v uint32) {
	selfArg, selfFin := self.handle()
	defer selfFin()
	C.wrap_ImGuiDataVarInfo_SetOffset(selfArg, C.ImU32(v))
}

func (self *DataVarInfo) Offset() uint32 {
	selfArg, selfFin := self.handle()

	defer func() {
		selfFin()
	}()
	return uint32(C.wrap_ImGuiDataVarInfo_GetOffset(selfArg))
}

func (self DockContext) SetNodes(v Storage) {
	vArg, _ := v.c()

	selfArg, selfFin := self.handle()
	defer selfFin()
	C.wrap_ImGuiDockContext_SetNodes(selfArg, vArg)
}

func (self *DockContext) Nodes() Storage {
	selfArg, selfFin := self.handle()

	defer func() {
		selfFin()
	}()

	result := C.wrap_ImGuiDockContext_GetNodes(selfArg)
	return *newStorageFromC(func() *C.ImGuiStorage { result := result; return &result }())
}

func (self DockContext) SetRequests(v Vector[*DockRequest]) {
	vData := v.Data
	vDataArg, _ := vData.handle()
	vVecArg := new(C.ImVector_ImGuiDockRequest)
	vVecArg.Size = C.int(v.Size)
	vVecArg.Capacity = C.int(v.Capacity)
	vVecArg.Data = vDataArg
	v.pinner.Pin(vVecArg.Data)

	selfArg, selfFin := self.handle()
	defer selfFin()
	C.wrap_ImGuiDockContext_SetRequests(selfArg, *vVecArg)
}

func (self *DockContext) Requests() Vector[*DockRequest] {
	selfArg, selfFin := self.handle()

	defer func() {
		selfFin()
	}()
	return newVectorFromC(C.wrap_ImGuiDockContext_GetRequests(selfArg).Size, C.wrap_ImGuiDockContext_GetRequests(selfArg).Capacity, newDockRequestFromC(C.wrap_ImGuiDockContext_GetRequests(selfArg).Data))
}

func (self DockContext) SetNodesSettings(v Vector[*DockNodeSettings]) {
	vData := v.Data
	vDataArg, _ := vData.handle()
	vVecArg := new(C.ImVector_ImGuiDockNodeSettings)
	vVecArg.Size = C.int(v.Size)
	vVecArg.Capacity = C.int(v.Capacity)
	vVecArg.Data = vDataArg
	v.pinner.Pin(vVecArg.Data)

	selfArg, selfFin := self.handle()
	defer selfFin()
	C.wrap_ImGuiDockContext_SetNodesSettings(selfArg, *vVecArg)
}

func (self *DockContext) NodesSettings() Vector[*DockNodeSettings] {
	selfArg, selfFin := self.handle()

	defer func() {
		selfFin()
	}()
	return newVectorFromC(C.wrap_ImGuiDockContext_GetNodesSettings(selfArg).Size, C.wrap_ImGuiDockContext_GetNodesSettings(selfArg).Capacity, newDockNodeSettingsFromC(C.wrap_ImGuiDockContext_GetNodesSettings(selfArg).Data))
}

func (self DockContext) SetWantFullRebuild(v bool) {
	selfArg, selfFin := self.handle()
	defer selfFin()
	C.wrap_ImGuiDockContext_SetWantFullRebuild(selfArg, C.bool(v))
}

func (self *DockContext) WantFullRebuild() bool {
	selfArg, selfFin := self.handle()

	defer func() {
		selfFin()
	}()
	return C.wrap_ImGuiDockContext_GetWantFullRebuild(selfArg) == C.bool(true)
}

func (self DockNode) SetID(v ID) {
	vArg, _ := v.c()

	selfArg, selfFin := self.handle()
	defer selfFin()
	C.wrap_ImGuiDockNode_SetID(selfArg, vArg)
}

func (self *DockNode) ID() ID {
	selfArg, selfFin := self.handle()

	defer func() {
		selfFin()
	}()

	result := C.wrap_ImGuiDockNode_GetID(selfArg)
	return *newIDFromC(func() *C.ImGuiID { result := result; return &result }())
}

func (self DockNode) SetSharedFlags(v DockNodeFlags) {
	selfArg, selfFin := self.handle()
	defer selfFin()
	C.wrap_ImGuiDockNode_SetSharedFlags(selfArg, C.ImGuiDockNodeFlags(v))
}

func (self *DockNode) SharedFlags() DockNodeFlags {
	selfArg, selfFin := self.handle()

	defer func() {
		selfFin()
	}()
	return DockNodeFlags(C.wrap_ImGuiDockNode_GetSharedFlags(selfArg))
}

func (self DockNode) SetLocalFlagsInWindows(v DockNodeFlags) {
	selfArg, selfFin := self.handle()
	defer selfFin()
	C.wrap_ImGuiDockNode_SetLocalFlagsInWindows(selfArg, C.ImGuiDockNodeFlags(v))
}

func (self *DockNode) LocalFlagsInWindows() DockNodeFlags {
	selfArg, selfFin := self.handle()

	defer func() {
		selfFin()
	}()
	return DockNodeFlags(C.wrap_ImGuiDockNode_GetLocalFlagsInWindows(selfArg))
}

func (self DockNode) SetMergedFlags(v DockNodeFlags) {
	selfArg, selfFin := self.handle()
	defer selfFin()
	C.wrap_ImGuiDockNode_SetMergedFlags(selfArg, C.ImGuiDockNodeFlags(v))
}

func (self *DockNode) MergedFlags() DockNodeFlags {
	selfArg, selfFin := self.handle()

	defer func() {
		selfFin()
	}()
	return DockNodeFlags(C.wrap_ImGuiDockNode_GetMergedFlags(selfArg))
}

func (self DockNode) SetState(v DockNodeState) {
	selfArg, selfFin := self.handle()
	defer selfFin()
	C.wrap_ImGuiDockNode_SetState(selfArg, C.ImGuiDockNodeState(v))
}

func (self *DockNode) State() DockNodeState {
	selfArg, selfFin := self.handle()

	defer func() {
		selfFin()
	}()
	return DockNodeState(C.wrap_ImGuiDockNode_GetState(selfArg))
}

func (self DockNode) SetParentNode(v *DockNode) {
	vArg, _ := v.handle()

	selfArg, selfFin := self.handle()
	defer selfFin()
	C.wrap_ImGuiDockNode_SetParentNode(selfArg, vArg)
}

func (self *DockNode) ParentNode() *DockNode {
	selfArg, selfFin := self.handle()

	defer func() {
		selfFin()
	}()
	return newDockNodeFromC(C.wrap_ImGuiDockNode_GetParentNode(selfArg))
}

func (self DockNode) SetTabBar(v *TabBar) {
	vArg, _ := v.handle()

	selfArg, selfFin := self.handle()
	defer selfFin()
	C.wrap_ImGuiDockNode_SetTabBar(selfArg, vArg)
}

func (self *DockNode) TabBar() *TabBar {
	selfArg, selfFin := self.handle()

	defer func() {
		selfFin()
	}()
	return newTabBarFromC(C.wrap_ImGuiDockNode_GetTabBar(selfArg))
}

func (self DockNode) SetPos(v Vec2) {
	selfArg, selfFin := self.handle()
	defer selfFin()
	C.wrap_ImGuiDockNode_SetPos(selfArg, v.toC())
}

func (self *DockNode) Pos() Vec2 {
	selfArg, selfFin := self.handle()

	defer func() {
		selfFin()
	}()
	return *(&Vec2{}).fromC(C.wrap_ImGuiDockNode_GetPos(selfArg))
}

func (self DockNode) SetSize(v Vec2) {
	selfArg, selfFin := self.handle()
	defer selfFin()
	C.wrap_ImGuiDockNode_SetSize(selfArg, v.toC())
}

func (self *DockNode) Size() Vec2 {
	selfArg, selfFin := self.handle()

	defer func() {
		selfFin()
	}()
	return *(&Vec2{}).fromC(C.wrap_ImGuiDockNode_GetSize(selfArg))
}

func (self DockNode) SetSizeRef(v Vec2) {
	selfArg, selfFin := self.handle()
	defer selfFin()
	C.wrap_ImGuiDockNode_SetSizeRef(selfArg, v.toC())
}

func (self *DockNode) SizeRef() Vec2 {
	selfArg, selfFin := self.handle()

	defer func() {
		selfFin()
	}()
	return *(&Vec2{}).fromC(C.wrap_ImGuiDockNode_GetSizeRef(selfArg))
}

func (self DockNode) SetSplitAxis(v Axis) {
	selfArg, selfFin := self.handle()
	defer selfFin()
	C.wrap_ImGuiDockNode_SetSplitAxis(selfArg, C.ImGuiAxis(v))
}

func (self *DockNode) SplitAxis() Axis {
	selfArg, selfFin := self.handle()

	defer func() {
		selfFin()
	}()
	return Axis(C.wrap_ImGuiDockNode_GetSplitAxis(selfArg))
}

func (self DockNode) SetWindowClass(v WindowClass) {
	vArg, _ := v.c()

	selfArg, selfFin := self.handle()
	defer selfFin()
	C.wrap_ImGuiDockNode_SetWindowClass(selfArg, vArg)
}

func (self *DockNode) WindowClass() WindowClass {
	selfArg, selfFin := self.handle()

	defer func() {
		selfFin()
	}()

	result := C.wrap_ImGuiDockNode_GetWindowClass(selfArg)
	return *newWindowClassFromC(func() *C.ImGuiWindowClass { result := result; return &result }())
}

func (self DockNode) SetLastBgColor(v uint32) {
	selfArg, selfFin := self.handle()
	defer selfFin()
	C.wrap_ImGuiDockNode_SetLastBgColor(selfArg, C.ImU32(v))
}

func (self *DockNode) LastBgColor() uint32 {
	selfArg, selfFin := self.handle()

	defer func() {
		selfFin()
	}()
	return uint32(C.wrap_ImGuiDockNode_GetLastBgColor(selfArg))
}

func (self DockNode) SetHostWindow(v *Window) {
	vArg, _ := v.handle()

	selfArg, selfFin := self.handle()
	defer selfFin()
	C.wrap_ImGuiDockNode_SetHostWindow(selfArg, vArg)
}

func (self *DockNode) HostWindow() *Window {
	selfArg, selfFin := self.handle()

	defer func() {
		selfFin()
	}()
	return newWindowFromC(C.wrap_ImGuiDockNode_GetHostWindow(selfArg))
}

func (self DockNode) SetVisibleWindow(v *Window) {
	vArg, _ := v.handle()

	selfArg, selfFin := self.handle()
	defer selfFin()
	C.wrap_ImGuiDockNode_SetVisibleWindow(selfArg, vArg)
}

func (self *DockNode) VisibleWindow() *Window {
	selfArg, selfFin := self.handle()

	defer func() {
		selfFin()
	}()
	return newWindowFromC(C.wrap_ImGuiDockNode_GetVisibleWindow(selfArg))
}

func (self DockNode) SetCentralNode(v *DockNode) {
	vArg, _ := v.handle()

	selfArg, selfFin := self.handle()
	defer selfFin()
	C.wrap_ImGuiDockNode_SetCentralNode(selfArg, vArg)
}

func (self *DockNode) CentralNode() *DockNode {
	selfArg, selfFin := self.handle()

	defer func() {
		selfFin()
	}()
	return newDockNodeFromC(C.wrap_ImGuiDockNode_GetCentralNode(selfArg))
}

func (self DockNode) SetOnlyNodeWithWindows(v *DockNode) {
	vArg, _ := v.handle()

	selfArg, selfFin := self.handle()
	defer selfFin()
	C.wrap_ImGuiDockNode_SetOnlyNodeWithWindows(selfArg, vArg)
}

func (self *DockNode) OnlyNodeWithWindows() *DockNode {
	selfArg, selfFin := self.handle()

	defer func() {
		selfFin()
	}()
	return newDockNodeFromC(C.wrap_ImGuiDockNode_GetOnlyNodeWithWindows(selfArg))
}

func (self DockNode) SetCountNodeWithWindows(v int32) {
	selfArg, selfFin := self.handle()
	defer selfFin()
	C.wrap_ImGuiDockNode_SetCountNodeWithWindows(selfArg, C.int(v))
}

func (self *DockNode) CountNodeWithWindows() int32 {
	selfArg, selfFin := self.handle()

	defer func() {
		selfFin()
	}()
	return int32(C.wrap_ImGuiDockNode_GetCountNodeWithWindows(selfArg))
}

func (self DockNode) SetLastFrameAlive(v int32) {
	selfArg, selfFin := self.handle()
	defer selfFin()
	C.wrap_ImGuiDockNode_SetLastFrameAlive(selfArg, C.int(v))
}

func (self *DockNode) LastFrameAlive() int32 {
	selfArg, selfFin := self.handle()

	defer func() {
		selfFin()
	}()
	return int32(C.wrap_ImGuiDockNode_GetLastFrameAlive(selfArg))
}

func (self DockNode) SetLastFrameActive(v int32) {
	selfArg, selfFin := self.handle()
	defer selfFin()
	C.wrap_ImGuiDockNode_SetLastFrameActive(selfArg, C.int(v))
}

func (self *DockNode) LastFrameActive() int32 {
	selfArg, selfFin := self.handle()

	defer func() {
		selfFin()
	}()
	return int32(C.wrap_ImGuiDockNode_GetLastFrameActive(selfArg))
}

func (self DockNode) SetLastFrameFocused(v int32) {
	selfArg, selfFin := self.handle()
	defer selfFin()
	C.wrap_ImGuiDockNode_SetLastFrameFocused(selfArg, C.int(v))
}

func (self *DockNode) LastFrameFocused() int32 {
	selfArg, selfFin := self.handle()

	defer func() {
		selfFin()
	}()
	return int32(C.wrap_ImGuiDockNode_GetLastFrameFocused(selfArg))
}

func (self DockNode) SetLastFocusedNodeId(v ID) {
	vArg, _ := v.c()

	selfArg, selfFin := self.handle()
	defer selfFin()
	C.wrap_ImGuiDockNode_SetLastFocusedNodeId(selfArg, vArg)
}

func (self *DockNode) LastFocusedNodeId() ID {
	selfArg, selfFin := self.handle()

	defer func() {
		selfFin()
	}()

	result := C.wrap_ImGuiDockNode_GetLastFocusedNodeId(selfArg)
	return *newIDFromC(func() *C.ImGuiID { result := result; return &result }())
}

func (self DockNode) SetSelectedTabId(v ID) {
	vArg, _ := v.c()

	selfArg, selfFin := self.handle()
	defer selfFin()
	C.wrap_ImGuiDockNode_SetSelectedTabId(selfArg, vArg)
}

func (self *DockNode) SelectedTabId() ID {
	selfArg, selfFin := self.handle()

	defer func() {
		selfFin()
	}()

	result := C.wrap_ImGuiDockNode_GetSelectedTabId(selfArg)
	return *newIDFromC(func() *C.ImGuiID { result := result; return &result }())
}

func (self DockNode) SetWantCloseTabId(v ID) {
	vArg, _ := v.c()

	selfArg, selfFin := self.handle()
	defer selfFin()
	C.wrap_ImGuiDockNode_SetWantCloseTabId(selfArg, vArg)
}

func (self *DockNode) WantCloseTabId() ID {
	selfArg, selfFin := self.handle()

	defer func() {
		selfFin()
	}()

	result := C.wrap_ImGuiDockNode_GetWantCloseTabId(selfArg)
	return *newIDFromC(func() *C.ImGuiID { result := result; return &result }())
}

func (self DockNode) SetRefViewportId(v ID) {
	vArg, _ := v.c()

	selfArg, selfFin := self.handle()
	defer selfFin()
	C.wrap_ImGuiDockNode_SetRefViewportId(selfArg, vArg)
}

func (self *DockNode) RefViewportId() ID {
	selfArg, selfFin := self.handle()

	defer func() {
		selfFin()
	}()

	result := C.wrap_ImGuiDockNode_GetRefViewportId(selfArg)
	return *newIDFromC(func() *C.ImGuiID { result := result; return &result }())
}

func (self DockNode) SetAuthorityForPos(v DataAuthority) {
	selfArg, selfFin := self.handle()
	defer selfFin()
	C.wrap_ImGuiDockNode_SetAuthorityForPos(selfArg, C.ImGuiDataAuthority(v))
}

func (self *DockNode) AuthorityForPos() DataAuthority {
	selfArg, selfFin := self.handle()

	defer func() {
		selfFin()
	}()
	return DataAuthority(C.wrap_ImGuiDockNode_GetAuthorityForPos(selfArg))
}

func (self DockNode) SetAuthorityForSize(v DataAuthority) {
	selfArg, selfFin := self.handle()
	defer selfFin()
	C.wrap_ImGuiDockNode_SetAuthorityForSize(selfArg, C.ImGuiDataAuthority(v))
}

func (self *DockNode) AuthorityForSize() DataAuthority {
	selfArg, selfFin := self.handle()

	defer func() {
		selfFin()
	}()
	return DataAuthority(C.wrap_ImGuiDockNode_GetAuthorityForSize(selfArg))
}

func (self DockNode) SetAuthorityForViewport(v DataAuthority) {
	selfArg, selfFin := self.handle()
	defer selfFin()
	C.wrap_ImGuiDockNode_SetAuthorityForViewport(selfArg, C.ImGuiDataAuthority(v))
}

func (self *DockNode) AuthorityForViewport() DataAuthority {
	selfArg, selfFin := self.handle()

	defer func() {
		selfFin()
	}()
	return DataAuthority(C.wrap_ImGuiDockNode_GetAuthorityForViewport(selfArg))
}

func (self DockNode) SetIsVisible(v bool) {
	selfArg, selfFin := self.handle()
	defer selfFin()
	C.wrap_ImGuiDockNode_SetIsVisible(selfArg, C.bool(v))
}

func (self *DockNode) IsVisible() bool {
	selfArg, selfFin := self.handle()

	defer func() {
		selfFin()
	}()
	return C.wrap_ImGuiDockNode_GetIsVisible(selfArg) == C.bool(true)
}

func (self DockNode) SetIsFocused(v bool) {
	selfArg, selfFin := self.handle()
	defer selfFin()
	C.wrap_ImGuiDockNode_SetIsFocused(selfArg, C.bool(v))
}

func (self *DockNode) IsFocused() bool {
	selfArg, selfFin := self.handle()

	defer func() {
		selfFin()
	}()
	return C.wrap_ImGuiDockNode_GetIsFocused(selfArg) == C.bool(true)
}

func (self DockNode) SetIsBgDrawnThisFrame(v bool) {
	selfArg, selfFin := self.handle()
	defer selfFin()
	C.wrap_ImGuiDockNode_SetIsBgDrawnThisFrame(selfArg, C.bool(v))
}

func (self *DockNode) IsBgDrawnThisFrame() bool {
	selfArg, selfFin := self.handle()

	defer func() {
		selfFin()
	}()
	return C.wrap_ImGuiDockNode_GetIsBgDrawnThisFrame(selfArg) == C.bool(true)
}

func (self DockNode) SetHasCloseButton(v bool) {
	selfArg, selfFin := self.handle()
	defer selfFin()
	C.wrap_ImGuiDockNode_SetHasCloseButton(selfArg, C.bool(v))
}

func (self *DockNode) HasCloseButton() bool {
	selfArg, selfFin := self.handle()

	defer func() {
		selfFin()
	}()
	return C.wrap_ImGuiDockNode_GetHasCloseButton(selfArg) == C.bool(true)
}

func (self DockNode) SetHasWindowMenuButton(v bool) {
	selfArg, selfFin := self.handle()
	defer selfFin()
	C.wrap_ImGuiDockNode_SetHasWindowMenuButton(selfArg, C.bool(v))
}

func (self *DockNode) HasWindowMenuButton() bool {
	selfArg, selfFin := self.handle()

	defer func() {
		selfFin()
	}()
	return C.wrap_ImGuiDockNode_GetHasWindowMenuButton(selfArg) == C.bool(true)
}

func (self DockNode) SetHasCentralNodeChild(v bool) {
	selfArg, selfFin := self.handle()
	defer selfFin()
	C.wrap_ImGuiDockNode_SetHasCentralNodeChild(selfArg, C.bool(v))
}

func (self *DockNode) HasCentralNodeChild() bool {
	selfArg, selfFin := self.handle()

	defer func() {
		selfFin()
	}()
	return C.wrap_ImGuiDockNode_GetHasCentralNodeChild(selfArg) == C.bool(true)
}

func (self DockNode) SetWantCloseAll(v bool) {
	selfArg, selfFin := self.handle()
	defer selfFin()
	C.wrap_ImGuiDockNode_SetWantCloseAll(selfArg, C.bool(v))
}

func (self *DockNode) WantCloseAll() bool {
	selfArg, selfFin := self.handle()

	defer func() {
		selfFin()
	}()
	return C.wrap_ImGuiDockNode_GetWantCloseAll(selfArg) == C.bool(true)
}

func (self DockNode) SetWantLockSizeOnce(v bool) {
	selfArg, selfFin := self.handle()
	defer selfFin()
	C.wrap_ImGuiDockNode_SetWantLockSizeOnce(selfArg, C.bool(v))
}

func (self *DockNode) WantLockSizeOnce() bool {
	selfArg, selfFin := self.handle()

	defer func() {
		selfFin()
	}()
	return C.wrap_ImGuiDockNode_GetWantLockSizeOnce(selfArg) == C.bool(true)
}

func (self DockNode) SetWantMouseMove(v bool) {
	selfArg, selfFin := self.handle()
	defer selfFin()
	C.wrap_ImGuiDockNode_SetWantMouseMove(selfArg, C.bool(v))
}

func (self *DockNode) WantMouseMove() bool {
	selfArg, selfFin := self.handle()

	defer func() {
		selfFin()
	}()
	return C.wrap_ImGuiDockNode_GetWantMouseMove(selfArg) == C.bool(true)
}

func (self DockNode) SetWantHiddenTabBarUpdate(v bool) {
	selfArg, selfFin := self.handle()
	defer selfFin()
	C.wrap_ImGuiDockNode_SetWantHiddenTabBarUpdate(selfArg, C.bool(v))
}

func (self *DockNode) WantHiddenTabBarUpdate() bool {
	selfArg, selfFin := self.handle()

	defer func() {
		selfFin()
	}()
	return C.wrap_ImGuiDockNode_GetWantHiddenTabBarUpdate(selfArg) == C.bool(true)
}

func (self DockNode) SetWantHiddenTabBarToggle(v bool) {
	selfArg, selfFin := self.handle()
	defer selfFin()
	C.wrap_ImGuiDockNode_SetWantHiddenTabBarToggle(selfArg, C.bool(v))
}

func (self *DockNode) WantHiddenTabBarToggle() bool {
	selfArg, selfFin := self.handle()

	defer func() {
		selfFin()
	}()
	return C.wrap_ImGuiDockNode_GetWantHiddenTabBarToggle(selfArg) == C.bool(true)
}

func (self GroupData) SetWindowID(v ID) {
	vArg, _ := v.c()

	selfArg, selfFin := self.handle()
	defer selfFin()
	C.wrap_ImGuiGroupData_SetWindowID(selfArg, vArg)
}

func (self *GroupData) WindowID() ID {
	selfArg, selfFin := self.handle()

	defer func() {
		selfFin()
	}()

	result := C.wrap_ImGuiGroupData_GetWindowID(selfArg)
	return *newIDFromC(func() *C.ImGuiID { result := result; return &result }())
}

func (self GroupData) SetBackupCursorPos(v Vec2) {
	selfArg, selfFin := self.handle()
	defer selfFin()
	C.wrap_ImGuiGroupData_SetBackupCursorPos(selfArg, v.toC())
}

func (self *GroupData) BackupCursorPos() Vec2 {
	selfArg, selfFin := self.handle()

	defer func() {
		selfFin()
	}()
	return *(&Vec2{}).fromC(C.wrap_ImGuiGroupData_GetBackupCursorPos(selfArg))
}

func (self GroupData) SetBackupCursorMaxPos(v Vec2) {
	selfArg, selfFin := self.handle()
	defer selfFin()
	C.wrap_ImGuiGroupData_SetBackupCursorMaxPos(selfArg, v.toC())
}

func (self *GroupData) BackupCursorMaxPos() Vec2 {
	selfArg, selfFin := self.handle()

	defer func() {
		selfFin()
	}()
	return *(&Vec2{}).fromC(C.wrap_ImGuiGroupData_GetBackupCursorMaxPos(selfArg))
}

func (self GroupData) SetBackupIndent(v Vec1) {
	vArg, _ := v.c()

	selfArg, selfFin := self.handle()
	defer selfFin()
	C.wrap_ImGuiGroupData_SetBackupIndent(selfArg, vArg)
}

func (self *GroupData) BackupIndent() Vec1 {
	selfArg, selfFin := self.handle()

	defer func() {
		selfFin()
	}()

	result := C.wrap_ImGuiGroupData_GetBackupIndent(selfArg)
	return *newVec1FromC(func() *C.ImVec1 { result := result; return &result }())
}

func (self GroupData) SetBackupGroupOffset(v Vec1) {
	vArg, _ := v.c()

	selfArg, selfFin := self.handle()
	defer selfFin()
	C.wrap_ImGuiGroupData_SetBackupGroupOffset(selfArg, vArg)
}

func (self *GroupData) BackupGroupOffset() Vec1 {
	selfArg, selfFin := self.handle()

	defer func() {
		selfFin()
	}()

	result := C.wrap_ImGuiGroupData_GetBackupGroupOffset(selfArg)
	return *newVec1FromC(func() *C.ImVec1 { result := result; return &result }())
}

func (self GroupData) SetBackupCurrLineSize(v Vec2) {
	selfArg, selfFin := self.handle()
	defer selfFin()
	C.wrap_ImGuiGroupData_SetBackupCurrLineSize(selfArg, v.toC())
}

func (self *GroupData) BackupCurrLineSize() Vec2 {
	selfArg, selfFin := self.handle()

	defer func() {
		selfFin()
	}()
	return *(&Vec2{}).fromC(C.wrap_ImGuiGroupData_GetBackupCurrLineSize(selfArg))
}

func (self GroupData) SetBackupCurrLineTextBaseOffset(v float32) {
	selfArg, selfFin := self.handle()
	defer selfFin()
	C.wrap_ImGuiGroupData_SetBackupCurrLineTextBaseOffset(selfArg, C.float(v))
}

func (self *GroupData) BackupCurrLineTextBaseOffset() float32 {
	selfArg, selfFin := self.handle()

	defer func() {
		selfFin()
	}()
	return float32(C.wrap_ImGuiGroupData_GetBackupCurrLineTextBaseOffset(selfArg))
}

func (self GroupData) SetBackupActiveIdIsAlive(v ID) {
	vArg, _ := v.c()

	selfArg, selfFin := self.handle()
	defer selfFin()
	C.wrap_ImGuiGroupData_SetBackupActiveIdIsAlive(selfArg, vArg)
}

func (self *GroupData) BackupActiveIdIsAlive() ID {
	selfArg, selfFin := self.handle()

	defer func() {
		selfFin()
	}()

	result := C.wrap_ImGuiGroupData_GetBackupActiveIdIsAlive(selfArg)
	return *newIDFromC(func() *C.ImGuiID { result := result; return &result }())
}

func (self GroupData) SetBackupActiveIdPreviousFrameIsAlive(v bool) {
	selfArg, selfFin := self.handle()
	defer selfFin()
	C.wrap_ImGuiGroupData_SetBackupActiveIdPreviousFrameIsAlive(selfArg, C.bool(v))
}

func (self *GroupData) BackupActiveIdPreviousFrameIsAlive() bool {
	selfArg, selfFin := self.handle()

	defer func() {
		selfFin()
	}()
	return C.wrap_ImGuiGroupData_GetBackupActiveIdPreviousFrameIsAlive(selfArg) == C.bool(true)
}

func (self GroupData) SetBackupHoveredIdIsAlive(v bool) {
	selfArg, selfFin := self.handle()
	defer selfFin()
	C.wrap_ImGuiGroupData_SetBackupHoveredIdIsAlive(selfArg, C.bool(v))
}

func (self *GroupData) BackupHoveredIdIsAlive() bool {
	selfArg, selfFin := self.handle()

	defer func() {
		selfFin()
	}()
	return C.wrap_ImGuiGroupData_GetBackupHoveredIdIsAlive(selfArg) == C.bool(true)
}

func (self GroupData) SetEmitItem(v bool) {
	selfArg, selfFin := self.handle()
	defer selfFin()
	C.wrap_ImGuiGroupData_SetEmitItem(selfArg, C.bool(v))
}

func (self *GroupData) EmitItem() bool {
	selfArg, selfFin := self.handle()

	defer func() {
		selfFin()
	}()
	return C.wrap_ImGuiGroupData_GetEmitItem(selfArg) == C.bool(true)
}

func (self IO) SetConfigFlags(v ConfigFlags) {
	selfArg, selfFin := self.handle()
	defer selfFin()
	C.wrap_ImGuiIO_SetConfigFlags(selfArg, C.ImGuiConfigFlags(v))
}

func (self *IO) ConfigFlags() ConfigFlags {
	selfArg, selfFin := self.handle()

	defer func() {
		selfFin()
	}()
	return ConfigFlags(C.wrap_ImGuiIO_GetConfigFlags(selfArg))
}

func (self IO) SetBackendFlags(v BackendFlags) {
	selfArg, selfFin := self.handle()
	defer selfFin()
	C.wrap_ImGuiIO_SetBackendFlags(selfArg, C.ImGuiBackendFlags(v))
}

func (self *IO) BackendFlags() BackendFlags {
	selfArg, selfFin := self.handle()

	defer func() {
		selfFin()
	}()
	return BackendFlags(C.wrap_ImGuiIO_GetBackendFlags(selfArg))
}

func (self IO) SetDisplaySize(v Vec2) {
	selfArg, selfFin := self.handle()
	defer selfFin()
	C.wrap_ImGuiIO_SetDisplaySize(selfArg, v.toC())
}

func (self *IO) DisplaySize() Vec2 {
	selfArg, selfFin := self.handle()

	defer func() {
		selfFin()
	}()
	return *(&Vec2{}).fromC(C.wrap_ImGuiIO_GetDisplaySize(selfArg))
}

func (self IO) SetDeltaTime(v float32) {
	selfArg, selfFin := self.handle()
	defer selfFin()
	C.wrap_ImGuiIO_SetDeltaTime(selfArg, C.float(v))
}

func (self *IO) DeltaTime() float32 {
	selfArg, selfFin := self.handle()

	defer func() {
		selfFin()
	}()
	return float32(C.wrap_ImGuiIO_GetDeltaTime(selfArg))
}

func (self IO) SetIniSavingRate(v float32) {
	selfArg, selfFin := self.handle()
	defer selfFin()
	C.wrap_ImGuiIO_SetIniSavingRate(selfArg, C.float(v))
}

func (self *IO) IniSavingRate() float32 {
	selfArg, selfFin := self.handle()

	defer func() {
		selfFin()
	}()
	return float32(C.wrap_ImGuiIO_GetIniSavingRate(selfArg))
}

func (self IO) SetIniFilename(v string) {
	vArg, _ := WrapString(v)

	selfArg, selfFin := self.handle()
	defer selfFin()
	C.wrap_ImGuiIO_SetIniFilename(selfArg, vArg)
}

func (self *IO) IniFilename() string {
	selfArg, selfFin := self.handle()

	defer func() {
		selfFin()
	}()
	return C.GoString(C.wrap_ImGuiIO_GetIniFilename(selfArg))
}

func (self IO) SetLogFilename(v string) {
	vArg, _ := WrapString(v)

	selfArg, selfFin := self.handle()
	defer selfFin()
	C.wrap_ImGuiIO_SetLogFilename(selfArg, vArg)
}

func (self *IO) LogFilename() string {
	selfArg, selfFin := self.handle()

	defer func() {
		selfFin()
	}()
	return C.GoString(C.wrap_ImGuiIO_GetLogFilename(selfArg))
}

func (self IO) SetUserData(v unsafe.Pointer) {
	vArg, _ := WrapVoidPtr(v)

	selfArg, selfFin := self.handle()
	defer selfFin()
	C.wrap_ImGuiIO_SetUserData(selfArg, vArg)
}

func (self *IO) UserData() unsafe.Pointer {
	selfArg, selfFin := self.handle()

	defer func() {
		selfFin()
	}()
	return unsafe.Pointer(C.wrap_ImGuiIO_GetUserData(selfArg))
}

func (self IO) SetFonts(v *FontAtlas) {
	vArg, _ := v.handle()

	selfArg, selfFin := self.handle()
	defer selfFin()
	C.wrap_ImGuiIO_SetFonts(selfArg, vArg)
}

func (self *IO) Fonts() *FontAtlas {
	selfArg, selfFin := self.handle()

	defer func() {
		selfFin()
	}()
	return newFontAtlasFromC(C.wrap_ImGuiIO_GetFonts(selfArg))
}

func (self IO) SetFontGlobalScale(v float32) {
	selfArg, selfFin := self.handle()
	defer selfFin()
	C.wrap_ImGuiIO_SetFontGlobalScale(selfArg, C.float(v))
}

func (self *IO) FontGlobalScale() float32 {
	selfArg, selfFin := self.handle()

	defer func() {
		selfFin()
	}()
	return float32(C.wrap_ImGuiIO_GetFontGlobalScale(selfArg))
}

func (self IO) SetFontAllowUserScaling(v bool) {
	selfArg, selfFin := self.handle()
	defer selfFin()
	C.wrap_ImGuiIO_SetFontAllowUserScaling(selfArg, C.bool(v))
}

func (self *IO) FontAllowUserScaling() bool {
	selfArg, selfFin := self.handle()

	defer func() {
		selfFin()
	}()
	return C.wrap_ImGuiIO_GetFontAllowUserScaling(selfArg) == C.bool(true)
}

func (self IO) SetFontDefault(v *Font) {
	vArg, _ := v.handle()

	selfArg, selfFin := self.handle()
	defer selfFin()
	C.wrap_ImGuiIO_SetFontDefault(selfArg, vArg)
}

func (self *IO) FontDefault() *Font {
	selfArg, selfFin := self.handle()

	defer func() {
		selfFin()
	}()
	return newFontFromC(C.wrap_ImGuiIO_GetFontDefault(selfArg))
}

func (self IO) SetDisplayFramebufferScale(v Vec2) {
	selfArg, selfFin := self.handle()
	defer selfFin()
	C.wrap_ImGuiIO_SetDisplayFramebufferScale(selfArg, v.toC())
}

func (self *IO) DisplayFramebufferScale() Vec2 {
	selfArg, selfFin := self.handle()

	defer func() {
		selfFin()
	}()
	return *(&Vec2{}).fromC(C.wrap_ImGuiIO_GetDisplayFramebufferScale(selfArg))
}

func (self IO) SetConfigDockingNoSplit(v bool) {
	selfArg, selfFin := self.handle()
	defer selfFin()
	C.wrap_ImGuiIO_SetConfigDockingNoSplit(selfArg, C.bool(v))
}

func (self *IO) ConfigDockingNoSplit() bool {
	selfArg, selfFin := self.handle()

	defer func() {
		selfFin()
	}()
	return C.wrap_ImGuiIO_GetConfigDockingNoSplit(selfArg) == C.bool(true)
}

func (self IO) SetConfigDockingWithShift(v bool) {
	selfArg, selfFin := self.handle()
	defer selfFin()
	C.wrap_ImGuiIO_SetConfigDockingWithShift(selfArg, C.bool(v))
}

func (self *IO) ConfigDockingWithShift() bool {
	selfArg, selfFin := self.handle()

	defer func() {
		selfFin()
	}()
	return C.wrap_ImGuiIO_GetConfigDockingWithShift(selfArg) == C.bool(true)
}

func (self IO) SetConfigDockingAlwaysTabBar(v bool) {
	selfArg, selfFin := self.handle()
	defer selfFin()
	C.wrap_ImGuiIO_SetConfigDockingAlwaysTabBar(selfArg, C.bool(v))
}

func (self *IO) ConfigDockingAlwaysTabBar() bool {
	selfArg, selfFin := self.handle()

	defer func() {
		selfFin()
	}()
	return C.wrap_ImGuiIO_GetConfigDockingAlwaysTabBar(selfArg) == C.bool(true)
}

func (self IO) SetConfigDockingTransparentPayload(v bool) {
	selfArg, selfFin := self.handle()
	defer selfFin()
	C.wrap_ImGuiIO_SetConfigDockingTransparentPayload(selfArg, C.bool(v))
}

func (self *IO) ConfigDockingTransparentPayload() bool {
	selfArg, selfFin := self.handle()

	defer func() {
		selfFin()
	}()
	return C.wrap_ImGuiIO_GetConfigDockingTransparentPayload(selfArg) == C.bool(true)
}

func (self IO) SetConfigViewportsNoAutoMerge(v bool) {
	selfArg, selfFin := self.handle()
	defer selfFin()
	C.wrap_ImGuiIO_SetConfigViewportsNoAutoMerge(selfArg, C.bool(v))
}

func (self *IO) ConfigViewportsNoAutoMerge() bool {
	selfArg, selfFin := self.handle()

	defer func() {
		selfFin()
	}()
	return C.wrap_ImGuiIO_GetConfigViewportsNoAutoMerge(selfArg) == C.bool(true)
}

func (self IO) SetConfigViewportsNoTaskBarIcon(v bool) {
	selfArg, selfFin := self.handle()
	defer selfFin()
	C.wrap_ImGuiIO_SetConfigViewportsNoTaskBarIcon(selfArg, C.bool(v))
}

func (self *IO) ConfigViewportsNoTaskBarIcon() bool {
	selfArg, selfFin := self.handle()

	defer func() {
		selfFin()
	}()
	return C.wrap_ImGuiIO_GetConfigViewportsNoTaskBarIcon(selfArg) == C.bool(true)
}

func (self IO) SetConfigViewportsNoDecoration(v bool) {
	selfArg, selfFin := self.handle()
	defer selfFin()
	C.wrap_ImGuiIO_SetConfigViewportsNoDecoration(selfArg, C.bool(v))
}

func (self *IO) ConfigViewportsNoDecoration() bool {
	selfArg, selfFin := self.handle()

	defer func() {
		selfFin()
	}()
	return C.wrap_ImGuiIO_GetConfigViewportsNoDecoration(selfArg) == C.bool(true)
}

func (self IO) SetConfigViewportsNoDefaultParent(v bool) {
	selfArg, selfFin := self.handle()
	defer selfFin()
	C.wrap_ImGuiIO_SetConfigViewportsNoDefaultParent(selfArg, C.bool(v))
}

func (self *IO) ConfigViewportsNoDefaultParent() bool {
	selfArg, selfFin := self.handle()

	defer func() {
		selfFin()
	}()
	return C.wrap_ImGuiIO_GetConfigViewportsNoDefaultParent(selfArg) == C.bool(true)
}

func (self IO) SetMouseDrawCursor(v bool) {
	selfArg, selfFin := self.handle()
	defer selfFin()
	C.wrap_ImGuiIO_SetMouseDrawCursor(selfArg, C.bool(v))
}

func (self *IO) MouseDrawCursor() bool {
	selfArg, selfFin := self.handle()

	defer func() {
		selfFin()
	}()
	return C.wrap_ImGuiIO_GetMouseDrawCursor(selfArg) == C.bool(true)
}

func (self IO) SetConfigMacOSXBehaviors(v bool) {
	selfArg, selfFin := self.handle()
	defer selfFin()
	C.wrap_ImGuiIO_SetConfigMacOSXBehaviors(selfArg, C.bool(v))
}

func (self *IO) ConfigMacOSXBehaviors() bool {
	selfArg, selfFin := self.handle()

	defer func() {
		selfFin()
	}()
	return C.wrap_ImGuiIO_GetConfigMacOSXBehaviors(selfArg) == C.bool(true)
}

func (self IO) SetConfigInputTrickleEventQueue(v bool) {
	selfArg, selfFin := self.handle()
	defer selfFin()
	C.wrap_ImGuiIO_SetConfigInputTrickleEventQueue(selfArg, C.bool(v))
}

func (self *IO) ConfigInputTrickleEventQueue() bool {
	selfArg, selfFin := self.handle()

	defer func() {
		selfFin()
	}()
	return C.wrap_ImGuiIO_GetConfigInputTrickleEventQueue(selfArg) == C.bool(true)
}

func (self IO) SetConfigInputTextCursorBlink(v bool) {
	selfArg, selfFin := self.handle()
	defer selfFin()
	C.wrap_ImGuiIO_SetConfigInputTextCursorBlink(selfArg, C.bool(v))
}

func (self *IO) ConfigInputTextCursorBlink() bool {
	selfArg, selfFin := self.handle()

	defer func() {
		selfFin()
	}()
	return C.wrap_ImGuiIO_GetConfigInputTextCursorBlink(selfArg) == C.bool(true)
}

func (self IO) SetConfigInputTextEnterKeepActive(v bool) {
	selfArg, selfFin := self.handle()
	defer selfFin()
	C.wrap_ImGuiIO_SetConfigInputTextEnterKeepActive(selfArg, C.bool(v))
}

func (self *IO) ConfigInputTextEnterKeepActive() bool {
	selfArg, selfFin := self.handle()

	defer func() {
		selfFin()
	}()
	return C.wrap_ImGuiIO_GetConfigInputTextEnterKeepActive(selfArg) == C.bool(true)
}

func (self IO) SetConfigDragClickToInputText(v bool) {
	selfArg, selfFin := self.handle()
	defer selfFin()
	C.wrap_ImGuiIO_SetConfigDragClickToInputText(selfArg, C.bool(v))
}

func (self *IO) ConfigDragClickToInputText() bool {
	selfArg, selfFin := self.handle()

	defer func() {
		selfFin()
	}()
	return C.wrap_ImGuiIO_GetConfigDragClickToInputText(selfArg) == C.bool(true)
}

func (self IO) SetConfigWindowsResizeFromEdges(v bool) {
	selfArg, selfFin := self.handle()
	defer selfFin()
	C.wrap_ImGuiIO_SetConfigWindowsResizeFromEdges(selfArg, C.bool(v))
}

func (self *IO) ConfigWindowsResizeFromEdges() bool {
	selfArg, selfFin := self.handle()

	defer func() {
		selfFin()
	}()
	return C.wrap_ImGuiIO_GetConfigWindowsResizeFromEdges(selfArg) == C.bool(true)
}

func (self IO) SetConfigWindowsMoveFromTitleBarOnly(v bool) {
	selfArg, selfFin := self.handle()
	defer selfFin()
	C.wrap_ImGuiIO_SetConfigWindowsMoveFromTitleBarOnly(selfArg, C.bool(v))
}

func (self *IO) ConfigWindowsMoveFromTitleBarOnly() bool {
	selfArg, selfFin := self.handle()

	defer func() {
		selfFin()
	}()
	return C.wrap_ImGuiIO_GetConfigWindowsMoveFromTitleBarOnly(selfArg) == C.bool(true)
}

func (self IO) SetConfigMemoryCompactTimer(v float32) {
	selfArg, selfFin := self.handle()
	defer selfFin()
	C.wrap_ImGuiIO_SetConfigMemoryCompactTimer(selfArg, C.float(v))
}

func (self *IO) ConfigMemoryCompactTimer() float32 {
	selfArg, selfFin := self.handle()

	defer func() {
		selfFin()
	}()
	return float32(C.wrap_ImGuiIO_GetConfigMemoryCompactTimer(selfArg))
}

func (self IO) SetMouseDoubleClickTime(v float32) {
	selfArg, selfFin := self.handle()
	defer selfFin()
	C.wrap_ImGuiIO_SetMouseDoubleClickTime(selfArg, C.float(v))
}

func (self *IO) MouseDoubleClickTime() float32 {
	selfArg, selfFin := self.handle()

	defer func() {
		selfFin()
	}()
	return float32(C.wrap_ImGuiIO_GetMouseDoubleClickTime(selfArg))
}

func (self IO) SetMouseDoubleClickMaxDist(v float32) {
	selfArg, selfFin := self.handle()
	defer selfFin()
	C.wrap_ImGuiIO_SetMouseDoubleClickMaxDist(selfArg, C.float(v))
}

func (self *IO) MouseDoubleClickMaxDist() float32 {
	selfArg, selfFin := self.handle()

	defer func() {
		selfFin()
	}()
	return float32(C.wrap_ImGuiIO_GetMouseDoubleClickMaxDist(selfArg))
}

func (self IO) SetMouseDragThreshold(v float32) {
	selfArg, selfFin := self.handle()
	defer selfFin()
	C.wrap_ImGuiIO_SetMouseDragThreshold(selfArg, C.float(v))
}

func (self *IO) MouseDragThreshold() float32 {
	selfArg, selfFin := self.handle()

	defer func() {
		selfFin()
	}()
	return float32(C.wrap_ImGuiIO_GetMouseDragThreshold(selfArg))
}

func (self IO) SetKeyRepeatDelay(v float32) {
	selfArg, selfFin := self.handle()
	defer selfFin()
	C.wrap_ImGuiIO_SetKeyRepeatDelay(selfArg, C.float(v))
}

func (self *IO) KeyRepeatDelay() float32 {
	selfArg, selfFin := self.handle()

	defer func() {
		selfFin()
	}()
	return float32(C.wrap_ImGuiIO_GetKeyRepeatDelay(selfArg))
}

func (self IO) SetKeyRepeatRate(v float32) {
	selfArg, selfFin := self.handle()
	defer selfFin()
	C.wrap_ImGuiIO_SetKeyRepeatRate(selfArg, C.float(v))
}

func (self *IO) KeyRepeatRate() float32 {
	selfArg, selfFin := self.handle()

	defer func() {
		selfFin()
	}()
	return float32(C.wrap_ImGuiIO_GetKeyRepeatRate(selfArg))
}

func (self IO) SetConfigDebugBeginReturnValueOnce(v bool) {
	selfArg, selfFin := self.handle()
	defer selfFin()
	C.wrap_ImGuiIO_SetConfigDebugBeginReturnValueOnce(selfArg, C.bool(v))
}

func (self *IO) ConfigDebugBeginReturnValueOnce() bool {
	selfArg, selfFin := self.handle()

	defer func() {
		selfFin()
	}()
	return C.wrap_ImGuiIO_GetConfigDebugBeginReturnValueOnce(selfArg) == C.bool(true)
}

func (self IO) SetConfigDebugBeginReturnValueLoop(v bool) {
	selfArg, selfFin := self.handle()
	defer selfFin()
	C.wrap_ImGuiIO_SetConfigDebugBeginReturnValueLoop(selfArg, C.bool(v))
}

func (self *IO) ConfigDebugBeginReturnValueLoop() bool {
	selfArg, selfFin := self.handle()

	defer func() {
		selfFin()
	}()
	return C.wrap_ImGuiIO_GetConfigDebugBeginReturnValueLoop(selfArg) == C.bool(true)
}

func (self IO) SetConfigDebugIgnoreFocusLoss(v bool) {
	selfArg, selfFin := self.handle()
	defer selfFin()
	C.wrap_ImGuiIO_SetConfigDebugIgnoreFocusLoss(selfArg, C.bool(v))
}

func (self *IO) ConfigDebugIgnoreFocusLoss() bool {
	selfArg, selfFin := self.handle()

	defer func() {
		selfFin()
	}()
	return C.wrap_ImGuiIO_GetConfigDebugIgnoreFocusLoss(selfArg) == C.bool(true)
}

func (self IO) SetConfigDebugIniSettings(v bool) {
	selfArg, selfFin := self.handle()
	defer selfFin()
	C.wrap_ImGuiIO_SetConfigDebugIniSettings(selfArg, C.bool(v))
}

func (self *IO) ConfigDebugIniSettings() bool {
	selfArg, selfFin := self.handle()

	defer func() {
		selfFin()
	}()
	return C.wrap_ImGuiIO_GetConfigDebugIniSettings(selfArg) == C.bool(true)
}

func (self IO) SetBackendPlatformName(v string) {
	vArg, _ := WrapString(v)

	selfArg, selfFin := self.handle()
	defer selfFin()
	C.wrap_ImGuiIO_SetBackendPlatformName(selfArg, vArg)
}

func (self *IO) BackendPlatformName() string {
	selfArg, selfFin := self.handle()

	defer func() {
		selfFin()
	}()
	return C.GoString(C.wrap_ImGuiIO_GetBackendPlatformName(selfArg))
}

func (self IO) SetBackendRendererName(v string) {
	vArg, _ := WrapString(v)

	selfArg, selfFin := self.handle()
	defer selfFin()
	C.wrap_ImGuiIO_SetBackendRendererName(selfArg, vArg)
}

func (self *IO) BackendRendererName() string {
	selfArg, selfFin := self.handle()

	defer func() {
		selfFin()
	}()
	return C.GoString(C.wrap_ImGuiIO_GetBackendRendererName(selfArg))
}

func (self IO) SetBackendPlatformUserData(v unsafe.Pointer) {
	vArg, _ := WrapVoidPtr(v)

	selfArg, selfFin := self.handle()
	defer selfFin()
	C.wrap_ImGuiIO_SetBackendPlatformUserData(selfArg, vArg)
}

func (self *IO) BackendPlatformUserData() unsafe.Pointer {
	selfArg, selfFin := self.handle()

	defer func() {
		selfFin()
	}()
	return unsafe.Pointer(C.wrap_ImGuiIO_GetBackendPlatformUserData(selfArg))
}

func (self IO) SetBackendRendererUserData(v unsafe.Pointer) {
	vArg, _ := WrapVoidPtr(v)

	selfArg, selfFin := self.handle()
	defer selfFin()
	C.wrap_ImGuiIO_SetBackendRendererUserData(selfArg, vArg)
}

func (self *IO) BackendRendererUserData() unsafe.Pointer {
	selfArg, selfFin := self.handle()

	defer func() {
		selfFin()
	}()
	return unsafe.Pointer(C.wrap_ImGuiIO_GetBackendRendererUserData(selfArg))
}

func (self IO) SetBackendLanguageUserData(v unsafe.Pointer) {
	vArg, _ := WrapVoidPtr(v)

	selfArg, selfFin := self.handle()
	defer selfFin()
	C.wrap_ImGuiIO_SetBackendLanguageUserData(selfArg, vArg)
}

func (self *IO) BackendLanguageUserData() unsafe.Pointer {
	selfArg, selfFin := self.handle()

	defer func() {
		selfFin()
	}()
	return unsafe.Pointer(C.wrap_ImGuiIO_GetBackendLanguageUserData(selfArg))
}

func (self IO) SetClipboardUserData(v unsafe.Pointer) {
	vArg, _ := WrapVoidPtr(v)

	selfArg, selfFin := self.handle()
	defer selfFin()
	C.wrap_ImGuiIO_SetClipboardUserData(selfArg, vArg)
}

func (self *IO) ClipboardUserData() unsafe.Pointer {
	selfArg, selfFin := self.handle()

	defer func() {
		selfFin()
	}()
	return unsafe.Pointer(C.wrap_ImGuiIO_GetClipboardUserData(selfArg))
}

func (self IO) SetUnusedPadding(v unsafe.Pointer) {
	vArg, _ := WrapVoidPtr(v)

	selfArg, selfFin := self.handle()
	defer selfFin()
	C.wrap_ImGuiIO_Set_UnusedPadding(selfArg, vArg)
}

func (self *IO) UnusedPadding() unsafe.Pointer {
	selfArg, selfFin := self.handle()

	defer func() {
		selfFin()
	}()
	return unsafe.Pointer(C.wrap_ImGuiIO_Get_UnusedPadding(selfArg))
}

func (self IO) SetPlatformLocaleDecimalPoint(v Wchar) {
	selfArg, selfFin := self.handle()
	defer selfFin()
	C.wrap_ImGuiIO_SetPlatformLocaleDecimalPoint(selfArg, C.ImWchar(v))
}

func (self *IO) PlatformLocaleDecimalPoint() Wchar {
	selfArg, selfFin := self.handle()

	defer func() {
		selfFin()
	}()
	return Wchar(C.wrap_ImGuiIO_GetPlatformLocaleDecimalPoint(selfArg))
}

func (self IO) SetWantCaptureMouse(v bool) {
	selfArg, selfFin := self.handle()
	defer selfFin()
	C.wrap_ImGuiIO_SetWantCaptureMouse(selfArg, C.bool(v))
}

func (self *IO) WantCaptureMouse() bool {
	selfArg, selfFin := self.handle()

	defer func() {
		selfFin()
	}()
	return C.wrap_ImGuiIO_GetWantCaptureMouse(selfArg) == C.bool(true)
}

func (self IO) SetWantCaptureKeyboard(v bool) {
	selfArg, selfFin := self.handle()
	defer selfFin()
	C.wrap_ImGuiIO_SetWantCaptureKeyboard(selfArg, C.bool(v))
}

func (self *IO) WantCaptureKeyboard() bool {
	selfArg, selfFin := self.handle()

	defer func() {
		selfFin()
	}()
	return C.wrap_ImGuiIO_GetWantCaptureKeyboard(selfArg) == C.bool(true)
}

func (self IO) SetWantTextInput(v bool) {
	selfArg, selfFin := self.handle()
	defer selfFin()
	C.wrap_ImGuiIO_SetWantTextInput(selfArg, C.bool(v))
}

func (self *IO) WantTextInput() bool {
	selfArg, selfFin := self.handle()

	defer func() {
		selfFin()
	}()
	return C.wrap_ImGuiIO_GetWantTextInput(selfArg) == C.bool(true)
}

func (self IO) SetWantSetMousePos(v bool) {
	selfArg, selfFin := self.handle()
	defer selfFin()
	C.wrap_ImGuiIO_SetWantSetMousePos(selfArg, C.bool(v))
}

func (self *IO) WantSetMousePos() bool {
	selfArg, selfFin := self.handle()

	defer func() {
		selfFin()
	}()
	return C.wrap_ImGuiIO_GetWantSetMousePos(selfArg) == C.bool(true)
}

func (self IO) SetWantSaveIniSettings(v bool) {
	selfArg, selfFin := self.handle()
	defer selfFin()
	C.wrap_ImGuiIO_SetWantSaveIniSettings(selfArg, C.bool(v))
}

func (self *IO) WantSaveIniSettings() bool {
	selfArg, selfFin := self.handle()

	defer func() {
		selfFin()
	}()
	return C.wrap_ImGuiIO_GetWantSaveIniSettings(selfArg) == C.bool(true)
}

func (self IO) SetNavActive(v bool) {
	selfArg, selfFin := self.handle()
	defer selfFin()
	C.wrap_ImGuiIO_SetNavActive(selfArg, C.bool(v))
}

func (self *IO) NavActive() bool {
	selfArg, selfFin := self.handle()

	defer func() {
		selfFin()
	}()
	return C.wrap_ImGuiIO_GetNavActive(selfArg) == C.bool(true)
}

func (self IO) SetNavVisible(v bool) {
	selfArg, selfFin := self.handle()
	defer selfFin()
	C.wrap_ImGuiIO_SetNavVisible(selfArg, C.bool(v))
}

func (self *IO) NavVisible() bool {
	selfArg, selfFin := self.handle()

	defer func() {
		selfFin()
	}()
	return C.wrap_ImGuiIO_GetNavVisible(selfArg) == C.bool(true)
}

func (self IO) SetFramerate(v float32) {
	selfArg, selfFin := self.handle()
	defer selfFin()
	C.wrap_ImGuiIO_SetFramerate(selfArg, C.float(v))
}

func (self *IO) Framerate() float32 {
	selfArg, selfFin := self.handle()

	defer func() {
		selfFin()
	}()
	return float32(C.wrap_ImGuiIO_GetFramerate(selfArg))
}

func (self IO) SetMetricsRenderVertices(v int32) {
	selfArg, selfFin := self.handle()
	defer selfFin()
	C.wrap_ImGuiIO_SetMetricsRenderVertices(selfArg, C.int(v))
}

func (self *IO) MetricsRenderVertices() int32 {
	selfArg, selfFin := self.handle()

	defer func() {
		selfFin()
	}()
	return int32(C.wrap_ImGuiIO_GetMetricsRenderVertices(selfArg))
}

func (self IO) SetMetricsRenderIndices(v int32) {
	selfArg, selfFin := self.handle()
	defer selfFin()
	C.wrap_ImGuiIO_SetMetricsRenderIndices(selfArg, C.int(v))
}

func (self *IO) MetricsRenderIndices() int32 {
	selfArg, selfFin := self.handle()

	defer func() {
		selfFin()
	}()
	return int32(C.wrap_ImGuiIO_GetMetricsRenderIndices(selfArg))
}

func (self IO) SetMetricsRenderWindows(v int32) {
	selfArg, selfFin := self.handle()
	defer selfFin()
	C.wrap_ImGuiIO_SetMetricsRenderWindows(selfArg, C.int(v))
}

func (self *IO) MetricsRenderWindows() int32 {
	selfArg, selfFin := self.handle()

	defer func() {
		selfFin()
	}()
	return int32(C.wrap_ImGuiIO_GetMetricsRenderWindows(selfArg))
}

func (self IO) SetMetricsActiveWindows(v int32) {
	selfArg, selfFin := self.handle()
	defer selfFin()
	C.wrap_ImGuiIO_SetMetricsActiveWindows(selfArg, C.int(v))
}

func (self *IO) MetricsActiveWindows() int32 {
	selfArg, selfFin := self.handle()

	defer func() {
		selfFin()
	}()
	return int32(C.wrap_ImGuiIO_GetMetricsActiveWindows(selfArg))
}

func (self IO) SetMetricsActiveAllocations(v int32) {
	selfArg, selfFin := self.handle()
	defer selfFin()
	C.wrap_ImGuiIO_SetMetricsActiveAllocations(selfArg, C.int(v))
}

func (self *IO) MetricsActiveAllocations() int32 {
	selfArg, selfFin := self.handle()

	defer func() {
		selfFin()
	}()
	return int32(C.wrap_ImGuiIO_GetMetricsActiveAllocations(selfArg))
}

func (self IO) SetMouseDelta(v Vec2) {
	selfArg, selfFin := self.handle()
	defer selfFin()
	C.wrap_ImGuiIO_SetMouseDelta(selfArg, v.toC())
}

func (self *IO) MouseDelta() Vec2 {
	selfArg, selfFin := self.handle()

	defer func() {
		selfFin()
	}()
	return *(&Vec2{}).fromC(C.wrap_ImGuiIO_GetMouseDelta(selfArg))
}

func (self IO) SetCtx(v *Context) {
	vArg, _ := v.handle()

	selfArg, selfFin := self.handle()
	defer selfFin()
	C.wrap_ImGuiIO_SetCtx(selfArg, vArg)
}

func (self *IO) Ctx() *Context {
	selfArg, selfFin := self.handle()

	defer func() {
		selfFin()
	}()
	return newContextFromC(C.wrap_ImGuiIO_GetCtx(selfArg))
}

func (self IO) SetMousePos(v Vec2) {
	selfArg, selfFin := self.handle()
	defer selfFin()
	C.wrap_ImGuiIO_SetMousePos(selfArg, v.toC())
}

func (self *IO) MousePos() Vec2 {
	selfArg, selfFin := self.handle()

	defer func() {
		selfFin()
	}()
	return *(&Vec2{}).fromC(C.wrap_ImGuiIO_GetMousePos(selfArg))
}

func (self IO) SetMouseWheel(v float32) {
	selfArg, selfFin := self.handle()
	defer selfFin()
	C.wrap_ImGuiIO_SetMouseWheel(selfArg, C.float(v))
}

func (self *IO) MouseWheel() float32 {
	selfArg, selfFin := self.handle()

	defer func() {
		selfFin()
	}()
	return float32(C.wrap_ImGuiIO_GetMouseWheel(selfArg))
}

func (self IO) SetMouseWheelH(v float32) {
	selfArg, selfFin := self.handle()
	defer selfFin()
	C.wrap_ImGuiIO_SetMouseWheelH(selfArg, C.float(v))
}

func (self *IO) MouseWheelH() float32 {
	selfArg, selfFin := self.handle()

	defer func() {
		selfFin()
	}()
	return float32(C.wrap_ImGuiIO_GetMouseWheelH(selfArg))
}

func (self IO) SetMouseSource(v MouseSource) {
	selfArg, selfFin := self.handle()
	defer selfFin()
	C.wrap_ImGuiIO_SetMouseSource(selfArg, C.ImGuiMouseSource(v))
}

func (self *IO) MouseSource() MouseSource {
	selfArg, selfFin := self.handle()

	defer func() {
		selfFin()
	}()
	return MouseSource(C.wrap_ImGuiIO_GetMouseSource(selfArg))
}

func (self IO) SetMouseHoveredViewport(v ID) {
	vArg, _ := v.c()

	selfArg, selfFin := self.handle()
	defer selfFin()
	C.wrap_ImGuiIO_SetMouseHoveredViewport(selfArg, vArg)
}

func (self *IO) MouseHoveredViewport() ID {
	selfArg, selfFin := self.handle()

	defer func() {
		selfFin()
	}()

	result := C.wrap_ImGuiIO_GetMouseHoveredViewport(selfArg)
	return *newIDFromC(func() *C.ImGuiID { result := result; return &result }())
}

func (self IO) SetKeyCtrl(v bool) {
	selfArg, selfFin := self.handle()
	defer selfFin()
	C.wrap_ImGuiIO_SetKeyCtrl(selfArg, C.bool(v))
}

func (self *IO) KeyCtrl() bool {
	selfArg, selfFin := self.handle()

	defer func() {
		selfFin()
	}()
	return C.wrap_ImGuiIO_GetKeyCtrl(selfArg) == C.bool(true)
}

func (self IO) SetKeyShift(v bool) {
	selfArg, selfFin := self.handle()
	defer selfFin()
	C.wrap_ImGuiIO_SetKeyShift(selfArg, C.bool(v))
}

func (self *IO) KeyShift() bool {
	selfArg, selfFin := self.handle()

	defer func() {
		selfFin()
	}()
	return C.wrap_ImGuiIO_GetKeyShift(selfArg) == C.bool(true)
}

func (self IO) SetKeyAlt(v bool) {
	selfArg, selfFin := self.handle()
	defer selfFin()
	C.wrap_ImGuiIO_SetKeyAlt(selfArg, C.bool(v))
}

func (self *IO) KeyAlt() bool {
	selfArg, selfFin := self.handle()

	defer func() {
		selfFin()
	}()
	return C.wrap_ImGuiIO_GetKeyAlt(selfArg) == C.bool(true)
}

func (self IO) SetKeySuper(v bool) {
	selfArg, selfFin := self.handle()
	defer selfFin()
	C.wrap_ImGuiIO_SetKeySuper(selfArg, C.bool(v))
}

func (self *IO) KeySuper() bool {
	selfArg, selfFin := self.handle()

	defer func() {
		selfFin()
	}()
	return C.wrap_ImGuiIO_GetKeySuper(selfArg) == C.bool(true)
}

func (self IO) SetKeyMods(v KeyChord) {
	vArg, _ := v.c()

	selfArg, selfFin := self.handle()
	defer selfFin()
	C.wrap_ImGuiIO_SetKeyMods(selfArg, vArg)
}

func (self *IO) KeyMods() KeyChord {
	selfArg, selfFin := self.handle()

	defer func() {
		selfFin()
	}()

	result := C.wrap_ImGuiIO_GetKeyMods(selfArg)
	return *newKeyChordFromC(func() *C.ImGuiKeyChord { result := result; return &result }())
}

func (self IO) SetWantCaptureMouseUnlessPopupClose(v bool) {
	selfArg, selfFin := self.handle()
	defer selfFin()
	C.wrap_ImGuiIO_SetWantCaptureMouseUnlessPopupClose(selfArg, C.bool(v))
}

func (self *IO) WantCaptureMouseUnlessPopupClose() bool {
	selfArg, selfFin := self.handle()

	defer func() {
		selfFin()
	}()
	return C.wrap_ImGuiIO_GetWantCaptureMouseUnlessPopupClose(selfArg) == C.bool(true)
}

func (self IO) SetMousePosPrev(v Vec2) {
	selfArg, selfFin := self.handle()
	defer selfFin()
	C.wrap_ImGuiIO_SetMousePosPrev(selfArg, v.toC())
}

func (self *IO) MousePosPrev() Vec2 {
	selfArg, selfFin := self.handle()

	defer func() {
		selfFin()
	}()
	return *(&Vec2{}).fromC(C.wrap_ImGuiIO_GetMousePosPrev(selfArg))
}

func (self IO) SetMouseWheelRequestAxisSwap(v bool) {
	selfArg, selfFin := self.handle()
	defer selfFin()
	C.wrap_ImGuiIO_SetMouseWheelRequestAxisSwap(selfArg, C.bool(v))
}

func (self *IO) MouseWheelRequestAxisSwap() bool {
	selfArg, selfFin := self.handle()

	defer func() {
		selfFin()
	}()
	return C.wrap_ImGuiIO_GetMouseWheelRequestAxisSwap(selfArg) == C.bool(true)
}

func (self IO) SetPenPressure(v float32) {
	selfArg, selfFin := self.handle()
	defer selfFin()
	C.wrap_ImGuiIO_SetPenPressure(selfArg, C.float(v))
}

func (self *IO) PenPressure() float32 {
	selfArg, selfFin := self.handle()

	defer func() {
		selfFin()
	}()
	return float32(C.wrap_ImGuiIO_GetPenPressure(selfArg))
}

func (self IO) SetAppFocusLost(v bool) {
	selfArg, selfFin := self.handle()
	defer selfFin()
	C.wrap_ImGuiIO_SetAppFocusLost(selfArg, C.bool(v))
}

func (self *IO) AppFocusLost() bool {
	selfArg, selfFin := self.handle()

	defer func() {
		selfFin()
	}()
	return C.wrap_ImGuiIO_GetAppFocusLost(selfArg) == C.bool(true)
}

func (self IO) SetBackendUsingLegacyKeyArrays(v int) {
	selfArg, selfFin := self.handle()
	defer selfFin()
	C.wrap_ImGuiIO_SetBackendUsingLegacyKeyArrays(selfArg, C.ImS8(v))
}

func (self *IO) BackendUsingLegacyKeyArrays() int {
	selfArg, selfFin := self.handle()

	defer func() {
		selfFin()
	}()
	return int(C.wrap_ImGuiIO_GetBackendUsingLegacyKeyArrays(selfArg))
}

func (self IO) SetBackendUsingLegacyNavInputArray(v bool) {
	selfArg, selfFin := self.handle()
	defer selfFin()
	C.wrap_ImGuiIO_SetBackendUsingLegacyNavInputArray(selfArg, C.bool(v))
}

func (self *IO) BackendUsingLegacyNavInputArray() bool {
	selfArg, selfFin := self.handle()

	defer func() {
		selfFin()
	}()
	return C.wrap_ImGuiIO_GetBackendUsingLegacyNavInputArray(selfArg) == C.bool(true)
}

func (self IO) SetInputQueueSurrogate(v uint16) {
	selfArg, selfFin := self.handle()
	defer selfFin()
	C.wrap_ImGuiIO_SetInputQueueSurrogate(selfArg, C.ImWchar16(v))
}

func (self *IO) InputQueueSurrogate() uint16 {
	selfArg, selfFin := self.handle()

	defer func() {
		selfFin()
	}()
	return uint16(C.wrap_ImGuiIO_GetInputQueueSurrogate(selfArg))
}

func (self IO) SetInputQueueCharacters(v Vector[(*Wchar)]) {
	vData := v.Data

	vVecArg := new(C.ImVector_ImWchar)
	vVecArg.Size = C.int(v.Size)
	vVecArg.Capacity = C.int(v.Capacity)
	vVecArg.Data = (*C.ImWchar)(vData)
	v.pinner.Pin(vVecArg.Data)

	selfArg, selfFin := self.handle()
	defer selfFin()
	C.wrap_ImGuiIO_SetInputQueueCharacters(selfArg, *vVecArg)
}

func (self *IO) InputQueueCharacters() Vector[(*Wchar)] {
	selfArg, selfFin := self.handle()

	defer func() {
		selfFin()
	}()
	return newVectorFromC(C.wrap_ImGuiIO_GetInputQueueCharacters(selfArg).Size, C.wrap_ImGuiIO_GetInputQueueCharacters(selfArg).Capacity, (*Wchar)(C.wrap_ImGuiIO_GetInputQueueCharacters(selfArg).Data))
}

func (self InputEvent) SetType(v InputEventType) {
	selfArg, selfFin := self.handle()
	defer selfFin()
	C.wrap_ImGuiInputEvent_SetType(selfArg, C.ImGuiInputEventType(v))
}

func (self *InputEvent) Type() InputEventType {
	selfArg, selfFin := self.handle()

	defer func() {
		selfFin()
	}()
	return InputEventType(C.wrap_ImGuiInputEvent_GetType(selfArg))
}

func (self InputEvent) SetSource(v InputSource) {
	selfArg, selfFin := self.handle()
	defer selfFin()
	C.wrap_ImGuiInputEvent_SetSource(selfArg, C.ImGuiInputSource(v))
}

func (self *InputEvent) Source() InputSource {
	selfArg, selfFin := self.handle()

	defer func() {
		selfFin()
	}()
	return InputSource(C.wrap_ImGuiInputEvent_GetSource(selfArg))
}

func (self InputEvent) SetEventId(v uint32) {
	selfArg, selfFin := self.handle()
	defer selfFin()
	C.wrap_ImGuiInputEvent_SetEventId(selfArg, C.ImU32(v))
}

func (self *InputEvent) EventId() uint32 {
	selfArg, selfFin := self.handle()

	defer func() {
		selfFin()
	}()
	return uint32(C.wrap_ImGuiInputEvent_GetEventId(selfArg))
}

func (self InputEvent) SetAddedByTestEngine(v bool) {
	selfArg, selfFin := self.handle()
	defer selfFin()
	C.wrap_ImGuiInputEvent_SetAddedByTestEngine(selfArg, C.bool(v))
}

func (self *InputEvent) AddedByTestEngine() bool {
	selfArg, selfFin := self.handle()

	defer func() {
		selfFin()
	}()
	return C.wrap_ImGuiInputEvent_GetAddedByTestEngine(selfArg) == C.bool(true)
}

func (self InputEventAppFocused) SetFocused(v bool) {
	selfArg, selfFin := self.handle()
	defer selfFin()
	C.wrap_ImGuiInputEventAppFocused_SetFocused(selfArg, C.bool(v))
}

func (self *InputEventAppFocused) Focused() bool {
	selfArg, selfFin := self.handle()

	defer func() {
		selfFin()
	}()
	return C.wrap_ImGuiInputEventAppFocused_GetFocused(selfArg) == C.bool(true)
}

func (self InputEventKey) SetKey(v Key) {
	selfArg, selfFin := self.handle()
	defer selfFin()
	C.wrap_ImGuiInputEventKey_SetKey(selfArg, C.ImGuiKey(v))
}

func (self *InputEventKey) Key() Key {
	selfArg, selfFin := self.handle()

	defer func() {
		selfFin()
	}()
	return Key(C.wrap_ImGuiInputEventKey_GetKey(selfArg))
}

func (self InputEventKey) SetDown(v bool) {
	selfArg, selfFin := self.handle()
	defer selfFin()
	C.wrap_ImGuiInputEventKey_SetDown(selfArg, C.bool(v))
}

func (self *InputEventKey) Down() bool {
	selfArg, selfFin := self.handle()

	defer func() {
		selfFin()
	}()
	return C.wrap_ImGuiInputEventKey_GetDown(selfArg) == C.bool(true)
}

func (self InputEventKey) SetAnalogValue(v float32) {
	selfArg, selfFin := self.handle()
	defer selfFin()
	C.wrap_ImGuiInputEventKey_SetAnalogValue(selfArg, C.float(v))
}

func (self *InputEventKey) AnalogValue() float32 {
	selfArg, selfFin := self.handle()

	defer func() {
		selfFin()
	}()
	return float32(C.wrap_ImGuiInputEventKey_GetAnalogValue(selfArg))
}

func (self InputEventMouseButton) SetButton(v int32) {
	selfArg, selfFin := self.handle()
	defer selfFin()
	C.wrap_ImGuiInputEventMouseButton_SetButton(selfArg, C.int(v))
}

func (self *InputEventMouseButton) Button() int32 {
	selfArg, selfFin := self.handle()

	defer func() {
		selfFin()
	}()
	return int32(C.wrap_ImGuiInputEventMouseButton_GetButton(selfArg))
}

func (self InputEventMouseButton) SetDown(v bool) {
	selfArg, selfFin := self.handle()
	defer selfFin()
	C.wrap_ImGuiInputEventMouseButton_SetDown(selfArg, C.bool(v))
}

func (self *InputEventMouseButton) Down() bool {
	selfArg, selfFin := self.handle()

	defer func() {
		selfFin()
	}()
	return C.wrap_ImGuiInputEventMouseButton_GetDown(selfArg) == C.bool(true)
}

func (self InputEventMouseButton) SetMouseSource(v MouseSource) {
	selfArg, selfFin := self.handle()
	defer selfFin()
	C.wrap_ImGuiInputEventMouseButton_SetMouseSource(selfArg, C.ImGuiMouseSource(v))
}

func (self *InputEventMouseButton) MouseSource() MouseSource {
	selfArg, selfFin := self.handle()

	defer func() {
		selfFin()
	}()
	return MouseSource(C.wrap_ImGuiInputEventMouseButton_GetMouseSource(selfArg))
}

func (self InputEventMousePos) SetPosX(v float32) {
	selfArg, selfFin := self.handle()
	defer selfFin()
	C.wrap_ImGuiInputEventMousePos_SetPosX(selfArg, C.float(v))
}

func (self *InputEventMousePos) PosX() float32 {
	selfArg, selfFin := self.handle()

	defer func() {
		selfFin()
	}()
	return float32(C.wrap_ImGuiInputEventMousePos_GetPosX(selfArg))
}

func (self InputEventMousePos) SetPosY(v float32) {
	selfArg, selfFin := self.handle()
	defer selfFin()
	C.wrap_ImGuiInputEventMousePos_SetPosY(selfArg, C.float(v))
}

func (self *InputEventMousePos) PosY() float32 {
	selfArg, selfFin := self.handle()

	defer func() {
		selfFin()
	}()
	return float32(C.wrap_ImGuiInputEventMousePos_GetPosY(selfArg))
}

func (self InputEventMousePos) SetMouseSource(v MouseSource) {
	selfArg, selfFin := self.handle()
	defer selfFin()
	C.wrap_ImGuiInputEventMousePos_SetMouseSource(selfArg, C.ImGuiMouseSource(v))
}

func (self *InputEventMousePos) MouseSource() MouseSource {
	selfArg, selfFin := self.handle()

	defer func() {
		selfFin()
	}()
	return MouseSource(C.wrap_ImGuiInputEventMousePos_GetMouseSource(selfArg))
}

func (self InputEventMouseViewport) SetHoveredViewportID(v ID) {
	vArg, _ := v.c()

	selfArg, selfFin := self.handle()
	defer selfFin()
	C.wrap_ImGuiInputEventMouseViewport_SetHoveredViewportID(selfArg, vArg)
}

func (self *InputEventMouseViewport) HoveredViewportID() ID {
	selfArg, selfFin := self.handle()

	defer func() {
		selfFin()
	}()

	result := C.wrap_ImGuiInputEventMouseViewport_GetHoveredViewportID(selfArg)
	return *newIDFromC(func() *C.ImGuiID { result := result; return &result }())
}

func (self InputEventMouseWheel) SetWheelX(v float32) {
	selfArg, selfFin := self.handle()
	defer selfFin()
	C.wrap_ImGuiInputEventMouseWheel_SetWheelX(selfArg, C.float(v))
}

func (self *InputEventMouseWheel) WheelX() float32 {
	selfArg, selfFin := self.handle()

	defer func() {
		selfFin()
	}()
	return float32(C.wrap_ImGuiInputEventMouseWheel_GetWheelX(selfArg))
}

func (self InputEventMouseWheel) SetWheelY(v float32) {
	selfArg, selfFin := self.handle()
	defer selfFin()
	C.wrap_ImGuiInputEventMouseWheel_SetWheelY(selfArg, C.float(v))
}

func (self *InputEventMouseWheel) WheelY() float32 {
	selfArg, selfFin := self.handle()

	defer func() {
		selfFin()
	}()
	return float32(C.wrap_ImGuiInputEventMouseWheel_GetWheelY(selfArg))
}

func (self InputEventMouseWheel) SetMouseSource(v MouseSource) {
	selfArg, selfFin := self.handle()
	defer selfFin()
	C.wrap_ImGuiInputEventMouseWheel_SetMouseSource(selfArg, C.ImGuiMouseSource(v))
}

func (self *InputEventMouseWheel) MouseSource() MouseSource {
	selfArg, selfFin := self.handle()

	defer func() {
		selfFin()
	}()
	return MouseSource(C.wrap_ImGuiInputEventMouseWheel_GetMouseSource(selfArg))
}

func (self InputEventText) SetChar(v uint32) {
	selfArg, selfFin := self.handle()
	defer selfFin()
	C.wrap_ImGuiInputEventText_SetChar(selfArg, C.uint(v))
}

func (self *InputEventText) Char() uint32 {
	selfArg, selfFin := self.handle()

	defer func() {
		selfFin()
	}()
	return uint32(C.wrap_ImGuiInputEventText_GetChar(selfArg))
}

func (self InputTextCallbackData) SetCtx(v *Context) {
	vArg, _ := v.handle()

	selfArg, selfFin := self.handle()
	defer selfFin()
	C.wrap_ImGuiInputTextCallbackData_SetCtx(selfArg, vArg)
}

func (self *InputTextCallbackData) Ctx() *Context {
	selfArg, selfFin := self.handle()

	defer func() {
		selfFin()
	}()
	return newContextFromC(C.wrap_ImGuiInputTextCallbackData_GetCtx(selfArg))
}

func (self InputTextCallbackData) SetEventFlag(v InputTextFlags) {
	selfArg, selfFin := self.handle()
	defer selfFin()
	C.wrap_ImGuiInputTextCallbackData_SetEventFlag(selfArg, C.ImGuiInputTextFlags(v))
}

func (self *InputTextCallbackData) EventFlag() InputTextFlags {
	selfArg, selfFin := self.handle()

	defer func() {
		selfFin()
	}()
	return InputTextFlags(C.wrap_ImGuiInputTextCallbackData_GetEventFlag(selfArg))
}

func (self InputTextCallbackData) SetFlags(v InputTextFlags) {
	selfArg, selfFin := self.handle()
	defer selfFin()
	C.wrap_ImGuiInputTextCallbackData_SetFlags(selfArg, C.ImGuiInputTextFlags(v))
}

func (self *InputTextCallbackData) Flags() InputTextFlags {
	selfArg, selfFin := self.handle()

	defer func() {
		selfFin()
	}()
	return InputTextFlags(C.wrap_ImGuiInputTextCallbackData_GetFlags(selfArg))
}

func (self InputTextCallbackData) SetUserData(v unsafe.Pointer) {
	vArg, _ := WrapVoidPtr(v)

	selfArg, selfFin := self.handle()
	defer selfFin()
	C.wrap_ImGuiInputTextCallbackData_SetUserData(selfArg, vArg)
}

func (self *InputTextCallbackData) UserData() unsafe.Pointer {
	selfArg, selfFin := self.handle()

	defer func() {
		selfFin()
	}()
	return unsafe.Pointer(C.wrap_ImGuiInputTextCallbackData_GetUserData(selfArg))
}

func (self InputTextCallbackData) SetEventChar(v Wchar) {
	selfArg, selfFin := self.handle()
	defer selfFin()
	C.wrap_ImGuiInputTextCallbackData_SetEventChar(selfArg, C.ImWchar(v))
}

func (self *InputTextCallbackData) EventChar() Wchar {
	selfArg, selfFin := self.handle()

	defer func() {
		selfFin()
	}()
	return Wchar(C.wrap_ImGuiInputTextCallbackData_GetEventChar(selfArg))
}

func (self InputTextCallbackData) SetEventKey(v Key) {
	selfArg, selfFin := self.handle()
	defer selfFin()
	C.wrap_ImGuiInputTextCallbackData_SetEventKey(selfArg, C.ImGuiKey(v))
}

func (self *InputTextCallbackData) EventKey() Key {
	selfArg, selfFin := self.handle()

	defer func() {
		selfFin()
	}()
	return Key(C.wrap_ImGuiInputTextCallbackData_GetEventKey(selfArg))
}

func (self InputTextCallbackData) SetBuf(v string) {
	vArg, _ := WrapString(v)

	selfArg, selfFin := self.handle()
	defer selfFin()
	C.wrap_ImGuiInputTextCallbackData_SetBuf(selfArg, vArg)
}

func (self *InputTextCallbackData) Buf() string {
	selfArg, selfFin := self.handle()

	defer func() {
		selfFin()
	}()
	return C.GoString(C.wrap_ImGuiInputTextCallbackData_GetBuf(selfArg))
}

func (self InputTextCallbackData) SetBufTextLen(v int32) {
	selfArg, selfFin := self.handle()
	defer selfFin()
	C.wrap_ImGuiInputTextCallbackData_SetBufTextLen(selfArg, C.int(v))
}

func (self *InputTextCallbackData) BufTextLen() int32 {
	selfArg, selfFin := self.handle()

	defer func() {
		selfFin()
	}()
	return int32(C.wrap_ImGuiInputTextCallbackData_GetBufTextLen(selfArg))
}

func (self InputTextCallbackData) SetBufSize(v int32) {
	selfArg, selfFin := self.handle()
	defer selfFin()
	C.wrap_ImGuiInputTextCallbackData_SetBufSize(selfArg, C.int(v))
}

func (self *InputTextCallbackData) BufSize() int32 {
	selfArg, selfFin := self.handle()

	defer func() {
		selfFin()
	}()
	return int32(C.wrap_ImGuiInputTextCallbackData_GetBufSize(selfArg))
}

func (self InputTextCallbackData) SetBufDirty(v bool) {
	selfArg, selfFin := self.handle()
	defer selfFin()
	C.wrap_ImGuiInputTextCallbackData_SetBufDirty(selfArg, C.bool(v))
}

func (self *InputTextCallbackData) BufDirty() bool {
	selfArg, selfFin := self.handle()

	defer func() {
		selfFin()
	}()
	return C.wrap_ImGuiInputTextCallbackData_GetBufDirty(selfArg) == C.bool(true)
}

func (self InputTextCallbackData) SetCursorPos(v int32) {
	selfArg, selfFin := self.handle()
	defer selfFin()
	C.wrap_ImGuiInputTextCallbackData_SetCursorPos(selfArg, C.int(v))
}

func (self *InputTextCallbackData) CursorPos() int32 {
	selfArg, selfFin := self.handle()

	defer func() {
		selfFin()
	}()
	return int32(C.wrap_ImGuiInputTextCallbackData_GetCursorPos(selfArg))
}

func (self InputTextCallbackData) SetSelectionStart(v int32) {
	selfArg, selfFin := self.handle()
	defer selfFin()
	C.wrap_ImGuiInputTextCallbackData_SetSelectionStart(selfArg, C.int(v))
}

func (self *InputTextCallbackData) SelectionStart() int32 {
	selfArg, selfFin := self.handle()

	defer func() {
		selfFin()
	}()
	return int32(C.wrap_ImGuiInputTextCallbackData_GetSelectionStart(selfArg))
}

func (self InputTextCallbackData) SetSelectionEnd(v int32) {
	selfArg, selfFin := self.handle()
	defer selfFin()
	C.wrap_ImGuiInputTextCallbackData_SetSelectionEnd(selfArg, C.int(v))
}

func (self *InputTextCallbackData) SelectionEnd() int32 {
	selfArg, selfFin := self.handle()

	defer func() {
		selfFin()
	}()
	return int32(C.wrap_ImGuiInputTextCallbackData_GetSelectionEnd(selfArg))
}

func (self InputTextDeactivatedState) SetID(v ID) {
	vArg, _ := v.c()

	selfArg, selfFin := self.handle()
	defer selfFin()
	C.wrap_ImGuiInputTextDeactivatedState_SetID(selfArg, vArg)
}

func (self *InputTextDeactivatedState) ID() ID {
	selfArg, selfFin := self.handle()

	defer func() {
		selfFin()
	}()

	result := C.wrap_ImGuiInputTextDeactivatedState_GetID(selfArg)
	return *newIDFromC(func() *C.ImGuiID { result := result; return &result }())
}

func (self InputTextDeactivatedState) SetTextA(v Vector[string]) {
	vData := v.Data
	vDataArg, _ := WrapString(vData)
	vVecArg := new(C.ImVector_char)
	vVecArg.Size = C.int(v.Size)
	vVecArg.Capacity = C.int(v.Capacity)
	vVecArg.Data = vDataArg
	v.pinner.Pin(vVecArg.Data)

	selfArg, selfFin := self.handle()
	defer selfFin()
	C.wrap_ImGuiInputTextDeactivatedState_SetTextA(selfArg, *vVecArg)
}

func (self *InputTextDeactivatedState) TextA() Vector[string] {
	selfArg, selfFin := self.handle()

	defer func() {
		selfFin()
	}()
	return newVectorFromC(C.wrap_ImGuiInputTextDeactivatedState_GetTextA(selfArg).Size, C.wrap_ImGuiInputTextDeactivatedState_GetTextA(selfArg).Capacity, C.GoString(C.wrap_ImGuiInputTextDeactivatedState_GetTextA(selfArg).Data))
}

func (self InputTextState) SetCtx(v *Context) {
	vArg, _ := v.handle()

	selfArg, selfFin := self.handle()
	defer selfFin()
	C.wrap_ImGuiInputTextState_SetCtx(selfArg, vArg)
}

func (self *InputTextState) Ctx() *Context {
	selfArg, selfFin := self.handle()

	defer func() {
		selfFin()
	}()
	return newContextFromC(C.wrap_ImGuiInputTextState_GetCtx(selfArg))
}

func (self InputTextState) SetID(v ID) {
	vArg, _ := v.c()

	selfArg, selfFin := self.handle()
	defer selfFin()
	C.wrap_ImGuiInputTextState_SetID(selfArg, vArg)
}

func (self *InputTextState) ID() ID {
	selfArg, selfFin := self.handle()

	defer func() {
		selfFin()
	}()

	result := C.wrap_ImGuiInputTextState_GetID(selfArg)
	return *newIDFromC(func() *C.ImGuiID { result := result; return &result }())
}

func (self InputTextState) SetCurLenW(v int32) {
	selfArg, selfFin := self.handle()
	defer selfFin()
	C.wrap_ImGuiInputTextState_SetCurLenW(selfArg, C.int(v))
}

func (self *InputTextState) CurLenW() int32 {
	selfArg, selfFin := self.handle()

	defer func() {
		selfFin()
	}()
	return int32(C.wrap_ImGuiInputTextState_GetCurLenW(selfArg))
}

func (self InputTextState) SetCurLenA(v int32) {
	selfArg, selfFin := self.handle()
	defer selfFin()
	C.wrap_ImGuiInputTextState_SetCurLenA(selfArg, C.int(v))
}

func (self *InputTextState) CurLenA() int32 {
	selfArg, selfFin := self.handle()

	defer func() {
		selfFin()
	}()
	return int32(C.wrap_ImGuiInputTextState_GetCurLenA(selfArg))
}

func (self InputTextState) SetTextW(v Vector[(*Wchar)]) {
	vData := v.Data

	vVecArg := new(C.ImVector_ImWchar)
	vVecArg.Size = C.int(v.Size)
	vVecArg.Capacity = C.int(v.Capacity)
	vVecArg.Data = (*C.ImWchar)(vData)
	v.pinner.Pin(vVecArg.Data)

	selfArg, selfFin := self.handle()
	defer selfFin()
	C.wrap_ImGuiInputTextState_SetTextW(selfArg, *vVecArg)
}

func (self *InputTextState) TextW() Vector[(*Wchar)] {
	selfArg, selfFin := self.handle()

	defer func() {
		selfFin()
	}()
	return newVectorFromC(C.wrap_ImGuiInputTextState_GetTextW(selfArg).Size, C.wrap_ImGuiInputTextState_GetTextW(selfArg).Capacity, (*Wchar)(C.wrap_ImGuiInputTextState_GetTextW(selfArg).Data))
}

func (self InputTextState) SetTextA(v Vector[string]) {
	vData := v.Data
	vDataArg, _ := WrapString(vData)
	vVecArg := new(C.ImVector_char)
	vVecArg.Size = C.int(v.Size)
	vVecArg.Capacity = C.int(v.Capacity)
	vVecArg.Data = vDataArg
	v.pinner.Pin(vVecArg.Data)

	selfArg, selfFin := self.handle()
	defer selfFin()
	C.wrap_ImGuiInputTextState_SetTextA(selfArg, *vVecArg)
}

func (self *InputTextState) TextA() Vector[string] {
	selfArg, selfFin := self.handle()

	defer func() {
		selfFin()
	}()
	return newVectorFromC(C.wrap_ImGuiInputTextState_GetTextA(selfArg).Size, C.wrap_ImGuiInputTextState_GetTextA(selfArg).Capacity, C.GoString(C.wrap_ImGuiInputTextState_GetTextA(selfArg).Data))
}

func (self InputTextState) SetInitialTextA(v Vector[string]) {
	vData := v.Data
	vDataArg, _ := WrapString(vData)
	vVecArg := new(C.ImVector_char)
	vVecArg.Size = C.int(v.Size)
	vVecArg.Capacity = C.int(v.Capacity)
	vVecArg.Data = vDataArg
	v.pinner.Pin(vVecArg.Data)

	selfArg, selfFin := self.handle()
	defer selfFin()
	C.wrap_ImGuiInputTextState_SetInitialTextA(selfArg, *vVecArg)
}

func (self *InputTextState) InitialTextA() Vector[string] {
	selfArg, selfFin := self.handle()

	defer func() {
		selfFin()
	}()
	return newVectorFromC(C.wrap_ImGuiInputTextState_GetInitialTextA(selfArg).Size, C.wrap_ImGuiInputTextState_GetInitialTextA(selfArg).Capacity, C.GoString(C.wrap_ImGuiInputTextState_GetInitialTextA(selfArg).Data))
}

func (self InputTextState) SetTextAIsValid(v bool) {
	selfArg, selfFin := self.handle()
	defer selfFin()
	C.wrap_ImGuiInputTextState_SetTextAIsValid(selfArg, C.bool(v))
}

func (self *InputTextState) TextAIsValid() bool {
	selfArg, selfFin := self.handle()

	defer func() {
		selfFin()
	}()
	return C.wrap_ImGuiInputTextState_GetTextAIsValid(selfArg) == C.bool(true)
}

func (self InputTextState) SetBufCapacityA(v int32) {
	selfArg, selfFin := self.handle()
	defer selfFin()
	C.wrap_ImGuiInputTextState_SetBufCapacityA(selfArg, C.int(v))
}

func (self *InputTextState) BufCapacityA() int32 {
	selfArg, selfFin := self.handle()

	defer func() {
		selfFin()
	}()
	return int32(C.wrap_ImGuiInputTextState_GetBufCapacityA(selfArg))
}

func (self InputTextState) SetScrollX(v float32) {
	selfArg, selfFin := self.handle()
	defer selfFin()
	C.wrap_ImGuiInputTextState_SetScrollX(selfArg, C.float(v))
}

func (self *InputTextState) ScrollX() float32 {
	selfArg, selfFin := self.handle()

	defer func() {
		selfFin()
	}()
	return float32(C.wrap_ImGuiInputTextState_GetScrollX(selfArg))
}

func (self InputTextState) SetStb(v STBTexteditState) {
	vArg, _ := v.c()

	selfArg, selfFin := self.handle()
	defer selfFin()
	C.wrap_ImGuiInputTextState_SetStb(selfArg, vArg)
}

func (self *InputTextState) Stb() STBTexteditState {
	selfArg, selfFin := self.handle()

	defer func() {
		selfFin()
	}()

	result := C.wrap_ImGuiInputTextState_GetStb(selfArg)
	return *newSTBTexteditStateFromC(func() *C.STB_TexteditState { result := result; return &result }())
}

func (self InputTextState) SetCursorAnim(v float32) {
	selfArg, selfFin := self.handle()
	defer selfFin()
	C.wrap_ImGuiInputTextState_SetCursorAnim(selfArg, C.float(v))
}

func (self *InputTextState) CursorAnim() float32 {
	selfArg, selfFin := self.handle()

	defer func() {
		selfFin()
	}()
	return float32(C.wrap_ImGuiInputTextState_GetCursorAnim(selfArg))
}

func (self InputTextState) SetCursorFollow(v bool) {
	selfArg, selfFin := self.handle()
	defer selfFin()
	C.wrap_ImGuiInputTextState_SetCursorFollow(selfArg, C.bool(v))
}

func (self *InputTextState) CursorFollow() bool {
	selfArg, selfFin := self.handle()

	defer func() {
		selfFin()
	}()
	return C.wrap_ImGuiInputTextState_GetCursorFollow(selfArg) == C.bool(true)
}

func (self InputTextState) SetSelectedAllMouseLock(v bool) {
	selfArg, selfFin := self.handle()
	defer selfFin()
	C.wrap_ImGuiInputTextState_SetSelectedAllMouseLock(selfArg, C.bool(v))
}

func (self *InputTextState) SelectedAllMouseLock() bool {
	selfArg, selfFin := self.handle()

	defer func() {
		selfFin()
	}()
	return C.wrap_ImGuiInputTextState_GetSelectedAllMouseLock(selfArg) == C.bool(true)
}

func (self InputTextState) SetEdited(v bool) {
	selfArg, selfFin := self.handle()
	defer selfFin()
	C.wrap_ImGuiInputTextState_SetEdited(selfArg, C.bool(v))
}

func (self *InputTextState) Edited() bool {
	selfArg, selfFin := self.handle()

	defer func() {
		selfFin()
	}()
	return C.wrap_ImGuiInputTextState_GetEdited(selfArg) == C.bool(true)
}

func (self InputTextState) SetFlags(v InputTextFlags) {
	selfArg, selfFin := self.handle()
	defer selfFin()
	C.wrap_ImGuiInputTextState_SetFlags(selfArg, C.ImGuiInputTextFlags(v))
}

func (self *InputTextState) Flags() InputTextFlags {
	selfArg, selfFin := self.handle()

	defer func() {
		selfFin()
	}()
	return InputTextFlags(C.wrap_ImGuiInputTextState_GetFlags(selfArg))
}

func (self KeyData) SetDown(v bool) {
	selfArg, selfFin := self.handle()
	defer selfFin()
	C.wrap_ImGuiKeyData_SetDown(selfArg, C.bool(v))
}

func (self *KeyData) Down() bool {
	selfArg, selfFin := self.handle()

	defer func() {
		selfFin()
	}()
	return C.wrap_ImGuiKeyData_GetDown(selfArg) == C.bool(true)
}

func (self KeyData) SetDownDuration(v float32) {
	selfArg, selfFin := self.handle()
	defer selfFin()
	C.wrap_ImGuiKeyData_SetDownDuration(selfArg, C.float(v))
}

func (self *KeyData) DownDuration() float32 {
	selfArg, selfFin := self.handle()

	defer func() {
		selfFin()
	}()
	return float32(C.wrap_ImGuiKeyData_GetDownDuration(selfArg))
}

func (self KeyData) SetDownDurationPrev(v float32) {
	selfArg, selfFin := self.handle()
	defer selfFin()
	C.wrap_ImGuiKeyData_SetDownDurationPrev(selfArg, C.float(v))
}

func (self *KeyData) DownDurationPrev() float32 {
	selfArg, selfFin := self.handle()

	defer func() {
		selfFin()
	}()
	return float32(C.wrap_ImGuiKeyData_GetDownDurationPrev(selfArg))
}

func (self KeyData) SetAnalogValue(v float32) {
	selfArg, selfFin := self.handle()
	defer selfFin()
	C.wrap_ImGuiKeyData_SetAnalogValue(selfArg, C.float(v))
}

func (self *KeyData) AnalogValue() float32 {
	selfArg, selfFin := self.handle()

	defer func() {
		selfFin()
	}()
	return float32(C.wrap_ImGuiKeyData_GetAnalogValue(selfArg))
}

func (self KeyOwnerData) SetOwnerCurr(v ID) {
	vArg, _ := v.c()

	selfArg, selfFin := self.handle()
	defer selfFin()
	C.wrap_ImGuiKeyOwnerData_SetOwnerCurr(selfArg, vArg)
}

func (self *KeyOwnerData) OwnerCurr() ID {
	selfArg, selfFin := self.handle()

	defer func() {
		selfFin()
	}()

	result := C.wrap_ImGuiKeyOwnerData_GetOwnerCurr(selfArg)
	return *newIDFromC(func() *C.ImGuiID { result := result; return &result }())
}

func (self KeyOwnerData) SetOwnerNext(v ID) {
	vArg, _ := v.c()

	selfArg, selfFin := self.handle()
	defer selfFin()
	C.wrap_ImGuiKeyOwnerData_SetOwnerNext(selfArg, vArg)
}

func (self *KeyOwnerData) OwnerNext() ID {
	selfArg, selfFin := self.handle()

	defer func() {
		selfFin()
	}()

	result := C.wrap_ImGuiKeyOwnerData_GetOwnerNext(selfArg)
	return *newIDFromC(func() *C.ImGuiID { result := result; return &result }())
}

func (self KeyOwnerData) SetLockThisFrame(v bool) {
	selfArg, selfFin := self.handle()
	defer selfFin()
	C.wrap_ImGuiKeyOwnerData_SetLockThisFrame(selfArg, C.bool(v))
}

func (self *KeyOwnerData) LockThisFrame() bool {
	selfArg, selfFin := self.handle()

	defer func() {
		selfFin()
	}()
	return C.wrap_ImGuiKeyOwnerData_GetLockThisFrame(selfArg) == C.bool(true)
}

func (self KeyOwnerData) SetLockUntilRelease(v bool) {
	selfArg, selfFin := self.handle()
	defer selfFin()
	C.wrap_ImGuiKeyOwnerData_SetLockUntilRelease(selfArg, C.bool(v))
}

func (self *KeyOwnerData) LockUntilRelease() bool {
	selfArg, selfFin := self.handle()

	defer func() {
		selfFin()
	}()
	return C.wrap_ImGuiKeyOwnerData_GetLockUntilRelease(selfArg) == C.bool(true)
}

func (self KeyRoutingData) SetMods(v uint16) {
	selfArg, selfFin := self.handle()
	defer selfFin()
	C.wrap_ImGuiKeyRoutingData_SetMods(selfArg, C.ImU16(v))
}

func (self *KeyRoutingData) Mods() uint16 {
	selfArg, selfFin := self.handle()

	defer func() {
		selfFin()
	}()
	return uint16(C.wrap_ImGuiKeyRoutingData_GetMods(selfArg))
}

func (self KeyRoutingData) SetRoutingNextScore(v byte) {
	selfArg, selfFin := self.handle()
	defer selfFin()
	C.wrap_ImGuiKeyRoutingData_SetRoutingNextScore(selfArg, C.ImU8(v))
}

func (self *KeyRoutingData) RoutingNextScore() byte {
	selfArg, selfFin := self.handle()

	defer func() {
		selfFin()
	}()
	return byte(C.wrap_ImGuiKeyRoutingData_GetRoutingNextScore(selfArg))
}

func (self KeyRoutingData) SetRoutingCurr(v ID) {
	vArg, _ := v.c()

	selfArg, selfFin := self.handle()
	defer selfFin()
	C.wrap_ImGuiKeyRoutingData_SetRoutingCurr(selfArg, vArg)
}

func (self *KeyRoutingData) RoutingCurr() ID {
	selfArg, selfFin := self.handle()

	defer func() {
		selfFin()
	}()

	result := C.wrap_ImGuiKeyRoutingData_GetRoutingCurr(selfArg)
	return *newIDFromC(func() *C.ImGuiID { result := result; return &result }())
}

func (self KeyRoutingData) SetRoutingNext(v ID) {
	vArg, _ := v.c()

	selfArg, selfFin := self.handle()
	defer selfFin()
	C.wrap_ImGuiKeyRoutingData_SetRoutingNext(selfArg, vArg)
}

func (self *KeyRoutingData) RoutingNext() ID {
	selfArg, selfFin := self.handle()

	defer func() {
		selfFin()
	}()

	result := C.wrap_ImGuiKeyRoutingData_GetRoutingNext(selfArg)
	return *newIDFromC(func() *C.ImGuiID { result := result; return &result }())
}

func (self KeyRoutingTable) SetEntries(v Vector[*KeyRoutingData]) {
	vData := v.Data
	vDataArg, _ := vData.handle()
	vVecArg := new(C.ImVector_ImGuiKeyRoutingData)
	vVecArg.Size = C.int(v.Size)
	vVecArg.Capacity = C.int(v.Capacity)
	vVecArg.Data = vDataArg
	v.pinner.Pin(vVecArg.Data)

	selfArg, selfFin := self.handle()
	defer selfFin()
	C.wrap_ImGuiKeyRoutingTable_SetEntries(selfArg, *vVecArg)
}

func (self *KeyRoutingTable) Entries() Vector[*KeyRoutingData] {
	selfArg, selfFin := self.handle()

	defer func() {
		selfFin()
	}()
	return newVectorFromC(C.wrap_ImGuiKeyRoutingTable_GetEntries(selfArg).Size, C.wrap_ImGuiKeyRoutingTable_GetEntries(selfArg).Capacity, newKeyRoutingDataFromC(C.wrap_ImGuiKeyRoutingTable_GetEntries(selfArg).Data))
}

func (self KeyRoutingTable) SetEntriesNext(v Vector[*KeyRoutingData]) {
	vData := v.Data
	vDataArg, _ := vData.handle()
	vVecArg := new(C.ImVector_ImGuiKeyRoutingData)
	vVecArg.Size = C.int(v.Size)
	vVecArg.Capacity = C.int(v.Capacity)
	vVecArg.Data = vDataArg
	v.pinner.Pin(vVecArg.Data)

	selfArg, selfFin := self.handle()
	defer selfFin()
	C.wrap_ImGuiKeyRoutingTable_SetEntriesNext(selfArg, *vVecArg)
}

func (self *KeyRoutingTable) EntriesNext() Vector[*KeyRoutingData] {
	selfArg, selfFin := self.handle()

	defer func() {
		selfFin()
	}()
	return newVectorFromC(C.wrap_ImGuiKeyRoutingTable_GetEntriesNext(selfArg).Size, C.wrap_ImGuiKeyRoutingTable_GetEntriesNext(selfArg).Capacity, newKeyRoutingDataFromC(C.wrap_ImGuiKeyRoutingTable_GetEntriesNext(selfArg).Data))
}

func (self LastItemData) SetID(v ID) {
	vArg, _ := v.c()

	selfArg, selfFin := self.handle()
	defer selfFin()
	C.wrap_ImGuiLastItemData_SetID(selfArg, vArg)
}

func (self *LastItemData) ID() ID {
	selfArg, selfFin := self.handle()

	defer func() {
		selfFin()
	}()

	result := C.wrap_ImGuiLastItemData_GetID(selfArg)
	return *newIDFromC(func() *C.ImGuiID { result := result; return &result }())
}

func (self LastItemData) SetInFlags(v ItemFlags) {
	selfArg, selfFin := self.handle()
	defer selfFin()
	C.wrap_ImGuiLastItemData_SetInFlags(selfArg, C.ImGuiItemFlags(v))
}

func (self *LastItemData) InFlags() ItemFlags {
	selfArg, selfFin := self.handle()

	defer func() {
		selfFin()
	}()
	return ItemFlags(C.wrap_ImGuiLastItemData_GetInFlags(selfArg))
}

func (self LastItemData) SetStatusFlags(v ItemStatusFlags) {
	selfArg, selfFin := self.handle()
	defer selfFin()
	C.wrap_ImGuiLastItemData_SetStatusFlags(selfArg, C.ImGuiItemStatusFlags(v))
}

func (self *LastItemData) StatusFlags() ItemStatusFlags {
	selfArg, selfFin := self.handle()

	defer func() {
		selfFin()
	}()
	return ItemStatusFlags(C.wrap_ImGuiLastItemData_GetStatusFlags(selfArg))
}

func (self LastItemData) SetRect(v Rect) {
	selfArg, selfFin := self.handle()
	defer selfFin()
	C.wrap_ImGuiLastItemData_SetRect(selfArg, v.toC())
}

func (self *LastItemData) Rect() Rect {
	selfArg, selfFin := self.handle()

	defer func() {
		selfFin()
	}()
	return *(&Rect{}).fromC(C.wrap_ImGuiLastItemData_GetRect(selfArg))
}

func (self LastItemData) SetNavRect(v Rect) {
	selfArg, selfFin := self.handle()
	defer selfFin()
	C.wrap_ImGuiLastItemData_SetNavRect(selfArg, v.toC())
}

func (self *LastItemData) NavRect() Rect {
	selfArg, selfFin := self.handle()

	defer func() {
		selfFin()
	}()
	return *(&Rect{}).fromC(C.wrap_ImGuiLastItemData_GetNavRect(selfArg))
}

func (self LastItemData) SetDisplayRect(v Rect) {
	selfArg, selfFin := self.handle()
	defer selfFin()
	C.wrap_ImGuiLastItemData_SetDisplayRect(selfArg, v.toC())
}

func (self *LastItemData) DisplayRect() Rect {
	selfArg, selfFin := self.handle()

	defer func() {
		selfFin()
	}()
	return *(&Rect{}).fromC(C.wrap_ImGuiLastItemData_GetDisplayRect(selfArg))
}

func (self ListClipper) SetCtx(v *Context) {
	vArg, _ := v.handle()

	selfArg, selfFin := self.handle()
	defer selfFin()
	C.wrap_ImGuiListClipper_SetCtx(selfArg, vArg)
}

func (self *ListClipper) Ctx() *Context {
	selfArg, selfFin := self.handle()

	defer func() {
		selfFin()
	}()
	return newContextFromC(C.wrap_ImGuiListClipper_GetCtx(selfArg))
}

func (self ListClipper) SetDisplayStart(v int32) {
	selfArg, selfFin := self.handle()
	defer selfFin()
	C.wrap_ImGuiListClipper_SetDisplayStart(selfArg, C.int(v))
}

func (self *ListClipper) DisplayStart() int32 {
	selfArg, selfFin := self.handle()

	defer func() {
		selfFin()
	}()
	return int32(C.wrap_ImGuiListClipper_GetDisplayStart(selfArg))
}

func (self ListClipper) SetDisplayEnd(v int32) {
	selfArg, selfFin := self.handle()
	defer selfFin()
	C.wrap_ImGuiListClipper_SetDisplayEnd(selfArg, C.int(v))
}

func (self *ListClipper) DisplayEnd() int32 {
	selfArg, selfFin := self.handle()

	defer func() {
		selfFin()
	}()
	return int32(C.wrap_ImGuiListClipper_GetDisplayEnd(selfArg))
}

func (self ListClipper) SetItemsCount(v int32) {
	selfArg, selfFin := self.handle()
	defer selfFin()
	C.wrap_ImGuiListClipper_SetItemsCount(selfArg, C.int(v))
}

func (self *ListClipper) ItemsCount() int32 {
	selfArg, selfFin := self.handle()

	defer func() {
		selfFin()
	}()
	return int32(C.wrap_ImGuiListClipper_GetItemsCount(selfArg))
}

func (self ListClipper) SetItemsHeight(v float32) {
	selfArg, selfFin := self.handle()
	defer selfFin()
	C.wrap_ImGuiListClipper_SetItemsHeight(selfArg, C.float(v))
}

func (self *ListClipper) ItemsHeight() float32 {
	selfArg, selfFin := self.handle()

	defer func() {
		selfFin()
	}()
	return float32(C.wrap_ImGuiListClipper_GetItemsHeight(selfArg))
}

func (self ListClipper) SetStartPosY(v float32) {
	selfArg, selfFin := self.handle()
	defer selfFin()
	C.wrap_ImGuiListClipper_SetStartPosY(selfArg, C.float(v))
}

func (self *ListClipper) StartPosY() float32 {
	selfArg, selfFin := self.handle()

	defer func() {
		selfFin()
	}()
	return float32(C.wrap_ImGuiListClipper_GetStartPosY(selfArg))
}

func (self ListClipper) SetTempData(v unsafe.Pointer) {
	vArg, _ := WrapVoidPtr(v)

	selfArg, selfFin := self.handle()
	defer selfFin()
	C.wrap_ImGuiListClipper_SetTempData(selfArg, vArg)
}

func (self *ListClipper) TempData() unsafe.Pointer {
	selfArg, selfFin := self.handle()

	defer func() {
		selfFin()
	}()
	return unsafe.Pointer(C.wrap_ImGuiListClipper_GetTempData(selfArg))
}

func (self ListClipperData) SetListClipper(v *ListClipper) {
	vArg, _ := v.handle()

	selfArg, selfFin := self.handle()
	defer selfFin()
	C.wrap_ImGuiListClipperData_SetListClipper(selfArg, vArg)
}

func (self *ListClipperData) ListClipper() *ListClipper {
	selfArg, selfFin := self.handle()

	defer func() {
		selfFin()
	}()
	return newListClipperFromC(C.wrap_ImGuiListClipperData_GetListClipper(selfArg))
}

func (self ListClipperData) SetLossynessOffset(v float32) {
	selfArg, selfFin := self.handle()
	defer selfFin()
	C.wrap_ImGuiListClipperData_SetLossynessOffset(selfArg, C.float(v))
}

func (self *ListClipperData) LossynessOffset() float32 {
	selfArg, selfFin := self.handle()

	defer func() {
		selfFin()
	}()
	return float32(C.wrap_ImGuiListClipperData_GetLossynessOffset(selfArg))
}

func (self ListClipperData) SetStepNo(v int32) {
	selfArg, selfFin := self.handle()
	defer selfFin()
	C.wrap_ImGuiListClipperData_SetStepNo(selfArg, C.int(v))
}

func (self *ListClipperData) StepNo() int32 {
	selfArg, selfFin := self.handle()

	defer func() {
		selfFin()
	}()
	return int32(C.wrap_ImGuiListClipperData_GetStepNo(selfArg))
}

func (self ListClipperData) SetItemsFrozen(v int32) {
	selfArg, selfFin := self.handle()
	defer selfFin()
	C.wrap_ImGuiListClipperData_SetItemsFrozen(selfArg, C.int(v))
}

func (self *ListClipperData) ItemsFrozen() int32 {
	selfArg, selfFin := self.handle()

	defer func() {
		selfFin()
	}()
	return int32(C.wrap_ImGuiListClipperData_GetItemsFrozen(selfArg))
}

func (self ListClipperData) SetRanges(v Vector[*ListClipperRange]) {
	vData := v.Data
	vDataArg, _ := vData.handle()
	vVecArg := new(C.ImVector_ImGuiListClipperRange)
	vVecArg.Size = C.int(v.Size)
	vVecArg.Capacity = C.int(v.Capacity)
	vVecArg.Data = vDataArg
	v.pinner.Pin(vVecArg.Data)

	selfArg, selfFin := self.handle()
	defer selfFin()
	C.wrap_ImGuiListClipperData_SetRanges(selfArg, *vVecArg)
}

func (self *ListClipperData) Ranges() Vector[*ListClipperRange] {
	selfArg, selfFin := self.handle()

	defer func() {
		selfFin()
	}()
	return newVectorFromC(C.wrap_ImGuiListClipperData_GetRanges(selfArg).Size, C.wrap_ImGuiListClipperData_GetRanges(selfArg).Capacity, newListClipperRangeFromC(C.wrap_ImGuiListClipperData_GetRanges(selfArg).Data))
}

func (self ListClipperRange) SetMin(v int32) {
	selfArg, selfFin := self.handle()
	defer selfFin()
	C.wrap_ImGuiListClipperRange_SetMin(selfArg, C.int(v))
}

func (self *ListClipperRange) Min() int32 {
	selfArg, selfFin := self.handle()

	defer func() {
		selfFin()
	}()
	return int32(C.wrap_ImGuiListClipperRange_GetMin(selfArg))
}

func (self ListClipperRange) SetMax(v int32) {
	selfArg, selfFin := self.handle()
	defer selfFin()
	C.wrap_ImGuiListClipperRange_SetMax(selfArg, C.int(v))
}

func (self *ListClipperRange) Max() int32 {
	selfArg, selfFin := self.handle()

	defer func() {
		selfFin()
	}()
	return int32(C.wrap_ImGuiListClipperRange_GetMax(selfArg))
}

func (self ListClipperRange) SetPosToIndexConvert(v bool) {
	selfArg, selfFin := self.handle()
	defer selfFin()
	C.wrap_ImGuiListClipperRange_SetPosToIndexConvert(selfArg, C.bool(v))
}

func (self *ListClipperRange) PosToIndexConvert() bool {
	selfArg, selfFin := self.handle()

	defer func() {
		selfFin()
	}()
	return C.wrap_ImGuiListClipperRange_GetPosToIndexConvert(selfArg) == C.bool(true)
}

func (self ListClipperRange) SetPosToIndexOffsetMin(v int) {
	selfArg, selfFin := self.handle()
	defer selfFin()
	C.wrap_ImGuiListClipperRange_SetPosToIndexOffsetMin(selfArg, C.ImS8(v))
}

func (self *ListClipperRange) PosToIndexOffsetMin() int {
	selfArg, selfFin := self.handle()

	defer func() {
		selfFin()
	}()
	return int(C.wrap_ImGuiListClipperRange_GetPosToIndexOffsetMin(selfArg))
}

func (self ListClipperRange) SetPosToIndexOffsetMax(v int) {
	selfArg, selfFin := self.handle()
	defer selfFin()
	C.wrap_ImGuiListClipperRange_SetPosToIndexOffsetMax(selfArg, C.ImS8(v))
}

func (self *ListClipperRange) PosToIndexOffsetMax() int {
	selfArg, selfFin := self.handle()

	defer func() {
		selfFin()
	}()
	return int(C.wrap_ImGuiListClipperRange_GetPosToIndexOffsetMax(selfArg))
}

func (self LocEntry) SetKey(v LocKey) {
	selfArg, selfFin := self.handle()
	defer selfFin()
	C.wrap_ImGuiLocEntry_SetKey(selfArg, C.ImGuiLocKey(v))
}

func (self *LocEntry) Key() LocKey {
	selfArg, selfFin := self.handle()

	defer func() {
		selfFin()
	}()
	return LocKey(C.wrap_ImGuiLocEntry_GetKey(selfArg))
}

func (self LocEntry) SetText(v string) {
	vArg, _ := WrapString(v)

	selfArg, selfFin := self.handle()
	defer selfFin()
	C.wrap_ImGuiLocEntry_SetText(selfArg, vArg)
}

func (self *LocEntry) Text() string {
	selfArg, selfFin := self.handle()

	defer func() {
		selfFin()
	}()
	return C.GoString(C.wrap_ImGuiLocEntry_GetText(selfArg))
}

func (self MenuColumns) SetTotalWidth(v uint32) {
	selfArg, selfFin := self.handle()
	defer selfFin()
	C.wrap_ImGuiMenuColumns_SetTotalWidth(selfArg, C.ImU32(v))
}

func (self *MenuColumns) TotalWidth() uint32 {
	selfArg, selfFin := self.handle()

	defer func() {
		selfFin()
	}()
	return uint32(C.wrap_ImGuiMenuColumns_GetTotalWidth(selfArg))
}

func (self MenuColumns) SetNextTotalWidth(v uint32) {
	selfArg, selfFin := self.handle()
	defer selfFin()
	C.wrap_ImGuiMenuColumns_SetNextTotalWidth(selfArg, C.ImU32(v))
}

func (self *MenuColumns) NextTotalWidth() uint32 {
	selfArg, selfFin := self.handle()

	defer func() {
		selfFin()
	}()
	return uint32(C.wrap_ImGuiMenuColumns_GetNextTotalWidth(selfArg))
}

func (self MenuColumns) SetSpacing(v uint16) {
	selfArg, selfFin := self.handle()
	defer selfFin()
	C.wrap_ImGuiMenuColumns_SetSpacing(selfArg, C.ImU16(v))
}

func (self *MenuColumns) Spacing() uint16 {
	selfArg, selfFin := self.handle()

	defer func() {
		selfFin()
	}()
	return uint16(C.wrap_ImGuiMenuColumns_GetSpacing(selfArg))
}

func (self MenuColumns) SetOffsetIcon(v uint16) {
	selfArg, selfFin := self.handle()
	defer selfFin()
	C.wrap_ImGuiMenuColumns_SetOffsetIcon(selfArg, C.ImU16(v))
}

func (self *MenuColumns) OffsetIcon() uint16 {
	selfArg, selfFin := self.handle()

	defer func() {
		selfFin()
	}()
	return uint16(C.wrap_ImGuiMenuColumns_GetOffsetIcon(selfArg))
}

func (self MenuColumns) SetOffsetLabel(v uint16) {
	selfArg, selfFin := self.handle()
	defer selfFin()
	C.wrap_ImGuiMenuColumns_SetOffsetLabel(selfArg, C.ImU16(v))
}

func (self *MenuColumns) OffsetLabel() uint16 {
	selfArg, selfFin := self.handle()

	defer func() {
		selfFin()
	}()
	return uint16(C.wrap_ImGuiMenuColumns_GetOffsetLabel(selfArg))
}

func (self MenuColumns) SetOffsetShortcut(v uint16) {
	selfArg, selfFin := self.handle()
	defer selfFin()
	C.wrap_ImGuiMenuColumns_SetOffsetShortcut(selfArg, C.ImU16(v))
}

func (self *MenuColumns) OffsetShortcut() uint16 {
	selfArg, selfFin := self.handle()

	defer func() {
		selfFin()
	}()
	return uint16(C.wrap_ImGuiMenuColumns_GetOffsetShortcut(selfArg))
}

func (self MenuColumns) SetOffsetMark(v uint16) {
	selfArg, selfFin := self.handle()
	defer selfFin()
	C.wrap_ImGuiMenuColumns_SetOffsetMark(selfArg, C.ImU16(v))
}

func (self *MenuColumns) OffsetMark() uint16 {
	selfArg, selfFin := self.handle()

	defer func() {
		selfFin()
	}()
	return uint16(C.wrap_ImGuiMenuColumns_GetOffsetMark(selfArg))
}

func (self MetricsConfig) SetShowDebugLog(v bool) {
	selfArg, selfFin := self.handle()
	defer selfFin()
	C.wrap_ImGuiMetricsConfig_SetShowDebugLog(selfArg, C.bool(v))
}

func (self *MetricsConfig) ShowDebugLog() bool {
	selfArg, selfFin := self.handle()

	defer func() {
		selfFin()
	}()
	return C.wrap_ImGuiMetricsConfig_GetShowDebugLog(selfArg) == C.bool(true)
}

func (self MetricsConfig) SetShowStackTool(v bool) {
	selfArg, selfFin := self.handle()
	defer selfFin()
	C.wrap_ImGuiMetricsConfig_SetShowStackTool(selfArg, C.bool(v))
}

func (self *MetricsConfig) ShowStackTool() bool {
	selfArg, selfFin := self.handle()

	defer func() {
		selfFin()
	}()
	return C.wrap_ImGuiMetricsConfig_GetShowStackTool(selfArg) == C.bool(true)
}

func (self MetricsConfig) SetShowWindowsRects(v bool) {
	selfArg, selfFin := self.handle()
	defer selfFin()
	C.wrap_ImGuiMetricsConfig_SetShowWindowsRects(selfArg, C.bool(v))
}

func (self *MetricsConfig) ShowWindowsRects() bool {
	selfArg, selfFin := self.handle()

	defer func() {
		selfFin()
	}()
	return C.wrap_ImGuiMetricsConfig_GetShowWindowsRects(selfArg) == C.bool(true)
}

func (self MetricsConfig) SetShowWindowsBeginOrder(v bool) {
	selfArg, selfFin := self.handle()
	defer selfFin()
	C.wrap_ImGuiMetricsConfig_SetShowWindowsBeginOrder(selfArg, C.bool(v))
}

func (self *MetricsConfig) ShowWindowsBeginOrder() bool {
	selfArg, selfFin := self.handle()

	defer func() {
		selfFin()
	}()
	return C.wrap_ImGuiMetricsConfig_GetShowWindowsBeginOrder(selfArg) == C.bool(true)
}

func (self MetricsConfig) SetShowTablesRects(v bool) {
	selfArg, selfFin := self.handle()
	defer selfFin()
	C.wrap_ImGuiMetricsConfig_SetShowTablesRects(selfArg, C.bool(v))
}

func (self *MetricsConfig) ShowTablesRects() bool {
	selfArg, selfFin := self.handle()

	defer func() {
		selfFin()
	}()
	return C.wrap_ImGuiMetricsConfig_GetShowTablesRects(selfArg) == C.bool(true)
}

func (self MetricsConfig) SetShowDrawCmdMesh(v bool) {
	selfArg, selfFin := self.handle()
	defer selfFin()
	C.wrap_ImGuiMetricsConfig_SetShowDrawCmdMesh(selfArg, C.bool(v))
}

func (self *MetricsConfig) ShowDrawCmdMesh() bool {
	selfArg, selfFin := self.handle()

	defer func() {
		selfFin()
	}()
	return C.wrap_ImGuiMetricsConfig_GetShowDrawCmdMesh(selfArg) == C.bool(true)
}

func (self MetricsConfig) SetShowDrawCmdBoundingBoxes(v bool) {
	selfArg, selfFin := self.handle()
	defer selfFin()
	C.wrap_ImGuiMetricsConfig_SetShowDrawCmdBoundingBoxes(selfArg, C.bool(v))
}

func (self *MetricsConfig) ShowDrawCmdBoundingBoxes() bool {
	selfArg, selfFin := self.handle()

	defer func() {
		selfFin()
	}()
	return C.wrap_ImGuiMetricsConfig_GetShowDrawCmdBoundingBoxes(selfArg) == C.bool(true)
}

func (self MetricsConfig) SetShowAtlasTintedWithTextColor(v bool) {
	selfArg, selfFin := self.handle()
	defer selfFin()
	C.wrap_ImGuiMetricsConfig_SetShowAtlasTintedWithTextColor(selfArg, C.bool(v))
}

func (self *MetricsConfig) ShowAtlasTintedWithTextColor() bool {
	selfArg, selfFin := self.handle()

	defer func() {
		selfFin()
	}()
	return C.wrap_ImGuiMetricsConfig_GetShowAtlasTintedWithTextColor(selfArg) == C.bool(true)
}

func (self MetricsConfig) SetShowDockingNodes(v bool) {
	selfArg, selfFin := self.handle()
	defer selfFin()
	C.wrap_ImGuiMetricsConfig_SetShowDockingNodes(selfArg, C.bool(v))
}

func (self *MetricsConfig) ShowDockingNodes() bool {
	selfArg, selfFin := self.handle()

	defer func() {
		selfFin()
	}()
	return C.wrap_ImGuiMetricsConfig_GetShowDockingNodes(selfArg) == C.bool(true)
}

func (self MetricsConfig) SetShowWindowsRectsType(v int32) {
	selfArg, selfFin := self.handle()
	defer selfFin()
	C.wrap_ImGuiMetricsConfig_SetShowWindowsRectsType(selfArg, C.int(v))
}

func (self *MetricsConfig) ShowWindowsRectsType() int32 {
	selfArg, selfFin := self.handle()

	defer func() {
		selfFin()
	}()
	return int32(C.wrap_ImGuiMetricsConfig_GetShowWindowsRectsType(selfArg))
}

func (self MetricsConfig) SetShowTablesRectsType(v int32) {
	selfArg, selfFin := self.handle()
	defer selfFin()
	C.wrap_ImGuiMetricsConfig_SetShowTablesRectsType(selfArg, C.int(v))
}

func (self *MetricsConfig) ShowTablesRectsType() int32 {
	selfArg, selfFin := self.handle()

	defer func() {
		selfFin()
	}()
	return int32(C.wrap_ImGuiMetricsConfig_GetShowTablesRectsType(selfArg))
}

func (self NavItemData) SetWindow(v *Window) {
	vArg, _ := v.handle()

	selfArg, selfFin := self.handle()
	defer selfFin()
	C.wrap_ImGuiNavItemData_SetWindow(selfArg, vArg)
}

func (self *NavItemData) Window() *Window {
	selfArg, selfFin := self.handle()

	defer func() {
		selfFin()
	}()
	return newWindowFromC(C.wrap_ImGuiNavItemData_GetWindow(selfArg))
}

func (self NavItemData) SetID(v ID) {
	vArg, _ := v.c()

	selfArg, selfFin := self.handle()
	defer selfFin()
	C.wrap_ImGuiNavItemData_SetID(selfArg, vArg)
}

func (self *NavItemData) ID() ID {
	selfArg, selfFin := self.handle()

	defer func() {
		selfFin()
	}()

	result := C.wrap_ImGuiNavItemData_GetID(selfArg)
	return *newIDFromC(func() *C.ImGuiID { result := result; return &result }())
}

func (self NavItemData) SetFocusScopeId(v ID) {
	vArg, _ := v.c()

	selfArg, selfFin := self.handle()
	defer selfFin()
	C.wrap_ImGuiNavItemData_SetFocusScopeId(selfArg, vArg)
}

func (self *NavItemData) FocusScopeId() ID {
	selfArg, selfFin := self.handle()

	defer func() {
		selfFin()
	}()

	result := C.wrap_ImGuiNavItemData_GetFocusScopeId(selfArg)
	return *newIDFromC(func() *C.ImGuiID { result := result; return &result }())
}

func (self NavItemData) SetRectRel(v Rect) {
	selfArg, selfFin := self.handle()
	defer selfFin()
	C.wrap_ImGuiNavItemData_SetRectRel(selfArg, v.toC())
}

func (self *NavItemData) RectRel() Rect {
	selfArg, selfFin := self.handle()

	defer func() {
		selfFin()
	}()
	return *(&Rect{}).fromC(C.wrap_ImGuiNavItemData_GetRectRel(selfArg))
}

func (self NavItemData) SetInFlags(v ItemFlags) {
	selfArg, selfFin := self.handle()
	defer selfFin()
	C.wrap_ImGuiNavItemData_SetInFlags(selfArg, C.ImGuiItemFlags(v))
}

func (self *NavItemData) InFlags() ItemFlags {
	selfArg, selfFin := self.handle()

	defer func() {
		selfFin()
	}()
	return ItemFlags(C.wrap_ImGuiNavItemData_GetInFlags(selfArg))
}

func (self NavItemData) SetDistBox(v float32) {
	selfArg, selfFin := self.handle()
	defer selfFin()
	C.wrap_ImGuiNavItemData_SetDistBox(selfArg, C.float(v))
}

func (self *NavItemData) DistBox() float32 {
	selfArg, selfFin := self.handle()

	defer func() {
		selfFin()
	}()
	return float32(C.wrap_ImGuiNavItemData_GetDistBox(selfArg))
}

func (self NavItemData) SetDistCenter(v float32) {
	selfArg, selfFin := self.handle()
	defer selfFin()
	C.wrap_ImGuiNavItemData_SetDistCenter(selfArg, C.float(v))
}

func (self *NavItemData) DistCenter() float32 {
	selfArg, selfFin := self.handle()

	defer func() {
		selfFin()
	}()
	return float32(C.wrap_ImGuiNavItemData_GetDistCenter(selfArg))
}

func (self NavItemData) SetDistAxial(v float32) {
	selfArg, selfFin := self.handle()
	defer selfFin()
	C.wrap_ImGuiNavItemData_SetDistAxial(selfArg, C.float(v))
}

func (self *NavItemData) DistAxial() float32 {
	selfArg, selfFin := self.handle()

	defer func() {
		selfFin()
	}()
	return float32(C.wrap_ImGuiNavItemData_GetDistAxial(selfArg))
}

func (self NavTreeNodeData) SetID(v ID) {
	vArg, _ := v.c()

	selfArg, selfFin := self.handle()
	defer selfFin()
	C.wrap_ImGuiNavTreeNodeData_SetID(selfArg, vArg)
}

func (self *NavTreeNodeData) ID() ID {
	selfArg, selfFin := self.handle()

	defer func() {
		selfFin()
	}()

	result := C.wrap_ImGuiNavTreeNodeData_GetID(selfArg)
	return *newIDFromC(func() *C.ImGuiID { result := result; return &result }())
}

func (self NavTreeNodeData) SetInFlags(v ItemFlags) {
	selfArg, selfFin := self.handle()
	defer selfFin()
	C.wrap_ImGuiNavTreeNodeData_SetInFlags(selfArg, C.ImGuiItemFlags(v))
}

func (self *NavTreeNodeData) InFlags() ItemFlags {
	selfArg, selfFin := self.handle()

	defer func() {
		selfFin()
	}()
	return ItemFlags(C.wrap_ImGuiNavTreeNodeData_GetInFlags(selfArg))
}

func (self NavTreeNodeData) SetNavRect(v Rect) {
	selfArg, selfFin := self.handle()
	defer selfFin()
	C.wrap_ImGuiNavTreeNodeData_SetNavRect(selfArg, v.toC())
}

func (self *NavTreeNodeData) NavRect() Rect {
	selfArg, selfFin := self.handle()

	defer func() {
		selfFin()
	}()
	return *(&Rect{}).fromC(C.wrap_ImGuiNavTreeNodeData_GetNavRect(selfArg))
}

func (self NextItemData) SetFlags(v NextItemDataFlags) {
	selfArg, selfFin := self.handle()
	defer selfFin()
	C.wrap_ImGuiNextItemData_SetFlags(selfArg, C.ImGuiNextItemDataFlags(v))
}

func (self *NextItemData) Flags() NextItemDataFlags {
	selfArg, selfFin := self.handle()

	defer func() {
		selfFin()
	}()
	return NextItemDataFlags(C.wrap_ImGuiNextItemData_GetFlags(selfArg))
}

func (self NextItemData) SetItemFlags(v ItemFlags) {
	selfArg, selfFin := self.handle()
	defer selfFin()
	C.wrap_ImGuiNextItemData_SetItemFlags(selfArg, C.ImGuiItemFlags(v))
}

func (self *NextItemData) ItemFlags() ItemFlags {
	selfArg, selfFin := self.handle()

	defer func() {
		selfFin()
	}()
	return ItemFlags(C.wrap_ImGuiNextItemData_GetItemFlags(selfArg))
}

func (self NextItemData) SetWidth(v float32) {
	selfArg, selfFin := self.handle()
	defer selfFin()
	C.wrap_ImGuiNextItemData_SetWidth(selfArg, C.float(v))
}

func (self *NextItemData) Width() float32 {
	selfArg, selfFin := self.handle()

	defer func() {
		selfFin()
	}()
	return float32(C.wrap_ImGuiNextItemData_GetWidth(selfArg))
}

func (self NextItemData) SetOpenCond(v Cond) {
	selfArg, selfFin := self.handle()
	defer selfFin()
	C.wrap_ImGuiNextItemData_SetOpenCond(selfArg, C.ImGuiCond(v))
}

func (self *NextItemData) OpenCond() Cond {
	selfArg, selfFin := self.handle()

	defer func() {
		selfFin()
	}()
	return Cond(C.wrap_ImGuiNextItemData_GetOpenCond(selfArg))
}

func (self NextItemData) SetOpenVal(v bool) {
	selfArg, selfFin := self.handle()
	defer selfFin()
	C.wrap_ImGuiNextItemData_SetOpenVal(selfArg, C.bool(v))
}

func (self *NextItemData) OpenVal() bool {
	selfArg, selfFin := self.handle()

	defer func() {
		selfFin()
	}()
	return C.wrap_ImGuiNextItemData_GetOpenVal(selfArg) == C.bool(true)
}

func (self NextWindowData) SetFlags(v NextWindowDataFlags) {
	selfArg, selfFin := self.handle()
	defer selfFin()
	C.wrap_ImGuiNextWindowData_SetFlags(selfArg, C.ImGuiNextWindowDataFlags(v))
}

func (self *NextWindowData) Flags() NextWindowDataFlags {
	selfArg, selfFin := self.handle()

	defer func() {
		selfFin()
	}()
	return NextWindowDataFlags(C.wrap_ImGuiNextWindowData_GetFlags(selfArg))
}

func (self NextWindowData) SetPosCond(v Cond) {
	selfArg, selfFin := self.handle()
	defer selfFin()
	C.wrap_ImGuiNextWindowData_SetPosCond(selfArg, C.ImGuiCond(v))
}

func (self *NextWindowData) PosCond() Cond {
	selfArg, selfFin := self.handle()

	defer func() {
		selfFin()
	}()
	return Cond(C.wrap_ImGuiNextWindowData_GetPosCond(selfArg))
}

func (self NextWindowData) SetSizeCond(v Cond) {
	selfArg, selfFin := self.handle()
	defer selfFin()
	C.wrap_ImGuiNextWindowData_SetSizeCond(selfArg, C.ImGuiCond(v))
}

func (self *NextWindowData) SizeCond() Cond {
	selfArg, selfFin := self.handle()

	defer func() {
		selfFin()
	}()
	return Cond(C.wrap_ImGuiNextWindowData_GetSizeCond(selfArg))
}

func (self NextWindowData) SetCollapsedCond(v Cond) {
	selfArg, selfFin := self.handle()
	defer selfFin()
	C.wrap_ImGuiNextWindowData_SetCollapsedCond(selfArg, C.ImGuiCond(v))
}

func (self *NextWindowData) CollapsedCond() Cond {
	selfArg, selfFin := self.handle()

	defer func() {
		selfFin()
	}()
	return Cond(C.wrap_ImGuiNextWindowData_GetCollapsedCond(selfArg))
}

func (self NextWindowData) SetDockCond(v Cond) {
	selfArg, selfFin := self.handle()
	defer selfFin()
	C.wrap_ImGuiNextWindowData_SetDockCond(selfArg, C.ImGuiCond(v))
}

func (self *NextWindowData) DockCond() Cond {
	selfArg, selfFin := self.handle()

	defer func() {
		selfFin()
	}()
	return Cond(C.wrap_ImGuiNextWindowData_GetDockCond(selfArg))
}

func (self NextWindowData) SetPosVal(v Vec2) {
	selfArg, selfFin := self.handle()
	defer selfFin()
	C.wrap_ImGuiNextWindowData_SetPosVal(selfArg, v.toC())
}

func (self *NextWindowData) PosVal() Vec2 {
	selfArg, selfFin := self.handle()

	defer func() {
		selfFin()
	}()
	return *(&Vec2{}).fromC(C.wrap_ImGuiNextWindowData_GetPosVal(selfArg))
}

func (self NextWindowData) SetPosPivotVal(v Vec2) {
	selfArg, selfFin := self.handle()
	defer selfFin()
	C.wrap_ImGuiNextWindowData_SetPosPivotVal(selfArg, v.toC())
}

func (self *NextWindowData) PosPivotVal() Vec2 {
	selfArg, selfFin := self.handle()

	defer func() {
		selfFin()
	}()
	return *(&Vec2{}).fromC(C.wrap_ImGuiNextWindowData_GetPosPivotVal(selfArg))
}

func (self NextWindowData) SetSizeVal(v Vec2) {
	selfArg, selfFin := self.handle()
	defer selfFin()
	C.wrap_ImGuiNextWindowData_SetSizeVal(selfArg, v.toC())
}

func (self *NextWindowData) SizeVal() Vec2 {
	selfArg, selfFin := self.handle()

	defer func() {
		selfFin()
	}()
	return *(&Vec2{}).fromC(C.wrap_ImGuiNextWindowData_GetSizeVal(selfArg))
}

func (self NextWindowData) SetContentSizeVal(v Vec2) {
	selfArg, selfFin := self.handle()
	defer selfFin()
	C.wrap_ImGuiNextWindowData_SetContentSizeVal(selfArg, v.toC())
}

func (self *NextWindowData) ContentSizeVal() Vec2 {
	selfArg, selfFin := self.handle()

	defer func() {
		selfFin()
	}()
	return *(&Vec2{}).fromC(C.wrap_ImGuiNextWindowData_GetContentSizeVal(selfArg))
}

func (self NextWindowData) SetScrollVal(v Vec2) {
	selfArg, selfFin := self.handle()
	defer selfFin()
	C.wrap_ImGuiNextWindowData_SetScrollVal(selfArg, v.toC())
}

func (self *NextWindowData) ScrollVal() Vec2 {
	selfArg, selfFin := self.handle()

	defer func() {
		selfFin()
	}()
	return *(&Vec2{}).fromC(C.wrap_ImGuiNextWindowData_GetScrollVal(selfArg))
}

func (self NextWindowData) SetPosUndock(v bool) {
	selfArg, selfFin := self.handle()
	defer selfFin()
	C.wrap_ImGuiNextWindowData_SetPosUndock(selfArg, C.bool(v))
}

func (self *NextWindowData) PosUndock() bool {
	selfArg, selfFin := self.handle()

	defer func() {
		selfFin()
	}()
	return C.wrap_ImGuiNextWindowData_GetPosUndock(selfArg) == C.bool(true)
}

func (self NextWindowData) SetCollapsedVal(v bool) {
	selfArg, selfFin := self.handle()
	defer selfFin()
	C.wrap_ImGuiNextWindowData_SetCollapsedVal(selfArg, C.bool(v))
}

func (self *NextWindowData) CollapsedVal() bool {
	selfArg, selfFin := self.handle()

	defer func() {
		selfFin()
	}()
	return C.wrap_ImGuiNextWindowData_GetCollapsedVal(selfArg) == C.bool(true)
}

func (self NextWindowData) SetSizeConstraintRect(v Rect) {
	selfArg, selfFin := self.handle()
	defer selfFin()
	C.wrap_ImGuiNextWindowData_SetSizeConstraintRect(selfArg, v.toC())
}

func (self *NextWindowData) SizeConstraintRect() Rect {
	selfArg, selfFin := self.handle()

	defer func() {
		selfFin()
	}()
	return *(&Rect{}).fromC(C.wrap_ImGuiNextWindowData_GetSizeConstraintRect(selfArg))
}

func (self NextWindowData) SetSizeCallbackUserData(v unsafe.Pointer) {
	vArg, _ := WrapVoidPtr(v)

	selfArg, selfFin := self.handle()
	defer selfFin()
	C.wrap_ImGuiNextWindowData_SetSizeCallbackUserData(selfArg, vArg)
}

func (self *NextWindowData) SizeCallbackUserData() unsafe.Pointer {
	selfArg, selfFin := self.handle()

	defer func() {
		selfFin()
	}()
	return unsafe.Pointer(C.wrap_ImGuiNextWindowData_GetSizeCallbackUserData(selfArg))
}

func (self NextWindowData) SetBgAlphaVal(v float32) {
	selfArg, selfFin := self.handle()
	defer selfFin()
	C.wrap_ImGuiNextWindowData_SetBgAlphaVal(selfArg, C.float(v))
}

func (self *NextWindowData) BgAlphaVal() float32 {
	selfArg, selfFin := self.handle()

	defer func() {
		selfFin()
	}()
	return float32(C.wrap_ImGuiNextWindowData_GetBgAlphaVal(selfArg))
}

func (self NextWindowData) SetViewportId(v ID) {
	vArg, _ := v.c()

	selfArg, selfFin := self.handle()
	defer selfFin()
	C.wrap_ImGuiNextWindowData_SetViewportId(selfArg, vArg)
}

func (self *NextWindowData) ViewportId() ID {
	selfArg, selfFin := self.handle()

	defer func() {
		selfFin()
	}()

	result := C.wrap_ImGuiNextWindowData_GetViewportId(selfArg)
	return *newIDFromC(func() *C.ImGuiID { result := result; return &result }())
}

func (self NextWindowData) SetDockId(v ID) {
	vArg, _ := v.c()

	selfArg, selfFin := self.handle()
	defer selfFin()
	C.wrap_ImGuiNextWindowData_SetDockId(selfArg, vArg)
}

func (self *NextWindowData) DockId() ID {
	selfArg, selfFin := self.handle()

	defer func() {
		selfFin()
	}()

	result := C.wrap_ImGuiNextWindowData_GetDockId(selfArg)
	return *newIDFromC(func() *C.ImGuiID { result := result; return &result }())
}

func (self NextWindowData) SetWindowClass(v WindowClass) {
	vArg, _ := v.c()

	selfArg, selfFin := self.handle()
	defer selfFin()
	C.wrap_ImGuiNextWindowData_SetWindowClass(selfArg, vArg)
}

func (self *NextWindowData) WindowClass() WindowClass {
	selfArg, selfFin := self.handle()

	defer func() {
		selfFin()
	}()

	result := C.wrap_ImGuiNextWindowData_GetWindowClass(selfArg)
	return *newWindowClassFromC(func() *C.ImGuiWindowClass { result := result; return &result }())
}

func (self NextWindowData) SetMenuBarOffsetMinVal(v Vec2) {
	selfArg, selfFin := self.handle()
	defer selfFin()
	C.wrap_ImGuiNextWindowData_SetMenuBarOffsetMinVal(selfArg, v.toC())
}

func (self *NextWindowData) MenuBarOffsetMinVal() Vec2 {
	selfArg, selfFin := self.handle()

	defer func() {
		selfFin()
	}()
	return *(&Vec2{}).fromC(C.wrap_ImGuiNextWindowData_GetMenuBarOffsetMinVal(selfArg))
}

func (self OldColumnData) SetOffsetNorm(v float32) {
	selfArg, selfFin := self.handle()
	defer selfFin()
	C.wrap_ImGuiOldColumnData_SetOffsetNorm(selfArg, C.float(v))
}

func (self *OldColumnData) OffsetNorm() float32 {
	selfArg, selfFin := self.handle()

	defer func() {
		selfFin()
	}()
	return float32(C.wrap_ImGuiOldColumnData_GetOffsetNorm(selfArg))
}

func (self OldColumnData) SetOffsetNormBeforeResize(v float32) {
	selfArg, selfFin := self.handle()
	defer selfFin()
	C.wrap_ImGuiOldColumnData_SetOffsetNormBeforeResize(selfArg, C.float(v))
}

func (self *OldColumnData) OffsetNormBeforeResize() float32 {
	selfArg, selfFin := self.handle()

	defer func() {
		selfFin()
	}()
	return float32(C.wrap_ImGuiOldColumnData_GetOffsetNormBeforeResize(selfArg))
}

func (self OldColumnData) SetFlags(v OldColumnFlags) {
	selfArg, selfFin := self.handle()
	defer selfFin()
	C.wrap_ImGuiOldColumnData_SetFlags(selfArg, C.ImGuiOldColumnFlags(v))
}

func (self *OldColumnData) Flags() OldColumnFlags {
	selfArg, selfFin := self.handle()

	defer func() {
		selfFin()
	}()
	return OldColumnFlags(C.wrap_ImGuiOldColumnData_GetFlags(selfArg))
}

func (self OldColumnData) SetClipRect(v Rect) {
	selfArg, selfFin := self.handle()
	defer selfFin()
	C.wrap_ImGuiOldColumnData_SetClipRect(selfArg, v.toC())
}

func (self *OldColumnData) ClipRect() Rect {
	selfArg, selfFin := self.handle()

	defer func() {
		selfFin()
	}()
	return *(&Rect{}).fromC(C.wrap_ImGuiOldColumnData_GetClipRect(selfArg))
}

func (self OldColumns) SetID(v ID) {
	vArg, _ := v.c()

	selfArg, selfFin := self.handle()
	defer selfFin()
	C.wrap_ImGuiOldColumns_SetID(selfArg, vArg)
}

func (self *OldColumns) ID() ID {
	selfArg, selfFin := self.handle()

	defer func() {
		selfFin()
	}()

	result := C.wrap_ImGuiOldColumns_GetID(selfArg)
	return *newIDFromC(func() *C.ImGuiID { result := result; return &result }())
}

func (self OldColumns) SetFlags(v OldColumnFlags) {
	selfArg, selfFin := self.handle()
	defer selfFin()
	C.wrap_ImGuiOldColumns_SetFlags(selfArg, C.ImGuiOldColumnFlags(v))
}

func (self *OldColumns) Flags() OldColumnFlags {
	selfArg, selfFin := self.handle()

	defer func() {
		selfFin()
	}()
	return OldColumnFlags(C.wrap_ImGuiOldColumns_GetFlags(selfArg))
}

func (self OldColumns) SetIsFirstFrame(v bool) {
	selfArg, selfFin := self.handle()
	defer selfFin()
	C.wrap_ImGuiOldColumns_SetIsFirstFrame(selfArg, C.bool(v))
}

func (self *OldColumns) IsFirstFrame() bool {
	selfArg, selfFin := self.handle()

	defer func() {
		selfFin()
	}()
	return C.wrap_ImGuiOldColumns_GetIsFirstFrame(selfArg) == C.bool(true)
}

func (self OldColumns) SetIsBeingResized(v bool) {
	selfArg, selfFin := self.handle()
	defer selfFin()
	C.wrap_ImGuiOldColumns_SetIsBeingResized(selfArg, C.bool(v))
}

func (self *OldColumns) IsBeingResized() bool {
	selfArg, selfFin := self.handle()

	defer func() {
		selfFin()
	}()
	return C.wrap_ImGuiOldColumns_GetIsBeingResized(selfArg) == C.bool(true)
}

func (self OldColumns) SetCurrent(v int32) {
	selfArg, selfFin := self.handle()
	defer selfFin()
	C.wrap_ImGuiOldColumns_SetCurrent(selfArg, C.int(v))
}

func (self *OldColumns) Current() int32 {
	selfArg, selfFin := self.handle()

	defer func() {
		selfFin()
	}()
	return int32(C.wrap_ImGuiOldColumns_GetCurrent(selfArg))
}

func (self OldColumns) SetCount(v int32) {
	selfArg, selfFin := self.handle()
	defer selfFin()
	C.wrap_ImGuiOldColumns_SetCount(selfArg, C.int(v))
}

func (self *OldColumns) Count() int32 {
	selfArg, selfFin := self.handle()

	defer func() {
		selfFin()
	}()
	return int32(C.wrap_ImGuiOldColumns_GetCount(selfArg))
}

func (self OldColumns) SetOffMinX(v float32) {
	selfArg, selfFin := self.handle()
	defer selfFin()
	C.wrap_ImGuiOldColumns_SetOffMinX(selfArg, C.float(v))
}

func (self *OldColumns) OffMinX() float32 {
	selfArg, selfFin := self.handle()

	defer func() {
		selfFin()
	}()
	return float32(C.wrap_ImGuiOldColumns_GetOffMinX(selfArg))
}

func (self OldColumns) SetOffMaxX(v float32) {
	selfArg, selfFin := self.handle()
	defer selfFin()
	C.wrap_ImGuiOldColumns_SetOffMaxX(selfArg, C.float(v))
}

func (self *OldColumns) OffMaxX() float32 {
	selfArg, selfFin := self.handle()

	defer func() {
		selfFin()
	}()
	return float32(C.wrap_ImGuiOldColumns_GetOffMaxX(selfArg))
}

func (self OldColumns) SetLineMinY(v float32) {
	selfArg, selfFin := self.handle()
	defer selfFin()
	C.wrap_ImGuiOldColumns_SetLineMinY(selfArg, C.float(v))
}

func (self *OldColumns) LineMinY() float32 {
	selfArg, selfFin := self.handle()

	defer func() {
		selfFin()
	}()
	return float32(C.wrap_ImGuiOldColumns_GetLineMinY(selfArg))
}

func (self OldColumns) SetLineMaxY(v float32) {
	selfArg, selfFin := self.handle()
	defer selfFin()
	C.wrap_ImGuiOldColumns_SetLineMaxY(selfArg, C.float(v))
}

func (self *OldColumns) LineMaxY() float32 {
	selfArg, selfFin := self.handle()

	defer func() {
		selfFin()
	}()
	return float32(C.wrap_ImGuiOldColumns_GetLineMaxY(selfArg))
}

func (self OldColumns) SetHostCursorPosY(v float32) {
	selfArg, selfFin := self.handle()
	defer selfFin()
	C.wrap_ImGuiOldColumns_SetHostCursorPosY(selfArg, C.float(v))
}

func (self *OldColumns) HostCursorPosY() float32 {
	selfArg, selfFin := self.handle()

	defer func() {
		selfFin()
	}()
	return float32(C.wrap_ImGuiOldColumns_GetHostCursorPosY(selfArg))
}

func (self OldColumns) SetHostCursorMaxPosX(v float32) {
	selfArg, selfFin := self.handle()
	defer selfFin()
	C.wrap_ImGuiOldColumns_SetHostCursorMaxPosX(selfArg, C.float(v))
}

func (self *OldColumns) HostCursorMaxPosX() float32 {
	selfArg, selfFin := self.handle()

	defer func() {
		selfFin()
	}()
	return float32(C.wrap_ImGuiOldColumns_GetHostCursorMaxPosX(selfArg))
}

func (self OldColumns) SetHostInitialClipRect(v Rect) {
	selfArg, selfFin := self.handle()
	defer selfFin()
	C.wrap_ImGuiOldColumns_SetHostInitialClipRect(selfArg, v.toC())
}

func (self *OldColumns) HostInitialClipRect() Rect {
	selfArg, selfFin := self.handle()

	defer func() {
		selfFin()
	}()
	return *(&Rect{}).fromC(C.wrap_ImGuiOldColumns_GetHostInitialClipRect(selfArg))
}

func (self OldColumns) SetHostBackupClipRect(v Rect) {
	selfArg, selfFin := self.handle()
	defer selfFin()
	C.wrap_ImGuiOldColumns_SetHostBackupClipRect(selfArg, v.toC())
}

func (self *OldColumns) HostBackupClipRect() Rect {
	selfArg, selfFin := self.handle()

	defer func() {
		selfFin()
	}()
	return *(&Rect{}).fromC(C.wrap_ImGuiOldColumns_GetHostBackupClipRect(selfArg))
}

func (self OldColumns) SetHostBackupParentWorkRect(v Rect) {
	selfArg, selfFin := self.handle()
	defer selfFin()
	C.wrap_ImGuiOldColumns_SetHostBackupParentWorkRect(selfArg, v.toC())
}

func (self *OldColumns) HostBackupParentWorkRect() Rect {
	selfArg, selfFin := self.handle()

	defer func() {
		selfFin()
	}()
	return *(&Rect{}).fromC(C.wrap_ImGuiOldColumns_GetHostBackupParentWorkRect(selfArg))
}

func (self OldColumns) SetColumns(v Vector[*OldColumnData]) {
	vData := v.Data
	vDataArg, _ := vData.handle()
	vVecArg := new(C.ImVector_ImGuiOldColumnData)
	vVecArg.Size = C.int(v.Size)
	vVecArg.Capacity = C.int(v.Capacity)
	vVecArg.Data = vDataArg
	v.pinner.Pin(vVecArg.Data)

	selfArg, selfFin := self.handle()
	defer selfFin()
	C.wrap_ImGuiOldColumns_SetColumns(selfArg, *vVecArg)
}

func (self *OldColumns) Columns() Vector[*OldColumnData] {
	selfArg, selfFin := self.handle()

	defer func() {
		selfFin()
	}()
	return newVectorFromC(C.wrap_ImGuiOldColumns_GetColumns(selfArg).Size, C.wrap_ImGuiOldColumns_GetColumns(selfArg).Capacity, newOldColumnDataFromC(C.wrap_ImGuiOldColumns_GetColumns(selfArg).Data))
}

func (self OldColumns) SetSplitter(v DrawListSplitter) {
	vArg, _ := v.c()

	selfArg, selfFin := self.handle()
	defer selfFin()
	C.wrap_ImGuiOldColumns_SetSplitter(selfArg, vArg)
}

func (self *OldColumns) Splitter() DrawListSplitter {
	selfArg, selfFin := self.handle()

	defer func() {
		selfFin()
	}()

	result := C.wrap_ImGuiOldColumns_GetSplitter(selfArg)
	return *newDrawListSplitterFromC(func() *C.ImDrawListSplitter { result := result; return &result }())
}

func (self OnceUponAFrame) SetRefFrame(v int32) {
	selfArg, selfFin := self.handle()
	defer selfFin()
	C.wrap_ImGuiOnceUponAFrame_SetRefFrame(selfArg, C.int(v))
}

func (self *OnceUponAFrame) RefFrame() int32 {
	selfArg, selfFin := self.handle()

	defer func() {
		selfFin()
	}()
	return int32(C.wrap_ImGuiOnceUponAFrame_GetRefFrame(selfArg))
}

func (self Payload) SetData(v unsafe.Pointer) {
	vArg, _ := WrapVoidPtr(v)

	selfArg, selfFin := self.handle()
	defer selfFin()
	C.wrap_ImGuiPayload_SetData(selfArg, vArg)
}

func (self *Payload) Data() unsafe.Pointer {
	selfArg, selfFin := self.handle()

	defer func() {
		selfFin()
	}()
	return unsafe.Pointer(C.wrap_ImGuiPayload_GetData(selfArg))
}

func (self Payload) SetDataSize(v int32) {
	selfArg, selfFin := self.handle()
	defer selfFin()
	C.wrap_ImGuiPayload_SetDataSize(selfArg, C.int(v))
}

func (self *Payload) DataSize() int32 {
	selfArg, selfFin := self.handle()

	defer func() {
		selfFin()
	}()
	return int32(C.wrap_ImGuiPayload_GetDataSize(selfArg))
}

func (self Payload) SetSourceId(v ID) {
	vArg, _ := v.c()

	selfArg, selfFin := self.handle()
	defer selfFin()
	C.wrap_ImGuiPayload_SetSourceId(selfArg, vArg)
}

func (self *Payload) SourceId() ID {
	selfArg, selfFin := self.handle()

	defer func() {
		selfFin()
	}()

	result := C.wrap_ImGuiPayload_GetSourceId(selfArg)
	return *newIDFromC(func() *C.ImGuiID { result := result; return &result }())
}

func (self Payload) SetSourceParentId(v ID) {
	vArg, _ := v.c()

	selfArg, selfFin := self.handle()
	defer selfFin()
	C.wrap_ImGuiPayload_SetSourceParentId(selfArg, vArg)
}

func (self *Payload) SourceParentId() ID {
	selfArg, selfFin := self.handle()

	defer func() {
		selfFin()
	}()

	result := C.wrap_ImGuiPayload_GetSourceParentId(selfArg)
	return *newIDFromC(func() *C.ImGuiID { result := result; return &result }())
}

func (self Payload) SetDataFrameCount(v int32) {
	selfArg, selfFin := self.handle()
	defer selfFin()
	C.wrap_ImGuiPayload_SetDataFrameCount(selfArg, C.int(v))
}

func (self *Payload) DataFrameCount() int32 {
	selfArg, selfFin := self.handle()

	defer func() {
		selfFin()
	}()
	return int32(C.wrap_ImGuiPayload_GetDataFrameCount(selfArg))
}

func (self Payload) SetPreview(v bool) {
	selfArg, selfFin := self.handle()
	defer selfFin()
	C.wrap_ImGuiPayload_SetPreview(selfArg, C.bool(v))
}

func (self *Payload) Preview() bool {
	selfArg, selfFin := self.handle()

	defer func() {
		selfFin()
	}()
	return C.wrap_ImGuiPayload_GetPreview(selfArg) == C.bool(true)
}

func (self Payload) SetDelivery(v bool) {
	selfArg, selfFin := self.handle()
	defer selfFin()
	C.wrap_ImGuiPayload_SetDelivery(selfArg, C.bool(v))
}

func (self *Payload) Delivery() bool {
	selfArg, selfFin := self.handle()

	defer func() {
		selfFin()
	}()
	return C.wrap_ImGuiPayload_GetDelivery(selfArg) == C.bool(true)
}

func (self PlatformIO) SetMonitors(v Vector[*PlatformMonitor]) {
	vData := v.Data
	vDataArg, _ := vData.handle()
	vVecArg := new(C.ImVector_ImGuiPlatformMonitor)
	vVecArg.Size = C.int(v.Size)
	vVecArg.Capacity = C.int(v.Capacity)
	vVecArg.Data = vDataArg
	v.pinner.Pin(vVecArg.Data)

	selfArg, selfFin := self.handle()
	defer selfFin()
	C.wrap_ImGuiPlatformIO_SetMonitors(selfArg, *vVecArg)
}

func (self *PlatformIO) Monitors() Vector[*PlatformMonitor] {
	selfArg, selfFin := self.handle()

	defer func() {
		selfFin()
	}()
	return newVectorFromC(C.wrap_ImGuiPlatformIO_GetMonitors(selfArg).Size, C.wrap_ImGuiPlatformIO_GetMonitors(selfArg).Capacity, newPlatformMonitorFromC(C.wrap_ImGuiPlatformIO_GetMonitors(selfArg).Data))
}

func (self PlatformImeData) SetWantVisible(v bool) {
	selfArg, selfFin := self.handle()
	defer selfFin()
	C.wrap_ImGuiPlatformImeData_SetWantVisible(selfArg, C.bool(v))
}

func (self *PlatformImeData) WantVisible() bool {
	selfArg, selfFin := self.handle()

	defer func() {
		selfFin()
	}()
	return C.wrap_ImGuiPlatformImeData_GetWantVisible(selfArg) == C.bool(true)
}

func (self PlatformImeData) SetInputPos(v Vec2) {
	selfArg, selfFin := self.handle()
	defer selfFin()
	C.wrap_ImGuiPlatformImeData_SetInputPos(selfArg, v.toC())
}

func (self *PlatformImeData) InputPos() Vec2 {
	selfArg, selfFin := self.handle()

	defer func() {
		selfFin()
	}()
	return *(&Vec2{}).fromC(C.wrap_ImGuiPlatformImeData_GetInputPos(selfArg))
}

func (self PlatformImeData) SetInputLineHeight(v float32) {
	selfArg, selfFin := self.handle()
	defer selfFin()
	C.wrap_ImGuiPlatformImeData_SetInputLineHeight(selfArg, C.float(v))
}

func (self *PlatformImeData) InputLineHeight() float32 {
	selfArg, selfFin := self.handle()

	defer func() {
		selfFin()
	}()
	return float32(C.wrap_ImGuiPlatformImeData_GetInputLineHeight(selfArg))
}

func (self PlatformMonitor) SetMainPos(v Vec2) {
	selfArg, selfFin := self.handle()
	defer selfFin()
	C.wrap_ImGuiPlatformMonitor_SetMainPos(selfArg, v.toC())
}

func (self *PlatformMonitor) MainPos() Vec2 {
	selfArg, selfFin := self.handle()

	defer func() {
		selfFin()
	}()
	return *(&Vec2{}).fromC(C.wrap_ImGuiPlatformMonitor_GetMainPos(selfArg))
}

func (self PlatformMonitor) SetMainSize(v Vec2) {
	selfArg, selfFin := self.handle()
	defer selfFin()
	C.wrap_ImGuiPlatformMonitor_SetMainSize(selfArg, v.toC())
}

func (self *PlatformMonitor) MainSize() Vec2 {
	selfArg, selfFin := self.handle()

	defer func() {
		selfFin()
	}()
	return *(&Vec2{}).fromC(C.wrap_ImGuiPlatformMonitor_GetMainSize(selfArg))
}

func (self PlatformMonitor) SetWorkPos(v Vec2) {
	selfArg, selfFin := self.handle()
	defer selfFin()
	C.wrap_ImGuiPlatformMonitor_SetWorkPos(selfArg, v.toC())
}

func (self *PlatformMonitor) WorkPos() Vec2 {
	selfArg, selfFin := self.handle()

	defer func() {
		selfFin()
	}()
	return *(&Vec2{}).fromC(C.wrap_ImGuiPlatformMonitor_GetWorkPos(selfArg))
}

func (self PlatformMonitor) SetWorkSize(v Vec2) {
	selfArg, selfFin := self.handle()
	defer selfFin()
	C.wrap_ImGuiPlatformMonitor_SetWorkSize(selfArg, v.toC())
}

func (self *PlatformMonitor) WorkSize() Vec2 {
	selfArg, selfFin := self.handle()

	defer func() {
		selfFin()
	}()
	return *(&Vec2{}).fromC(C.wrap_ImGuiPlatformMonitor_GetWorkSize(selfArg))
}

func (self PlatformMonitor) SetDpiScale(v float32) {
	selfArg, selfFin := self.handle()
	defer selfFin()
	C.wrap_ImGuiPlatformMonitor_SetDpiScale(selfArg, C.float(v))
}

func (self *PlatformMonitor) DpiScale() float32 {
	selfArg, selfFin := self.handle()

	defer func() {
		selfFin()
	}()
	return float32(C.wrap_ImGuiPlatformMonitor_GetDpiScale(selfArg))
}

func (self PlatformMonitor) SetPlatformHandle(v unsafe.Pointer) {
	vArg, _ := WrapVoidPtr(v)

	selfArg, selfFin := self.handle()
	defer selfFin()
	C.wrap_ImGuiPlatformMonitor_SetPlatformHandle(selfArg, vArg)
}

func (self *PlatformMonitor) PlatformHandle() unsafe.Pointer {
	selfArg, selfFin := self.handle()

	defer func() {
		selfFin()
	}()
	return unsafe.Pointer(C.wrap_ImGuiPlatformMonitor_GetPlatformHandle(selfArg))
}

func (self PopupData) SetPopupId(v ID) {
	vArg, _ := v.c()

	selfArg, selfFin := self.handle()
	defer selfFin()
	C.wrap_ImGuiPopupData_SetPopupId(selfArg, vArg)
}

func (self *PopupData) PopupId() ID {
	selfArg, selfFin := self.handle()

	defer func() {
		selfFin()
	}()

	result := C.wrap_ImGuiPopupData_GetPopupId(selfArg)
	return *newIDFromC(func() *C.ImGuiID { result := result; return &result }())
}

func (self PopupData) SetWindow(v *Window) {
	vArg, _ := v.handle()

	selfArg, selfFin := self.handle()
	defer selfFin()
	C.wrap_ImGuiPopupData_SetWindow(selfArg, vArg)
}

func (self *PopupData) Window() *Window {
	selfArg, selfFin := self.handle()

	defer func() {
		selfFin()
	}()
	return newWindowFromC(C.wrap_ImGuiPopupData_GetWindow(selfArg))
}

func (self PopupData) SetBackupNavWindow(v *Window) {
	vArg, _ := v.handle()

	selfArg, selfFin := self.handle()
	defer selfFin()
	C.wrap_ImGuiPopupData_SetBackupNavWindow(selfArg, vArg)
}

func (self *PopupData) BackupNavWindow() *Window {
	selfArg, selfFin := self.handle()

	defer func() {
		selfFin()
	}()
	return newWindowFromC(C.wrap_ImGuiPopupData_GetBackupNavWindow(selfArg))
}

func (self PopupData) SetParentNavLayer(v int32) {
	selfArg, selfFin := self.handle()
	defer selfFin()
	C.wrap_ImGuiPopupData_SetParentNavLayer(selfArg, C.int(v))
}

func (self *PopupData) ParentNavLayer() int32 {
	selfArg, selfFin := self.handle()

	defer func() {
		selfFin()
	}()
	return int32(C.wrap_ImGuiPopupData_GetParentNavLayer(selfArg))
}

func (self PopupData) SetOpenFrameCount(v int32) {
	selfArg, selfFin := self.handle()
	defer selfFin()
	C.wrap_ImGuiPopupData_SetOpenFrameCount(selfArg, C.int(v))
}

func (self *PopupData) OpenFrameCount() int32 {
	selfArg, selfFin := self.handle()

	defer func() {
		selfFin()
	}()
	return int32(C.wrap_ImGuiPopupData_GetOpenFrameCount(selfArg))
}

func (self PopupData) SetOpenParentId(v ID) {
	vArg, _ := v.c()

	selfArg, selfFin := self.handle()
	defer selfFin()
	C.wrap_ImGuiPopupData_SetOpenParentId(selfArg, vArg)
}

func (self *PopupData) OpenParentId() ID {
	selfArg, selfFin := self.handle()

	defer func() {
		selfFin()
	}()

	result := C.wrap_ImGuiPopupData_GetOpenParentId(selfArg)
	return *newIDFromC(func() *C.ImGuiID { result := result; return &result }())
}

func (self PopupData) SetOpenPopupPos(v Vec2) {
	selfArg, selfFin := self.handle()
	defer selfFin()
	C.wrap_ImGuiPopupData_SetOpenPopupPos(selfArg, v.toC())
}

func (self *PopupData) OpenPopupPos() Vec2 {
	selfArg, selfFin := self.handle()

	defer func() {
		selfFin()
	}()
	return *(&Vec2{}).fromC(C.wrap_ImGuiPopupData_GetOpenPopupPos(selfArg))
}

func (self PopupData) SetOpenMousePos(v Vec2) {
	selfArg, selfFin := self.handle()
	defer selfFin()
	C.wrap_ImGuiPopupData_SetOpenMousePos(selfArg, v.toC())
}

func (self *PopupData) OpenMousePos() Vec2 {
	selfArg, selfFin := self.handle()

	defer func() {
		selfFin()
	}()
	return *(&Vec2{}).fromC(C.wrap_ImGuiPopupData_GetOpenMousePos(selfArg))
}

func (self PtrOrIndex) SetPtr(v unsafe.Pointer) {
	vArg, _ := WrapVoidPtr(v)

	selfArg, selfFin := self.handle()
	defer selfFin()
	C.wrap_ImGuiPtrOrIndex_SetPtr(selfArg, vArg)
}

func (self *PtrOrIndex) Ptr() unsafe.Pointer {
	selfArg, selfFin := self.handle()

	defer func() {
		selfFin()
	}()
	return unsafe.Pointer(C.wrap_ImGuiPtrOrIndex_GetPtr(selfArg))
}

func (self PtrOrIndex) SetIndex(v int32) {
	selfArg, selfFin := self.handle()
	defer selfFin()
	C.wrap_ImGuiPtrOrIndex_SetIndex(selfArg, C.int(v))
}

func (self *PtrOrIndex) Index() int32 {
	selfArg, selfFin := self.handle()

	defer func() {
		selfFin()
	}()
	return int32(C.wrap_ImGuiPtrOrIndex_GetIndex(selfArg))
}

func (self SettingsHandler) SetTypeName(v string) {
	vArg, _ := WrapString(v)

	selfArg, selfFin := self.handle()
	defer selfFin()
	C.wrap_ImGuiSettingsHandler_SetTypeName(selfArg, vArg)
}

func (self *SettingsHandler) TypeName() string {
	selfArg, selfFin := self.handle()

	defer func() {
		selfFin()
	}()
	return C.GoString(C.wrap_ImGuiSettingsHandler_GetTypeName(selfArg))
}

func (self SettingsHandler) SetTypeHash(v ID) {
	vArg, _ := v.c()

	selfArg, selfFin := self.handle()
	defer selfFin()
	C.wrap_ImGuiSettingsHandler_SetTypeHash(selfArg, vArg)
}

func (self *SettingsHandler) TypeHash() ID {
	selfArg, selfFin := self.handle()

	defer func() {
		selfFin()
	}()

	result := C.wrap_ImGuiSettingsHandler_GetTypeHash(selfArg)
	return *newIDFromC(func() *C.ImGuiID { result := result; return &result }())
}

func (self SettingsHandler) SetUserData(v unsafe.Pointer) {
	vArg, _ := WrapVoidPtr(v)

	selfArg, selfFin := self.handle()
	defer selfFin()
	C.wrap_ImGuiSettingsHandler_SetUserData(selfArg, vArg)
}

func (self *SettingsHandler) UserData() unsafe.Pointer {
	selfArg, selfFin := self.handle()

	defer func() {
		selfFin()
	}()
	return unsafe.Pointer(C.wrap_ImGuiSettingsHandler_GetUserData(selfArg))
}

func (self ShrinkWidthItem) SetIndex(v int32) {
	selfArg, selfFin := self.handle()
	defer selfFin()
	C.wrap_ImGuiShrinkWidthItem_SetIndex(selfArg, C.int(v))
}

func (self *ShrinkWidthItem) Index() int32 {
	selfArg, selfFin := self.handle()

	defer func() {
		selfFin()
	}()
	return int32(C.wrap_ImGuiShrinkWidthItem_GetIndex(selfArg))
}

func (self ShrinkWidthItem) SetWidth(v float32) {
	selfArg, selfFin := self.handle()
	defer selfFin()
	C.wrap_ImGuiShrinkWidthItem_SetWidth(selfArg, C.float(v))
}

func (self *ShrinkWidthItem) Width() float32 {
	selfArg, selfFin := self.handle()

	defer func() {
		selfFin()
	}()
	return float32(C.wrap_ImGuiShrinkWidthItem_GetWidth(selfArg))
}

func (self ShrinkWidthItem) SetInitialWidth(v float32) {
	selfArg, selfFin := self.handle()
	defer selfFin()
	C.wrap_ImGuiShrinkWidthItem_SetInitialWidth(selfArg, C.float(v))
}

func (self *ShrinkWidthItem) InitialWidth() float32 {
	selfArg, selfFin := self.handle()

	defer func() {
		selfFin()
	}()
	return float32(C.wrap_ImGuiShrinkWidthItem_GetInitialWidth(selfArg))
}

func (self SizeCallbackData) SetUserData(v unsafe.Pointer) {
	vArg, _ := WrapVoidPtr(v)

	selfArg, selfFin := self.handle()
	defer selfFin()
	C.wrap_ImGuiSizeCallbackData_SetUserData(selfArg, vArg)
}

func (self *SizeCallbackData) UserData() unsafe.Pointer {
	selfArg, selfFin := self.handle()

	defer func() {
		selfFin()
	}()
	return unsafe.Pointer(C.wrap_ImGuiSizeCallbackData_GetUserData(selfArg))
}

func (self SizeCallbackData) SetPos(v Vec2) {
	selfArg, selfFin := self.handle()
	defer selfFin()
	C.wrap_ImGuiSizeCallbackData_SetPos(selfArg, v.toC())
}

func (self *SizeCallbackData) Pos() Vec2 {
	selfArg, selfFin := self.handle()

	defer func() {
		selfFin()
	}()
	return *(&Vec2{}).fromC(C.wrap_ImGuiSizeCallbackData_GetPos(selfArg))
}

func (self SizeCallbackData) SetCurrentSize(v Vec2) {
	selfArg, selfFin := self.handle()
	defer selfFin()
	C.wrap_ImGuiSizeCallbackData_SetCurrentSize(selfArg, v.toC())
}

func (self *SizeCallbackData) CurrentSize() Vec2 {
	selfArg, selfFin := self.handle()

	defer func() {
		selfFin()
	}()
	return *(&Vec2{}).fromC(C.wrap_ImGuiSizeCallbackData_GetCurrentSize(selfArg))
}

func (self SizeCallbackData) SetDesiredSize(v Vec2) {
	selfArg, selfFin := self.handle()
	defer selfFin()
	C.wrap_ImGuiSizeCallbackData_SetDesiredSize(selfArg, v.toC())
}

func (self *SizeCallbackData) DesiredSize() Vec2 {
	selfArg, selfFin := self.handle()

	defer func() {
		selfFin()
	}()
	return *(&Vec2{}).fromC(C.wrap_ImGuiSizeCallbackData_GetDesiredSize(selfArg))
}

func (self StackLevelInfo) SetID(v ID) {
	vArg, _ := v.c()

	selfArg, selfFin := self.handle()
	defer selfFin()
	C.wrap_ImGuiStackLevelInfo_SetID(selfArg, vArg)
}

func (self *StackLevelInfo) ID() ID {
	selfArg, selfFin := self.handle()

	defer func() {
		selfFin()
	}()

	result := C.wrap_ImGuiStackLevelInfo_GetID(selfArg)
	return *newIDFromC(func() *C.ImGuiID { result := result; return &result }())
}

func (self StackLevelInfo) SetQueryFrameCount(v int) {
	selfArg, selfFin := self.handle()
	defer selfFin()
	C.wrap_ImGuiStackLevelInfo_SetQueryFrameCount(selfArg, C.ImS8(v))
}

func (self *StackLevelInfo) QueryFrameCount() int {
	selfArg, selfFin := self.handle()

	defer func() {
		selfFin()
	}()
	return int(C.wrap_ImGuiStackLevelInfo_GetQueryFrameCount(selfArg))
}

func (self StackLevelInfo) SetQuerySuccess(v bool) {
	selfArg, selfFin := self.handle()
	defer selfFin()
	C.wrap_ImGuiStackLevelInfo_SetQuerySuccess(selfArg, C.bool(v))
}

func (self *StackLevelInfo) QuerySuccess() bool {
	selfArg, selfFin := self.handle()

	defer func() {
		selfFin()
	}()
	return C.wrap_ImGuiStackLevelInfo_GetQuerySuccess(selfArg) == C.bool(true)
}

func (self StackLevelInfo) SetDataType(v DataType) {
	selfArg, selfFin := self.handle()
	defer selfFin()
	C.wrap_ImGuiStackLevelInfo_SetDataType(selfArg, C.ImGuiDataType(v))
}

func (self *StackLevelInfo) DataType() DataType {
	selfArg, selfFin := self.handle()

	defer func() {
		selfFin()
	}()
	return DataType(C.wrap_ImGuiStackLevelInfo_GetDataType(selfArg))
}

func (self StackSizes) SetSizeOfIDStack(v int16) {
	selfArg, selfFin := self.handle()
	defer selfFin()
	C.wrap_ImGuiStackSizes_SetSizeOfIDStack(selfArg, C.short(v))
}

func (self *StackSizes) SizeOfIDStack() int16 {
	selfArg, selfFin := self.handle()

	defer func() {
		selfFin()
	}()
	return int16(C.wrap_ImGuiStackSizes_GetSizeOfIDStack(selfArg))
}

func (self StackSizes) SetSizeOfColorStack(v int16) {
	selfArg, selfFin := self.handle()
	defer selfFin()
	C.wrap_ImGuiStackSizes_SetSizeOfColorStack(selfArg, C.short(v))
}

func (self *StackSizes) SizeOfColorStack() int16 {
	selfArg, selfFin := self.handle()

	defer func() {
		selfFin()
	}()
	return int16(C.wrap_ImGuiStackSizes_GetSizeOfColorStack(selfArg))
}

func (self StackSizes) SetSizeOfStyleVarStack(v int16) {
	selfArg, selfFin := self.handle()
	defer selfFin()
	C.wrap_ImGuiStackSizes_SetSizeOfStyleVarStack(selfArg, C.short(v))
}

func (self *StackSizes) SizeOfStyleVarStack() int16 {
	selfArg, selfFin := self.handle()

	defer func() {
		selfFin()
	}()
	return int16(C.wrap_ImGuiStackSizes_GetSizeOfStyleVarStack(selfArg))
}

func (self StackSizes) SetSizeOfFontStack(v int16) {
	selfArg, selfFin := self.handle()
	defer selfFin()
	C.wrap_ImGuiStackSizes_SetSizeOfFontStack(selfArg, C.short(v))
}

func (self *StackSizes) SizeOfFontStack() int16 {
	selfArg, selfFin := self.handle()

	defer func() {
		selfFin()
	}()
	return int16(C.wrap_ImGuiStackSizes_GetSizeOfFontStack(selfArg))
}

func (self StackSizes) SetSizeOfFocusScopeStack(v int16) {
	selfArg, selfFin := self.handle()
	defer selfFin()
	C.wrap_ImGuiStackSizes_SetSizeOfFocusScopeStack(selfArg, C.short(v))
}

func (self *StackSizes) SizeOfFocusScopeStack() int16 {
	selfArg, selfFin := self.handle()

	defer func() {
		selfFin()
	}()
	return int16(C.wrap_ImGuiStackSizes_GetSizeOfFocusScopeStack(selfArg))
}

func (self StackSizes) SetSizeOfGroupStack(v int16) {
	selfArg, selfFin := self.handle()
	defer selfFin()
	C.wrap_ImGuiStackSizes_SetSizeOfGroupStack(selfArg, C.short(v))
}

func (self *StackSizes) SizeOfGroupStack() int16 {
	selfArg, selfFin := self.handle()

	defer func() {
		selfFin()
	}()
	return int16(C.wrap_ImGuiStackSizes_GetSizeOfGroupStack(selfArg))
}

func (self StackSizes) SetSizeOfItemFlagsStack(v int16) {
	selfArg, selfFin := self.handle()
	defer selfFin()
	C.wrap_ImGuiStackSizes_SetSizeOfItemFlagsStack(selfArg, C.short(v))
}

func (self *StackSizes) SizeOfItemFlagsStack() int16 {
	selfArg, selfFin := self.handle()

	defer func() {
		selfFin()
	}()
	return int16(C.wrap_ImGuiStackSizes_GetSizeOfItemFlagsStack(selfArg))
}

func (self StackSizes) SetSizeOfBeginPopupStack(v int16) {
	selfArg, selfFin := self.handle()
	defer selfFin()
	C.wrap_ImGuiStackSizes_SetSizeOfBeginPopupStack(selfArg, C.short(v))
}

func (self *StackSizes) SizeOfBeginPopupStack() int16 {
	selfArg, selfFin := self.handle()

	defer func() {
		selfFin()
	}()
	return int16(C.wrap_ImGuiStackSizes_GetSizeOfBeginPopupStack(selfArg))
}

func (self StackSizes) SetSizeOfDisabledStack(v int16) {
	selfArg, selfFin := self.handle()
	defer selfFin()
	C.wrap_ImGuiStackSizes_SetSizeOfDisabledStack(selfArg, C.short(v))
}

func (self *StackSizes) SizeOfDisabledStack() int16 {
	selfArg, selfFin := self.handle()

	defer func() {
		selfFin()
	}()
	return int16(C.wrap_ImGuiStackSizes_GetSizeOfDisabledStack(selfArg))
}

func (self StackTool) SetLastActiveFrame(v int32) {
	selfArg, selfFin := self.handle()
	defer selfFin()
	C.wrap_ImGuiStackTool_SetLastActiveFrame(selfArg, C.int(v))
}

func (self *StackTool) LastActiveFrame() int32 {
	selfArg, selfFin := self.handle()

	defer func() {
		selfFin()
	}()
	return int32(C.wrap_ImGuiStackTool_GetLastActiveFrame(selfArg))
}

func (self StackTool) SetStackLevel(v int32) {
	selfArg, selfFin := self.handle()
	defer selfFin()
	C.wrap_ImGuiStackTool_SetStackLevel(selfArg, C.int(v))
}

func (self *StackTool) StackLevel() int32 {
	selfArg, selfFin := self.handle()

	defer func() {
		selfFin()
	}()
	return int32(C.wrap_ImGuiStackTool_GetStackLevel(selfArg))
}

func (self StackTool) SetQueryId(v ID) {
	vArg, _ := v.c()

	selfArg, selfFin := self.handle()
	defer selfFin()
	C.wrap_ImGuiStackTool_SetQueryId(selfArg, vArg)
}

func (self *StackTool) QueryId() ID {
	selfArg, selfFin := self.handle()

	defer func() {
		selfFin()
	}()

	result := C.wrap_ImGuiStackTool_GetQueryId(selfArg)
	return *newIDFromC(func() *C.ImGuiID { result := result; return &result }())
}

func (self StackTool) SetResults(v Vector[*StackLevelInfo]) {
	vData := v.Data
	vDataArg, _ := vData.handle()
	vVecArg := new(C.ImVector_ImGuiStackLevelInfo)
	vVecArg.Size = C.int(v.Size)
	vVecArg.Capacity = C.int(v.Capacity)
	vVecArg.Data = vDataArg
	v.pinner.Pin(vVecArg.Data)

	selfArg, selfFin := self.handle()
	defer selfFin()
	C.wrap_ImGuiStackTool_SetResults(selfArg, *vVecArg)
}

func (self *StackTool) Results() Vector[*StackLevelInfo] {
	selfArg, selfFin := self.handle()

	defer func() {
		selfFin()
	}()
	return newVectorFromC(C.wrap_ImGuiStackTool_GetResults(selfArg).Size, C.wrap_ImGuiStackTool_GetResults(selfArg).Capacity, newStackLevelInfoFromC(C.wrap_ImGuiStackTool_GetResults(selfArg).Data))
}

func (self StackTool) SetCopyToClipboardOnCtrlC(v bool) {
	selfArg, selfFin := self.handle()
	defer selfFin()
	C.wrap_ImGuiStackTool_SetCopyToClipboardOnCtrlC(selfArg, C.bool(v))
}

func (self *StackTool) CopyToClipboardOnCtrlC() bool {
	selfArg, selfFin := self.handle()

	defer func() {
		selfFin()
	}()
	return C.wrap_ImGuiStackTool_GetCopyToClipboardOnCtrlC(selfArg) == C.bool(true)
}

func (self StackTool) SetCopyToClipboardLastTime(v float32) {
	selfArg, selfFin := self.handle()
	defer selfFin()
	C.wrap_ImGuiStackTool_SetCopyToClipboardLastTime(selfArg, C.float(v))
}

func (self *StackTool) CopyToClipboardLastTime() float32 {
	selfArg, selfFin := self.handle()

	defer func() {
		selfFin()
	}()
	return float32(C.wrap_ImGuiStackTool_GetCopyToClipboardLastTime(selfArg))
}

func (self Storage) SetData(v Vector[*StoragePair]) {
	vData := v.Data
	vDataArg, _ := vData.handle()
	vVecArg := new(C.ImVector_ImGuiStoragePair)
	vVecArg.Size = C.int(v.Size)
	vVecArg.Capacity = C.int(v.Capacity)
	vVecArg.Data = vDataArg
	v.pinner.Pin(vVecArg.Data)

	selfArg, selfFin := self.handle()
	defer selfFin()
	C.wrap_ImGuiStorage_SetData(selfArg, *vVecArg)
}

func (self *Storage) Data() Vector[*StoragePair] {
	selfArg, selfFin := self.handle()

	defer func() {
		selfFin()
	}()
	return newVectorFromC(C.wrap_ImGuiStorage_GetData(selfArg).Size, C.wrap_ImGuiStorage_GetData(selfArg).Capacity, newStoragePairFromC(C.wrap_ImGuiStorage_GetData(selfArg).Data))
}

func (self StoragePair) SetKey(v ID) {
	vArg, _ := v.c()

	selfArg, selfFin := self.handle()
	defer selfFin()
	C.wrap_ImGuiStoragePair_SetKey(selfArg, vArg)
}

func (self *StoragePair) Key() ID {
	selfArg, selfFin := self.handle()

	defer func() {
		selfFin()
	}()

	result := C.wrap_ImGuiStoragePair_GetKey(selfArg)
	return *newIDFromC(func() *C.ImGuiID { result := result; return &result }())
}

func (self Style) SetAlpha(v float32) {
	selfArg, selfFin := self.handle()
	defer selfFin()
	C.wrap_ImGuiStyle_SetAlpha(selfArg, C.float(v))
}

func (self *Style) Alpha() float32 {
	selfArg, selfFin := self.handle()

	defer func() {
		selfFin()
	}()
	return float32(C.wrap_ImGuiStyle_GetAlpha(selfArg))
}

func (self Style) SetDisabledAlpha(v float32) {
	selfArg, selfFin := self.handle()
	defer selfFin()
	C.wrap_ImGuiStyle_SetDisabledAlpha(selfArg, C.float(v))
}

func (self *Style) DisabledAlpha() float32 {
	selfArg, selfFin := self.handle()

	defer func() {
		selfFin()
	}()
	return float32(C.wrap_ImGuiStyle_GetDisabledAlpha(selfArg))
}

func (self Style) SetWindowPadding(v Vec2) {
	selfArg, selfFin := self.handle()
	defer selfFin()
	C.wrap_ImGuiStyle_SetWindowPadding(selfArg, v.toC())
}

func (self *Style) WindowPadding() Vec2 {
	selfArg, selfFin := self.handle()

	defer func() {
		selfFin()
	}()
	return *(&Vec2{}).fromC(C.wrap_ImGuiStyle_GetWindowPadding(selfArg))
}

func (self Style) SetWindowRounding(v float32) {
	selfArg, selfFin := self.handle()
	defer selfFin()
	C.wrap_ImGuiStyle_SetWindowRounding(selfArg, C.float(v))
}

func (self *Style) WindowRounding() float32 {
	selfArg, selfFin := self.handle()

	defer func() {
		selfFin()
	}()
	return float32(C.wrap_ImGuiStyle_GetWindowRounding(selfArg))
}

func (self Style) SetWindowBorderSize(v float32) {
	selfArg, selfFin := self.handle()
	defer selfFin()
	C.wrap_ImGuiStyle_SetWindowBorderSize(selfArg, C.float(v))
}

func (self *Style) WindowBorderSize() float32 {
	selfArg, selfFin := self.handle()

	defer func() {
		selfFin()
	}()
	return float32(C.wrap_ImGuiStyle_GetWindowBorderSize(selfArg))
}

func (self Style) SetWindowMinSize(v Vec2) {
	selfArg, selfFin := self.handle()
	defer selfFin()
	C.wrap_ImGuiStyle_SetWindowMinSize(selfArg, v.toC())
}

func (self *Style) WindowMinSize() Vec2 {
	selfArg, selfFin := self.handle()

	defer func() {
		selfFin()
	}()
	return *(&Vec2{}).fromC(C.wrap_ImGuiStyle_GetWindowMinSize(selfArg))
}

func (self Style) SetWindowTitleAlign(v Vec2) {
	selfArg, selfFin := self.handle()
	defer selfFin()
	C.wrap_ImGuiStyle_SetWindowTitleAlign(selfArg, v.toC())
}

func (self *Style) WindowTitleAlign() Vec2 {
	selfArg, selfFin := self.handle()

	defer func() {
		selfFin()
	}()
	return *(&Vec2{}).fromC(C.wrap_ImGuiStyle_GetWindowTitleAlign(selfArg))
}

func (self Style) SetWindowMenuButtonPosition(v Dir) {
	selfArg, selfFin := self.handle()
	defer selfFin()
	C.wrap_ImGuiStyle_SetWindowMenuButtonPosition(selfArg, C.ImGuiDir(v))
}

func (self *Style) WindowMenuButtonPosition() Dir {
	selfArg, selfFin := self.handle()

	defer func() {
		selfFin()
	}()
	return Dir(C.wrap_ImGuiStyle_GetWindowMenuButtonPosition(selfArg))
}

func (self Style) SetChildRounding(v float32) {
	selfArg, selfFin := self.handle()
	defer selfFin()
	C.wrap_ImGuiStyle_SetChildRounding(selfArg, C.float(v))
}

func (self *Style) ChildRounding() float32 {
	selfArg, selfFin := self.handle()

	defer func() {
		selfFin()
	}()
	return float32(C.wrap_ImGuiStyle_GetChildRounding(selfArg))
}

func (self Style) SetChildBorderSize(v float32) {
	selfArg, selfFin := self.handle()
	defer selfFin()
	C.wrap_ImGuiStyle_SetChildBorderSize(selfArg, C.float(v))
}

func (self *Style) ChildBorderSize() float32 {
	selfArg, selfFin := self.handle()

	defer func() {
		selfFin()
	}()
	return float32(C.wrap_ImGuiStyle_GetChildBorderSize(selfArg))
}

func (self Style) SetPopupRounding(v float32) {
	selfArg, selfFin := self.handle()
	defer selfFin()
	C.wrap_ImGuiStyle_SetPopupRounding(selfArg, C.float(v))
}

func (self *Style) PopupRounding() float32 {
	selfArg, selfFin := self.handle()

	defer func() {
		selfFin()
	}()
	return float32(C.wrap_ImGuiStyle_GetPopupRounding(selfArg))
}

func (self Style) SetPopupBorderSize(v float32) {
	selfArg, selfFin := self.handle()
	defer selfFin()
	C.wrap_ImGuiStyle_SetPopupBorderSize(selfArg, C.float(v))
}

func (self *Style) PopupBorderSize() float32 {
	selfArg, selfFin := self.handle()

	defer func() {
		selfFin()
	}()
	return float32(C.wrap_ImGuiStyle_GetPopupBorderSize(selfArg))
}

func (self Style) SetFramePadding(v Vec2) {
	selfArg, selfFin := self.handle()
	defer selfFin()
	C.wrap_ImGuiStyle_SetFramePadding(selfArg, v.toC())
}

func (self *Style) FramePadding() Vec2 {
	selfArg, selfFin := self.handle()

	defer func() {
		selfFin()
	}()
	return *(&Vec2{}).fromC(C.wrap_ImGuiStyle_GetFramePadding(selfArg))
}

func (self Style) SetFrameRounding(v float32) {
	selfArg, selfFin := self.handle()
	defer selfFin()
	C.wrap_ImGuiStyle_SetFrameRounding(selfArg, C.float(v))
}

func (self *Style) FrameRounding() float32 {
	selfArg, selfFin := self.handle()

	defer func() {
		selfFin()
	}()
	return float32(C.wrap_ImGuiStyle_GetFrameRounding(selfArg))
}

func (self Style) SetFrameBorderSize(v float32) {
	selfArg, selfFin := self.handle()
	defer selfFin()
	C.wrap_ImGuiStyle_SetFrameBorderSize(selfArg, C.float(v))
}

func (self *Style) FrameBorderSize() float32 {
	selfArg, selfFin := self.handle()

	defer func() {
		selfFin()
	}()
	return float32(C.wrap_ImGuiStyle_GetFrameBorderSize(selfArg))
}

func (self Style) SetItemSpacing(v Vec2) {
	selfArg, selfFin := self.handle()
	defer selfFin()
	C.wrap_ImGuiStyle_SetItemSpacing(selfArg, v.toC())
}

func (self *Style) ItemSpacing() Vec2 {
	selfArg, selfFin := self.handle()

	defer func() {
		selfFin()
	}()
	return *(&Vec2{}).fromC(C.wrap_ImGuiStyle_GetItemSpacing(selfArg))
}

func (self Style) SetItemInnerSpacing(v Vec2) {
	selfArg, selfFin := self.handle()
	defer selfFin()
	C.wrap_ImGuiStyle_SetItemInnerSpacing(selfArg, v.toC())
}

func (self *Style) ItemInnerSpacing() Vec2 {
	selfArg, selfFin := self.handle()

	defer func() {
		selfFin()
	}()
	return *(&Vec2{}).fromC(C.wrap_ImGuiStyle_GetItemInnerSpacing(selfArg))
}

func (self Style) SetCellPadding(v Vec2) {
	selfArg, selfFin := self.handle()
	defer selfFin()
	C.wrap_ImGuiStyle_SetCellPadding(selfArg, v.toC())
}

func (self *Style) CellPadding() Vec2 {
	selfArg, selfFin := self.handle()

	defer func() {
		selfFin()
	}()
	return *(&Vec2{}).fromC(C.wrap_ImGuiStyle_GetCellPadding(selfArg))
}

func (self Style) SetTouchExtraPadding(v Vec2) {
	selfArg, selfFin := self.handle()
	defer selfFin()
	C.wrap_ImGuiStyle_SetTouchExtraPadding(selfArg, v.toC())
}

func (self *Style) TouchExtraPadding() Vec2 {
	selfArg, selfFin := self.handle()

	defer func() {
		selfFin()
	}()
	return *(&Vec2{}).fromC(C.wrap_ImGuiStyle_GetTouchExtraPadding(selfArg))
}

func (self Style) SetIndentSpacing(v float32) {
	selfArg, selfFin := self.handle()
	defer selfFin()
	C.wrap_ImGuiStyle_SetIndentSpacing(selfArg, C.float(v))
}

func (self *Style) IndentSpacing() float32 {
	selfArg, selfFin := self.handle()

	defer func() {
		selfFin()
	}()
	return float32(C.wrap_ImGuiStyle_GetIndentSpacing(selfArg))
}

func (self Style) SetColumnsMinSpacing(v float32) {
	selfArg, selfFin := self.handle()
	defer selfFin()
	C.wrap_ImGuiStyle_SetColumnsMinSpacing(selfArg, C.float(v))
}

func (self *Style) ColumnsMinSpacing() float32 {
	selfArg, selfFin := self.handle()

	defer func() {
		selfFin()
	}()
	return float32(C.wrap_ImGuiStyle_GetColumnsMinSpacing(selfArg))
}

func (self Style) SetScrollbarSize(v float32) {
	selfArg, selfFin := self.handle()
	defer selfFin()
	C.wrap_ImGuiStyle_SetScrollbarSize(selfArg, C.float(v))
}

func (self *Style) ScrollbarSize() float32 {
	selfArg, selfFin := self.handle()

	defer func() {
		selfFin()
	}()
	return float32(C.wrap_ImGuiStyle_GetScrollbarSize(selfArg))
}

func (self Style) SetScrollbarRounding(v float32) {
	selfArg, selfFin := self.handle()
	defer selfFin()
	C.wrap_ImGuiStyle_SetScrollbarRounding(selfArg, C.float(v))
}

func (self *Style) ScrollbarRounding() float32 {
	selfArg, selfFin := self.handle()

	defer func() {
		selfFin()
	}()
	return float32(C.wrap_ImGuiStyle_GetScrollbarRounding(selfArg))
}

func (self Style) SetGrabMinSize(v float32) {
	selfArg, selfFin := self.handle()
	defer selfFin()
	C.wrap_ImGuiStyle_SetGrabMinSize(selfArg, C.float(v))
}

func (self *Style) GrabMinSize() float32 {
	selfArg, selfFin := self.handle()

	defer func() {
		selfFin()
	}()
	return float32(C.wrap_ImGuiStyle_GetGrabMinSize(selfArg))
}

func (self Style) SetGrabRounding(v float32) {
	selfArg, selfFin := self.handle()
	defer selfFin()
	C.wrap_ImGuiStyle_SetGrabRounding(selfArg, C.float(v))
}

func (self *Style) GrabRounding() float32 {
	selfArg, selfFin := self.handle()

	defer func() {
		selfFin()
	}()
	return float32(C.wrap_ImGuiStyle_GetGrabRounding(selfArg))
}

func (self Style) SetLogSliderDeadzone(v float32) {
	selfArg, selfFin := self.handle()
	defer selfFin()
	C.wrap_ImGuiStyle_SetLogSliderDeadzone(selfArg, C.float(v))
}

func (self *Style) LogSliderDeadzone() float32 {
	selfArg, selfFin := self.handle()

	defer func() {
		selfFin()
	}()
	return float32(C.wrap_ImGuiStyle_GetLogSliderDeadzone(selfArg))
}

func (self Style) SetTabRounding(v float32) {
	selfArg, selfFin := self.handle()
	defer selfFin()
	C.wrap_ImGuiStyle_SetTabRounding(selfArg, C.float(v))
}

func (self *Style) TabRounding() float32 {
	selfArg, selfFin := self.handle()

	defer func() {
		selfFin()
	}()
	return float32(C.wrap_ImGuiStyle_GetTabRounding(selfArg))
}

func (self Style) SetTabBorderSize(v float32) {
	selfArg, selfFin := self.handle()
	defer selfFin()
	C.wrap_ImGuiStyle_SetTabBorderSize(selfArg, C.float(v))
}

func (self *Style) TabBorderSize() float32 {
	selfArg, selfFin := self.handle()

	defer func() {
		selfFin()
	}()
	return float32(C.wrap_ImGuiStyle_GetTabBorderSize(selfArg))
}

func (self Style) SetTabMinWidthForCloseButton(v float32) {
	selfArg, selfFin := self.handle()
	defer selfFin()
	C.wrap_ImGuiStyle_SetTabMinWidthForCloseButton(selfArg, C.float(v))
}

func (self *Style) TabMinWidthForCloseButton() float32 {
	selfArg, selfFin := self.handle()

	defer func() {
		selfFin()
	}()
	return float32(C.wrap_ImGuiStyle_GetTabMinWidthForCloseButton(selfArg))
}

func (self Style) SetTabBarBorderSize(v float32) {
	selfArg, selfFin := self.handle()
	defer selfFin()
	C.wrap_ImGuiStyle_SetTabBarBorderSize(selfArg, C.float(v))
}

func (self *Style) TabBarBorderSize() float32 {
	selfArg, selfFin := self.handle()

	defer func() {
		selfFin()
	}()
	return float32(C.wrap_ImGuiStyle_GetTabBarBorderSize(selfArg))
}

func (self Style) SetColorButtonPosition(v Dir) {
	selfArg, selfFin := self.handle()
	defer selfFin()
	C.wrap_ImGuiStyle_SetColorButtonPosition(selfArg, C.ImGuiDir(v))
}

func (self *Style) ColorButtonPosition() Dir {
	selfArg, selfFin := self.handle()

	defer func() {
		selfFin()
	}()
	return Dir(C.wrap_ImGuiStyle_GetColorButtonPosition(selfArg))
}

func (self Style) SetButtonTextAlign(v Vec2) {
	selfArg, selfFin := self.handle()
	defer selfFin()
	C.wrap_ImGuiStyle_SetButtonTextAlign(selfArg, v.toC())
}

func (self *Style) ButtonTextAlign() Vec2 {
	selfArg, selfFin := self.handle()

	defer func() {
		selfFin()
	}()
	return *(&Vec2{}).fromC(C.wrap_ImGuiStyle_GetButtonTextAlign(selfArg))
}

func (self Style) SetSelectableTextAlign(v Vec2) {
	selfArg, selfFin := self.handle()
	defer selfFin()
	C.wrap_ImGuiStyle_SetSelectableTextAlign(selfArg, v.toC())
}

func (self *Style) SelectableTextAlign() Vec2 {
	selfArg, selfFin := self.handle()

	defer func() {
		selfFin()
	}()
	return *(&Vec2{}).fromC(C.wrap_ImGuiStyle_GetSelectableTextAlign(selfArg))
}

func (self Style) SetSeparatorTextBorderSize(v float32) {
	selfArg, selfFin := self.handle()
	defer selfFin()
	C.wrap_ImGuiStyle_SetSeparatorTextBorderSize(selfArg, C.float(v))
}

func (self *Style) SeparatorTextBorderSize() float32 {
	selfArg, selfFin := self.handle()

	defer func() {
		selfFin()
	}()
	return float32(C.wrap_ImGuiStyle_GetSeparatorTextBorderSize(selfArg))
}

func (self Style) SetSeparatorTextAlign(v Vec2) {
	selfArg, selfFin := self.handle()
	defer selfFin()
	C.wrap_ImGuiStyle_SetSeparatorTextAlign(selfArg, v.toC())
}

func (self *Style) SeparatorTextAlign() Vec2 {
	selfArg, selfFin := self.handle()

	defer func() {
		selfFin()
	}()
	return *(&Vec2{}).fromC(C.wrap_ImGuiStyle_GetSeparatorTextAlign(selfArg))
}

func (self Style) SetSeparatorTextPadding(v Vec2) {
	selfArg, selfFin := self.handle()
	defer selfFin()
	C.wrap_ImGuiStyle_SetSeparatorTextPadding(selfArg, v.toC())
}

func (self *Style) SeparatorTextPadding() Vec2 {
	selfArg, selfFin := self.handle()

	defer func() {
		selfFin()
	}()
	return *(&Vec2{}).fromC(C.wrap_ImGuiStyle_GetSeparatorTextPadding(selfArg))
}

func (self Style) SetDisplayWindowPadding(v Vec2) {
	selfArg, selfFin := self.handle()
	defer selfFin()
	C.wrap_ImGuiStyle_SetDisplayWindowPadding(selfArg, v.toC())
}

func (self *Style) DisplayWindowPadding() Vec2 {
	selfArg, selfFin := self.handle()

	defer func() {
		selfFin()
	}()
	return *(&Vec2{}).fromC(C.wrap_ImGuiStyle_GetDisplayWindowPadding(selfArg))
}

func (self Style) SetDisplaySafeAreaPadding(v Vec2) {
	selfArg, selfFin := self.handle()
	defer selfFin()
	C.wrap_ImGuiStyle_SetDisplaySafeAreaPadding(selfArg, v.toC())
}

func (self *Style) DisplaySafeAreaPadding() Vec2 {
	selfArg, selfFin := self.handle()

	defer func() {
		selfFin()
	}()
	return *(&Vec2{}).fromC(C.wrap_ImGuiStyle_GetDisplaySafeAreaPadding(selfArg))
}

func (self Style) SetDockingSeparatorSize(v float32) {
	selfArg, selfFin := self.handle()
	defer selfFin()
	C.wrap_ImGuiStyle_SetDockingSeparatorSize(selfArg, C.float(v))
}

func (self *Style) DockingSeparatorSize() float32 {
	selfArg, selfFin := self.handle()

	defer func() {
		selfFin()
	}()
	return float32(C.wrap_ImGuiStyle_GetDockingSeparatorSize(selfArg))
}

func (self Style) SetMouseCursorScale(v float32) {
	selfArg, selfFin := self.handle()
	defer selfFin()
	C.wrap_ImGuiStyle_SetMouseCursorScale(selfArg, C.float(v))
}

func (self *Style) MouseCursorScale() float32 {
	selfArg, selfFin := self.handle()

	defer func() {
		selfFin()
	}()
	return float32(C.wrap_ImGuiStyle_GetMouseCursorScale(selfArg))
}

func (self Style) SetAntiAliasedLines(v bool) {
	selfArg, selfFin := self.handle()
	defer selfFin()
	C.wrap_ImGuiStyle_SetAntiAliasedLines(selfArg, C.bool(v))
}

func (self *Style) AntiAliasedLines() bool {
	selfArg, selfFin := self.handle()

	defer func() {
		selfFin()
	}()
	return C.wrap_ImGuiStyle_GetAntiAliasedLines(selfArg) == C.bool(true)
}

func (self Style) SetAntiAliasedLinesUseTex(v bool) {
	selfArg, selfFin := self.handle()
	defer selfFin()
	C.wrap_ImGuiStyle_SetAntiAliasedLinesUseTex(selfArg, C.bool(v))
}

func (self *Style) AntiAliasedLinesUseTex() bool {
	selfArg, selfFin := self.handle()

	defer func() {
		selfFin()
	}()
	return C.wrap_ImGuiStyle_GetAntiAliasedLinesUseTex(selfArg) == C.bool(true)
}

func (self Style) SetAntiAliasedFill(v bool) {
	selfArg, selfFin := self.handle()
	defer selfFin()
	C.wrap_ImGuiStyle_SetAntiAliasedFill(selfArg, C.bool(v))
}

func (self *Style) AntiAliasedFill() bool {
	selfArg, selfFin := self.handle()

	defer func() {
		selfFin()
	}()
	return C.wrap_ImGuiStyle_GetAntiAliasedFill(selfArg) == C.bool(true)
}

func (self Style) SetCurveTessellationTol(v float32) {
	selfArg, selfFin := self.handle()
	defer selfFin()
	C.wrap_ImGuiStyle_SetCurveTessellationTol(selfArg, C.float(v))
}

func (self *Style) CurveTessellationTol() float32 {
	selfArg, selfFin := self.handle()

	defer func() {
		selfFin()
	}()
	return float32(C.wrap_ImGuiStyle_GetCurveTessellationTol(selfArg))
}

func (self Style) SetCircleTessellationMaxError(v float32) {
	selfArg, selfFin := self.handle()
	defer selfFin()
	C.wrap_ImGuiStyle_SetCircleTessellationMaxError(selfArg, C.float(v))
}

func (self *Style) CircleTessellationMaxError() float32 {
	selfArg, selfFin := self.handle()

	defer func() {
		selfFin()
	}()
	return float32(C.wrap_ImGuiStyle_GetCircleTessellationMaxError(selfArg))
}

func (self Style) SetHoverStationaryDelay(v float32) {
	selfArg, selfFin := self.handle()
	defer selfFin()
	C.wrap_ImGuiStyle_SetHoverStationaryDelay(selfArg, C.float(v))
}

func (self *Style) HoverStationaryDelay() float32 {
	selfArg, selfFin := self.handle()

	defer func() {
		selfFin()
	}()
	return float32(C.wrap_ImGuiStyle_GetHoverStationaryDelay(selfArg))
}

func (self Style) SetHoverDelayShort(v float32) {
	selfArg, selfFin := self.handle()
	defer selfFin()
	C.wrap_ImGuiStyle_SetHoverDelayShort(selfArg, C.float(v))
}

func (self *Style) HoverDelayShort() float32 {
	selfArg, selfFin := self.handle()

	defer func() {
		selfFin()
	}()
	return float32(C.wrap_ImGuiStyle_GetHoverDelayShort(selfArg))
}

func (self Style) SetHoverDelayNormal(v float32) {
	selfArg, selfFin := self.handle()
	defer selfFin()
	C.wrap_ImGuiStyle_SetHoverDelayNormal(selfArg, C.float(v))
}

func (self *Style) HoverDelayNormal() float32 {
	selfArg, selfFin := self.handle()

	defer func() {
		selfFin()
	}()
	return float32(C.wrap_ImGuiStyle_GetHoverDelayNormal(selfArg))
}

func (self Style) SetHoverFlagsForTooltipMouse(v HoveredFlags) {
	selfArg, selfFin := self.handle()
	defer selfFin()
	C.wrap_ImGuiStyle_SetHoverFlagsForTooltipMouse(selfArg, C.ImGuiHoveredFlags(v))
}

func (self *Style) HoverFlagsForTooltipMouse() HoveredFlags {
	selfArg, selfFin := self.handle()

	defer func() {
		selfFin()
	}()
	return HoveredFlags(C.wrap_ImGuiStyle_GetHoverFlagsForTooltipMouse(selfArg))
}

func (self Style) SetHoverFlagsForTooltipNav(v HoveredFlags) {
	selfArg, selfFin := self.handle()
	defer selfFin()
	C.wrap_ImGuiStyle_SetHoverFlagsForTooltipNav(selfArg, C.ImGuiHoveredFlags(v))
}

func (self *Style) HoverFlagsForTooltipNav() HoveredFlags {
	selfArg, selfFin := self.handle()

	defer func() {
		selfFin()
	}()
	return HoveredFlags(C.wrap_ImGuiStyle_GetHoverFlagsForTooltipNav(selfArg))
}

func (self StyleMod) SetVarIdx(v StyleVar) {
	selfArg, selfFin := self.handle()
	defer selfFin()
	C.wrap_ImGuiStyleMod_SetVarIdx(selfArg, C.ImGuiStyleVar(v))
}

func (self *StyleMod) VarIdx() StyleVar {
	selfArg, selfFin := self.handle()

	defer func() {
		selfFin()
	}()
	return StyleVar(C.wrap_ImGuiStyleMod_GetVarIdx(selfArg))
}

func (self TabBar) SetTabs(v Vector[*TabItem]) {
	vData := v.Data
	vDataArg, _ := vData.handle()
	vVecArg := new(C.ImVector_ImGuiTabItem)
	vVecArg.Size = C.int(v.Size)
	vVecArg.Capacity = C.int(v.Capacity)
	vVecArg.Data = vDataArg
	v.pinner.Pin(vVecArg.Data)

	selfArg, selfFin := self.handle()
	defer selfFin()
	C.wrap_ImGuiTabBar_SetTabs(selfArg, *vVecArg)
}

func (self *TabBar) Tabs() Vector[*TabItem] {
	selfArg, selfFin := self.handle()

	defer func() {
		selfFin()
	}()
	return newVectorFromC(C.wrap_ImGuiTabBar_GetTabs(selfArg).Size, C.wrap_ImGuiTabBar_GetTabs(selfArg).Capacity, newTabItemFromC(C.wrap_ImGuiTabBar_GetTabs(selfArg).Data))
}

func (self TabBar) SetFlags(v TabBarFlags) {
	selfArg, selfFin := self.handle()
	defer selfFin()
	C.wrap_ImGuiTabBar_SetFlags(selfArg, C.ImGuiTabBarFlags(v))
}

func (self *TabBar) Flags() TabBarFlags {
	selfArg, selfFin := self.handle()

	defer func() {
		selfFin()
	}()
	return TabBarFlags(C.wrap_ImGuiTabBar_GetFlags(selfArg))
}

func (self TabBar) SetID(v ID) {
	vArg, _ := v.c()

	selfArg, selfFin := self.handle()
	defer selfFin()
	C.wrap_ImGuiTabBar_SetID(selfArg, vArg)
}

func (self *TabBar) ID() ID {
	selfArg, selfFin := self.handle()

	defer func() {
		selfFin()
	}()

	result := C.wrap_ImGuiTabBar_GetID(selfArg)
	return *newIDFromC(func() *C.ImGuiID { result := result; return &result }())
}

func (self TabBar) SetSelectedTabId(v ID) {
	vArg, _ := v.c()

	selfArg, selfFin := self.handle()
	defer selfFin()
	C.wrap_ImGuiTabBar_SetSelectedTabId(selfArg, vArg)
}

func (self *TabBar) SelectedTabId() ID {
	selfArg, selfFin := self.handle()

	defer func() {
		selfFin()
	}()

	result := C.wrap_ImGuiTabBar_GetSelectedTabId(selfArg)
	return *newIDFromC(func() *C.ImGuiID { result := result; return &result }())
}

func (self TabBar) SetNextSelectedTabId(v ID) {
	vArg, _ := v.c()

	selfArg, selfFin := self.handle()
	defer selfFin()
	C.wrap_ImGuiTabBar_SetNextSelectedTabId(selfArg, vArg)
}

func (self *TabBar) NextSelectedTabId() ID {
	selfArg, selfFin := self.handle()

	defer func() {
		selfFin()
	}()

	result := C.wrap_ImGuiTabBar_GetNextSelectedTabId(selfArg)
	return *newIDFromC(func() *C.ImGuiID { result := result; return &result }())
}

func (self TabBar) SetVisibleTabId(v ID) {
	vArg, _ := v.c()

	selfArg, selfFin := self.handle()
	defer selfFin()
	C.wrap_ImGuiTabBar_SetVisibleTabId(selfArg, vArg)
}

func (self *TabBar) VisibleTabId() ID {
	selfArg, selfFin := self.handle()

	defer func() {
		selfFin()
	}()

	result := C.wrap_ImGuiTabBar_GetVisibleTabId(selfArg)
	return *newIDFromC(func() *C.ImGuiID { result := result; return &result }())
}

func (self TabBar) SetCurrFrameVisible(v int32) {
	selfArg, selfFin := self.handle()
	defer selfFin()
	C.wrap_ImGuiTabBar_SetCurrFrameVisible(selfArg, C.int(v))
}

func (self *TabBar) CurrFrameVisible() int32 {
	selfArg, selfFin := self.handle()

	defer func() {
		selfFin()
	}()
	return int32(C.wrap_ImGuiTabBar_GetCurrFrameVisible(selfArg))
}

func (self TabBar) SetPrevFrameVisible(v int32) {
	selfArg, selfFin := self.handle()
	defer selfFin()
	C.wrap_ImGuiTabBar_SetPrevFrameVisible(selfArg, C.int(v))
}

func (self *TabBar) PrevFrameVisible() int32 {
	selfArg, selfFin := self.handle()

	defer func() {
		selfFin()
	}()
	return int32(C.wrap_ImGuiTabBar_GetPrevFrameVisible(selfArg))
}

func (self TabBar) SetBarRect(v Rect) {
	selfArg, selfFin := self.handle()
	defer selfFin()
	C.wrap_ImGuiTabBar_SetBarRect(selfArg, v.toC())
}

func (self *TabBar) BarRect() Rect {
	selfArg, selfFin := self.handle()

	defer func() {
		selfFin()
	}()
	return *(&Rect{}).fromC(C.wrap_ImGuiTabBar_GetBarRect(selfArg))
}

func (self TabBar) SetCurrTabsContentsHeight(v float32) {
	selfArg, selfFin := self.handle()
	defer selfFin()
	C.wrap_ImGuiTabBar_SetCurrTabsContentsHeight(selfArg, C.float(v))
}

func (self *TabBar) CurrTabsContentsHeight() float32 {
	selfArg, selfFin := self.handle()

	defer func() {
		selfFin()
	}()
	return float32(C.wrap_ImGuiTabBar_GetCurrTabsContentsHeight(selfArg))
}

func (self TabBar) SetPrevTabsContentsHeight(v float32) {
	selfArg, selfFin := self.handle()
	defer selfFin()
	C.wrap_ImGuiTabBar_SetPrevTabsContentsHeight(selfArg, C.float(v))
}

func (self *TabBar) PrevTabsContentsHeight() float32 {
	selfArg, selfFin := self.handle()

	defer func() {
		selfFin()
	}()
	return float32(C.wrap_ImGuiTabBar_GetPrevTabsContentsHeight(selfArg))
}

func (self TabBar) SetWidthAllTabs(v float32) {
	selfArg, selfFin := self.handle()
	defer selfFin()
	C.wrap_ImGuiTabBar_SetWidthAllTabs(selfArg, C.float(v))
}

func (self *TabBar) WidthAllTabs() float32 {
	selfArg, selfFin := self.handle()

	defer func() {
		selfFin()
	}()
	return float32(C.wrap_ImGuiTabBar_GetWidthAllTabs(selfArg))
}

func (self TabBar) SetWidthAllTabsIdeal(v float32) {
	selfArg, selfFin := self.handle()
	defer selfFin()
	C.wrap_ImGuiTabBar_SetWidthAllTabsIdeal(selfArg, C.float(v))
}

func (self *TabBar) WidthAllTabsIdeal() float32 {
	selfArg, selfFin := self.handle()

	defer func() {
		selfFin()
	}()
	return float32(C.wrap_ImGuiTabBar_GetWidthAllTabsIdeal(selfArg))
}

func (self TabBar) SetScrollingAnim(v float32) {
	selfArg, selfFin := self.handle()
	defer selfFin()
	C.wrap_ImGuiTabBar_SetScrollingAnim(selfArg, C.float(v))
}

func (self *TabBar) ScrollingAnim() float32 {
	selfArg, selfFin := self.handle()

	defer func() {
		selfFin()
	}()
	return float32(C.wrap_ImGuiTabBar_GetScrollingAnim(selfArg))
}

func (self TabBar) SetScrollingTarget(v float32) {
	selfArg, selfFin := self.handle()
	defer selfFin()
	C.wrap_ImGuiTabBar_SetScrollingTarget(selfArg, C.float(v))
}

func (self *TabBar) ScrollingTarget() float32 {
	selfArg, selfFin := self.handle()

	defer func() {
		selfFin()
	}()
	return float32(C.wrap_ImGuiTabBar_GetScrollingTarget(selfArg))
}

func (self TabBar) SetScrollingTargetDistToVisibility(v float32) {
	selfArg, selfFin := self.handle()
	defer selfFin()
	C.wrap_ImGuiTabBar_SetScrollingTargetDistToVisibility(selfArg, C.float(v))
}

func (self *TabBar) ScrollingTargetDistToVisibility() float32 {
	selfArg, selfFin := self.handle()

	defer func() {
		selfFin()
	}()
	return float32(C.wrap_ImGuiTabBar_GetScrollingTargetDistToVisibility(selfArg))
}

func (self TabBar) SetScrollingSpeed(v float32) {
	selfArg, selfFin := self.handle()
	defer selfFin()
	C.wrap_ImGuiTabBar_SetScrollingSpeed(selfArg, C.float(v))
}

func (self *TabBar) ScrollingSpeed() float32 {
	selfArg, selfFin := self.handle()

	defer func() {
		selfFin()
	}()
	return float32(C.wrap_ImGuiTabBar_GetScrollingSpeed(selfArg))
}

func (self TabBar) SetScrollingRectMinX(v float32) {
	selfArg, selfFin := self.handle()
	defer selfFin()
	C.wrap_ImGuiTabBar_SetScrollingRectMinX(selfArg, C.float(v))
}

func (self *TabBar) ScrollingRectMinX() float32 {
	selfArg, selfFin := self.handle()

	defer func() {
		selfFin()
	}()
	return float32(C.wrap_ImGuiTabBar_GetScrollingRectMinX(selfArg))
}

func (self TabBar) SetScrollingRectMaxX(v float32) {
	selfArg, selfFin := self.handle()
	defer selfFin()
	C.wrap_ImGuiTabBar_SetScrollingRectMaxX(selfArg, C.float(v))
}

func (self *TabBar) ScrollingRectMaxX() float32 {
	selfArg, selfFin := self.handle()

	defer func() {
		selfFin()
	}()
	return float32(C.wrap_ImGuiTabBar_GetScrollingRectMaxX(selfArg))
}

func (self TabBar) SetSeparatorMinX(v float32) {
	selfArg, selfFin := self.handle()
	defer selfFin()
	C.wrap_ImGuiTabBar_SetSeparatorMinX(selfArg, C.float(v))
}

func (self *TabBar) SeparatorMinX() float32 {
	selfArg, selfFin := self.handle()

	defer func() {
		selfFin()
	}()
	return float32(C.wrap_ImGuiTabBar_GetSeparatorMinX(selfArg))
}

func (self TabBar) SetSeparatorMaxX(v float32) {
	selfArg, selfFin := self.handle()
	defer selfFin()
	C.wrap_ImGuiTabBar_SetSeparatorMaxX(selfArg, C.float(v))
}

func (self *TabBar) SeparatorMaxX() float32 {
	selfArg, selfFin := self.handle()

	defer func() {
		selfFin()
	}()
	return float32(C.wrap_ImGuiTabBar_GetSeparatorMaxX(selfArg))
}

func (self TabBar) SetReorderRequestTabId(v ID) {
	vArg, _ := v.c()

	selfArg, selfFin := self.handle()
	defer selfFin()
	C.wrap_ImGuiTabBar_SetReorderRequestTabId(selfArg, vArg)
}

func (self *TabBar) ReorderRequestTabId() ID {
	selfArg, selfFin := self.handle()

	defer func() {
		selfFin()
	}()

	result := C.wrap_ImGuiTabBar_GetReorderRequestTabId(selfArg)
	return *newIDFromC(func() *C.ImGuiID { result := result; return &result }())
}

func (self TabBar) SetReorderRequestOffset(v int) {
	selfArg, selfFin := self.handle()
	defer selfFin()
	C.wrap_ImGuiTabBar_SetReorderRequestOffset(selfArg, C.ImS16(v))
}

func (self *TabBar) ReorderRequestOffset() int {
	selfArg, selfFin := self.handle()

	defer func() {
		selfFin()
	}()
	return int(C.wrap_ImGuiTabBar_GetReorderRequestOffset(selfArg))
}

func (self TabBar) SetBeginCount(v int) {
	selfArg, selfFin := self.handle()
	defer selfFin()
	C.wrap_ImGuiTabBar_SetBeginCount(selfArg, C.ImS8(v))
}

func (self *TabBar) BeginCount() int {
	selfArg, selfFin := self.handle()

	defer func() {
		selfFin()
	}()
	return int(C.wrap_ImGuiTabBar_GetBeginCount(selfArg))
}

func (self TabBar) SetWantLayout(v bool) {
	selfArg, selfFin := self.handle()
	defer selfFin()
	C.wrap_ImGuiTabBar_SetWantLayout(selfArg, C.bool(v))
}

func (self *TabBar) WantLayout() bool {
	selfArg, selfFin := self.handle()

	defer func() {
		selfFin()
	}()
	return C.wrap_ImGuiTabBar_GetWantLayout(selfArg) == C.bool(true)
}

func (self TabBar) SetVisibleTabWasSubmitted(v bool) {
	selfArg, selfFin := self.handle()
	defer selfFin()
	C.wrap_ImGuiTabBar_SetVisibleTabWasSubmitted(selfArg, C.bool(v))
}

func (self *TabBar) VisibleTabWasSubmitted() bool {
	selfArg, selfFin := self.handle()

	defer func() {
		selfFin()
	}()
	return C.wrap_ImGuiTabBar_GetVisibleTabWasSubmitted(selfArg) == C.bool(true)
}

func (self TabBar) SetTabsAddedNew(v bool) {
	selfArg, selfFin := self.handle()
	defer selfFin()
	C.wrap_ImGuiTabBar_SetTabsAddedNew(selfArg, C.bool(v))
}

func (self *TabBar) TabsAddedNew() bool {
	selfArg, selfFin := self.handle()

	defer func() {
		selfFin()
	}()
	return C.wrap_ImGuiTabBar_GetTabsAddedNew(selfArg) == C.bool(true)
}

func (self TabBar) SetTabsActiveCount(v int) {
	selfArg, selfFin := self.handle()
	defer selfFin()
	C.wrap_ImGuiTabBar_SetTabsActiveCount(selfArg, C.ImS16(v))
}

func (self *TabBar) TabsActiveCount() int {
	selfArg, selfFin := self.handle()

	defer func() {
		selfFin()
	}()
	return int(C.wrap_ImGuiTabBar_GetTabsActiveCount(selfArg))
}

func (self TabBar) SetLastTabItemIdx(v int) {
	selfArg, selfFin := self.handle()
	defer selfFin()
	C.wrap_ImGuiTabBar_SetLastTabItemIdx(selfArg, C.ImS16(v))
}

func (self *TabBar) LastTabItemIdx() int {
	selfArg, selfFin := self.handle()

	defer func() {
		selfFin()
	}()
	return int(C.wrap_ImGuiTabBar_GetLastTabItemIdx(selfArg))
}

func (self TabBar) SetItemSpacingY(v float32) {
	selfArg, selfFin := self.handle()
	defer selfFin()
	C.wrap_ImGuiTabBar_SetItemSpacingY(selfArg, C.float(v))
}

func (self *TabBar) ItemSpacingY() float32 {
	selfArg, selfFin := self.handle()

	defer func() {
		selfFin()
	}()
	return float32(C.wrap_ImGuiTabBar_GetItemSpacingY(selfArg))
}

func (self TabBar) SetFramePadding(v Vec2) {
	selfArg, selfFin := self.handle()
	defer selfFin()
	C.wrap_ImGuiTabBar_SetFramePadding(selfArg, v.toC())
}

func (self *TabBar) FramePadding() Vec2 {
	selfArg, selfFin := self.handle()

	defer func() {
		selfFin()
	}()
	return *(&Vec2{}).fromC(C.wrap_ImGuiTabBar_GetFramePadding(selfArg))
}

func (self TabBar) SetBackupCursorPos(v Vec2) {
	selfArg, selfFin := self.handle()
	defer selfFin()
	C.wrap_ImGuiTabBar_SetBackupCursorPos(selfArg, v.toC())
}

func (self *TabBar) BackupCursorPos() Vec2 {
	selfArg, selfFin := self.handle()

	defer func() {
		selfFin()
	}()
	return *(&Vec2{}).fromC(C.wrap_ImGuiTabBar_GetBackupCursorPos(selfArg))
}

func (self TabBar) SetTabsNames(v TextBuffer) {
	vArg, _ := v.c()

	selfArg, selfFin := self.handle()
	defer selfFin()
	C.wrap_ImGuiTabBar_SetTabsNames(selfArg, vArg)
}

func (self *TabBar) TabsNames() TextBuffer {
	selfArg, selfFin := self.handle()

	defer func() {
		selfFin()
	}()

	result := C.wrap_ImGuiTabBar_GetTabsNames(selfArg)
	return *newTextBufferFromC(func() *C.ImGuiTextBuffer { result := result; return &result }())
}

func (self TabItem) SetID(v ID) {
	vArg, _ := v.c()

	selfArg, selfFin := self.handle()
	defer selfFin()
	C.wrap_ImGuiTabItem_SetID(selfArg, vArg)
}

func (self *TabItem) ID() ID {
	selfArg, selfFin := self.handle()

	defer func() {
		selfFin()
	}()

	result := C.wrap_ImGuiTabItem_GetID(selfArg)
	return *newIDFromC(func() *C.ImGuiID { result := result; return &result }())
}

func (self TabItem) SetFlags(v TabItemFlags) {
	selfArg, selfFin := self.handle()
	defer selfFin()
	C.wrap_ImGuiTabItem_SetFlags(selfArg, C.ImGuiTabItemFlags(v))
}

func (self *TabItem) Flags() TabItemFlags {
	selfArg, selfFin := self.handle()

	defer func() {
		selfFin()
	}()
	return TabItemFlags(C.wrap_ImGuiTabItem_GetFlags(selfArg))
}

func (self TabItem) SetWindow(v *Window) {
	vArg, _ := v.handle()

	selfArg, selfFin := self.handle()
	defer selfFin()
	C.wrap_ImGuiTabItem_SetWindow(selfArg, vArg)
}

func (self *TabItem) Window() *Window {
	selfArg, selfFin := self.handle()

	defer func() {
		selfFin()
	}()
	return newWindowFromC(C.wrap_ImGuiTabItem_GetWindow(selfArg))
}

func (self TabItem) SetLastFrameVisible(v int32) {
	selfArg, selfFin := self.handle()
	defer selfFin()
	C.wrap_ImGuiTabItem_SetLastFrameVisible(selfArg, C.int(v))
}

func (self *TabItem) LastFrameVisible() int32 {
	selfArg, selfFin := self.handle()

	defer func() {
		selfFin()
	}()
	return int32(C.wrap_ImGuiTabItem_GetLastFrameVisible(selfArg))
}

func (self TabItem) SetLastFrameSelected(v int32) {
	selfArg, selfFin := self.handle()
	defer selfFin()
	C.wrap_ImGuiTabItem_SetLastFrameSelected(selfArg, C.int(v))
}

func (self *TabItem) LastFrameSelected() int32 {
	selfArg, selfFin := self.handle()

	defer func() {
		selfFin()
	}()
	return int32(C.wrap_ImGuiTabItem_GetLastFrameSelected(selfArg))
}

func (self TabItem) SetOffset(v float32) {
	selfArg, selfFin := self.handle()
	defer selfFin()
	C.wrap_ImGuiTabItem_SetOffset(selfArg, C.float(v))
}

func (self *TabItem) Offset() float32 {
	selfArg, selfFin := self.handle()

	defer func() {
		selfFin()
	}()
	return float32(C.wrap_ImGuiTabItem_GetOffset(selfArg))
}

func (self TabItem) SetWidth(v float32) {
	selfArg, selfFin := self.handle()
	defer selfFin()
	C.wrap_ImGuiTabItem_SetWidth(selfArg, C.float(v))
}

func (self *TabItem) Width() float32 {
	selfArg, selfFin := self.handle()

	defer func() {
		selfFin()
	}()
	return float32(C.wrap_ImGuiTabItem_GetWidth(selfArg))
}

func (self TabItem) SetContentWidth(v float32) {
	selfArg, selfFin := self.handle()
	defer selfFin()
	C.wrap_ImGuiTabItem_SetContentWidth(selfArg, C.float(v))
}

func (self *TabItem) ContentWidth() float32 {
	selfArg, selfFin := self.handle()

	defer func() {
		selfFin()
	}()
	return float32(C.wrap_ImGuiTabItem_GetContentWidth(selfArg))
}

func (self TabItem) SetRequestedWidth(v float32) {
	selfArg, selfFin := self.handle()
	defer selfFin()
	C.wrap_ImGuiTabItem_SetRequestedWidth(selfArg, C.float(v))
}

func (self *TabItem) RequestedWidth() float32 {
	selfArg, selfFin := self.handle()

	defer func() {
		selfFin()
	}()
	return float32(C.wrap_ImGuiTabItem_GetRequestedWidth(selfArg))
}

func (self TabItem) SetNameOffset(v int) {
	selfArg, selfFin := self.handle()
	defer selfFin()
	C.wrap_ImGuiTabItem_SetNameOffset(selfArg, C.ImS32(v))
}

func (self *TabItem) NameOffset() int {
	selfArg, selfFin := self.handle()

	defer func() {
		selfFin()
	}()
	return int(C.wrap_ImGuiTabItem_GetNameOffset(selfArg))
}

func (self TabItem) SetBeginOrder(v int) {
	selfArg, selfFin := self.handle()
	defer selfFin()
	C.wrap_ImGuiTabItem_SetBeginOrder(selfArg, C.ImS16(v))
}

func (self *TabItem) BeginOrder() int {
	selfArg, selfFin := self.handle()

	defer func() {
		selfFin()
	}()
	return int(C.wrap_ImGuiTabItem_GetBeginOrder(selfArg))
}

func (self TabItem) SetIndexDuringLayout(v int) {
	selfArg, selfFin := self.handle()
	defer selfFin()
	C.wrap_ImGuiTabItem_SetIndexDuringLayout(selfArg, C.ImS16(v))
}

func (self *TabItem) IndexDuringLayout() int {
	selfArg, selfFin := self.handle()

	defer func() {
		selfFin()
	}()
	return int(C.wrap_ImGuiTabItem_GetIndexDuringLayout(selfArg))
}

func (self TabItem) SetWantClose(v bool) {
	selfArg, selfFin := self.handle()
	defer selfFin()
	C.wrap_ImGuiTabItem_SetWantClose(selfArg, C.bool(v))
}

func (self *TabItem) WantClose() bool {
	selfArg, selfFin := self.handle()

	defer func() {
		selfFin()
	}()
	return C.wrap_ImGuiTabItem_GetWantClose(selfArg) == C.bool(true)
}

func (self Table) SetID(v ID) {
	vArg, _ := v.c()

	selfArg, selfFin := self.handle()
	defer selfFin()
	C.wrap_ImGuiTable_SetID(selfArg, vArg)
}

func (self *Table) ID() ID {
	selfArg, selfFin := self.handle()

	defer func() {
		selfFin()
	}()

	result := C.wrap_ImGuiTable_GetID(selfArg)
	return *newIDFromC(func() *C.ImGuiID { result := result; return &result }())
}

func (self Table) SetFlags(v TableFlags) {
	selfArg, selfFin := self.handle()
	defer selfFin()
	C.wrap_ImGuiTable_SetFlags(selfArg, C.ImGuiTableFlags(v))
}

func (self *Table) Flags() TableFlags {
	selfArg, selfFin := self.handle()

	defer func() {
		selfFin()
	}()
	return TableFlags(C.wrap_ImGuiTable_GetFlags(selfArg))
}

func (self Table) SetRawData(v unsafe.Pointer) {
	vArg, _ := WrapVoidPtr(v)

	selfArg, selfFin := self.handle()
	defer selfFin()
	C.wrap_ImGuiTable_SetRawData(selfArg, vArg)
}

func (self *Table) RawData() unsafe.Pointer {
	selfArg, selfFin := self.handle()

	defer func() {
		selfFin()
	}()
	return unsafe.Pointer(C.wrap_ImGuiTable_GetRawData(selfArg))
}

func (self Table) SetTempData(v *TableTempData) {
	vArg, _ := v.handle()

	selfArg, selfFin := self.handle()
	defer selfFin()
	C.wrap_ImGuiTable_SetTempData(selfArg, vArg)
}

func (self *Table) TempData() *TableTempData {
	selfArg, selfFin := self.handle()

	defer func() {
		selfFin()
	}()
	return newTableTempDataFromC(C.wrap_ImGuiTable_GetTempData(selfArg))
}

func (self Table) SetEnabledMaskByDisplayOrder(v BitArrayPtr) {
	vArg, _ := v.c()

	selfArg, selfFin := self.handle()
	defer selfFin()
	C.wrap_ImGuiTable_SetEnabledMaskByDisplayOrder(selfArg, vArg)
}

func (self *Table) EnabledMaskByDisplayOrder() BitArrayPtr {
	selfArg, selfFin := self.handle()

	defer func() {
		selfFin()
	}()

	result := C.wrap_ImGuiTable_GetEnabledMaskByDisplayOrder(selfArg)
	return *newBitArrayPtrFromC(func() *C.ImBitArrayPtr { result := result; return &result }())
}

func (self Table) SetEnabledMaskByIndex(v BitArrayPtr) {
	vArg, _ := v.c()

	selfArg, selfFin := self.handle()
	defer selfFin()
	C.wrap_ImGuiTable_SetEnabledMaskByIndex(selfArg, vArg)
}

func (self *Table) EnabledMaskByIndex() BitArrayPtr {
	selfArg, selfFin := self.handle()

	defer func() {
		selfFin()
	}()

	result := C.wrap_ImGuiTable_GetEnabledMaskByIndex(selfArg)
	return *newBitArrayPtrFromC(func() *C.ImBitArrayPtr { result := result; return &result }())
}

func (self Table) SetVisibleMaskByIndex(v BitArrayPtr) {
	vArg, _ := v.c()

	selfArg, selfFin := self.handle()
	defer selfFin()
	C.wrap_ImGuiTable_SetVisibleMaskByIndex(selfArg, vArg)
}

func (self *Table) VisibleMaskByIndex() BitArrayPtr {
	selfArg, selfFin := self.handle()

	defer func() {
		selfFin()
	}()

	result := C.wrap_ImGuiTable_GetVisibleMaskByIndex(selfArg)
	return *newBitArrayPtrFromC(func() *C.ImBitArrayPtr { result := result; return &result }())
}

func (self Table) SetSettingsLoadedFlags(v TableFlags) {
	selfArg, selfFin := self.handle()
	defer selfFin()
	C.wrap_ImGuiTable_SetSettingsLoadedFlags(selfArg, C.ImGuiTableFlags(v))
}

func (self *Table) SettingsLoadedFlags() TableFlags {
	selfArg, selfFin := self.handle()

	defer func() {
		selfFin()
	}()
	return TableFlags(C.wrap_ImGuiTable_GetSettingsLoadedFlags(selfArg))
}

func (self Table) SetSettingsOffset(v int32) {
	selfArg, selfFin := self.handle()
	defer selfFin()
	C.wrap_ImGuiTable_SetSettingsOffset(selfArg, C.int(v))
}

func (self *Table) SettingsOffset() int32 {
	selfArg, selfFin := self.handle()

	defer func() {
		selfFin()
	}()
	return int32(C.wrap_ImGuiTable_GetSettingsOffset(selfArg))
}

func (self Table) SetLastFrameActive(v int32) {
	selfArg, selfFin := self.handle()
	defer selfFin()
	C.wrap_ImGuiTable_SetLastFrameActive(selfArg, C.int(v))
}

func (self *Table) LastFrameActive() int32 {
	selfArg, selfFin := self.handle()

	defer func() {
		selfFin()
	}()
	return int32(C.wrap_ImGuiTable_GetLastFrameActive(selfArg))
}

func (self Table) SetColumnsCount(v int32) {
	selfArg, selfFin := self.handle()
	defer selfFin()
	C.wrap_ImGuiTable_SetColumnsCount(selfArg, C.int(v))
}

func (self *Table) ColumnsCount() int32 {
	selfArg, selfFin := self.handle()

	defer func() {
		selfFin()
	}()
	return int32(C.wrap_ImGuiTable_GetColumnsCount(selfArg))
}

func (self Table) SetCurrentRow(v int32) {
	selfArg, selfFin := self.handle()
	defer selfFin()
	C.wrap_ImGuiTable_SetCurrentRow(selfArg, C.int(v))
}

func (self *Table) CurrentRow() int32 {
	selfArg, selfFin := self.handle()

	defer func() {
		selfFin()
	}()
	return int32(C.wrap_ImGuiTable_GetCurrentRow(selfArg))
}

func (self Table) SetCurrentColumn(v int32) {
	selfArg, selfFin := self.handle()
	defer selfFin()
	C.wrap_ImGuiTable_SetCurrentColumn(selfArg, C.int(v))
}

func (self *Table) CurrentColumn() int32 {
	selfArg, selfFin := self.handle()

	defer func() {
		selfFin()
	}()
	return int32(C.wrap_ImGuiTable_GetCurrentColumn(selfArg))
}

func (self Table) SetInstanceCurrent(v int) {
	selfArg, selfFin := self.handle()
	defer selfFin()
	C.wrap_ImGuiTable_SetInstanceCurrent(selfArg, C.ImS16(v))
}

func (self *Table) InstanceCurrent() int {
	selfArg, selfFin := self.handle()

	defer func() {
		selfFin()
	}()
	return int(C.wrap_ImGuiTable_GetInstanceCurrent(selfArg))
}

func (self Table) SetInstanceInteracted(v int) {
	selfArg, selfFin := self.handle()
	defer selfFin()
	C.wrap_ImGuiTable_SetInstanceInteracted(selfArg, C.ImS16(v))
}

func (self *Table) InstanceInteracted() int {
	selfArg, selfFin := self.handle()

	defer func() {
		selfFin()
	}()
	return int(C.wrap_ImGuiTable_GetInstanceInteracted(selfArg))
}

func (self Table) SetRowPosY1(v float32) {
	selfArg, selfFin := self.handle()
	defer selfFin()
	C.wrap_ImGuiTable_SetRowPosY1(selfArg, C.float(v))
}

func (self *Table) RowPosY1() float32 {
	selfArg, selfFin := self.handle()

	defer func() {
		selfFin()
	}()
	return float32(C.wrap_ImGuiTable_GetRowPosY1(selfArg))
}

func (self Table) SetRowPosY2(v float32) {
	selfArg, selfFin := self.handle()
	defer selfFin()
	C.wrap_ImGuiTable_SetRowPosY2(selfArg, C.float(v))
}

func (self *Table) RowPosY2() float32 {
	selfArg, selfFin := self.handle()

	defer func() {
		selfFin()
	}()
	return float32(C.wrap_ImGuiTable_GetRowPosY2(selfArg))
}

func (self Table) SetRowMinHeight(v float32) {
	selfArg, selfFin := self.handle()
	defer selfFin()
	C.wrap_ImGuiTable_SetRowMinHeight(selfArg, C.float(v))
}

func (self *Table) RowMinHeight() float32 {
	selfArg, selfFin := self.handle()

	defer func() {
		selfFin()
	}()
	return float32(C.wrap_ImGuiTable_GetRowMinHeight(selfArg))
}

func (self Table) SetRowCellPaddingY(v float32) {
	selfArg, selfFin := self.handle()
	defer selfFin()
	C.wrap_ImGuiTable_SetRowCellPaddingY(selfArg, C.float(v))
}

func (self *Table) RowCellPaddingY() float32 {
	selfArg, selfFin := self.handle()

	defer func() {
		selfFin()
	}()
	return float32(C.wrap_ImGuiTable_GetRowCellPaddingY(selfArg))
}

func (self Table) SetRowTextBaseline(v float32) {
	selfArg, selfFin := self.handle()
	defer selfFin()
	C.wrap_ImGuiTable_SetRowTextBaseline(selfArg, C.float(v))
}

func (self *Table) RowTextBaseline() float32 {
	selfArg, selfFin := self.handle()

	defer func() {
		selfFin()
	}()
	return float32(C.wrap_ImGuiTable_GetRowTextBaseline(selfArg))
}

func (self Table) SetRowIndentOffsetX(v float32) {
	selfArg, selfFin := self.handle()
	defer selfFin()
	C.wrap_ImGuiTable_SetRowIndentOffsetX(selfArg, C.float(v))
}

func (self *Table) RowIndentOffsetX() float32 {
	selfArg, selfFin := self.handle()

	defer func() {
		selfFin()
	}()
	return float32(C.wrap_ImGuiTable_GetRowIndentOffsetX(selfArg))
}

func (self Table) SetRowFlags(v TableRowFlags) {
	selfArg, selfFin := self.handle()
	defer selfFin()
	C.wrap_ImGuiTable_SetRowFlags(selfArg, C.ImGuiTableRowFlags(v))
}

func (self *Table) RowFlags() TableRowFlags {
	selfArg, selfFin := self.handle()

	defer func() {
		selfFin()
	}()
	return TableRowFlags(C.wrap_ImGuiTable_GetRowFlags(selfArg))
}

func (self Table) SetLastRowFlags(v TableRowFlags) {
	selfArg, selfFin := self.handle()
	defer selfFin()
	C.wrap_ImGuiTable_SetLastRowFlags(selfArg, C.ImGuiTableRowFlags(v))
}

func (self *Table) LastRowFlags() TableRowFlags {
	selfArg, selfFin := self.handle()

	defer func() {
		selfFin()
	}()
	return TableRowFlags(C.wrap_ImGuiTable_GetLastRowFlags(selfArg))
}

func (self Table) SetRowBgColorCounter(v int32) {
	selfArg, selfFin := self.handle()
	defer selfFin()
	C.wrap_ImGuiTable_SetRowBgColorCounter(selfArg, C.int(v))
}

func (self *Table) RowBgColorCounter() int32 {
	selfArg, selfFin := self.handle()

	defer func() {
		selfFin()
	}()
	return int32(C.wrap_ImGuiTable_GetRowBgColorCounter(selfArg))
}

func (self Table) SetBorderColorStrong(v uint32) {
	selfArg, selfFin := self.handle()
	defer selfFin()
	C.wrap_ImGuiTable_SetBorderColorStrong(selfArg, C.ImU32(v))
}

func (self *Table) BorderColorStrong() uint32 {
	selfArg, selfFin := self.handle()

	defer func() {
		selfFin()
	}()
	return uint32(C.wrap_ImGuiTable_GetBorderColorStrong(selfArg))
}

func (self Table) SetBorderColorLight(v uint32) {
	selfArg, selfFin := self.handle()
	defer selfFin()
	C.wrap_ImGuiTable_SetBorderColorLight(selfArg, C.ImU32(v))
}

func (self *Table) BorderColorLight() uint32 {
	selfArg, selfFin := self.handle()

	defer func() {
		selfFin()
	}()
	return uint32(C.wrap_ImGuiTable_GetBorderColorLight(selfArg))
}

func (self Table) SetBorderX1(v float32) {
	selfArg, selfFin := self.handle()
	defer selfFin()
	C.wrap_ImGuiTable_SetBorderX1(selfArg, C.float(v))
}

func (self *Table) BorderX1() float32 {
	selfArg, selfFin := self.handle()

	defer func() {
		selfFin()
	}()
	return float32(C.wrap_ImGuiTable_GetBorderX1(selfArg))
}

func (self Table) SetBorderX2(v float32) {
	selfArg, selfFin := self.handle()
	defer selfFin()
	C.wrap_ImGuiTable_SetBorderX2(selfArg, C.float(v))
}

func (self *Table) BorderX2() float32 {
	selfArg, selfFin := self.handle()

	defer func() {
		selfFin()
	}()
	return float32(C.wrap_ImGuiTable_GetBorderX2(selfArg))
}

func (self Table) SetHostIndentX(v float32) {
	selfArg, selfFin := self.handle()
	defer selfFin()
	C.wrap_ImGuiTable_SetHostIndentX(selfArg, C.float(v))
}

func (self *Table) HostIndentX() float32 {
	selfArg, selfFin := self.handle()

	defer func() {
		selfFin()
	}()
	return float32(C.wrap_ImGuiTable_GetHostIndentX(selfArg))
}

func (self Table) SetMinColumnWidth(v float32) {
	selfArg, selfFin := self.handle()
	defer selfFin()
	C.wrap_ImGuiTable_SetMinColumnWidth(selfArg, C.float(v))
}

func (self *Table) MinColumnWidth() float32 {
	selfArg, selfFin := self.handle()

	defer func() {
		selfFin()
	}()
	return float32(C.wrap_ImGuiTable_GetMinColumnWidth(selfArg))
}

func (self Table) SetOuterPaddingX(v float32) {
	selfArg, selfFin := self.handle()
	defer selfFin()
	C.wrap_ImGuiTable_SetOuterPaddingX(selfArg, C.float(v))
}

func (self *Table) OuterPaddingX() float32 {
	selfArg, selfFin := self.handle()

	defer func() {
		selfFin()
	}()
	return float32(C.wrap_ImGuiTable_GetOuterPaddingX(selfArg))
}

func (self Table) SetCellPaddingX(v float32) {
	selfArg, selfFin := self.handle()
	defer selfFin()
	C.wrap_ImGuiTable_SetCellPaddingX(selfArg, C.float(v))
}

func (self *Table) CellPaddingX() float32 {
	selfArg, selfFin := self.handle()

	defer func() {
		selfFin()
	}()
	return float32(C.wrap_ImGuiTable_GetCellPaddingX(selfArg))
}

func (self Table) SetCellSpacingX1(v float32) {
	selfArg, selfFin := self.handle()
	defer selfFin()
	C.wrap_ImGuiTable_SetCellSpacingX1(selfArg, C.float(v))
}

func (self *Table) CellSpacingX1() float32 {
	selfArg, selfFin := self.handle()

	defer func() {
		selfFin()
	}()
	return float32(C.wrap_ImGuiTable_GetCellSpacingX1(selfArg))
}

func (self Table) SetCellSpacingX2(v float32) {
	selfArg, selfFin := self.handle()
	defer selfFin()
	C.wrap_ImGuiTable_SetCellSpacingX2(selfArg, C.float(v))
}

func (self *Table) CellSpacingX2() float32 {
	selfArg, selfFin := self.handle()

	defer func() {
		selfFin()
	}()
	return float32(C.wrap_ImGuiTable_GetCellSpacingX2(selfArg))
}

func (self Table) SetInnerWidth(v float32) {
	selfArg, selfFin := self.handle()
	defer selfFin()
	C.wrap_ImGuiTable_SetInnerWidth(selfArg, C.float(v))
}

func (self *Table) InnerWidth() float32 {
	selfArg, selfFin := self.handle()

	defer func() {
		selfFin()
	}()
	return float32(C.wrap_ImGuiTable_GetInnerWidth(selfArg))
}

func (self Table) SetColumnsGivenWidth(v float32) {
	selfArg, selfFin := self.handle()
	defer selfFin()
	C.wrap_ImGuiTable_SetColumnsGivenWidth(selfArg, C.float(v))
}

func (self *Table) ColumnsGivenWidth() float32 {
	selfArg, selfFin := self.handle()

	defer func() {
		selfFin()
	}()
	return float32(C.wrap_ImGuiTable_GetColumnsGivenWidth(selfArg))
}

func (self Table) SetColumnsAutoFitWidth(v float32) {
	selfArg, selfFin := self.handle()
	defer selfFin()
	C.wrap_ImGuiTable_SetColumnsAutoFitWidth(selfArg, C.float(v))
}

func (self *Table) ColumnsAutoFitWidth() float32 {
	selfArg, selfFin := self.handle()

	defer func() {
		selfFin()
	}()
	return float32(C.wrap_ImGuiTable_GetColumnsAutoFitWidth(selfArg))
}

func (self Table) SetColumnsStretchSumWeights(v float32) {
	selfArg, selfFin := self.handle()
	defer selfFin()
	C.wrap_ImGuiTable_SetColumnsStretchSumWeights(selfArg, C.float(v))
}

func (self *Table) ColumnsStretchSumWeights() float32 {
	selfArg, selfFin := self.handle()

	defer func() {
		selfFin()
	}()
	return float32(C.wrap_ImGuiTable_GetColumnsStretchSumWeights(selfArg))
}

func (self Table) SetResizedColumnNextWidth(v float32) {
	selfArg, selfFin := self.handle()
	defer selfFin()
	C.wrap_ImGuiTable_SetResizedColumnNextWidth(selfArg, C.float(v))
}

func (self *Table) ResizedColumnNextWidth() float32 {
	selfArg, selfFin := self.handle()

	defer func() {
		selfFin()
	}()
	return float32(C.wrap_ImGuiTable_GetResizedColumnNextWidth(selfArg))
}

func (self Table) SetResizeLockMinContentsX2(v float32) {
	selfArg, selfFin := self.handle()
	defer selfFin()
	C.wrap_ImGuiTable_SetResizeLockMinContentsX2(selfArg, C.float(v))
}

func (self *Table) ResizeLockMinContentsX2() float32 {
	selfArg, selfFin := self.handle()

	defer func() {
		selfFin()
	}()
	return float32(C.wrap_ImGuiTable_GetResizeLockMinContentsX2(selfArg))
}

func (self Table) SetRefScale(v float32) {
	selfArg, selfFin := self.handle()
	defer selfFin()
	C.wrap_ImGuiTable_SetRefScale(selfArg, C.float(v))
}

func (self *Table) RefScale() float32 {
	selfArg, selfFin := self.handle()

	defer func() {
		selfFin()
	}()
	return float32(C.wrap_ImGuiTable_GetRefScale(selfArg))
}

func (self Table) SetOuterRect(v Rect) {
	selfArg, selfFin := self.handle()
	defer selfFin()
	C.wrap_ImGuiTable_SetOuterRect(selfArg, v.toC())
}

func (self *Table) OuterRect() Rect {
	selfArg, selfFin := self.handle()

	defer func() {
		selfFin()
	}()
	return *(&Rect{}).fromC(C.wrap_ImGuiTable_GetOuterRect(selfArg))
}

func (self Table) SetInnerRect(v Rect) {
	selfArg, selfFin := self.handle()
	defer selfFin()
	C.wrap_ImGuiTable_SetInnerRect(selfArg, v.toC())
}

func (self *Table) InnerRect() Rect {
	selfArg, selfFin := self.handle()

	defer func() {
		selfFin()
	}()
	return *(&Rect{}).fromC(C.wrap_ImGuiTable_GetInnerRect(selfArg))
}

func (self Table) SetWorkRect(v Rect) {
	selfArg, selfFin := self.handle()
	defer selfFin()
	C.wrap_ImGuiTable_SetWorkRect(selfArg, v.toC())
}

func (self *Table) WorkRect() Rect {
	selfArg, selfFin := self.handle()

	defer func() {
		selfFin()
	}()
	return *(&Rect{}).fromC(C.wrap_ImGuiTable_GetWorkRect(selfArg))
}

func (self Table) SetInnerClipRect(v Rect) {
	selfArg, selfFin := self.handle()
	defer selfFin()
	C.wrap_ImGuiTable_SetInnerClipRect(selfArg, v.toC())
}

func (self *Table) InnerClipRect() Rect {
	selfArg, selfFin := self.handle()

	defer func() {
		selfFin()
	}()
	return *(&Rect{}).fromC(C.wrap_ImGuiTable_GetInnerClipRect(selfArg))
}

func (self Table) SetBgClipRect(v Rect) {
	selfArg, selfFin := self.handle()
	defer selfFin()
	C.wrap_ImGuiTable_SetBgClipRect(selfArg, v.toC())
}

func (self *Table) BgClipRect() Rect {
	selfArg, selfFin := self.handle()

	defer func() {
		selfFin()
	}()
	return *(&Rect{}).fromC(C.wrap_ImGuiTable_GetBgClipRect(selfArg))
}

func (self Table) SetBg0ClipRectForDrawCmd(v Rect) {
	selfArg, selfFin := self.handle()
	defer selfFin()
	C.wrap_ImGuiTable_SetBg0ClipRectForDrawCmd(selfArg, v.toC())
}

func (self *Table) Bg0ClipRectForDrawCmd() Rect {
	selfArg, selfFin := self.handle()

	defer func() {
		selfFin()
	}()
	return *(&Rect{}).fromC(C.wrap_ImGuiTable_GetBg0ClipRectForDrawCmd(selfArg))
}

func (self Table) SetBg2ClipRectForDrawCmd(v Rect) {
	selfArg, selfFin := self.handle()
	defer selfFin()
	C.wrap_ImGuiTable_SetBg2ClipRectForDrawCmd(selfArg, v.toC())
}

func (self *Table) Bg2ClipRectForDrawCmd() Rect {
	selfArg, selfFin := self.handle()

	defer func() {
		selfFin()
	}()
	return *(&Rect{}).fromC(C.wrap_ImGuiTable_GetBg2ClipRectForDrawCmd(selfArg))
}

func (self Table) SetHostClipRect(v Rect) {
	selfArg, selfFin := self.handle()
	defer selfFin()
	C.wrap_ImGuiTable_SetHostClipRect(selfArg, v.toC())
}

func (self *Table) HostClipRect() Rect {
	selfArg, selfFin := self.handle()

	defer func() {
		selfFin()
	}()
	return *(&Rect{}).fromC(C.wrap_ImGuiTable_GetHostClipRect(selfArg))
}

func (self Table) SetHostBackupInnerClipRect(v Rect) {
	selfArg, selfFin := self.handle()
	defer selfFin()
	C.wrap_ImGuiTable_SetHostBackupInnerClipRect(selfArg, v.toC())
}

func (self *Table) HostBackupInnerClipRect() Rect {
	selfArg, selfFin := self.handle()

	defer func() {
		selfFin()
	}()
	return *(&Rect{}).fromC(C.wrap_ImGuiTable_GetHostBackupInnerClipRect(selfArg))
}

func (self Table) SetOuterWindow(v *Window) {
	vArg, _ := v.handle()

	selfArg, selfFin := self.handle()
	defer selfFin()
	C.wrap_ImGuiTable_SetOuterWindow(selfArg, vArg)
}

func (self *Table) OuterWindow() *Window {
	selfArg, selfFin := self.handle()

	defer func() {
		selfFin()
	}()
	return newWindowFromC(C.wrap_ImGuiTable_GetOuterWindow(selfArg))
}

func (self Table) SetInnerWindow(v *Window) {
	vArg, _ := v.handle()

	selfArg, selfFin := self.handle()
	defer selfFin()
	C.wrap_ImGuiTable_SetInnerWindow(selfArg, vArg)
}

func (self *Table) InnerWindow() *Window {
	selfArg, selfFin := self.handle()

	defer func() {
		selfFin()
	}()
	return newWindowFromC(C.wrap_ImGuiTable_GetInnerWindow(selfArg))
}

func (self Table) SetColumnsNames(v TextBuffer) {
	vArg, _ := v.c()

	selfArg, selfFin := self.handle()
	defer selfFin()
	C.wrap_ImGuiTable_SetColumnsNames(selfArg, vArg)
}

func (self *Table) ColumnsNames() TextBuffer {
	selfArg, selfFin := self.handle()

	defer func() {
		selfFin()
	}()

	result := C.wrap_ImGuiTable_GetColumnsNames(selfArg)
	return *newTextBufferFromC(func() *C.ImGuiTextBuffer { result := result; return &result }())
}

func (self Table) SetDrawSplitter(v *DrawListSplitter) {
	vArg, _ := v.handle()

	selfArg, selfFin := self.handle()
	defer selfFin()
	C.wrap_ImGuiTable_SetDrawSplitter(selfArg, vArg)
}

func (self *Table) DrawSplitter() *DrawListSplitter {
	selfArg, selfFin := self.handle()

	defer func() {
		selfFin()
	}()
	return newDrawListSplitterFromC(C.wrap_ImGuiTable_GetDrawSplitter(selfArg))
}

func (self Table) SetInstanceDataFirst(v TableInstanceData) {
	vArg, _ := v.c()

	selfArg, selfFin := self.handle()
	defer selfFin()
	C.wrap_ImGuiTable_SetInstanceDataFirst(selfArg, vArg)
}

func (self *Table) InstanceDataFirst() TableInstanceData {
	selfArg, selfFin := self.handle()

	defer func() {
		selfFin()
	}()

	result := C.wrap_ImGuiTable_GetInstanceDataFirst(selfArg)
	return *newTableInstanceDataFromC(func() *C.ImGuiTableInstanceData { result := result; return &result }())
}

func (self Table) SetInstanceDataExtra(v Vector[*TableInstanceData]) {
	vData := v.Data
	vDataArg, _ := vData.handle()
	vVecArg := new(C.ImVector_ImGuiTableInstanceData)
	vVecArg.Size = C.int(v.Size)
	vVecArg.Capacity = C.int(v.Capacity)
	vVecArg.Data = vDataArg
	v.pinner.Pin(vVecArg.Data)

	selfArg, selfFin := self.handle()
	defer selfFin()
	C.wrap_ImGuiTable_SetInstanceDataExtra(selfArg, *vVecArg)
}

func (self *Table) InstanceDataExtra() Vector[*TableInstanceData] {
	selfArg, selfFin := self.handle()

	defer func() {
		selfFin()
	}()
	return newVectorFromC(C.wrap_ImGuiTable_GetInstanceDataExtra(selfArg).Size, C.wrap_ImGuiTable_GetInstanceDataExtra(selfArg).Capacity, newTableInstanceDataFromC(C.wrap_ImGuiTable_GetInstanceDataExtra(selfArg).Data))
}

func (self Table) SetSortSpecsSingle(v TableColumnSortSpecs) {
	vArg, _ := v.c()

	selfArg, selfFin := self.handle()
	defer selfFin()
	C.wrap_ImGuiTable_SetSortSpecsSingle(selfArg, vArg)
}

func (self *Table) SortSpecsSingle() TableColumnSortSpecs {
	selfArg, selfFin := self.handle()

	defer func() {
		selfFin()
	}()

	result := C.wrap_ImGuiTable_GetSortSpecsSingle(selfArg)
	return *newTableColumnSortSpecsFromC(func() *C.ImGuiTableColumnSortSpecs { result := result; return &result }())
}

func (self Table) SetSortSpecsMulti(v Vector[*TableColumnSortSpecs]) {
	vData := v.Data
	vDataArg, _ := vData.handle()
	vVecArg := new(C.ImVector_ImGuiTableColumnSortSpecs)
	vVecArg.Size = C.int(v.Size)
	vVecArg.Capacity = C.int(v.Capacity)
	vVecArg.Data = vDataArg
	v.pinner.Pin(vVecArg.Data)

	selfArg, selfFin := self.handle()
	defer selfFin()
	C.wrap_ImGuiTable_SetSortSpecsMulti(selfArg, *vVecArg)
}

func (self *Table) SortSpecsMulti() Vector[*TableColumnSortSpecs] {
	selfArg, selfFin := self.handle()

	defer func() {
		selfFin()
	}()
	return newVectorFromC(C.wrap_ImGuiTable_GetSortSpecsMulti(selfArg).Size, C.wrap_ImGuiTable_GetSortSpecsMulti(selfArg).Capacity, newTableColumnSortSpecsFromC(C.wrap_ImGuiTable_GetSortSpecsMulti(selfArg).Data))
}

func (self Table) SetSortSpecs(v TableSortSpecs) {
	vArg, _ := v.c()

	selfArg, selfFin := self.handle()
	defer selfFin()
	C.wrap_ImGuiTable_SetSortSpecs(selfArg, vArg)
}

func (self *Table) SortSpecs() TableSortSpecs {
	selfArg, selfFin := self.handle()

	defer func() {
		selfFin()
	}()

	result := C.wrap_ImGuiTable_GetSortSpecs(selfArg)
	return *newTableSortSpecsFromC(func() *C.ImGuiTableSortSpecs { result := result; return &result }())
}

func (self Table) SetDummyDrawChannel(v TableDrawChannelIdx) {
	vArg, _ := v.c()

	selfArg, selfFin := self.handle()
	defer selfFin()
	C.wrap_ImGuiTable_SetDummyDrawChannel(selfArg, vArg)
}

func (self *Table) DummyDrawChannel() TableDrawChannelIdx {
	selfArg, selfFin := self.handle()

	defer func() {
		selfFin()
	}()

	result := C.wrap_ImGuiTable_GetDummyDrawChannel(selfArg)
	return *newTableDrawChannelIdxFromC(func() *C.ImGuiTableDrawChannelIdx { result := result; return &result }())
}

func (self Table) SetBg2DrawChannelCurrent(v TableDrawChannelIdx) {
	vArg, _ := v.c()

	selfArg, selfFin := self.handle()
	defer selfFin()
	C.wrap_ImGuiTable_SetBg2DrawChannelCurrent(selfArg, vArg)
}

func (self *Table) Bg2DrawChannelCurrent() TableDrawChannelIdx {
	selfArg, selfFin := self.handle()

	defer func() {
		selfFin()
	}()

	result := C.wrap_ImGuiTable_GetBg2DrawChannelCurrent(selfArg)
	return *newTableDrawChannelIdxFromC(func() *C.ImGuiTableDrawChannelIdx { result := result; return &result }())
}

func (self Table) SetBg2DrawChannelUnfrozen(v TableDrawChannelIdx) {
	vArg, _ := v.c()

	selfArg, selfFin := self.handle()
	defer selfFin()
	C.wrap_ImGuiTable_SetBg2DrawChannelUnfrozen(selfArg, vArg)
}

func (self *Table) Bg2DrawChannelUnfrozen() TableDrawChannelIdx {
	selfArg, selfFin := self.handle()

	defer func() {
		selfFin()
	}()

	result := C.wrap_ImGuiTable_GetBg2DrawChannelUnfrozen(selfArg)
	return *newTableDrawChannelIdxFromC(func() *C.ImGuiTableDrawChannelIdx { result := result; return &result }())
}

func (self Table) SetIsLayoutLocked(v bool) {
	selfArg, selfFin := self.handle()
	defer selfFin()
	C.wrap_ImGuiTable_SetIsLayoutLocked(selfArg, C.bool(v))
}

func (self *Table) IsLayoutLocked() bool {
	selfArg, selfFin := self.handle()

	defer func() {
		selfFin()
	}()
	return C.wrap_ImGuiTable_GetIsLayoutLocked(selfArg) == C.bool(true)
}

func (self Table) SetIsInsideRow(v bool) {
	selfArg, selfFin := self.handle()
	defer selfFin()
	C.wrap_ImGuiTable_SetIsInsideRow(selfArg, C.bool(v))
}

func (self *Table) IsInsideRow() bool {
	selfArg, selfFin := self.handle()

	defer func() {
		selfFin()
	}()
	return C.wrap_ImGuiTable_GetIsInsideRow(selfArg) == C.bool(true)
}

func (self Table) SetIsInitializing(v bool) {
	selfArg, selfFin := self.handle()
	defer selfFin()
	C.wrap_ImGuiTable_SetIsInitializing(selfArg, C.bool(v))
}

func (self *Table) IsInitializing() bool {
	selfArg, selfFin := self.handle()

	defer func() {
		selfFin()
	}()
	return C.wrap_ImGuiTable_GetIsInitializing(selfArg) == C.bool(true)
}

func (self Table) SetIsSortSpecsDirty(v bool) {
	selfArg, selfFin := self.handle()
	defer selfFin()
	C.wrap_ImGuiTable_SetIsSortSpecsDirty(selfArg, C.bool(v))
}

func (self *Table) IsSortSpecsDirty() bool {
	selfArg, selfFin := self.handle()

	defer func() {
		selfFin()
	}()
	return C.wrap_ImGuiTable_GetIsSortSpecsDirty(selfArg) == C.bool(true)
}

func (self Table) SetIsUsingHeaders(v bool) {
	selfArg, selfFin := self.handle()
	defer selfFin()
	C.wrap_ImGuiTable_SetIsUsingHeaders(selfArg, C.bool(v))
}

func (self *Table) IsUsingHeaders() bool {
	selfArg, selfFin := self.handle()

	defer func() {
		selfFin()
	}()
	return C.wrap_ImGuiTable_GetIsUsingHeaders(selfArg) == C.bool(true)
}

func (self Table) SetIsContextPopupOpen(v bool) {
	selfArg, selfFin := self.handle()
	defer selfFin()
	C.wrap_ImGuiTable_SetIsContextPopupOpen(selfArg, C.bool(v))
}

func (self *Table) IsContextPopupOpen() bool {
	selfArg, selfFin := self.handle()

	defer func() {
		selfFin()
	}()
	return C.wrap_ImGuiTable_GetIsContextPopupOpen(selfArg) == C.bool(true)
}

func (self Table) SetIsSettingsRequestLoad(v bool) {
	selfArg, selfFin := self.handle()
	defer selfFin()
	C.wrap_ImGuiTable_SetIsSettingsRequestLoad(selfArg, C.bool(v))
}

func (self *Table) IsSettingsRequestLoad() bool {
	selfArg, selfFin := self.handle()

	defer func() {
		selfFin()
	}()
	return C.wrap_ImGuiTable_GetIsSettingsRequestLoad(selfArg) == C.bool(true)
}

func (self Table) SetIsSettingsDirty(v bool) {
	selfArg, selfFin := self.handle()
	defer selfFin()
	C.wrap_ImGuiTable_SetIsSettingsDirty(selfArg, C.bool(v))
}

func (self *Table) IsSettingsDirty() bool {
	selfArg, selfFin := self.handle()

	defer func() {
		selfFin()
	}()
	return C.wrap_ImGuiTable_GetIsSettingsDirty(selfArg) == C.bool(true)
}

func (self Table) SetIsDefaultDisplayOrder(v bool) {
	selfArg, selfFin := self.handle()
	defer selfFin()
	C.wrap_ImGuiTable_SetIsDefaultDisplayOrder(selfArg, C.bool(v))
}

func (self *Table) IsDefaultDisplayOrder() bool {
	selfArg, selfFin := self.handle()

	defer func() {
		selfFin()
	}()
	return C.wrap_ImGuiTable_GetIsDefaultDisplayOrder(selfArg) == C.bool(true)
}

func (self Table) SetIsResetAllRequest(v bool) {
	selfArg, selfFin := self.handle()
	defer selfFin()
	C.wrap_ImGuiTable_SetIsResetAllRequest(selfArg, C.bool(v))
}

func (self *Table) IsResetAllRequest() bool {
	selfArg, selfFin := self.handle()

	defer func() {
		selfFin()
	}()
	return C.wrap_ImGuiTable_GetIsResetAllRequest(selfArg) == C.bool(true)
}

func (self Table) SetIsResetDisplayOrderRequest(v bool) {
	selfArg, selfFin := self.handle()
	defer selfFin()
	C.wrap_ImGuiTable_SetIsResetDisplayOrderRequest(selfArg, C.bool(v))
}

func (self *Table) IsResetDisplayOrderRequest() bool {
	selfArg, selfFin := self.handle()

	defer func() {
		selfFin()
	}()
	return C.wrap_ImGuiTable_GetIsResetDisplayOrderRequest(selfArg) == C.bool(true)
}

func (self Table) SetIsUnfrozenRows(v bool) {
	selfArg, selfFin := self.handle()
	defer selfFin()
	C.wrap_ImGuiTable_SetIsUnfrozenRows(selfArg, C.bool(v))
}

func (self *Table) IsUnfrozenRows() bool {
	selfArg, selfFin := self.handle()

	defer func() {
		selfFin()
	}()
	return C.wrap_ImGuiTable_GetIsUnfrozenRows(selfArg) == C.bool(true)
}

func (self Table) SetIsDefaultSizingPolicy(v bool) {
	selfArg, selfFin := self.handle()
	defer selfFin()
	C.wrap_ImGuiTable_SetIsDefaultSizingPolicy(selfArg, C.bool(v))
}

func (self *Table) IsDefaultSizingPolicy() bool {
	selfArg, selfFin := self.handle()

	defer func() {
		selfFin()
	}()
	return C.wrap_ImGuiTable_GetIsDefaultSizingPolicy(selfArg) == C.bool(true)
}

func (self Table) SetHasScrollbarYCurr(v bool) {
	selfArg, selfFin := self.handle()
	defer selfFin()
	C.wrap_ImGuiTable_SetHasScrollbarYCurr(selfArg, C.bool(v))
}

func (self *Table) HasScrollbarYCurr() bool {
	selfArg, selfFin := self.handle()

	defer func() {
		selfFin()
	}()
	return C.wrap_ImGuiTable_GetHasScrollbarYCurr(selfArg) == C.bool(true)
}

func (self Table) SetHasScrollbarYPrev(v bool) {
	selfArg, selfFin := self.handle()
	defer selfFin()
	C.wrap_ImGuiTable_SetHasScrollbarYPrev(selfArg, C.bool(v))
}

func (self *Table) HasScrollbarYPrev() bool {
	selfArg, selfFin := self.handle()

	defer func() {
		selfFin()
	}()
	return C.wrap_ImGuiTable_GetHasScrollbarYPrev(selfArg) == C.bool(true)
}

func (self Table) SetMemoryCompacted(v bool) {
	selfArg, selfFin := self.handle()
	defer selfFin()
	C.wrap_ImGuiTable_SetMemoryCompacted(selfArg, C.bool(v))
}

func (self *Table) MemoryCompacted() bool {
	selfArg, selfFin := self.handle()

	defer func() {
		selfFin()
	}()
	return C.wrap_ImGuiTable_GetMemoryCompacted(selfArg) == C.bool(true)
}

func (self Table) SetHostSkipItems(v bool) {
	selfArg, selfFin := self.handle()
	defer selfFin()
	C.wrap_ImGuiTable_SetHostSkipItems(selfArg, C.bool(v))
}

func (self *Table) HostSkipItems() bool {
	selfArg, selfFin := self.handle()

	defer func() {
		selfFin()
	}()
	return C.wrap_ImGuiTable_GetHostSkipItems(selfArg) == C.bool(true)
}

func (self TableCellData) SetBgColor(v uint32) {
	selfArg, selfFin := self.handle()
	defer selfFin()
	C.wrap_ImGuiTableCellData_SetBgColor(selfArg, C.ImU32(v))
}

func (self *TableCellData) BgColor() uint32 {
	selfArg, selfFin := self.handle()

	defer func() {
		selfFin()
	}()
	return uint32(C.wrap_ImGuiTableCellData_GetBgColor(selfArg))
}

func (self TableColumn) SetFlags(v TableColumnFlags) {
	selfArg, selfFin := self.handle()
	defer selfFin()
	C.wrap_ImGuiTableColumn_SetFlags(selfArg, C.ImGuiTableColumnFlags(v))
}

func (self *TableColumn) Flags() TableColumnFlags {
	selfArg, selfFin := self.handle()

	defer func() {
		selfFin()
	}()
	return TableColumnFlags(C.wrap_ImGuiTableColumn_GetFlags(selfArg))
}

func (self TableColumn) SetWidthGiven(v float32) {
	selfArg, selfFin := self.handle()
	defer selfFin()
	C.wrap_ImGuiTableColumn_SetWidthGiven(selfArg, C.float(v))
}

func (self *TableColumn) WidthGiven() float32 {
	selfArg, selfFin := self.handle()

	defer func() {
		selfFin()
	}()
	return float32(C.wrap_ImGuiTableColumn_GetWidthGiven(selfArg))
}

func (self TableColumn) SetMinX(v float32) {
	selfArg, selfFin := self.handle()
	defer selfFin()
	C.wrap_ImGuiTableColumn_SetMinX(selfArg, C.float(v))
}

func (self *TableColumn) MinX() float32 {
	selfArg, selfFin := self.handle()

	defer func() {
		selfFin()
	}()
	return float32(C.wrap_ImGuiTableColumn_GetMinX(selfArg))
}

func (self TableColumn) SetMaxX(v float32) {
	selfArg, selfFin := self.handle()
	defer selfFin()
	C.wrap_ImGuiTableColumn_SetMaxX(selfArg, C.float(v))
}

func (self *TableColumn) MaxX() float32 {
	selfArg, selfFin := self.handle()

	defer func() {
		selfFin()
	}()
	return float32(C.wrap_ImGuiTableColumn_GetMaxX(selfArg))
}

func (self TableColumn) SetWidthRequest(v float32) {
	selfArg, selfFin := self.handle()
	defer selfFin()
	C.wrap_ImGuiTableColumn_SetWidthRequest(selfArg, C.float(v))
}

func (self *TableColumn) WidthRequest() float32 {
	selfArg, selfFin := self.handle()

	defer func() {
		selfFin()
	}()
	return float32(C.wrap_ImGuiTableColumn_GetWidthRequest(selfArg))
}

func (self TableColumn) SetWidthAuto(v float32) {
	selfArg, selfFin := self.handle()
	defer selfFin()
	C.wrap_ImGuiTableColumn_SetWidthAuto(selfArg, C.float(v))
}

func (self *TableColumn) WidthAuto() float32 {
	selfArg, selfFin := self.handle()

	defer func() {
		selfFin()
	}()
	return float32(C.wrap_ImGuiTableColumn_GetWidthAuto(selfArg))
}

func (self TableColumn) SetStretchWeight(v float32) {
	selfArg, selfFin := self.handle()
	defer selfFin()
	C.wrap_ImGuiTableColumn_SetStretchWeight(selfArg, C.float(v))
}

func (self *TableColumn) StretchWeight() float32 {
	selfArg, selfFin := self.handle()

	defer func() {
		selfFin()
	}()
	return float32(C.wrap_ImGuiTableColumn_GetStretchWeight(selfArg))
}

func (self TableColumn) SetInitStretchWeightOrWidth(v float32) {
	selfArg, selfFin := self.handle()
	defer selfFin()
	C.wrap_ImGuiTableColumn_SetInitStretchWeightOrWidth(selfArg, C.float(v))
}

func (self *TableColumn) InitStretchWeightOrWidth() float32 {
	selfArg, selfFin := self.handle()

	defer func() {
		selfFin()
	}()
	return float32(C.wrap_ImGuiTableColumn_GetInitStretchWeightOrWidth(selfArg))
}

func (self TableColumn) SetClipRect(v Rect) {
	selfArg, selfFin := self.handle()
	defer selfFin()
	C.wrap_ImGuiTableColumn_SetClipRect(selfArg, v.toC())
}

func (self *TableColumn) ClipRect() Rect {
	selfArg, selfFin := self.handle()

	defer func() {
		selfFin()
	}()
	return *(&Rect{}).fromC(C.wrap_ImGuiTableColumn_GetClipRect(selfArg))
}

func (self TableColumn) SetUserID(v ID) {
	vArg, _ := v.c()

	selfArg, selfFin := self.handle()
	defer selfFin()
	C.wrap_ImGuiTableColumn_SetUserID(selfArg, vArg)
}

func (self *TableColumn) UserID() ID {
	selfArg, selfFin := self.handle()

	defer func() {
		selfFin()
	}()

	result := C.wrap_ImGuiTableColumn_GetUserID(selfArg)
	return *newIDFromC(func() *C.ImGuiID { result := result; return &result }())
}

func (self TableColumn) SetWorkMinX(v float32) {
	selfArg, selfFin := self.handle()
	defer selfFin()
	C.wrap_ImGuiTableColumn_SetWorkMinX(selfArg, C.float(v))
}

func (self *TableColumn) WorkMinX() float32 {
	selfArg, selfFin := self.handle()

	defer func() {
		selfFin()
	}()
	return float32(C.wrap_ImGuiTableColumn_GetWorkMinX(selfArg))
}

func (self TableColumn) SetWorkMaxX(v float32) {
	selfArg, selfFin := self.handle()
	defer selfFin()
	C.wrap_ImGuiTableColumn_SetWorkMaxX(selfArg, C.float(v))
}

func (self *TableColumn) WorkMaxX() float32 {
	selfArg, selfFin := self.handle()

	defer func() {
		selfFin()
	}()
	return float32(C.wrap_ImGuiTableColumn_GetWorkMaxX(selfArg))
}

func (self TableColumn) SetItemWidth(v float32) {
	selfArg, selfFin := self.handle()
	defer selfFin()
	C.wrap_ImGuiTableColumn_SetItemWidth(selfArg, C.float(v))
}

func (self *TableColumn) ItemWidth() float32 {
	selfArg, selfFin := self.handle()

	defer func() {
		selfFin()
	}()
	return float32(C.wrap_ImGuiTableColumn_GetItemWidth(selfArg))
}

func (self TableColumn) SetContentMaxXFrozen(v float32) {
	selfArg, selfFin := self.handle()
	defer selfFin()
	C.wrap_ImGuiTableColumn_SetContentMaxXFrozen(selfArg, C.float(v))
}

func (self *TableColumn) ContentMaxXFrozen() float32 {
	selfArg, selfFin := self.handle()

	defer func() {
		selfFin()
	}()
	return float32(C.wrap_ImGuiTableColumn_GetContentMaxXFrozen(selfArg))
}

func (self TableColumn) SetContentMaxXUnfrozen(v float32) {
	selfArg, selfFin := self.handle()
	defer selfFin()
	C.wrap_ImGuiTableColumn_SetContentMaxXUnfrozen(selfArg, C.float(v))
}

func (self *TableColumn) ContentMaxXUnfrozen() float32 {
	selfArg, selfFin := self.handle()

	defer func() {
		selfFin()
	}()
	return float32(C.wrap_ImGuiTableColumn_GetContentMaxXUnfrozen(selfArg))
}

func (self TableColumn) SetContentMaxXHeadersUsed(v float32) {
	selfArg, selfFin := self.handle()
	defer selfFin()
	C.wrap_ImGuiTableColumn_SetContentMaxXHeadersUsed(selfArg, C.float(v))
}

func (self *TableColumn) ContentMaxXHeadersUsed() float32 {
	selfArg, selfFin := self.handle()

	defer func() {
		selfFin()
	}()
	return float32(C.wrap_ImGuiTableColumn_GetContentMaxXHeadersUsed(selfArg))
}

func (self TableColumn) SetContentMaxXHeadersIdeal(v float32) {
	selfArg, selfFin := self.handle()
	defer selfFin()
	C.wrap_ImGuiTableColumn_SetContentMaxXHeadersIdeal(selfArg, C.float(v))
}

func (self *TableColumn) ContentMaxXHeadersIdeal() float32 {
	selfArg, selfFin := self.handle()

	defer func() {
		selfFin()
	}()
	return float32(C.wrap_ImGuiTableColumn_GetContentMaxXHeadersIdeal(selfArg))
}

func (self TableColumn) SetNameOffset(v int) {
	selfArg, selfFin := self.handle()
	defer selfFin()
	C.wrap_ImGuiTableColumn_SetNameOffset(selfArg, C.ImS16(v))
}

func (self *TableColumn) NameOffset() int {
	selfArg, selfFin := self.handle()

	defer func() {
		selfFin()
	}()
	return int(C.wrap_ImGuiTableColumn_GetNameOffset(selfArg))
}

func (self TableColumn) SetDrawChannelCurrent(v TableDrawChannelIdx) {
	vArg, _ := v.c()

	selfArg, selfFin := self.handle()
	defer selfFin()
	C.wrap_ImGuiTableColumn_SetDrawChannelCurrent(selfArg, vArg)
}

func (self *TableColumn) DrawChannelCurrent() TableDrawChannelIdx {
	selfArg, selfFin := self.handle()

	defer func() {
		selfFin()
	}()

	result := C.wrap_ImGuiTableColumn_GetDrawChannelCurrent(selfArg)
	return *newTableDrawChannelIdxFromC(func() *C.ImGuiTableDrawChannelIdx { result := result; return &result }())
}

func (self TableColumn) SetDrawChannelFrozen(v TableDrawChannelIdx) {
	vArg, _ := v.c()

	selfArg, selfFin := self.handle()
	defer selfFin()
	C.wrap_ImGuiTableColumn_SetDrawChannelFrozen(selfArg, vArg)
}

func (self *TableColumn) DrawChannelFrozen() TableDrawChannelIdx {
	selfArg, selfFin := self.handle()

	defer func() {
		selfFin()
	}()

	result := C.wrap_ImGuiTableColumn_GetDrawChannelFrozen(selfArg)
	return *newTableDrawChannelIdxFromC(func() *C.ImGuiTableDrawChannelIdx { result := result; return &result }())
}

func (self TableColumn) SetDrawChannelUnfrozen(v TableDrawChannelIdx) {
	vArg, _ := v.c()

	selfArg, selfFin := self.handle()
	defer selfFin()
	C.wrap_ImGuiTableColumn_SetDrawChannelUnfrozen(selfArg, vArg)
}

func (self *TableColumn) DrawChannelUnfrozen() TableDrawChannelIdx {
	selfArg, selfFin := self.handle()

	defer func() {
		selfFin()
	}()

	result := C.wrap_ImGuiTableColumn_GetDrawChannelUnfrozen(selfArg)
	return *newTableDrawChannelIdxFromC(func() *C.ImGuiTableDrawChannelIdx { result := result; return &result }())
}

func (self TableColumn) SetIsEnabled(v bool) {
	selfArg, selfFin := self.handle()
	defer selfFin()
	C.wrap_ImGuiTableColumn_SetIsEnabled(selfArg, C.bool(v))
}

func (self *TableColumn) IsEnabled() bool {
	selfArg, selfFin := self.handle()

	defer func() {
		selfFin()
	}()
	return C.wrap_ImGuiTableColumn_GetIsEnabled(selfArg) == C.bool(true)
}

func (self TableColumn) SetIsUserEnabled(v bool) {
	selfArg, selfFin := self.handle()
	defer selfFin()
	C.wrap_ImGuiTableColumn_SetIsUserEnabled(selfArg, C.bool(v))
}

func (self *TableColumn) IsUserEnabled() bool {
	selfArg, selfFin := self.handle()

	defer func() {
		selfFin()
	}()
	return C.wrap_ImGuiTableColumn_GetIsUserEnabled(selfArg) == C.bool(true)
}

func (self TableColumn) SetIsUserEnabledNextFrame(v bool) {
	selfArg, selfFin := self.handle()
	defer selfFin()
	C.wrap_ImGuiTableColumn_SetIsUserEnabledNextFrame(selfArg, C.bool(v))
}

func (self *TableColumn) IsUserEnabledNextFrame() bool {
	selfArg, selfFin := self.handle()

	defer func() {
		selfFin()
	}()
	return C.wrap_ImGuiTableColumn_GetIsUserEnabledNextFrame(selfArg) == C.bool(true)
}

func (self TableColumn) SetIsVisibleX(v bool) {
	selfArg, selfFin := self.handle()
	defer selfFin()
	C.wrap_ImGuiTableColumn_SetIsVisibleX(selfArg, C.bool(v))
}

func (self *TableColumn) IsVisibleX() bool {
	selfArg, selfFin := self.handle()

	defer func() {
		selfFin()
	}()
	return C.wrap_ImGuiTableColumn_GetIsVisibleX(selfArg) == C.bool(true)
}

func (self TableColumn) SetIsVisibleY(v bool) {
	selfArg, selfFin := self.handle()
	defer selfFin()
	C.wrap_ImGuiTableColumn_SetIsVisibleY(selfArg, C.bool(v))
}

func (self *TableColumn) IsVisibleY() bool {
	selfArg, selfFin := self.handle()

	defer func() {
		selfFin()
	}()
	return C.wrap_ImGuiTableColumn_GetIsVisibleY(selfArg) == C.bool(true)
}

func (self TableColumn) SetIsRequestOutput(v bool) {
	selfArg, selfFin := self.handle()
	defer selfFin()
	C.wrap_ImGuiTableColumn_SetIsRequestOutput(selfArg, C.bool(v))
}

func (self *TableColumn) IsRequestOutput() bool {
	selfArg, selfFin := self.handle()

	defer func() {
		selfFin()
	}()
	return C.wrap_ImGuiTableColumn_GetIsRequestOutput(selfArg) == C.bool(true)
}

func (self TableColumn) SetIsSkipItems(v bool) {
	selfArg, selfFin := self.handle()
	defer selfFin()
	C.wrap_ImGuiTableColumn_SetIsSkipItems(selfArg, C.bool(v))
}

func (self *TableColumn) IsSkipItems() bool {
	selfArg, selfFin := self.handle()

	defer func() {
		selfFin()
	}()
	return C.wrap_ImGuiTableColumn_GetIsSkipItems(selfArg) == C.bool(true)
}

func (self TableColumn) SetIsPreserveWidthAuto(v bool) {
	selfArg, selfFin := self.handle()
	defer selfFin()
	C.wrap_ImGuiTableColumn_SetIsPreserveWidthAuto(selfArg, C.bool(v))
}

func (self *TableColumn) IsPreserveWidthAuto() bool {
	selfArg, selfFin := self.handle()

	defer func() {
		selfFin()
	}()
	return C.wrap_ImGuiTableColumn_GetIsPreserveWidthAuto(selfArg) == C.bool(true)
}

func (self TableColumn) SetNavLayerCurrent(v int) {
	selfArg, selfFin := self.handle()
	defer selfFin()
	C.wrap_ImGuiTableColumn_SetNavLayerCurrent(selfArg, C.ImS8(v))
}

func (self *TableColumn) NavLayerCurrent() int {
	selfArg, selfFin := self.handle()

	defer func() {
		selfFin()
	}()
	return int(C.wrap_ImGuiTableColumn_GetNavLayerCurrent(selfArg))
}

func (self TableColumn) SetAutoFitQueue(v byte) {
	selfArg, selfFin := self.handle()
	defer selfFin()
	C.wrap_ImGuiTableColumn_SetAutoFitQueue(selfArg, C.ImU8(v))
}

func (self *TableColumn) AutoFitQueue() byte {
	selfArg, selfFin := self.handle()

	defer func() {
		selfFin()
	}()
	return byte(C.wrap_ImGuiTableColumn_GetAutoFitQueue(selfArg))
}

func (self TableColumn) SetCannotSkipItemsQueue(v byte) {
	selfArg, selfFin := self.handle()
	defer selfFin()
	C.wrap_ImGuiTableColumn_SetCannotSkipItemsQueue(selfArg, C.ImU8(v))
}

func (self *TableColumn) CannotSkipItemsQueue() byte {
	selfArg, selfFin := self.handle()

	defer func() {
		selfFin()
	}()
	return byte(C.wrap_ImGuiTableColumn_GetCannotSkipItemsQueue(selfArg))
}

func (self TableColumn) SetSortDirection(v byte) {
	selfArg, selfFin := self.handle()
	defer selfFin()
	C.wrap_ImGuiTableColumn_SetSortDirection(selfArg, C.ImU8(v))
}

func (self *TableColumn) SortDirection() byte {
	selfArg, selfFin := self.handle()

	defer func() {
		selfFin()
	}()
	return byte(C.wrap_ImGuiTableColumn_GetSortDirection(selfArg))
}

func (self TableColumn) SetSortDirectionsAvailCount(v byte) {
	selfArg, selfFin := self.handle()
	defer selfFin()
	C.wrap_ImGuiTableColumn_SetSortDirectionsAvailCount(selfArg, C.ImU8(v))
}

func (self *TableColumn) SortDirectionsAvailCount() byte {
	selfArg, selfFin := self.handle()

	defer func() {
		selfFin()
	}()
	return byte(C.wrap_ImGuiTableColumn_GetSortDirectionsAvailCount(selfArg))
}

func (self TableColumn) SetSortDirectionsAvailMask(v byte) {
	selfArg, selfFin := self.handle()
	defer selfFin()
	C.wrap_ImGuiTableColumn_SetSortDirectionsAvailMask(selfArg, C.ImU8(v))
}

func (self *TableColumn) SortDirectionsAvailMask() byte {
	selfArg, selfFin := self.handle()

	defer func() {
		selfFin()
	}()
	return byte(C.wrap_ImGuiTableColumn_GetSortDirectionsAvailMask(selfArg))
}

func (self TableColumn) SetSortDirectionsAvailList(v byte) {
	selfArg, selfFin := self.handle()
	defer selfFin()
	C.wrap_ImGuiTableColumn_SetSortDirectionsAvailList(selfArg, C.ImU8(v))
}

func (self *TableColumn) SortDirectionsAvailList() byte {
	selfArg, selfFin := self.handle()

	defer func() {
		selfFin()
	}()
	return byte(C.wrap_ImGuiTableColumn_GetSortDirectionsAvailList(selfArg))
}

func (self TableColumnSettings) SetWidthOrWeight(v float32) {
	selfArg, selfFin := self.handle()
	defer selfFin()
	C.wrap_ImGuiTableColumnSettings_SetWidthOrWeight(selfArg, C.float(v))
}

func (self *TableColumnSettings) WidthOrWeight() float32 {
	selfArg, selfFin := self.handle()

	defer func() {
		selfFin()
	}()
	return float32(C.wrap_ImGuiTableColumnSettings_GetWidthOrWeight(selfArg))
}

func (self TableColumnSettings) SetUserID(v ID) {
	vArg, _ := v.c()

	selfArg, selfFin := self.handle()
	defer selfFin()
	C.wrap_ImGuiTableColumnSettings_SetUserID(selfArg, vArg)
}

func (self *TableColumnSettings) UserID() ID {
	selfArg, selfFin := self.handle()

	defer func() {
		selfFin()
	}()

	result := C.wrap_ImGuiTableColumnSettings_GetUserID(selfArg)
	return *newIDFromC(func() *C.ImGuiID { result := result; return &result }())
}

func (self TableColumnSettings) SetSortDirection(v byte) {
	selfArg, selfFin := self.handle()
	defer selfFin()
	C.wrap_ImGuiTableColumnSettings_SetSortDirection(selfArg, C.ImU8(v))
}

func (self *TableColumnSettings) SortDirection() byte {
	selfArg, selfFin := self.handle()

	defer func() {
		selfFin()
	}()
	return byte(C.wrap_ImGuiTableColumnSettings_GetSortDirection(selfArg))
}

func (self TableColumnSettings) SetIsEnabled(v byte) {
	selfArg, selfFin := self.handle()
	defer selfFin()
	C.wrap_ImGuiTableColumnSettings_SetIsEnabled(selfArg, C.ImU8(v))
}

func (self *TableColumnSettings) IsEnabled() byte {
	selfArg, selfFin := self.handle()

	defer func() {
		selfFin()
	}()
	return byte(C.wrap_ImGuiTableColumnSettings_GetIsEnabled(selfArg))
}

func (self TableColumnSettings) SetIsStretch(v byte) {
	selfArg, selfFin := self.handle()
	defer selfFin()
	C.wrap_ImGuiTableColumnSettings_SetIsStretch(selfArg, C.ImU8(v))
}

func (self *TableColumnSettings) IsStretch() byte {
	selfArg, selfFin := self.handle()

	defer func() {
		selfFin()
	}()
	return byte(C.wrap_ImGuiTableColumnSettings_GetIsStretch(selfArg))
}

func (self TableColumnSortSpecs) SetColumnUserID(v ID) {
	vArg, _ := v.c()

	selfArg, selfFin := self.handle()
	defer selfFin()
	C.wrap_ImGuiTableColumnSortSpecs_SetColumnUserID(selfArg, vArg)
}

func (self *TableColumnSortSpecs) ColumnUserID() ID {
	selfArg, selfFin := self.handle()

	defer func() {
		selfFin()
	}()

	result := C.wrap_ImGuiTableColumnSortSpecs_GetColumnUserID(selfArg)
	return *newIDFromC(func() *C.ImGuiID { result := result; return &result }())
}

func (self TableColumnSortSpecs) SetColumnIndex(v int) {
	selfArg, selfFin := self.handle()
	defer selfFin()
	C.wrap_ImGuiTableColumnSortSpecs_SetColumnIndex(selfArg, C.ImS16(v))
}

func (self *TableColumnSortSpecs) ColumnIndex() int {
	selfArg, selfFin := self.handle()

	defer func() {
		selfFin()
	}()
	return int(C.wrap_ImGuiTableColumnSortSpecs_GetColumnIndex(selfArg))
}

func (self TableColumnSortSpecs) SetSortOrder(v int) {
	selfArg, selfFin := self.handle()
	defer selfFin()
	C.wrap_ImGuiTableColumnSortSpecs_SetSortOrder(selfArg, C.ImS16(v))
}

func (self *TableColumnSortSpecs) SortOrder() int {
	selfArg, selfFin := self.handle()

	defer func() {
		selfFin()
	}()
	return int(C.wrap_ImGuiTableColumnSortSpecs_GetSortOrder(selfArg))
}

func (self TableColumnSortSpecs) SetSortDirection(v SortDirection) {
	selfArg, selfFin := self.handle()
	defer selfFin()
	C.wrap_ImGuiTableColumnSortSpecs_SetSortDirection(selfArg, C.ImGuiSortDirection(v))
}

func (self *TableColumnSortSpecs) SortDirection() SortDirection {
	selfArg, selfFin := self.handle()

	defer func() {
		selfFin()
	}()
	return SortDirection(C.wrap_ImGuiTableColumnSortSpecs_GetSortDirection(selfArg))
}

func (self TableInstanceData) SetTableInstanceID(v ID) {
	vArg, _ := v.c()

	selfArg, selfFin := self.handle()
	defer selfFin()
	C.wrap_ImGuiTableInstanceData_SetTableInstanceID(selfArg, vArg)
}

func (self *TableInstanceData) TableInstanceID() ID {
	selfArg, selfFin := self.handle()

	defer func() {
		selfFin()
	}()

	result := C.wrap_ImGuiTableInstanceData_GetTableInstanceID(selfArg)
	return *newIDFromC(func() *C.ImGuiID { result := result; return &result }())
}

func (self TableInstanceData) SetLastOuterHeight(v float32) {
	selfArg, selfFin := self.handle()
	defer selfFin()
	C.wrap_ImGuiTableInstanceData_SetLastOuterHeight(selfArg, C.float(v))
}

func (self *TableInstanceData) LastOuterHeight() float32 {
	selfArg, selfFin := self.handle()

	defer func() {
		selfFin()
	}()
	return float32(C.wrap_ImGuiTableInstanceData_GetLastOuterHeight(selfArg))
}

func (self TableInstanceData) SetLastFirstRowHeight(v float32) {
	selfArg, selfFin := self.handle()
	defer selfFin()
	C.wrap_ImGuiTableInstanceData_SetLastFirstRowHeight(selfArg, C.float(v))
}

func (self *TableInstanceData) LastFirstRowHeight() float32 {
	selfArg, selfFin := self.handle()

	defer func() {
		selfFin()
	}()
	return float32(C.wrap_ImGuiTableInstanceData_GetLastFirstRowHeight(selfArg))
}

func (self TableInstanceData) SetLastFrozenHeight(v float32) {
	selfArg, selfFin := self.handle()
	defer selfFin()
	C.wrap_ImGuiTableInstanceData_SetLastFrozenHeight(selfArg, C.float(v))
}

func (self *TableInstanceData) LastFrozenHeight() float32 {
	selfArg, selfFin := self.handle()

	defer func() {
		selfFin()
	}()
	return float32(C.wrap_ImGuiTableInstanceData_GetLastFrozenHeight(selfArg))
}

func (self TableInstanceData) SetHoveredRowLast(v int32) {
	selfArg, selfFin := self.handle()
	defer selfFin()
	C.wrap_ImGuiTableInstanceData_SetHoveredRowLast(selfArg, C.int(v))
}

func (self *TableInstanceData) HoveredRowLast() int32 {
	selfArg, selfFin := self.handle()

	defer func() {
		selfFin()
	}()
	return int32(C.wrap_ImGuiTableInstanceData_GetHoveredRowLast(selfArg))
}

func (self TableInstanceData) SetHoveredRowNext(v int32) {
	selfArg, selfFin := self.handle()
	defer selfFin()
	C.wrap_ImGuiTableInstanceData_SetHoveredRowNext(selfArg, C.int(v))
}

func (self *TableInstanceData) HoveredRowNext() int32 {
	selfArg, selfFin := self.handle()

	defer func() {
		selfFin()
	}()
	return int32(C.wrap_ImGuiTableInstanceData_GetHoveredRowNext(selfArg))
}

func (self TableSettings) SetID(v ID) {
	vArg, _ := v.c()

	selfArg, selfFin := self.handle()
	defer selfFin()
	C.wrap_ImGuiTableSettings_SetID(selfArg, vArg)
}

func (self *TableSettings) ID() ID {
	selfArg, selfFin := self.handle()

	defer func() {
		selfFin()
	}()

	result := C.wrap_ImGuiTableSettings_GetID(selfArg)
	return *newIDFromC(func() *C.ImGuiID { result := result; return &result }())
}

func (self TableSettings) SetSaveFlags(v TableFlags) {
	selfArg, selfFin := self.handle()
	defer selfFin()
	C.wrap_ImGuiTableSettings_SetSaveFlags(selfArg, C.ImGuiTableFlags(v))
}

func (self *TableSettings) SaveFlags() TableFlags {
	selfArg, selfFin := self.handle()

	defer func() {
		selfFin()
	}()
	return TableFlags(C.wrap_ImGuiTableSettings_GetSaveFlags(selfArg))
}

func (self TableSettings) SetRefScale(v float32) {
	selfArg, selfFin := self.handle()
	defer selfFin()
	C.wrap_ImGuiTableSettings_SetRefScale(selfArg, C.float(v))
}

func (self *TableSettings) RefScale() float32 {
	selfArg, selfFin := self.handle()

	defer func() {
		selfFin()
	}()
	return float32(C.wrap_ImGuiTableSettings_GetRefScale(selfArg))
}

func (self TableSettings) SetWantApply(v bool) {
	selfArg, selfFin := self.handle()
	defer selfFin()
	C.wrap_ImGuiTableSettings_SetWantApply(selfArg, C.bool(v))
}

func (self *TableSettings) WantApply() bool {
	selfArg, selfFin := self.handle()

	defer func() {
		selfFin()
	}()
	return C.wrap_ImGuiTableSettings_GetWantApply(selfArg) == C.bool(true)
}

func (self TableSortSpecs) SetSpecs(v *TableColumnSortSpecs) {
	vArg, _ := v.handle()

	selfArg, selfFin := self.handle()
	defer selfFin()
	C.wrap_ImGuiTableSortSpecs_SetSpecs(selfArg, vArg)
}

func (self *TableSortSpecs) Specs() *TableColumnSortSpecs {
	selfArg, selfFin := self.handle()

	defer func() {
		selfFin()
	}()
	return newTableColumnSortSpecsFromC(C.wrap_ImGuiTableSortSpecs_GetSpecs(selfArg))
}

func (self TableSortSpecs) SetSpecsCount(v int32) {
	selfArg, selfFin := self.handle()
	defer selfFin()
	C.wrap_ImGuiTableSortSpecs_SetSpecsCount(selfArg, C.int(v))
}

func (self *TableSortSpecs) SpecsCount() int32 {
	selfArg, selfFin := self.handle()

	defer func() {
		selfFin()
	}()
	return int32(C.wrap_ImGuiTableSortSpecs_GetSpecsCount(selfArg))
}

func (self TableSortSpecs) SetSpecsDirty(v bool) {
	selfArg, selfFin := self.handle()
	defer selfFin()
	C.wrap_ImGuiTableSortSpecs_SetSpecsDirty(selfArg, C.bool(v))
}

func (self *TableSortSpecs) SpecsDirty() bool {
	selfArg, selfFin := self.handle()

	defer func() {
		selfFin()
	}()
	return C.wrap_ImGuiTableSortSpecs_GetSpecsDirty(selfArg) == C.bool(true)
}

func (self TableTempData) SetTableIndex(v int32) {
	selfArg, selfFin := self.handle()
	defer selfFin()
	C.wrap_ImGuiTableTempData_SetTableIndex(selfArg, C.int(v))
}

func (self *TableTempData) TableIndex() int32 {
	selfArg, selfFin := self.handle()

	defer func() {
		selfFin()
	}()
	return int32(C.wrap_ImGuiTableTempData_GetTableIndex(selfArg))
}

func (self TableTempData) SetLastTimeActive(v float32) {
	selfArg, selfFin := self.handle()
	defer selfFin()
	C.wrap_ImGuiTableTempData_SetLastTimeActive(selfArg, C.float(v))
}

func (self *TableTempData) LastTimeActive() float32 {
	selfArg, selfFin := self.handle()

	defer func() {
		selfFin()
	}()
	return float32(C.wrap_ImGuiTableTempData_GetLastTimeActive(selfArg))
}

func (self TableTempData) SetUserOuterSize(v Vec2) {
	selfArg, selfFin := self.handle()
	defer selfFin()
	C.wrap_ImGuiTableTempData_SetUserOuterSize(selfArg, v.toC())
}

func (self *TableTempData) UserOuterSize() Vec2 {
	selfArg, selfFin := self.handle()

	defer func() {
		selfFin()
	}()
	return *(&Vec2{}).fromC(C.wrap_ImGuiTableTempData_GetUserOuterSize(selfArg))
}

func (self TableTempData) SetDrawSplitter(v DrawListSplitter) {
	vArg, _ := v.c()

	selfArg, selfFin := self.handle()
	defer selfFin()
	C.wrap_ImGuiTableTempData_SetDrawSplitter(selfArg, vArg)
}

func (self *TableTempData) DrawSplitter() DrawListSplitter {
	selfArg, selfFin := self.handle()

	defer func() {
		selfFin()
	}()

	result := C.wrap_ImGuiTableTempData_GetDrawSplitter(selfArg)
	return *newDrawListSplitterFromC(func() *C.ImDrawListSplitter { result := result; return &result }())
}

func (self TableTempData) SetHostBackupWorkRect(v Rect) {
	selfArg, selfFin := self.handle()
	defer selfFin()
	C.wrap_ImGuiTableTempData_SetHostBackupWorkRect(selfArg, v.toC())
}

func (self *TableTempData) HostBackupWorkRect() Rect {
	selfArg, selfFin := self.handle()

	defer func() {
		selfFin()
	}()
	return *(&Rect{}).fromC(C.wrap_ImGuiTableTempData_GetHostBackupWorkRect(selfArg))
}

func (self TableTempData) SetHostBackupParentWorkRect(v Rect) {
	selfArg, selfFin := self.handle()
	defer selfFin()
	C.wrap_ImGuiTableTempData_SetHostBackupParentWorkRect(selfArg, v.toC())
}

func (self *TableTempData) HostBackupParentWorkRect() Rect {
	selfArg, selfFin := self.handle()

	defer func() {
		selfFin()
	}()
	return *(&Rect{}).fromC(C.wrap_ImGuiTableTempData_GetHostBackupParentWorkRect(selfArg))
}

func (self TableTempData) SetHostBackupPrevLineSize(v Vec2) {
	selfArg, selfFin := self.handle()
	defer selfFin()
	C.wrap_ImGuiTableTempData_SetHostBackupPrevLineSize(selfArg, v.toC())
}

func (self *TableTempData) HostBackupPrevLineSize() Vec2 {
	selfArg, selfFin := self.handle()

	defer func() {
		selfFin()
	}()
	return *(&Vec2{}).fromC(C.wrap_ImGuiTableTempData_GetHostBackupPrevLineSize(selfArg))
}

func (self TableTempData) SetHostBackupCurrLineSize(v Vec2) {
	selfArg, selfFin := self.handle()
	defer selfFin()
	C.wrap_ImGuiTableTempData_SetHostBackupCurrLineSize(selfArg, v.toC())
}

func (self *TableTempData) HostBackupCurrLineSize() Vec2 {
	selfArg, selfFin := self.handle()

	defer func() {
		selfFin()
	}()
	return *(&Vec2{}).fromC(C.wrap_ImGuiTableTempData_GetHostBackupCurrLineSize(selfArg))
}

func (self TableTempData) SetHostBackupCursorMaxPos(v Vec2) {
	selfArg, selfFin := self.handle()
	defer selfFin()
	C.wrap_ImGuiTableTempData_SetHostBackupCursorMaxPos(selfArg, v.toC())
}

func (self *TableTempData) HostBackupCursorMaxPos() Vec2 {
	selfArg, selfFin := self.handle()

	defer func() {
		selfFin()
	}()
	return *(&Vec2{}).fromC(C.wrap_ImGuiTableTempData_GetHostBackupCursorMaxPos(selfArg))
}

func (self TableTempData) SetHostBackupColumnsOffset(v Vec1) {
	vArg, _ := v.c()

	selfArg, selfFin := self.handle()
	defer selfFin()
	C.wrap_ImGuiTableTempData_SetHostBackupColumnsOffset(selfArg, vArg)
}

func (self *TableTempData) HostBackupColumnsOffset() Vec1 {
	selfArg, selfFin := self.handle()

	defer func() {
		selfFin()
	}()

	result := C.wrap_ImGuiTableTempData_GetHostBackupColumnsOffset(selfArg)
	return *newVec1FromC(func() *C.ImVec1 { result := result; return &result }())
}

func (self TableTempData) SetHostBackupItemWidth(v float32) {
	selfArg, selfFin := self.handle()
	defer selfFin()
	C.wrap_ImGuiTableTempData_SetHostBackupItemWidth(selfArg, C.float(v))
}

func (self *TableTempData) HostBackupItemWidth() float32 {
	selfArg, selfFin := self.handle()

	defer func() {
		selfFin()
	}()
	return float32(C.wrap_ImGuiTableTempData_GetHostBackupItemWidth(selfArg))
}

func (self TableTempData) SetHostBackupItemWidthStackSize(v int32) {
	selfArg, selfFin := self.handle()
	defer selfFin()
	C.wrap_ImGuiTableTempData_SetHostBackupItemWidthStackSize(selfArg, C.int(v))
}

func (self *TableTempData) HostBackupItemWidthStackSize() int32 {
	selfArg, selfFin := self.handle()

	defer func() {
		selfFin()
	}()
	return int32(C.wrap_ImGuiTableTempData_GetHostBackupItemWidthStackSize(selfArg))
}

func (self TextBuffer) SetBuf(v Vector[string]) {
	vData := v.Data
	vDataArg, _ := WrapString(vData)
	vVecArg := new(C.ImVector_char)
	vVecArg.Size = C.int(v.Size)
	vVecArg.Capacity = C.int(v.Capacity)
	vVecArg.Data = vDataArg
	v.pinner.Pin(vVecArg.Data)

	selfArg, selfFin := self.handle()
	defer selfFin()
	C.wrap_ImGuiTextBuffer_SetBuf(selfArg, *vVecArg)
}

func (self *TextBuffer) Buf() Vector[string] {
	selfArg, selfFin := self.handle()

	defer func() {
		selfFin()
	}()
	return newVectorFromC(C.wrap_ImGuiTextBuffer_GetBuf(selfArg).Size, C.wrap_ImGuiTextBuffer_GetBuf(selfArg).Capacity, C.GoString(C.wrap_ImGuiTextBuffer_GetBuf(selfArg).Data))
}

func (self TextFilter) SetFilters(v Vector[*TextRange]) {
	vData := v.Data
	vDataArg, _ := vData.handle()
	vVecArg := new(C.ImVector_ImGuiTextRange)
	vVecArg.Size = C.int(v.Size)
	vVecArg.Capacity = C.int(v.Capacity)
	vVecArg.Data = vDataArg
	v.pinner.Pin(vVecArg.Data)

	selfArg, selfFin := self.handle()
	defer selfFin()
	C.wrap_ImGuiTextFilter_SetFilters(selfArg, *vVecArg)
}

func (self *TextFilter) Filters() Vector[*TextRange] {
	selfArg, selfFin := self.handle()

	defer func() {
		selfFin()
	}()
	return newVectorFromC(C.wrap_ImGuiTextFilter_GetFilters(selfArg).Size, C.wrap_ImGuiTextFilter_GetFilters(selfArg).Capacity, newTextRangeFromC(C.wrap_ImGuiTextFilter_GetFilters(selfArg).Data))
}

func (self TextFilter) SetCountGrep(v int32) {
	selfArg, selfFin := self.handle()
	defer selfFin()
	C.wrap_ImGuiTextFilter_SetCountGrep(selfArg, C.int(v))
}

func (self *TextFilter) CountGrep() int32 {
	selfArg, selfFin := self.handle()

	defer func() {
		selfFin()
	}()
	return int32(C.wrap_ImGuiTextFilter_GetCountGrep(selfArg))
}

func (self TextIndex) SetLineOffsets(v Vector[*int32]) {
	vData := v.Data
	vDataArg, _ := WrapNumberPtr[C.int, int32](vData)
	vVecArg := new(C.ImVector_int)
	vVecArg.Size = C.int(v.Size)
	vVecArg.Capacity = C.int(v.Capacity)
	vVecArg.Data = vDataArg
	v.pinner.Pin(vVecArg.Data)

	selfArg, selfFin := self.handle()
	defer selfFin()
	C.wrap_ImGuiTextIndex_SetLineOffsets(selfArg, *vVecArg)
}

func (self *TextIndex) LineOffsets() Vector[*int32] {
	selfArg, selfFin := self.handle()

	defer func() {
		selfFin()
	}()
	return newVectorFromC(C.wrap_ImGuiTextIndex_GetLineOffsets(selfArg).Size, C.wrap_ImGuiTextIndex_GetLineOffsets(selfArg).Capacity, (*int32)(C.wrap_ImGuiTextIndex_GetLineOffsets(selfArg).Data))
}

func (self TextIndex) SetEndOffset(v int32) {
	selfArg, selfFin := self.handle()
	defer selfFin()
	C.wrap_ImGuiTextIndex_SetEndOffset(selfArg, C.int(v))
}

func (self *TextIndex) EndOffset() int32 {
	selfArg, selfFin := self.handle()

	defer func() {
		selfFin()
	}()
	return int32(C.wrap_ImGuiTextIndex_GetEndOffset(selfArg))
}

func (self TextRange) SetB(v string) {
	vArg, _ := WrapString(v)

	selfArg, selfFin := self.handle()
	defer selfFin()
	C.wrap_ImGuiTextRange_SetB(selfArg, vArg)
}

func (self *TextRange) B() string {
	selfArg, selfFin := self.handle()

	defer func() {
		selfFin()
	}()
	return C.GoString(C.wrap_ImGuiTextRange_GetB(selfArg))
}

func (self TextRange) SetE(v string) {
	vArg, _ := WrapString(v)

	selfArg, selfFin := self.handle()
	defer selfFin()
	C.wrap_ImGuiTextRange_SetE(selfArg, vArg)
}

func (self *TextRange) E() string {
	selfArg, selfFin := self.handle()

	defer func() {
		selfFin()
	}()
	return C.GoString(C.wrap_ImGuiTextRange_GetE(selfArg))
}

func (self TypingSelectRequest) SetFlags(v TypingSelectFlags) {
	selfArg, selfFin := self.handle()
	defer selfFin()
	C.wrap_ImGuiTypingSelectRequest_SetFlags(selfArg, C.ImGuiTypingSelectFlags(v))
}

func (self *TypingSelectRequest) Flags() TypingSelectFlags {
	selfArg, selfFin := self.handle()

	defer func() {
		selfFin()
	}()
	return TypingSelectFlags(C.wrap_ImGuiTypingSelectRequest_GetFlags(selfArg))
}

func (self TypingSelectRequest) SetSearchBufferLen(v int32) {
	selfArg, selfFin := self.handle()
	defer selfFin()
	C.wrap_ImGuiTypingSelectRequest_SetSearchBufferLen(selfArg, C.int(v))
}

func (self *TypingSelectRequest) SearchBufferLen() int32 {
	selfArg, selfFin := self.handle()

	defer func() {
		selfFin()
	}()
	return int32(C.wrap_ImGuiTypingSelectRequest_GetSearchBufferLen(selfArg))
}

func (self TypingSelectRequest) SetSearchBuffer(v string) {
	vArg, _ := WrapString(v)

	selfArg, selfFin := self.handle()
	defer selfFin()
	C.wrap_ImGuiTypingSelectRequest_SetSearchBuffer(selfArg, vArg)
}

func (self *TypingSelectRequest) SearchBuffer() string {
	selfArg, selfFin := self.handle()

	defer func() {
		selfFin()
	}()
	return C.GoString(C.wrap_ImGuiTypingSelectRequest_GetSearchBuffer(selfArg))
}

func (self TypingSelectRequest) SetSelectRequest(v bool) {
	selfArg, selfFin := self.handle()
	defer selfFin()
	C.wrap_ImGuiTypingSelectRequest_SetSelectRequest(selfArg, C.bool(v))
}

func (self *TypingSelectRequest) SelectRequest() bool {
	selfArg, selfFin := self.handle()

	defer func() {
		selfFin()
	}()
	return C.wrap_ImGuiTypingSelectRequest_GetSelectRequest(selfArg) == C.bool(true)
}

func (self TypingSelectRequest) SetSingleCharMode(v bool) {
	selfArg, selfFin := self.handle()
	defer selfFin()
	C.wrap_ImGuiTypingSelectRequest_SetSingleCharMode(selfArg, C.bool(v))
}

func (self *TypingSelectRequest) SingleCharMode() bool {
	selfArg, selfFin := self.handle()

	defer func() {
		selfFin()
	}()
	return C.wrap_ImGuiTypingSelectRequest_GetSingleCharMode(selfArg) == C.bool(true)
}

func (self TypingSelectRequest) SetSingleCharSize(v int) {
	selfArg, selfFin := self.handle()
	defer selfFin()
	C.wrap_ImGuiTypingSelectRequest_SetSingleCharSize(selfArg, C.ImS8(v))
}

func (self *TypingSelectRequest) SingleCharSize() int {
	selfArg, selfFin := self.handle()

	defer func() {
		selfFin()
	}()
	return int(C.wrap_ImGuiTypingSelectRequest_GetSingleCharSize(selfArg))
}

func (self TypingSelectState) SetRequest(v TypingSelectRequest) {
	vArg, _ := v.c()

	selfArg, selfFin := self.handle()
	defer selfFin()
	C.wrap_ImGuiTypingSelectState_SetRequest(selfArg, vArg)
}

func (self *TypingSelectState) Request() TypingSelectRequest {
	selfArg, selfFin := self.handle()

	defer func() {
		selfFin()
	}()

	result := C.wrap_ImGuiTypingSelectState_GetRequest(selfArg)
	return *newTypingSelectRequestFromC(func() *C.ImGuiTypingSelectRequest { result := result; return &result }())
}

func (self TypingSelectState) SetFocusScope(v ID) {
	vArg, _ := v.c()

	selfArg, selfFin := self.handle()
	defer selfFin()
	C.wrap_ImGuiTypingSelectState_SetFocusScope(selfArg, vArg)
}

func (self *TypingSelectState) FocusScope() ID {
	selfArg, selfFin := self.handle()

	defer func() {
		selfFin()
	}()

	result := C.wrap_ImGuiTypingSelectState_GetFocusScope(selfArg)
	return *newIDFromC(func() *C.ImGuiID { result := result; return &result }())
}

func (self TypingSelectState) SetLastRequestFrame(v int32) {
	selfArg, selfFin := self.handle()
	defer selfFin()
	C.wrap_ImGuiTypingSelectState_SetLastRequestFrame(selfArg, C.int(v))
}

func (self *TypingSelectState) LastRequestFrame() int32 {
	selfArg, selfFin := self.handle()

	defer func() {
		selfFin()
	}()
	return int32(C.wrap_ImGuiTypingSelectState_GetLastRequestFrame(selfArg))
}

func (self TypingSelectState) SetLastRequestTime(v float32) {
	selfArg, selfFin := self.handle()
	defer selfFin()
	C.wrap_ImGuiTypingSelectState_SetLastRequestTime(selfArg, C.float(v))
}

func (self *TypingSelectState) LastRequestTime() float32 {
	selfArg, selfFin := self.handle()

	defer func() {
		selfFin()
	}()
	return float32(C.wrap_ImGuiTypingSelectState_GetLastRequestTime(selfArg))
}

func (self TypingSelectState) SetSingleCharModeLock(v bool) {
	selfArg, selfFin := self.handle()
	defer selfFin()
	C.wrap_ImGuiTypingSelectState_SetSingleCharModeLock(selfArg, C.bool(v))
}

func (self *TypingSelectState) SingleCharModeLock() bool {
	selfArg, selfFin := self.handle()

	defer func() {
		selfFin()
	}()
	return C.wrap_ImGuiTypingSelectState_GetSingleCharModeLock(selfArg) == C.bool(true)
}

func (self Viewport) SetID(v ID) {
	vArg, _ := v.c()

	selfArg, selfFin := self.handle()
	defer selfFin()
	C.wrap_ImGuiViewport_SetID(selfArg, vArg)
}

func (self *Viewport) ID() ID {
	selfArg, selfFin := self.handle()

	defer func() {
		selfFin()
	}()

	result := C.wrap_ImGuiViewport_GetID(selfArg)
	return *newIDFromC(func() *C.ImGuiID { result := result; return &result }())
}

func (self Viewport) SetFlags(v ViewportFlags) {
	selfArg, selfFin := self.handle()
	defer selfFin()
	C.wrap_ImGuiViewport_SetFlags(selfArg, C.ImGuiViewportFlags(v))
}

func (self *Viewport) Flags() ViewportFlags {
	selfArg, selfFin := self.handle()

	defer func() {
		selfFin()
	}()
	return ViewportFlags(C.wrap_ImGuiViewport_GetFlags(selfArg))
}

func (self Viewport) SetPos(v Vec2) {
	selfArg, selfFin := self.handle()
	defer selfFin()
	C.wrap_ImGuiViewport_SetPos(selfArg, v.toC())
}

func (self *Viewport) Pos() Vec2 {
	selfArg, selfFin := self.handle()

	defer func() {
		selfFin()
	}()
	return *(&Vec2{}).fromC(C.wrap_ImGuiViewport_GetPos(selfArg))
}

func (self Viewport) SetSize(v Vec2) {
	selfArg, selfFin := self.handle()
	defer selfFin()
	C.wrap_ImGuiViewport_SetSize(selfArg, v.toC())
}

func (self *Viewport) Size() Vec2 {
	selfArg, selfFin := self.handle()

	defer func() {
		selfFin()
	}()
	return *(&Vec2{}).fromC(C.wrap_ImGuiViewport_GetSize(selfArg))
}

func (self Viewport) SetWorkPos(v Vec2) {
	selfArg, selfFin := self.handle()
	defer selfFin()
	C.wrap_ImGuiViewport_SetWorkPos(selfArg, v.toC())
}

func (self *Viewport) WorkPos() Vec2 {
	selfArg, selfFin := self.handle()

	defer func() {
		selfFin()
	}()
	return *(&Vec2{}).fromC(C.wrap_ImGuiViewport_GetWorkPos(selfArg))
}

func (self Viewport) SetWorkSize(v Vec2) {
	selfArg, selfFin := self.handle()
	defer selfFin()
	C.wrap_ImGuiViewport_SetWorkSize(selfArg, v.toC())
}

func (self *Viewport) WorkSize() Vec2 {
	selfArg, selfFin := self.handle()

	defer func() {
		selfFin()
	}()
	return *(&Vec2{}).fromC(C.wrap_ImGuiViewport_GetWorkSize(selfArg))
}

func (self Viewport) SetDpiScale(v float32) {
	selfArg, selfFin := self.handle()
	defer selfFin()
	C.wrap_ImGuiViewport_SetDpiScale(selfArg, C.float(v))
}

func (self *Viewport) DpiScale() float32 {
	selfArg, selfFin := self.handle()

	defer func() {
		selfFin()
	}()
	return float32(C.wrap_ImGuiViewport_GetDpiScale(selfArg))
}

func (self Viewport) SetParentViewportId(v ID) {
	vArg, _ := v.c()

	selfArg, selfFin := self.handle()
	defer selfFin()
	C.wrap_ImGuiViewport_SetParentViewportId(selfArg, vArg)
}

func (self *Viewport) ParentViewportId() ID {
	selfArg, selfFin := self.handle()

	defer func() {
		selfFin()
	}()

	result := C.wrap_ImGuiViewport_GetParentViewportId(selfArg)
	return *newIDFromC(func() *C.ImGuiID { result := result; return &result }())
}

func (self Viewport) SetDrawData(v *DrawData) {
	vArg, _ := v.handle()

	selfArg, selfFin := self.handle()
	defer selfFin()
	C.wrap_ImGuiViewport_SetDrawData(selfArg, vArg)
}

func (self *Viewport) DrawData() *DrawData {
	selfArg, selfFin := self.handle()

	defer func() {
		selfFin()
	}()
	return newDrawDataFromC(C.wrap_ImGuiViewport_GetDrawData(selfArg))
}

func (self Viewport) SetRendererUserData(v unsafe.Pointer) {
	vArg, _ := WrapVoidPtr(v)

	selfArg, selfFin := self.handle()
	defer selfFin()
	C.wrap_ImGuiViewport_SetRendererUserData(selfArg, vArg)
}

func (self *Viewport) RendererUserData() unsafe.Pointer {
	selfArg, selfFin := self.handle()

	defer func() {
		selfFin()
	}()
	return unsafe.Pointer(C.wrap_ImGuiViewport_GetRendererUserData(selfArg))
}

func (self Viewport) SetPlatformUserData(v unsafe.Pointer) {
	vArg, _ := WrapVoidPtr(v)

	selfArg, selfFin := self.handle()
	defer selfFin()
	C.wrap_ImGuiViewport_SetPlatformUserData(selfArg, vArg)
}

func (self *Viewport) PlatformUserData() unsafe.Pointer {
	selfArg, selfFin := self.handle()

	defer func() {
		selfFin()
	}()
	return unsafe.Pointer(C.wrap_ImGuiViewport_GetPlatformUserData(selfArg))
}

func (self Viewport) SetPlatformHandle(v unsafe.Pointer) {
	vArg, _ := WrapVoidPtr(v)

	selfArg, selfFin := self.handle()
	defer selfFin()
	C.wrap_ImGuiViewport_SetPlatformHandle(selfArg, vArg)
}

func (self *Viewport) PlatformHandle() unsafe.Pointer {
	selfArg, selfFin := self.handle()

	defer func() {
		selfFin()
	}()
	return unsafe.Pointer(C.wrap_ImGuiViewport_GetPlatformHandle(selfArg))
}

func (self Viewport) SetPlatformHandleRaw(v unsafe.Pointer) {
	vArg, _ := WrapVoidPtr(v)

	selfArg, selfFin := self.handle()
	defer selfFin()
	C.wrap_ImGuiViewport_SetPlatformHandleRaw(selfArg, vArg)
}

func (self *Viewport) PlatformHandleRaw() unsafe.Pointer {
	selfArg, selfFin := self.handle()

	defer func() {
		selfFin()
	}()
	return unsafe.Pointer(C.wrap_ImGuiViewport_GetPlatformHandleRaw(selfArg))
}

func (self Viewport) SetPlatformWindowCreated(v bool) {
	selfArg, selfFin := self.handle()
	defer selfFin()
	C.wrap_ImGuiViewport_SetPlatformWindowCreated(selfArg, C.bool(v))
}

func (self *Viewport) PlatformWindowCreated() bool {
	selfArg, selfFin := self.handle()

	defer func() {
		selfFin()
	}()
	return C.wrap_ImGuiViewport_GetPlatformWindowCreated(selfArg) == C.bool(true)
}

func (self Viewport) SetPlatformRequestMove(v bool) {
	selfArg, selfFin := self.handle()
	defer selfFin()
	C.wrap_ImGuiViewport_SetPlatformRequestMove(selfArg, C.bool(v))
}

func (self *Viewport) PlatformRequestMove() bool {
	selfArg, selfFin := self.handle()

	defer func() {
		selfFin()
	}()
	return C.wrap_ImGuiViewport_GetPlatformRequestMove(selfArg) == C.bool(true)
}

func (self Viewport) SetPlatformRequestResize(v bool) {
	selfArg, selfFin := self.handle()
	defer selfFin()
	C.wrap_ImGuiViewport_SetPlatformRequestResize(selfArg, C.bool(v))
}

func (self *Viewport) PlatformRequestResize() bool {
	selfArg, selfFin := self.handle()

	defer func() {
		selfFin()
	}()
	return C.wrap_ImGuiViewport_GetPlatformRequestResize(selfArg) == C.bool(true)
}

func (self Viewport) SetPlatformRequestClose(v bool) {
	selfArg, selfFin := self.handle()
	defer selfFin()
	C.wrap_ImGuiViewport_SetPlatformRequestClose(selfArg, C.bool(v))
}

func (self *Viewport) PlatformRequestClose() bool {
	selfArg, selfFin := self.handle()

	defer func() {
		selfFin()
	}()
	return C.wrap_ImGuiViewport_GetPlatformRequestClose(selfArg) == C.bool(true)
}

func (self ViewportP) SetImGuiViewport(v Viewport) {
	vArg, _ := v.c()

	selfArg, selfFin := self.handle()
	defer selfFin()
	C.wrap_ImGuiViewportP_Set_ImGuiViewport(selfArg, vArg)
}

func (self *ViewportP) ImGuiViewport() Viewport {
	selfArg, selfFin := self.handle()

	defer func() {
		selfFin()
	}()

	result := C.wrap_ImGuiViewportP_Get_ImGuiViewport(selfArg)
	return *newViewportFromC(func() *C.ImGuiViewport { result := result; return &result }())
}

func (self ViewportP) SetWindow(v *Window) {
	vArg, _ := v.handle()

	selfArg, selfFin := self.handle()
	defer selfFin()
	C.wrap_ImGuiViewportP_SetWindow(selfArg, vArg)
}

func (self *ViewportP) Window() *Window {
	selfArg, selfFin := self.handle()

	defer func() {
		selfFin()
	}()
	return newWindowFromC(C.wrap_ImGuiViewportP_GetWindow(selfArg))
}

func (self ViewportP) SetIdx(v int32) {
	selfArg, selfFin := self.handle()
	defer selfFin()
	C.wrap_ImGuiViewportP_SetIdx(selfArg, C.int(v))
}

func (self *ViewportP) Idx() int32 {
	selfArg, selfFin := self.handle()

	defer func() {
		selfFin()
	}()
	return int32(C.wrap_ImGuiViewportP_GetIdx(selfArg))
}

func (self ViewportP) SetLastFrameActive(v int32) {
	selfArg, selfFin := self.handle()
	defer selfFin()
	C.wrap_ImGuiViewportP_SetLastFrameActive(selfArg, C.int(v))
}

func (self *ViewportP) LastFrameActive() int32 {
	selfArg, selfFin := self.handle()

	defer func() {
		selfFin()
	}()
	return int32(C.wrap_ImGuiViewportP_GetLastFrameActive(selfArg))
}

func (self ViewportP) SetLastFocusedStampCount(v int32) {
	selfArg, selfFin := self.handle()
	defer selfFin()
	C.wrap_ImGuiViewportP_SetLastFocusedStampCount(selfArg, C.int(v))
}

func (self *ViewportP) LastFocusedStampCount() int32 {
	selfArg, selfFin := self.handle()

	defer func() {
		selfFin()
	}()
	return int32(C.wrap_ImGuiViewportP_GetLastFocusedStampCount(selfArg))
}

func (self ViewportP) SetLastNameHash(v ID) {
	vArg, _ := v.c()

	selfArg, selfFin := self.handle()
	defer selfFin()
	C.wrap_ImGuiViewportP_SetLastNameHash(selfArg, vArg)
}

func (self *ViewportP) LastNameHash() ID {
	selfArg, selfFin := self.handle()

	defer func() {
		selfFin()
	}()

	result := C.wrap_ImGuiViewportP_GetLastNameHash(selfArg)
	return *newIDFromC(func() *C.ImGuiID { result := result; return &result }())
}

func (self ViewportP) SetLastPos(v Vec2) {
	selfArg, selfFin := self.handle()
	defer selfFin()
	C.wrap_ImGuiViewportP_SetLastPos(selfArg, v.toC())
}

func (self *ViewportP) LastPos() Vec2 {
	selfArg, selfFin := self.handle()

	defer func() {
		selfFin()
	}()
	return *(&Vec2{}).fromC(C.wrap_ImGuiViewportP_GetLastPos(selfArg))
}

func (self ViewportP) SetAlpha(v float32) {
	selfArg, selfFin := self.handle()
	defer selfFin()
	C.wrap_ImGuiViewportP_SetAlpha(selfArg, C.float(v))
}

func (self *ViewportP) Alpha() float32 {
	selfArg, selfFin := self.handle()

	defer func() {
		selfFin()
	}()
	return float32(C.wrap_ImGuiViewportP_GetAlpha(selfArg))
}

func (self ViewportP) SetLastAlpha(v float32) {
	selfArg, selfFin := self.handle()
	defer selfFin()
	C.wrap_ImGuiViewportP_SetLastAlpha(selfArg, C.float(v))
}

func (self *ViewportP) LastAlpha() float32 {
	selfArg, selfFin := self.handle()

	defer func() {
		selfFin()
	}()
	return float32(C.wrap_ImGuiViewportP_GetLastAlpha(selfArg))
}

func (self ViewportP) SetLastFocusedHadNavWindow(v bool) {
	selfArg, selfFin := self.handle()
	defer selfFin()
	C.wrap_ImGuiViewportP_SetLastFocusedHadNavWindow(selfArg, C.bool(v))
}

func (self *ViewportP) LastFocusedHadNavWindow() bool {
	selfArg, selfFin := self.handle()

	defer func() {
		selfFin()
	}()
	return C.wrap_ImGuiViewportP_GetLastFocusedHadNavWindow(selfArg) == C.bool(true)
}

func (self ViewportP) SetPlatformMonitor(v int16) {
	selfArg, selfFin := self.handle()
	defer selfFin()
	C.wrap_ImGuiViewportP_SetPlatformMonitor(selfArg, C.short(v))
}

func (self *ViewportP) PlatformMonitor() int16 {
	selfArg, selfFin := self.handle()

	defer func() {
		selfFin()
	}()
	return int16(C.wrap_ImGuiViewportP_GetPlatformMonitor(selfArg))
}

func (self ViewportP) SetBgFgDrawListsLastFrame(v *[2]int32) {
	vArg := make([]C.int, len(v))
	for i, vV := range v {
		vArg[i] = C.int(vV)
	}

	selfArg, selfFin := self.handle()
	defer selfFin()
	C.wrap_ImGuiViewportP_SetBgFgDrawListsLastFrame(selfArg, (*C.int)(&vArg[0]))
}

func (self ViewportP) SetDrawDataP(v DrawData) {
	vArg, _ := v.c()

	selfArg, selfFin := self.handle()
	defer selfFin()
	C.wrap_ImGuiViewportP_SetDrawDataP(selfArg, vArg)
}

func (self *ViewportP) DrawDataP() DrawData {
	selfArg, selfFin := self.handle()

	defer func() {
		selfFin()
	}()

	result := C.wrap_ImGuiViewportP_GetDrawDataP(selfArg)
	return *newDrawDataFromC(func() *C.ImDrawData { result := result; return &result }())
}

func (self ViewportP) SetDrawDataBuilder(v DrawDataBuilder) {
	vArg, _ := v.c()

	selfArg, selfFin := self.handle()
	defer selfFin()
	C.wrap_ImGuiViewportP_SetDrawDataBuilder(selfArg, vArg)
}

func (self *ViewportP) DrawDataBuilder() DrawDataBuilder {
	selfArg, selfFin := self.handle()

	defer func() {
		selfFin()
	}()

	result := C.wrap_ImGuiViewportP_GetDrawDataBuilder(selfArg)
	return *newDrawDataBuilderFromC(func() *C.ImDrawDataBuilder { result := result; return &result }())
}

func (self ViewportP) SetLastPlatformPos(v Vec2) {
	selfArg, selfFin := self.handle()
	defer selfFin()
	C.wrap_ImGuiViewportP_SetLastPlatformPos(selfArg, v.toC())
}

func (self *ViewportP) LastPlatformPos() Vec2 {
	selfArg, selfFin := self.handle()

	defer func() {
		selfFin()
	}()
	return *(&Vec2{}).fromC(C.wrap_ImGuiViewportP_GetLastPlatformPos(selfArg))
}

func (self ViewportP) SetLastPlatformSize(v Vec2) {
	selfArg, selfFin := self.handle()
	defer selfFin()
	C.wrap_ImGuiViewportP_SetLastPlatformSize(selfArg, v.toC())
}

func (self *ViewportP) LastPlatformSize() Vec2 {
	selfArg, selfFin := self.handle()

	defer func() {
		selfFin()
	}()
	return *(&Vec2{}).fromC(C.wrap_ImGuiViewportP_GetLastPlatformSize(selfArg))
}

func (self ViewportP) SetLastRendererSize(v Vec2) {
	selfArg, selfFin := self.handle()
	defer selfFin()
	C.wrap_ImGuiViewportP_SetLastRendererSize(selfArg, v.toC())
}

func (self *ViewportP) LastRendererSize() Vec2 {
	selfArg, selfFin := self.handle()

	defer func() {
		selfFin()
	}()
	return *(&Vec2{}).fromC(C.wrap_ImGuiViewportP_GetLastRendererSize(selfArg))
}

func (self ViewportP) SetWorkOffsetMin(v Vec2) {
	selfArg, selfFin := self.handle()
	defer selfFin()
	C.wrap_ImGuiViewportP_SetWorkOffsetMin(selfArg, v.toC())
}

func (self *ViewportP) WorkOffsetMin() Vec2 {
	selfArg, selfFin := self.handle()

	defer func() {
		selfFin()
	}()
	return *(&Vec2{}).fromC(C.wrap_ImGuiViewportP_GetWorkOffsetMin(selfArg))
}

func (self ViewportP) SetWorkOffsetMax(v Vec2) {
	selfArg, selfFin := self.handle()
	defer selfFin()
	C.wrap_ImGuiViewportP_SetWorkOffsetMax(selfArg, v.toC())
}

func (self *ViewportP) WorkOffsetMax() Vec2 {
	selfArg, selfFin := self.handle()

	defer func() {
		selfFin()
	}()
	return *(&Vec2{}).fromC(C.wrap_ImGuiViewportP_GetWorkOffsetMax(selfArg))
}

func (self ViewportP) SetBuildWorkOffsetMin(v Vec2) {
	selfArg, selfFin := self.handle()
	defer selfFin()
	C.wrap_ImGuiViewportP_SetBuildWorkOffsetMin(selfArg, v.toC())
}

func (self *ViewportP) BuildWorkOffsetMin() Vec2 {
	selfArg, selfFin := self.handle()

	defer func() {
		selfFin()
	}()
	return *(&Vec2{}).fromC(C.wrap_ImGuiViewportP_GetBuildWorkOffsetMin(selfArg))
}

func (self ViewportP) SetBuildWorkOffsetMax(v Vec2) {
	selfArg, selfFin := self.handle()
	defer selfFin()
	C.wrap_ImGuiViewportP_SetBuildWorkOffsetMax(selfArg, v.toC())
}

func (self *ViewportP) BuildWorkOffsetMax() Vec2 {
	selfArg, selfFin := self.handle()

	defer func() {
		selfFin()
	}()
	return *(&Vec2{}).fromC(C.wrap_ImGuiViewportP_GetBuildWorkOffsetMax(selfArg))
}

func (self Window) SetCtx(v *Context) {
	vArg, _ := v.handle()

	selfArg, selfFin := self.handle()
	defer selfFin()
	C.wrap_ImGuiWindow_SetCtx(selfArg, vArg)
}

func (self *Window) Ctx() *Context {
	selfArg, selfFin := self.handle()

	defer func() {
		selfFin()
	}()
	return newContextFromC(C.wrap_ImGuiWindow_GetCtx(selfArg))
}

func (self Window) SetName(v string) {
	vArg, _ := WrapString(v)

	selfArg, selfFin := self.handle()
	defer selfFin()
	C.wrap_ImGuiWindow_SetName(selfArg, vArg)
}

func (self *Window) Name() string {
	selfArg, selfFin := self.handle()

	defer func() {
		selfFin()
	}()
	return C.GoString(C.wrap_ImGuiWindow_GetName(selfArg))
}

func (self Window) SetID(v ID) {
	vArg, _ := v.c()

	selfArg, selfFin := self.handle()
	defer selfFin()
	C.wrap_ImGuiWindow_SetID(selfArg, vArg)
}

func (self *Window) ID() ID {
	selfArg, selfFin := self.handle()

	defer func() {
		selfFin()
	}()

	result := C.wrap_ImGuiWindow_GetID(selfArg)
	return *newIDFromC(func() *C.ImGuiID { result := result; return &result }())
}

func (self Window) SetFlags(v WindowFlags) {
	selfArg, selfFin := self.handle()
	defer selfFin()
	C.wrap_ImGuiWindow_SetFlags(selfArg, C.ImGuiWindowFlags(v))
}

func (self *Window) Flags() WindowFlags {
	selfArg, selfFin := self.handle()

	defer func() {
		selfFin()
	}()
	return WindowFlags(C.wrap_ImGuiWindow_GetFlags(selfArg))
}

func (self Window) SetFlagsPreviousFrame(v WindowFlags) {
	selfArg, selfFin := self.handle()
	defer selfFin()
	C.wrap_ImGuiWindow_SetFlagsPreviousFrame(selfArg, C.ImGuiWindowFlags(v))
}

func (self *Window) FlagsPreviousFrame() WindowFlags {
	selfArg, selfFin := self.handle()

	defer func() {
		selfFin()
	}()
	return WindowFlags(C.wrap_ImGuiWindow_GetFlagsPreviousFrame(selfArg))
}

func (self Window) SetWindowClass(v WindowClass) {
	vArg, _ := v.c()

	selfArg, selfFin := self.handle()
	defer selfFin()
	C.wrap_ImGuiWindow_SetWindowClass(selfArg, vArg)
}

func (self *Window) WindowClass() WindowClass {
	selfArg, selfFin := self.handle()

	defer func() {
		selfFin()
	}()

	result := C.wrap_ImGuiWindow_GetWindowClass(selfArg)
	return *newWindowClassFromC(func() *C.ImGuiWindowClass { result := result; return &result }())
}

func (self Window) SetViewport(v *ViewportP) {
	vArg, _ := v.handle()

	selfArg, selfFin := self.handle()
	defer selfFin()
	C.wrap_ImGuiWindow_SetViewport(selfArg, vArg)
}

func (self *Window) Viewport() *ViewportP {
	selfArg, selfFin := self.handle()

	defer func() {
		selfFin()
	}()
	return newViewportPFromC(C.wrap_ImGuiWindow_GetViewport(selfArg))
}

func (self Window) SetViewportId(v ID) {
	vArg, _ := v.c()

	selfArg, selfFin := self.handle()
	defer selfFin()
	C.wrap_ImGuiWindow_SetViewportId(selfArg, vArg)
}

func (self *Window) ViewportId() ID {
	selfArg, selfFin := self.handle()

	defer func() {
		selfFin()
	}()

	result := C.wrap_ImGuiWindow_GetViewportId(selfArg)
	return *newIDFromC(func() *C.ImGuiID { result := result; return &result }())
}

func (self Window) SetViewportPos(v Vec2) {
	selfArg, selfFin := self.handle()
	defer selfFin()
	C.wrap_ImGuiWindow_SetViewportPos(selfArg, v.toC())
}

func (self *Window) ViewportPos() Vec2 {
	selfArg, selfFin := self.handle()

	defer func() {
		selfFin()
	}()
	return *(&Vec2{}).fromC(C.wrap_ImGuiWindow_GetViewportPos(selfArg))
}

func (self Window) SetViewportAllowPlatformMonitorExtend(v int32) {
	selfArg, selfFin := self.handle()
	defer selfFin()
	C.wrap_ImGuiWindow_SetViewportAllowPlatformMonitorExtend(selfArg, C.int(v))
}

func (self *Window) ViewportAllowPlatformMonitorExtend() int32 {
	selfArg, selfFin := self.handle()

	defer func() {
		selfFin()
	}()
	return int32(C.wrap_ImGuiWindow_GetViewportAllowPlatformMonitorExtend(selfArg))
}

func (self Window) SetPos(v Vec2) {
	selfArg, selfFin := self.handle()
	defer selfFin()
	C.wrap_ImGuiWindow_SetPos(selfArg, v.toC())
}

func (self *Window) Pos() Vec2 {
	selfArg, selfFin := self.handle()

	defer func() {
		selfFin()
	}()
	return *(&Vec2{}).fromC(C.wrap_ImGuiWindow_GetPos(selfArg))
}

func (self Window) SetSize(v Vec2) {
	selfArg, selfFin := self.handle()
	defer selfFin()
	C.wrap_ImGuiWindow_SetSize(selfArg, v.toC())
}

func (self *Window) Size() Vec2 {
	selfArg, selfFin := self.handle()

	defer func() {
		selfFin()
	}()
	return *(&Vec2{}).fromC(C.wrap_ImGuiWindow_GetSize(selfArg))
}

func (self Window) SetSizeFull(v Vec2) {
	selfArg, selfFin := self.handle()
	defer selfFin()
	C.wrap_ImGuiWindow_SetSizeFull(selfArg, v.toC())
}

func (self *Window) SizeFull() Vec2 {
	selfArg, selfFin := self.handle()

	defer func() {
		selfFin()
	}()
	return *(&Vec2{}).fromC(C.wrap_ImGuiWindow_GetSizeFull(selfArg))
}

func (self Window) SetContentSize(v Vec2) {
	selfArg, selfFin := self.handle()
	defer selfFin()
	C.wrap_ImGuiWindow_SetContentSize(selfArg, v.toC())
}

func (self *Window) ContentSize() Vec2 {
	selfArg, selfFin := self.handle()

	defer func() {
		selfFin()
	}()
	return *(&Vec2{}).fromC(C.wrap_ImGuiWindow_GetContentSize(selfArg))
}

func (self Window) SetContentSizeIdeal(v Vec2) {
	selfArg, selfFin := self.handle()
	defer selfFin()
	C.wrap_ImGuiWindow_SetContentSizeIdeal(selfArg, v.toC())
}

func (self *Window) ContentSizeIdeal() Vec2 {
	selfArg, selfFin := self.handle()

	defer func() {
		selfFin()
	}()
	return *(&Vec2{}).fromC(C.wrap_ImGuiWindow_GetContentSizeIdeal(selfArg))
}

func (self Window) SetContentSizeExplicit(v Vec2) {
	selfArg, selfFin := self.handle()
	defer selfFin()
	C.wrap_ImGuiWindow_SetContentSizeExplicit(selfArg, v.toC())
}

func (self *Window) ContentSizeExplicit() Vec2 {
	selfArg, selfFin := self.handle()

	defer func() {
		selfFin()
	}()
	return *(&Vec2{}).fromC(C.wrap_ImGuiWindow_GetContentSizeExplicit(selfArg))
}

func (self Window) SetWindowPadding(v Vec2) {
	selfArg, selfFin := self.handle()
	defer selfFin()
	C.wrap_ImGuiWindow_SetWindowPadding(selfArg, v.toC())
}

func (self *Window) WindowPadding() Vec2 {
	selfArg, selfFin := self.handle()

	defer func() {
		selfFin()
	}()
	return *(&Vec2{}).fromC(C.wrap_ImGuiWindow_GetWindowPadding(selfArg))
}

func (self Window) SetWindowRounding(v float32) {
	selfArg, selfFin := self.handle()
	defer selfFin()
	C.wrap_ImGuiWindow_SetWindowRounding(selfArg, C.float(v))
}

func (self *Window) WindowRounding() float32 {
	selfArg, selfFin := self.handle()

	defer func() {
		selfFin()
	}()
	return float32(C.wrap_ImGuiWindow_GetWindowRounding(selfArg))
}

func (self Window) SetWindowBorderSize(v float32) {
	selfArg, selfFin := self.handle()
	defer selfFin()
	C.wrap_ImGuiWindow_SetWindowBorderSize(selfArg, C.float(v))
}

func (self *Window) WindowBorderSize() float32 {
	selfArg, selfFin := self.handle()

	defer func() {
		selfFin()
	}()
	return float32(C.wrap_ImGuiWindow_GetWindowBorderSize(selfArg))
}

func (self Window) SetDecoOuterSizeX1(v float32) {
	selfArg, selfFin := self.handle()
	defer selfFin()
	C.wrap_ImGuiWindow_SetDecoOuterSizeX1(selfArg, C.float(v))
}

func (self *Window) DecoOuterSizeX1() float32 {
	selfArg, selfFin := self.handle()

	defer func() {
		selfFin()
	}()
	return float32(C.wrap_ImGuiWindow_GetDecoOuterSizeX1(selfArg))
}

func (self Window) SetDecoOuterSizeY1(v float32) {
	selfArg, selfFin := self.handle()
	defer selfFin()
	C.wrap_ImGuiWindow_SetDecoOuterSizeY1(selfArg, C.float(v))
}

func (self *Window) DecoOuterSizeY1() float32 {
	selfArg, selfFin := self.handle()

	defer func() {
		selfFin()
	}()
	return float32(C.wrap_ImGuiWindow_GetDecoOuterSizeY1(selfArg))
}

func (self Window) SetDecoOuterSizeX2(v float32) {
	selfArg, selfFin := self.handle()
	defer selfFin()
	C.wrap_ImGuiWindow_SetDecoOuterSizeX2(selfArg, C.float(v))
}

func (self *Window) DecoOuterSizeX2() float32 {
	selfArg, selfFin := self.handle()

	defer func() {
		selfFin()
	}()
	return float32(C.wrap_ImGuiWindow_GetDecoOuterSizeX2(selfArg))
}

func (self Window) SetDecoOuterSizeY2(v float32) {
	selfArg, selfFin := self.handle()
	defer selfFin()
	C.wrap_ImGuiWindow_SetDecoOuterSizeY2(selfArg, C.float(v))
}

func (self *Window) DecoOuterSizeY2() float32 {
	selfArg, selfFin := self.handle()

	defer func() {
		selfFin()
	}()
	return float32(C.wrap_ImGuiWindow_GetDecoOuterSizeY2(selfArg))
}

func (self Window) SetDecoInnerSizeX1(v float32) {
	selfArg, selfFin := self.handle()
	defer selfFin()
	C.wrap_ImGuiWindow_SetDecoInnerSizeX1(selfArg, C.float(v))
}

func (self *Window) DecoInnerSizeX1() float32 {
	selfArg, selfFin := self.handle()

	defer func() {
		selfFin()
	}()
	return float32(C.wrap_ImGuiWindow_GetDecoInnerSizeX1(selfArg))
}

func (self Window) SetDecoInnerSizeY1(v float32) {
	selfArg, selfFin := self.handle()
	defer selfFin()
	C.wrap_ImGuiWindow_SetDecoInnerSizeY1(selfArg, C.float(v))
}

func (self *Window) DecoInnerSizeY1() float32 {
	selfArg, selfFin := self.handle()

	defer func() {
		selfFin()
	}()
	return float32(C.wrap_ImGuiWindow_GetDecoInnerSizeY1(selfArg))
}

func (self Window) SetNameBufLen(v int32) {
	selfArg, selfFin := self.handle()
	defer selfFin()
	C.wrap_ImGuiWindow_SetNameBufLen(selfArg, C.int(v))
}

func (self *Window) NameBufLen() int32 {
	selfArg, selfFin := self.handle()

	defer func() {
		selfFin()
	}()
	return int32(C.wrap_ImGuiWindow_GetNameBufLen(selfArg))
}

func (self Window) SetMoveId(v ID) {
	vArg, _ := v.c()

	selfArg, selfFin := self.handle()
	defer selfFin()
	C.wrap_ImGuiWindow_SetMoveId(selfArg, vArg)
}

func (self *Window) MoveId() ID {
	selfArg, selfFin := self.handle()

	defer func() {
		selfFin()
	}()

	result := C.wrap_ImGuiWindow_GetMoveId(selfArg)
	return *newIDFromC(func() *C.ImGuiID { result := result; return &result }())
}

func (self Window) SetTabId(v ID) {
	vArg, _ := v.c()

	selfArg, selfFin := self.handle()
	defer selfFin()
	C.wrap_ImGuiWindow_SetTabId(selfArg, vArg)
}

func (self *Window) TabId() ID {
	selfArg, selfFin := self.handle()

	defer func() {
		selfFin()
	}()

	result := C.wrap_ImGuiWindow_GetTabId(selfArg)
	return *newIDFromC(func() *C.ImGuiID { result := result; return &result }())
}

func (self Window) SetChildId(v ID) {
	vArg, _ := v.c()

	selfArg, selfFin := self.handle()
	defer selfFin()
	C.wrap_ImGuiWindow_SetChildId(selfArg, vArg)
}

func (self *Window) ChildId() ID {
	selfArg, selfFin := self.handle()

	defer func() {
		selfFin()
	}()

	result := C.wrap_ImGuiWindow_GetChildId(selfArg)
	return *newIDFromC(func() *C.ImGuiID { result := result; return &result }())
}

func (self Window) SetScroll(v Vec2) {
	selfArg, selfFin := self.handle()
	defer selfFin()
	C.wrap_ImGuiWindow_SetScroll(selfArg, v.toC())
}

func (self *Window) Scroll() Vec2 {
	selfArg, selfFin := self.handle()

	defer func() {
		selfFin()
	}()
	return *(&Vec2{}).fromC(C.wrap_ImGuiWindow_GetScroll(selfArg))
}

func (self Window) SetScrollMax(v Vec2) {
	selfArg, selfFin := self.handle()
	defer selfFin()
	C.wrap_ImGuiWindow_SetScrollMax(selfArg, v.toC())
}

func (self *Window) ScrollMax() Vec2 {
	selfArg, selfFin := self.handle()

	defer func() {
		selfFin()
	}()
	return *(&Vec2{}).fromC(C.wrap_ImGuiWindow_GetScrollMax(selfArg))
}

func (self Window) SetScrollTarget(v Vec2) {
	selfArg, selfFin := self.handle()
	defer selfFin()
	C.wrap_ImGuiWindow_SetScrollTarget(selfArg, v.toC())
}

func (self *Window) ScrollTarget() Vec2 {
	selfArg, selfFin := self.handle()

	defer func() {
		selfFin()
	}()
	return *(&Vec2{}).fromC(C.wrap_ImGuiWindow_GetScrollTarget(selfArg))
}

func (self Window) SetScrollTargetCenterRatio(v Vec2) {
	selfArg, selfFin := self.handle()
	defer selfFin()
	C.wrap_ImGuiWindow_SetScrollTargetCenterRatio(selfArg, v.toC())
}

func (self *Window) ScrollTargetCenterRatio() Vec2 {
	selfArg, selfFin := self.handle()

	defer func() {
		selfFin()
	}()
	return *(&Vec2{}).fromC(C.wrap_ImGuiWindow_GetScrollTargetCenterRatio(selfArg))
}

func (self Window) SetScrollTargetEdgeSnapDist(v Vec2) {
	selfArg, selfFin := self.handle()
	defer selfFin()
	C.wrap_ImGuiWindow_SetScrollTargetEdgeSnapDist(selfArg, v.toC())
}

func (self *Window) ScrollTargetEdgeSnapDist() Vec2 {
	selfArg, selfFin := self.handle()

	defer func() {
		selfFin()
	}()
	return *(&Vec2{}).fromC(C.wrap_ImGuiWindow_GetScrollTargetEdgeSnapDist(selfArg))
}

func (self Window) SetScrollbarSizes(v Vec2) {
	selfArg, selfFin := self.handle()
	defer selfFin()
	C.wrap_ImGuiWindow_SetScrollbarSizes(selfArg, v.toC())
}

func (self *Window) ScrollbarSizes() Vec2 {
	selfArg, selfFin := self.handle()

	defer func() {
		selfFin()
	}()
	return *(&Vec2{}).fromC(C.wrap_ImGuiWindow_GetScrollbarSizes(selfArg))
}

func (self Window) SetScrollbarX(v bool) {
	selfArg, selfFin := self.handle()
	defer selfFin()
	C.wrap_ImGuiWindow_SetScrollbarX(selfArg, C.bool(v))
}

func (self *Window) ScrollbarX() bool {
	selfArg, selfFin := self.handle()

	defer func() {
		selfFin()
	}()
	return C.wrap_ImGuiWindow_GetScrollbarX(selfArg) == C.bool(true)
}

func (self Window) SetScrollbarY(v bool) {
	selfArg, selfFin := self.handle()
	defer selfFin()
	C.wrap_ImGuiWindow_SetScrollbarY(selfArg, C.bool(v))
}

func (self *Window) ScrollbarY() bool {
	selfArg, selfFin := self.handle()

	defer func() {
		selfFin()
	}()
	return C.wrap_ImGuiWindow_GetScrollbarY(selfArg) == C.bool(true)
}

func (self Window) SetViewportOwned(v bool) {
	selfArg, selfFin := self.handle()
	defer selfFin()
	C.wrap_ImGuiWindow_SetViewportOwned(selfArg, C.bool(v))
}

func (self *Window) ViewportOwned() bool {
	selfArg, selfFin := self.handle()

	defer func() {
		selfFin()
	}()
	return C.wrap_ImGuiWindow_GetViewportOwned(selfArg) == C.bool(true)
}

func (self Window) SetActive(v bool) {
	selfArg, selfFin := self.handle()
	defer selfFin()
	C.wrap_ImGuiWindow_SetActive(selfArg, C.bool(v))
}

func (self *Window) Active() bool {
	selfArg, selfFin := self.handle()

	defer func() {
		selfFin()
	}()
	return C.wrap_ImGuiWindow_GetActive(selfArg) == C.bool(true)
}

func (self Window) SetWasActive(v bool) {
	selfArg, selfFin := self.handle()
	defer selfFin()
	C.wrap_ImGuiWindow_SetWasActive(selfArg, C.bool(v))
}

func (self *Window) WasActive() bool {
	selfArg, selfFin := self.handle()

	defer func() {
		selfFin()
	}()
	return C.wrap_ImGuiWindow_GetWasActive(selfArg) == C.bool(true)
}

func (self Window) SetWriteAccessed(v bool) {
	selfArg, selfFin := self.handle()
	defer selfFin()
	C.wrap_ImGuiWindow_SetWriteAccessed(selfArg, C.bool(v))
}

func (self *Window) WriteAccessed() bool {
	selfArg, selfFin := self.handle()

	defer func() {
		selfFin()
	}()
	return C.wrap_ImGuiWindow_GetWriteAccessed(selfArg) == C.bool(true)
}

func (self Window) SetCollapsed(v bool) {
	selfArg, selfFin := self.handle()
	defer selfFin()
	C.wrap_ImGuiWindow_SetCollapsed(selfArg, C.bool(v))
}

func (self *Window) Collapsed() bool {
	selfArg, selfFin := self.handle()

	defer func() {
		selfFin()
	}()
	return C.wrap_ImGuiWindow_GetCollapsed(selfArg) == C.bool(true)
}

func (self Window) SetWantCollapseToggle(v bool) {
	selfArg, selfFin := self.handle()
	defer selfFin()
	C.wrap_ImGuiWindow_SetWantCollapseToggle(selfArg, C.bool(v))
}

func (self *Window) WantCollapseToggle() bool {
	selfArg, selfFin := self.handle()

	defer func() {
		selfFin()
	}()
	return C.wrap_ImGuiWindow_GetWantCollapseToggle(selfArg) == C.bool(true)
}

func (self Window) SetSkipItems(v bool) {
	selfArg, selfFin := self.handle()
	defer selfFin()
	C.wrap_ImGuiWindow_SetSkipItems(selfArg, C.bool(v))
}

func (self *Window) SkipItems() bool {
	selfArg, selfFin := self.handle()

	defer func() {
		selfFin()
	}()
	return C.wrap_ImGuiWindow_GetSkipItems(selfArg) == C.bool(true)
}

func (self Window) SetAppearing(v bool) {
	selfArg, selfFin := self.handle()
	defer selfFin()
	C.wrap_ImGuiWindow_SetAppearing(selfArg, C.bool(v))
}

func (self *Window) Appearing() bool {
	selfArg, selfFin := self.handle()

	defer func() {
		selfFin()
	}()
	return C.wrap_ImGuiWindow_GetAppearing(selfArg) == C.bool(true)
}

func (self Window) SetHidden(v bool) {
	selfArg, selfFin := self.handle()
	defer selfFin()
	C.wrap_ImGuiWindow_SetHidden(selfArg, C.bool(v))
}

func (self *Window) Hidden() bool {
	selfArg, selfFin := self.handle()

	defer func() {
		selfFin()
	}()
	return C.wrap_ImGuiWindow_GetHidden(selfArg) == C.bool(true)
}

func (self Window) SetIsFallbackWindow(v bool) {
	selfArg, selfFin := self.handle()
	defer selfFin()
	C.wrap_ImGuiWindow_SetIsFallbackWindow(selfArg, C.bool(v))
}

func (self *Window) IsFallbackWindow() bool {
	selfArg, selfFin := self.handle()

	defer func() {
		selfFin()
	}()
	return C.wrap_ImGuiWindow_GetIsFallbackWindow(selfArg) == C.bool(true)
}

func (self Window) SetIsExplicitChild(v bool) {
	selfArg, selfFin := self.handle()
	defer selfFin()
	C.wrap_ImGuiWindow_SetIsExplicitChild(selfArg, C.bool(v))
}

func (self *Window) IsExplicitChild() bool {
	selfArg, selfFin := self.handle()

	defer func() {
		selfFin()
	}()
	return C.wrap_ImGuiWindow_GetIsExplicitChild(selfArg) == C.bool(true)
}

func (self Window) SetHasCloseButton(v bool) {
	selfArg, selfFin := self.handle()
	defer selfFin()
	C.wrap_ImGuiWindow_SetHasCloseButton(selfArg, C.bool(v))
}

func (self *Window) HasCloseButton() bool {
	selfArg, selfFin := self.handle()

	defer func() {
		selfFin()
	}()
	return C.wrap_ImGuiWindow_GetHasCloseButton(selfArg) == C.bool(true)
}

func (self Window) SetBeginCount(v int16) {
	selfArg, selfFin := self.handle()
	defer selfFin()
	C.wrap_ImGuiWindow_SetBeginCount(selfArg, C.short(v))
}

func (self *Window) BeginCount() int16 {
	selfArg, selfFin := self.handle()

	defer func() {
		selfFin()
	}()
	return int16(C.wrap_ImGuiWindow_GetBeginCount(selfArg))
}

func (self Window) SetBeginCountPreviousFrame(v int16) {
	selfArg, selfFin := self.handle()
	defer selfFin()
	C.wrap_ImGuiWindow_SetBeginCountPreviousFrame(selfArg, C.short(v))
}

func (self *Window) BeginCountPreviousFrame() int16 {
	selfArg, selfFin := self.handle()

	defer func() {
		selfFin()
	}()
	return int16(C.wrap_ImGuiWindow_GetBeginCountPreviousFrame(selfArg))
}

func (self Window) SetBeginOrderWithinParent(v int16) {
	selfArg, selfFin := self.handle()
	defer selfFin()
	C.wrap_ImGuiWindow_SetBeginOrderWithinParent(selfArg, C.short(v))
}

func (self *Window) BeginOrderWithinParent() int16 {
	selfArg, selfFin := self.handle()

	defer func() {
		selfFin()
	}()
	return int16(C.wrap_ImGuiWindow_GetBeginOrderWithinParent(selfArg))
}

func (self Window) SetBeginOrderWithinContext(v int16) {
	selfArg, selfFin := self.handle()
	defer selfFin()
	C.wrap_ImGuiWindow_SetBeginOrderWithinContext(selfArg, C.short(v))
}

func (self *Window) BeginOrderWithinContext() int16 {
	selfArg, selfFin := self.handle()

	defer func() {
		selfFin()
	}()
	return int16(C.wrap_ImGuiWindow_GetBeginOrderWithinContext(selfArg))
}

func (self Window) SetFocusOrder(v int16) {
	selfArg, selfFin := self.handle()
	defer selfFin()
	C.wrap_ImGuiWindow_SetFocusOrder(selfArg, C.short(v))
}

func (self *Window) FocusOrder() int16 {
	selfArg, selfFin := self.handle()

	defer func() {
		selfFin()
	}()
	return int16(C.wrap_ImGuiWindow_GetFocusOrder(selfArg))
}

func (self Window) SetPopupId(v ID) {
	vArg, _ := v.c()

	selfArg, selfFin := self.handle()
	defer selfFin()
	C.wrap_ImGuiWindow_SetPopupId(selfArg, vArg)
}

func (self *Window) PopupId() ID {
	selfArg, selfFin := self.handle()

	defer func() {
		selfFin()
	}()

	result := C.wrap_ImGuiWindow_GetPopupId(selfArg)
	return *newIDFromC(func() *C.ImGuiID { result := result; return &result }())
}

func (self Window) SetAutoFitFramesX(v int) {
	selfArg, selfFin := self.handle()
	defer selfFin()
	C.wrap_ImGuiWindow_SetAutoFitFramesX(selfArg, C.ImS8(v))
}

func (self *Window) AutoFitFramesX() int {
	selfArg, selfFin := self.handle()

	defer func() {
		selfFin()
	}()
	return int(C.wrap_ImGuiWindow_GetAutoFitFramesX(selfArg))
}

func (self Window) SetAutoFitFramesY(v int) {
	selfArg, selfFin := self.handle()
	defer selfFin()
	C.wrap_ImGuiWindow_SetAutoFitFramesY(selfArg, C.ImS8(v))
}

func (self *Window) AutoFitFramesY() int {
	selfArg, selfFin := self.handle()

	defer func() {
		selfFin()
	}()
	return int(C.wrap_ImGuiWindow_GetAutoFitFramesY(selfArg))
}

func (self Window) SetAutoFitChildAxises(v int) {
	selfArg, selfFin := self.handle()
	defer selfFin()
	C.wrap_ImGuiWindow_SetAutoFitChildAxises(selfArg, C.ImS8(v))
}

func (self *Window) AutoFitChildAxises() int {
	selfArg, selfFin := self.handle()

	defer func() {
		selfFin()
	}()
	return int(C.wrap_ImGuiWindow_GetAutoFitChildAxises(selfArg))
}

func (self Window) SetAutoFitOnlyGrows(v bool) {
	selfArg, selfFin := self.handle()
	defer selfFin()
	C.wrap_ImGuiWindow_SetAutoFitOnlyGrows(selfArg, C.bool(v))
}

func (self *Window) AutoFitOnlyGrows() bool {
	selfArg, selfFin := self.handle()

	defer func() {
		selfFin()
	}()
	return C.wrap_ImGuiWindow_GetAutoFitOnlyGrows(selfArg) == C.bool(true)
}

func (self Window) SetAutoPosLastDirection(v Dir) {
	selfArg, selfFin := self.handle()
	defer selfFin()
	C.wrap_ImGuiWindow_SetAutoPosLastDirection(selfArg, C.ImGuiDir(v))
}

func (self *Window) AutoPosLastDirection() Dir {
	selfArg, selfFin := self.handle()

	defer func() {
		selfFin()
	}()
	return Dir(C.wrap_ImGuiWindow_GetAutoPosLastDirection(selfArg))
}

func (self Window) SetHiddenFramesCanSkipItems(v int) {
	selfArg, selfFin := self.handle()
	defer selfFin()
	C.wrap_ImGuiWindow_SetHiddenFramesCanSkipItems(selfArg, C.ImS8(v))
}

func (self *Window) HiddenFramesCanSkipItems() int {
	selfArg, selfFin := self.handle()

	defer func() {
		selfFin()
	}()
	return int(C.wrap_ImGuiWindow_GetHiddenFramesCanSkipItems(selfArg))
}

func (self Window) SetHiddenFramesCannotSkipItems(v int) {
	selfArg, selfFin := self.handle()
	defer selfFin()
	C.wrap_ImGuiWindow_SetHiddenFramesCannotSkipItems(selfArg, C.ImS8(v))
}

func (self *Window) HiddenFramesCannotSkipItems() int {
	selfArg, selfFin := self.handle()

	defer func() {
		selfFin()
	}()
	return int(C.wrap_ImGuiWindow_GetHiddenFramesCannotSkipItems(selfArg))
}

func (self Window) SetHiddenFramesForRenderOnly(v int) {
	selfArg, selfFin := self.handle()
	defer selfFin()
	C.wrap_ImGuiWindow_SetHiddenFramesForRenderOnly(selfArg, C.ImS8(v))
}

func (self *Window) HiddenFramesForRenderOnly() int {
	selfArg, selfFin := self.handle()

	defer func() {
		selfFin()
	}()
	return int(C.wrap_ImGuiWindow_GetHiddenFramesForRenderOnly(selfArg))
}

func (self Window) SetDisableInputsFrames(v int) {
	selfArg, selfFin := self.handle()
	defer selfFin()
	C.wrap_ImGuiWindow_SetDisableInputsFrames(selfArg, C.ImS8(v))
}

func (self *Window) DisableInputsFrames() int {
	selfArg, selfFin := self.handle()

	defer func() {
		selfFin()
	}()
	return int(C.wrap_ImGuiWindow_GetDisableInputsFrames(selfArg))
}

func (self Window) SetSetWindowPosAllowFlags(v Cond) {
	selfArg, selfFin := self.handle()
	defer selfFin()
	C.wrap_ImGuiWindow_SetSetWindowPosAllowFlags(selfArg, C.ImGuiCond(v))
}

func (self *Window) SetWindowPosAllowFlags() Cond {
	selfArg, selfFin := self.handle()

	defer func() {
		selfFin()
	}()
	return Cond(C.wrap_ImGuiWindow_GetSetWindowPosAllowFlags(selfArg))
}

func (self Window) SetSetWindowSizeAllowFlags(v Cond) {
	selfArg, selfFin := self.handle()
	defer selfFin()
	C.wrap_ImGuiWindow_SetSetWindowSizeAllowFlags(selfArg, C.ImGuiCond(v))
}

func (self *Window) SetWindowSizeAllowFlags() Cond {
	selfArg, selfFin := self.handle()

	defer func() {
		selfFin()
	}()
	return Cond(C.wrap_ImGuiWindow_GetSetWindowSizeAllowFlags(selfArg))
}

func (self Window) SetSetWindowCollapsedAllowFlags(v Cond) {
	selfArg, selfFin := self.handle()
	defer selfFin()
	C.wrap_ImGuiWindow_SetSetWindowCollapsedAllowFlags(selfArg, C.ImGuiCond(v))
}

func (self *Window) SetWindowCollapsedAllowFlags() Cond {
	selfArg, selfFin := self.handle()

	defer func() {
		selfFin()
	}()
	return Cond(C.wrap_ImGuiWindow_GetSetWindowCollapsedAllowFlags(selfArg))
}

func (self Window) SetSetWindowDockAllowFlags(v Cond) {
	selfArg, selfFin := self.handle()
	defer selfFin()
	C.wrap_ImGuiWindow_SetSetWindowDockAllowFlags(selfArg, C.ImGuiCond(v))
}

func (self *Window) SetWindowDockAllowFlags() Cond {
	selfArg, selfFin := self.handle()

	defer func() {
		selfFin()
	}()
	return Cond(C.wrap_ImGuiWindow_GetSetWindowDockAllowFlags(selfArg))
}

func (self Window) SetSetWindowPosVal(v Vec2) {
	selfArg, selfFin := self.handle()
	defer selfFin()
	C.wrap_ImGuiWindow_SetSetWindowPosVal(selfArg, v.toC())
}

func (self *Window) SetWindowPosVal() Vec2 {
	selfArg, selfFin := self.handle()

	defer func() {
		selfFin()
	}()
	return *(&Vec2{}).fromC(C.wrap_ImGuiWindow_GetSetWindowPosVal(selfArg))
}

func (self Window) SetSetWindowPosPivot(v Vec2) {
	selfArg, selfFin := self.handle()
	defer selfFin()
	C.wrap_ImGuiWindow_SetSetWindowPosPivot(selfArg, v.toC())
}

func (self *Window) SetWindowPosPivot() Vec2 {
	selfArg, selfFin := self.handle()

	defer func() {
		selfFin()
	}()
	return *(&Vec2{}).fromC(C.wrap_ImGuiWindow_GetSetWindowPosPivot(selfArg))
}

func (self Window) SetIDStack(v Vector[*ID]) {
	vData := v.Data
	vDataArg, _ := vData.handle()
	vVecArg := new(C.ImVector_ImGuiID)
	vVecArg.Size = C.int(v.Size)
	vVecArg.Capacity = C.int(v.Capacity)
	vVecArg.Data = vDataArg
	v.pinner.Pin(vVecArg.Data)

	selfArg, selfFin := self.handle()
	defer selfFin()
	C.wrap_ImGuiWindow_SetIDStack(selfArg, *vVecArg)
}

func (self *Window) IDStack() Vector[*ID] {
	selfArg, selfFin := self.handle()

	defer func() {
		selfFin()
	}()
	return newVectorFromC(C.wrap_ImGuiWindow_GetIDStack(selfArg).Size, C.wrap_ImGuiWindow_GetIDStack(selfArg).Capacity, newIDFromC(C.wrap_ImGuiWindow_GetIDStack(selfArg).Data))
}

func (self Window) SetDC(v WindowTempData) {
	vArg, _ := v.c()

	selfArg, selfFin := self.handle()
	defer selfFin()
	C.wrap_ImGuiWindow_SetDC(selfArg, vArg)
}

func (self *Window) DC() WindowTempData {
	selfArg, selfFin := self.handle()

	defer func() {
		selfFin()
	}()

	result := C.wrap_ImGuiWindow_GetDC(selfArg)
	return *newWindowTempDataFromC(func() *C.ImGuiWindowTempData { result := result; return &result }())
}

func (self Window) SetOuterRectClipped(v Rect) {
	selfArg, selfFin := self.handle()
	defer selfFin()
	C.wrap_ImGuiWindow_SetOuterRectClipped(selfArg, v.toC())
}

func (self *Window) OuterRectClipped() Rect {
	selfArg, selfFin := self.handle()

	defer func() {
		selfFin()
	}()
	return *(&Rect{}).fromC(C.wrap_ImGuiWindow_GetOuterRectClipped(selfArg))
}

func (self Window) SetInnerRect(v Rect) {
	selfArg, selfFin := self.handle()
	defer selfFin()
	C.wrap_ImGuiWindow_SetInnerRect(selfArg, v.toC())
}

func (self *Window) InnerRect() Rect {
	selfArg, selfFin := self.handle()

	defer func() {
		selfFin()
	}()
	return *(&Rect{}).fromC(C.wrap_ImGuiWindow_GetInnerRect(selfArg))
}

func (self Window) SetInnerClipRect(v Rect) {
	selfArg, selfFin := self.handle()
	defer selfFin()
	C.wrap_ImGuiWindow_SetInnerClipRect(selfArg, v.toC())
}

func (self *Window) InnerClipRect() Rect {
	selfArg, selfFin := self.handle()

	defer func() {
		selfFin()
	}()
	return *(&Rect{}).fromC(C.wrap_ImGuiWindow_GetInnerClipRect(selfArg))
}

func (self Window) SetWorkRect(v Rect) {
	selfArg, selfFin := self.handle()
	defer selfFin()
	C.wrap_ImGuiWindow_SetWorkRect(selfArg, v.toC())
}

func (self *Window) WorkRect() Rect {
	selfArg, selfFin := self.handle()

	defer func() {
		selfFin()
	}()
	return *(&Rect{}).fromC(C.wrap_ImGuiWindow_GetWorkRect(selfArg))
}

func (self Window) SetParentWorkRect(v Rect) {
	selfArg, selfFin := self.handle()
	defer selfFin()
	C.wrap_ImGuiWindow_SetParentWorkRect(selfArg, v.toC())
}

func (self *Window) ParentWorkRect() Rect {
	selfArg, selfFin := self.handle()

	defer func() {
		selfFin()
	}()
	return *(&Rect{}).fromC(C.wrap_ImGuiWindow_GetParentWorkRect(selfArg))
}

func (self Window) SetClipRect(v Rect) {
	selfArg, selfFin := self.handle()
	defer selfFin()
	C.wrap_ImGuiWindow_SetClipRect(selfArg, v.toC())
}

func (self *Window) ClipRect() Rect {
	selfArg, selfFin := self.handle()

	defer func() {
		selfFin()
	}()
	return *(&Rect{}).fromC(C.wrap_ImGuiWindow_GetClipRect(selfArg))
}

func (self Window) SetContentRegionRect(v Rect) {
	selfArg, selfFin := self.handle()
	defer selfFin()
	C.wrap_ImGuiWindow_SetContentRegionRect(selfArg, v.toC())
}

func (self *Window) ContentRegionRect() Rect {
	selfArg, selfFin := self.handle()

	defer func() {
		selfFin()
	}()
	return *(&Rect{}).fromC(C.wrap_ImGuiWindow_GetContentRegionRect(selfArg))
}

func (self Window) SetLastFrameActive(v int32) {
	selfArg, selfFin := self.handle()
	defer selfFin()
	C.wrap_ImGuiWindow_SetLastFrameActive(selfArg, C.int(v))
}

func (self *Window) LastFrameActive() int32 {
	selfArg, selfFin := self.handle()

	defer func() {
		selfFin()
	}()
	return int32(C.wrap_ImGuiWindow_GetLastFrameActive(selfArg))
}

func (self Window) SetLastFrameJustFocused(v int32) {
	selfArg, selfFin := self.handle()
	defer selfFin()
	C.wrap_ImGuiWindow_SetLastFrameJustFocused(selfArg, C.int(v))
}

func (self *Window) LastFrameJustFocused() int32 {
	selfArg, selfFin := self.handle()

	defer func() {
		selfFin()
	}()
	return int32(C.wrap_ImGuiWindow_GetLastFrameJustFocused(selfArg))
}

func (self Window) SetLastTimeActive(v float32) {
	selfArg, selfFin := self.handle()
	defer selfFin()
	C.wrap_ImGuiWindow_SetLastTimeActive(selfArg, C.float(v))
}

func (self *Window) LastTimeActive() float32 {
	selfArg, selfFin := self.handle()

	defer func() {
		selfFin()
	}()
	return float32(C.wrap_ImGuiWindow_GetLastTimeActive(selfArg))
}

func (self Window) SetItemWidthDefault(v float32) {
	selfArg, selfFin := self.handle()
	defer selfFin()
	C.wrap_ImGuiWindow_SetItemWidthDefault(selfArg, C.float(v))
}

func (self *Window) ItemWidthDefault() float32 {
	selfArg, selfFin := self.handle()

	defer func() {
		selfFin()
	}()
	return float32(C.wrap_ImGuiWindow_GetItemWidthDefault(selfArg))
}

func (self Window) SetStateStorage(v Storage) {
	vArg, _ := v.c()

	selfArg, selfFin := self.handle()
	defer selfFin()
	C.wrap_ImGuiWindow_SetStateStorage(selfArg, vArg)
}

func (self *Window) StateStorage() Storage {
	selfArg, selfFin := self.handle()

	defer func() {
		selfFin()
	}()

	result := C.wrap_ImGuiWindow_GetStateStorage(selfArg)
	return *newStorageFromC(func() *C.ImGuiStorage { result := result; return &result }())
}

func (self Window) SetColumnsStorage(v Vector[*OldColumns]) {
	vData := v.Data
	vDataArg, _ := vData.handle()
	vVecArg := new(C.ImVector_ImGuiOldColumns)
	vVecArg.Size = C.int(v.Size)
	vVecArg.Capacity = C.int(v.Capacity)
	vVecArg.Data = vDataArg
	v.pinner.Pin(vVecArg.Data)

	selfArg, selfFin := self.handle()
	defer selfFin()
	C.wrap_ImGuiWindow_SetColumnsStorage(selfArg, *vVecArg)
}

func (self *Window) ColumnsStorage() Vector[*OldColumns] {
	selfArg, selfFin := self.handle()

	defer func() {
		selfFin()
	}()
	return newVectorFromC(C.wrap_ImGuiWindow_GetColumnsStorage(selfArg).Size, C.wrap_ImGuiWindow_GetColumnsStorage(selfArg).Capacity, newOldColumnsFromC(C.wrap_ImGuiWindow_GetColumnsStorage(selfArg).Data))
}

func (self Window) SetFontWindowScale(v float32) {
	selfArg, selfFin := self.handle()
	defer selfFin()
	C.wrap_ImGuiWindow_SetFontWindowScale(selfArg, C.float(v))
}

func (self *Window) FontWindowScale() float32 {
	selfArg, selfFin := self.handle()

	defer func() {
		selfFin()
	}()
	return float32(C.wrap_ImGuiWindow_GetFontWindowScale(selfArg))
}

func (self Window) SetFontDpiScale(v float32) {
	selfArg, selfFin := self.handle()
	defer selfFin()
	C.wrap_ImGuiWindow_SetFontDpiScale(selfArg, C.float(v))
}

func (self *Window) FontDpiScale() float32 {
	selfArg, selfFin := self.handle()

	defer func() {
		selfFin()
	}()
	return float32(C.wrap_ImGuiWindow_GetFontDpiScale(selfArg))
}

func (self Window) SetSettingsOffset(v int32) {
	selfArg, selfFin := self.handle()
	defer selfFin()
	C.wrap_ImGuiWindow_SetSettingsOffset(selfArg, C.int(v))
}

func (self *Window) SettingsOffset() int32 {
	selfArg, selfFin := self.handle()

	defer func() {
		selfFin()
	}()
	return int32(C.wrap_ImGuiWindow_GetSettingsOffset(selfArg))
}

func (self Window) SetDrawList(v *DrawList) {
	vArg, _ := v.handle()

	selfArg, selfFin := self.handle()
	defer selfFin()
	C.wrap_ImGuiWindow_SetDrawList(selfArg, vArg)
}

func (self *Window) DrawList() *DrawList {
	selfArg, selfFin := self.handle()

	defer func() {
		selfFin()
	}()
	return newDrawListFromC(C.wrap_ImGuiWindow_GetDrawList(selfArg))
}

func (self Window) SetDrawListInst(v DrawList) {
	vArg, _ := v.c()

	selfArg, selfFin := self.handle()
	defer selfFin()
	C.wrap_ImGuiWindow_SetDrawListInst(selfArg, vArg)
}

func (self *Window) DrawListInst() DrawList {
	selfArg, selfFin := self.handle()

	defer func() {
		selfFin()
	}()

	result := C.wrap_ImGuiWindow_GetDrawListInst(selfArg)
	return *newDrawListFromC(func() *C.ImDrawList { result := result; return &result }())
}

func (self Window) SetParentWindow(v *Window) {
	vArg, _ := v.handle()

	selfArg, selfFin := self.handle()
	defer selfFin()
	C.wrap_ImGuiWindow_SetParentWindow(selfArg, vArg)
}

func (self *Window) ParentWindow() *Window {
	selfArg, selfFin := self.handle()

	defer func() {
		selfFin()
	}()
	return newWindowFromC(C.wrap_ImGuiWindow_GetParentWindow(selfArg))
}

func (self Window) SetParentWindowInBeginStack(v *Window) {
	vArg, _ := v.handle()

	selfArg, selfFin := self.handle()
	defer selfFin()
	C.wrap_ImGuiWindow_SetParentWindowInBeginStack(selfArg, vArg)
}

func (self *Window) ParentWindowInBeginStack() *Window {
	selfArg, selfFin := self.handle()

	defer func() {
		selfFin()
	}()
	return newWindowFromC(C.wrap_ImGuiWindow_GetParentWindowInBeginStack(selfArg))
}

func (self Window) SetRootWindow(v *Window) {
	vArg, _ := v.handle()

	selfArg, selfFin := self.handle()
	defer selfFin()
	C.wrap_ImGuiWindow_SetRootWindow(selfArg, vArg)
}

func (self *Window) RootWindow() *Window {
	selfArg, selfFin := self.handle()

	defer func() {
		selfFin()
	}()
	return newWindowFromC(C.wrap_ImGuiWindow_GetRootWindow(selfArg))
}

func (self Window) SetRootWindowPopupTree(v *Window) {
	vArg, _ := v.handle()

	selfArg, selfFin := self.handle()
	defer selfFin()
	C.wrap_ImGuiWindow_SetRootWindowPopupTree(selfArg, vArg)
}

func (self *Window) RootWindowPopupTree() *Window {
	selfArg, selfFin := self.handle()

	defer func() {
		selfFin()
	}()
	return newWindowFromC(C.wrap_ImGuiWindow_GetRootWindowPopupTree(selfArg))
}

func (self Window) SetRootWindowDockTree(v *Window) {
	vArg, _ := v.handle()

	selfArg, selfFin := self.handle()
	defer selfFin()
	C.wrap_ImGuiWindow_SetRootWindowDockTree(selfArg, vArg)
}

func (self *Window) RootWindowDockTree() *Window {
	selfArg, selfFin := self.handle()

	defer func() {
		selfFin()
	}()
	return newWindowFromC(C.wrap_ImGuiWindow_GetRootWindowDockTree(selfArg))
}

func (self Window) SetRootWindowForTitleBarHighlight(v *Window) {
	vArg, _ := v.handle()

	selfArg, selfFin := self.handle()
	defer selfFin()
	C.wrap_ImGuiWindow_SetRootWindowForTitleBarHighlight(selfArg, vArg)
}

func (self *Window) RootWindowForTitleBarHighlight() *Window {
	selfArg, selfFin := self.handle()

	defer func() {
		selfFin()
	}()
	return newWindowFromC(C.wrap_ImGuiWindow_GetRootWindowForTitleBarHighlight(selfArg))
}

func (self Window) SetRootWindowForNav(v *Window) {
	vArg, _ := v.handle()

	selfArg, selfFin := self.handle()
	defer selfFin()
	C.wrap_ImGuiWindow_SetRootWindowForNav(selfArg, vArg)
}

func (self *Window) RootWindowForNav() *Window {
	selfArg, selfFin := self.handle()

	defer func() {
		selfFin()
	}()
	return newWindowFromC(C.wrap_ImGuiWindow_GetRootWindowForNav(selfArg))
}

func (self Window) SetNavLastChildNavWindow(v *Window) {
	vArg, _ := v.handle()

	selfArg, selfFin := self.handle()
	defer selfFin()
	C.wrap_ImGuiWindow_SetNavLastChildNavWindow(selfArg, vArg)
}

func (self *Window) NavLastChildNavWindow() *Window {
	selfArg, selfFin := self.handle()

	defer func() {
		selfFin()
	}()
	return newWindowFromC(C.wrap_ImGuiWindow_GetNavLastChildNavWindow(selfArg))
}

func (self Window) SetNavPreferredScoringPosRel(v [2]*Vec2) {
	vArg := make([]C.ImVec2, len(v))
	vFin := make([]func(), len(v))
	for i, vV := range v {
		var tmp *C.ImVec2
		tmp, vFin[i] = wrap[C.ImVec2, *Vec2](vV)
		vArg[i] = *tmp
	}

	selfArg, selfFin := self.handle()
	defer selfFin()
	C.wrap_ImGuiWindow_SetNavPreferredScoringPosRel(selfArg, (*C.ImVec2)(&vArg[0]))
}

func (self Window) SetNavRootFocusScopeId(v ID) {
	vArg, _ := v.c()

	selfArg, selfFin := self.handle()
	defer selfFin()
	C.wrap_ImGuiWindow_SetNavRootFocusScopeId(selfArg, vArg)
}

func (self *Window) NavRootFocusScopeId() ID {
	selfArg, selfFin := self.handle()

	defer func() {
		selfFin()
	}()

	result := C.wrap_ImGuiWindow_GetNavRootFocusScopeId(selfArg)
	return *newIDFromC(func() *C.ImGuiID { result := result; return &result }())
}

func (self Window) SetMemoryDrawListIdxCapacity(v int32) {
	selfArg, selfFin := self.handle()
	defer selfFin()
	C.wrap_ImGuiWindow_SetMemoryDrawListIdxCapacity(selfArg, C.int(v))
}

func (self *Window) MemoryDrawListIdxCapacity() int32 {
	selfArg, selfFin := self.handle()

	defer func() {
		selfFin()
	}()
	return int32(C.wrap_ImGuiWindow_GetMemoryDrawListIdxCapacity(selfArg))
}

func (self Window) SetMemoryDrawListVtxCapacity(v int32) {
	selfArg, selfFin := self.handle()
	defer selfFin()
	C.wrap_ImGuiWindow_SetMemoryDrawListVtxCapacity(selfArg, C.int(v))
}

func (self *Window) MemoryDrawListVtxCapacity() int32 {
	selfArg, selfFin := self.handle()

	defer func() {
		selfFin()
	}()
	return int32(C.wrap_ImGuiWindow_GetMemoryDrawListVtxCapacity(selfArg))
}

func (self Window) SetMemoryCompacted(v bool) {
	selfArg, selfFin := self.handle()
	defer selfFin()
	C.wrap_ImGuiWindow_SetMemoryCompacted(selfArg, C.bool(v))
}

func (self *Window) MemoryCompacted() bool {
	selfArg, selfFin := self.handle()

	defer func() {
		selfFin()
	}()
	return C.wrap_ImGuiWindow_GetMemoryCompacted(selfArg) == C.bool(true)
}

func (self Window) SetDockIsActive(v bool) {
	selfArg, selfFin := self.handle()
	defer selfFin()
	C.wrap_ImGuiWindow_SetDockIsActive(selfArg, C.bool(v))
}

func (self *Window) DockIsActive() bool {
	selfArg, selfFin := self.handle()

	defer func() {
		selfFin()
	}()
	return C.wrap_ImGuiWindow_GetDockIsActive(selfArg) == C.bool(true)
}

func (self Window) SetDockNodeIsVisible(v bool) {
	selfArg, selfFin := self.handle()
	defer selfFin()
	C.wrap_ImGuiWindow_SetDockNodeIsVisible(selfArg, C.bool(v))
}

func (self *Window) DockNodeIsVisible() bool {
	selfArg, selfFin := self.handle()

	defer func() {
		selfFin()
	}()
	return C.wrap_ImGuiWindow_GetDockNodeIsVisible(selfArg) == C.bool(true)
}

func (self Window) SetDockTabIsVisible(v bool) {
	selfArg, selfFin := self.handle()
	defer selfFin()
	C.wrap_ImGuiWindow_SetDockTabIsVisible(selfArg, C.bool(v))
}

func (self *Window) DockTabIsVisible() bool {
	selfArg, selfFin := self.handle()

	defer func() {
		selfFin()
	}()
	return C.wrap_ImGuiWindow_GetDockTabIsVisible(selfArg) == C.bool(true)
}

func (self Window) SetDockTabWantClose(v bool) {
	selfArg, selfFin := self.handle()
	defer selfFin()
	C.wrap_ImGuiWindow_SetDockTabWantClose(selfArg, C.bool(v))
}

func (self *Window) DockTabWantClose() bool {
	selfArg, selfFin := self.handle()

	defer func() {
		selfFin()
	}()
	return C.wrap_ImGuiWindow_GetDockTabWantClose(selfArg) == C.bool(true)
}

func (self Window) SetDockOrder(v int16) {
	selfArg, selfFin := self.handle()
	defer selfFin()
	C.wrap_ImGuiWindow_SetDockOrder(selfArg, C.short(v))
}

func (self *Window) DockOrder() int16 {
	selfArg, selfFin := self.handle()

	defer func() {
		selfFin()
	}()
	return int16(C.wrap_ImGuiWindow_GetDockOrder(selfArg))
}

func (self Window) SetDockStyle(v WindowDockStyle) {
	vArg, _ := v.c()

	selfArg, selfFin := self.handle()
	defer selfFin()
	C.wrap_ImGuiWindow_SetDockStyle(selfArg, vArg)
}

func (self *Window) DockStyle() WindowDockStyle {
	selfArg, selfFin := self.handle()

	defer func() {
		selfFin()
	}()

	result := C.wrap_ImGuiWindow_GetDockStyle(selfArg)
	return *newWindowDockStyleFromC(func() *C.ImGuiWindowDockStyle { result := result; return &result }())
}

func (self Window) SetDockNode(v *DockNode) {
	vArg, _ := v.handle()

	selfArg, selfFin := self.handle()
	defer selfFin()
	C.wrap_ImGuiWindow_SetDockNode(selfArg, vArg)
}

func (self *Window) DockNode() *DockNode {
	selfArg, selfFin := self.handle()

	defer func() {
		selfFin()
	}()
	return newDockNodeFromC(C.wrap_ImGuiWindow_GetDockNode(selfArg))
}

func (self Window) SetDockNodeAsHost(v *DockNode) {
	vArg, _ := v.handle()

	selfArg, selfFin := self.handle()
	defer selfFin()
	C.wrap_ImGuiWindow_SetDockNodeAsHost(selfArg, vArg)
}

func (self *Window) DockNodeAsHost() *DockNode {
	selfArg, selfFin := self.handle()

	defer func() {
		selfFin()
	}()
	return newDockNodeFromC(C.wrap_ImGuiWindow_GetDockNodeAsHost(selfArg))
}

func (self Window) SetDockId(v ID) {
	vArg, _ := v.c()

	selfArg, selfFin := self.handle()
	defer selfFin()
	C.wrap_ImGuiWindow_SetDockId(selfArg, vArg)
}

func (self *Window) DockId() ID {
	selfArg, selfFin := self.handle()

	defer func() {
		selfFin()
	}()

	result := C.wrap_ImGuiWindow_GetDockId(selfArg)
	return *newIDFromC(func() *C.ImGuiID { result := result; return &result }())
}

func (self Window) SetDockTabItemStatusFlags(v ItemStatusFlags) {
	selfArg, selfFin := self.handle()
	defer selfFin()
	C.wrap_ImGuiWindow_SetDockTabItemStatusFlags(selfArg, C.ImGuiItemStatusFlags(v))
}

func (self *Window) DockTabItemStatusFlags() ItemStatusFlags {
	selfArg, selfFin := self.handle()

	defer func() {
		selfFin()
	}()
	return ItemStatusFlags(C.wrap_ImGuiWindow_GetDockTabItemStatusFlags(selfArg))
}

func (self Window) SetDockTabItemRect(v Rect) {
	selfArg, selfFin := self.handle()
	defer selfFin()
	C.wrap_ImGuiWindow_SetDockTabItemRect(selfArg, v.toC())
}

func (self *Window) DockTabItemRect() Rect {
	selfArg, selfFin := self.handle()

	defer func() {
		selfFin()
	}()
	return *(&Rect{}).fromC(C.wrap_ImGuiWindow_GetDockTabItemRect(selfArg))
}

func (self WindowClass) SetClassId(v ID) {
	vArg, _ := v.c()

	selfArg, selfFin := self.handle()
	defer selfFin()
	C.wrap_ImGuiWindowClass_SetClassId(selfArg, vArg)
}

func (self *WindowClass) ClassId() ID {
	selfArg, selfFin := self.handle()

	defer func() {
		selfFin()
	}()

	result := C.wrap_ImGuiWindowClass_GetClassId(selfArg)
	return *newIDFromC(func() *C.ImGuiID { result := result; return &result }())
}

func (self WindowClass) SetParentViewportId(v ID) {
	vArg, _ := v.c()

	selfArg, selfFin := self.handle()
	defer selfFin()
	C.wrap_ImGuiWindowClass_SetParentViewportId(selfArg, vArg)
}

func (self *WindowClass) ParentViewportId() ID {
	selfArg, selfFin := self.handle()

	defer func() {
		selfFin()
	}()

	result := C.wrap_ImGuiWindowClass_GetParentViewportId(selfArg)
	return *newIDFromC(func() *C.ImGuiID { result := result; return &result }())
}

func (self WindowClass) SetViewportFlagsOverrideSet(v ViewportFlags) {
	selfArg, selfFin := self.handle()
	defer selfFin()
	C.wrap_ImGuiWindowClass_SetViewportFlagsOverrideSet(selfArg, C.ImGuiViewportFlags(v))
}

func (self *WindowClass) ViewportFlagsOverrideSet() ViewportFlags {
	selfArg, selfFin := self.handle()

	defer func() {
		selfFin()
	}()
	return ViewportFlags(C.wrap_ImGuiWindowClass_GetViewportFlagsOverrideSet(selfArg))
}

func (self WindowClass) SetViewportFlagsOverrideClear(v ViewportFlags) {
	selfArg, selfFin := self.handle()
	defer selfFin()
	C.wrap_ImGuiWindowClass_SetViewportFlagsOverrideClear(selfArg, C.ImGuiViewportFlags(v))
}

func (self *WindowClass) ViewportFlagsOverrideClear() ViewportFlags {
	selfArg, selfFin := self.handle()

	defer func() {
		selfFin()
	}()
	return ViewportFlags(C.wrap_ImGuiWindowClass_GetViewportFlagsOverrideClear(selfArg))
}

func (self WindowClass) SetTabItemFlagsOverrideSet(v TabItemFlags) {
	selfArg, selfFin := self.handle()
	defer selfFin()
	C.wrap_ImGuiWindowClass_SetTabItemFlagsOverrideSet(selfArg, C.ImGuiTabItemFlags(v))
}

func (self *WindowClass) TabItemFlagsOverrideSet() TabItemFlags {
	selfArg, selfFin := self.handle()

	defer func() {
		selfFin()
	}()
	return TabItemFlags(C.wrap_ImGuiWindowClass_GetTabItemFlagsOverrideSet(selfArg))
}

func (self WindowClass) SetDockNodeFlagsOverrideSet(v DockNodeFlags) {
	selfArg, selfFin := self.handle()
	defer selfFin()
	C.wrap_ImGuiWindowClass_SetDockNodeFlagsOverrideSet(selfArg, C.ImGuiDockNodeFlags(v))
}

func (self *WindowClass) DockNodeFlagsOverrideSet() DockNodeFlags {
	selfArg, selfFin := self.handle()

	defer func() {
		selfFin()
	}()
	return DockNodeFlags(C.wrap_ImGuiWindowClass_GetDockNodeFlagsOverrideSet(selfArg))
}

func (self WindowClass) SetDockingAlwaysTabBar(v bool) {
	selfArg, selfFin := self.handle()
	defer selfFin()
	C.wrap_ImGuiWindowClass_SetDockingAlwaysTabBar(selfArg, C.bool(v))
}

func (self *WindowClass) DockingAlwaysTabBar() bool {
	selfArg, selfFin := self.handle()

	defer func() {
		selfFin()
	}()
	return C.wrap_ImGuiWindowClass_GetDockingAlwaysTabBar(selfArg) == C.bool(true)
}

func (self WindowClass) SetDockingAllowUnclassed(v bool) {
	selfArg, selfFin := self.handle()
	defer selfFin()
	C.wrap_ImGuiWindowClass_SetDockingAllowUnclassed(selfArg, C.bool(v))
}

func (self *WindowClass) DockingAllowUnclassed() bool {
	selfArg, selfFin := self.handle()

	defer func() {
		selfFin()
	}()
	return C.wrap_ImGuiWindowClass_GetDockingAllowUnclassed(selfArg) == C.bool(true)
}

func (self WindowSettings) SetID(v ID) {
	vArg, _ := v.c()

	selfArg, selfFin := self.handle()
	defer selfFin()
	C.wrap_ImGuiWindowSettings_SetID(selfArg, vArg)
}

func (self *WindowSettings) ID() ID {
	selfArg, selfFin := self.handle()

	defer func() {
		selfFin()
	}()

	result := C.wrap_ImGuiWindowSettings_GetID(selfArg)
	return *newIDFromC(func() *C.ImGuiID { result := result; return &result }())
}

func (self WindowSettings) SetViewportId(v ID) {
	vArg, _ := v.c()

	selfArg, selfFin := self.handle()
	defer selfFin()
	C.wrap_ImGuiWindowSettings_SetViewportId(selfArg, vArg)
}

func (self *WindowSettings) ViewportId() ID {
	selfArg, selfFin := self.handle()

	defer func() {
		selfFin()
	}()

	result := C.wrap_ImGuiWindowSettings_GetViewportId(selfArg)
	return *newIDFromC(func() *C.ImGuiID { result := result; return &result }())
}

func (self WindowSettings) SetDockId(v ID) {
	vArg, _ := v.c()

	selfArg, selfFin := self.handle()
	defer selfFin()
	C.wrap_ImGuiWindowSettings_SetDockId(selfArg, vArg)
}

func (self *WindowSettings) DockId() ID {
	selfArg, selfFin := self.handle()

	defer func() {
		selfFin()
	}()

	result := C.wrap_ImGuiWindowSettings_GetDockId(selfArg)
	return *newIDFromC(func() *C.ImGuiID { result := result; return &result }())
}

func (self WindowSettings) SetClassId(v ID) {
	vArg, _ := v.c()

	selfArg, selfFin := self.handle()
	defer selfFin()
	C.wrap_ImGuiWindowSettings_SetClassId(selfArg, vArg)
}

func (self *WindowSettings) ClassId() ID {
	selfArg, selfFin := self.handle()

	defer func() {
		selfFin()
	}()

	result := C.wrap_ImGuiWindowSettings_GetClassId(selfArg)
	return *newIDFromC(func() *C.ImGuiID { result := result; return &result }())
}

func (self WindowSettings) SetDockOrder(v int16) {
	selfArg, selfFin := self.handle()
	defer selfFin()
	C.wrap_ImGuiWindowSettings_SetDockOrder(selfArg, C.short(v))
}

func (self *WindowSettings) DockOrder() int16 {
	selfArg, selfFin := self.handle()

	defer func() {
		selfFin()
	}()
	return int16(C.wrap_ImGuiWindowSettings_GetDockOrder(selfArg))
}

func (self WindowSettings) SetCollapsed(v bool) {
	selfArg, selfFin := self.handle()
	defer selfFin()
	C.wrap_ImGuiWindowSettings_SetCollapsed(selfArg, C.bool(v))
}

func (self *WindowSettings) Collapsed() bool {
	selfArg, selfFin := self.handle()

	defer func() {
		selfFin()
	}()
	return C.wrap_ImGuiWindowSettings_GetCollapsed(selfArg) == C.bool(true)
}

func (self WindowSettings) SetWantApply(v bool) {
	selfArg, selfFin := self.handle()
	defer selfFin()
	C.wrap_ImGuiWindowSettings_SetWantApply(selfArg, C.bool(v))
}

func (self *WindowSettings) WantApply() bool {
	selfArg, selfFin := self.handle()

	defer func() {
		selfFin()
	}()
	return C.wrap_ImGuiWindowSettings_GetWantApply(selfArg) == C.bool(true)
}

func (self WindowSettings) SetWantDelete(v bool) {
	selfArg, selfFin := self.handle()
	defer selfFin()
	C.wrap_ImGuiWindowSettings_SetWantDelete(selfArg, C.bool(v))
}

func (self *WindowSettings) WantDelete() bool {
	selfArg, selfFin := self.handle()

	defer func() {
		selfFin()
	}()
	return C.wrap_ImGuiWindowSettings_GetWantDelete(selfArg) == C.bool(true)
}

func (self WindowStackData) SetWindow(v *Window) {
	vArg, _ := v.handle()

	selfArg, selfFin := self.handle()
	defer selfFin()
	C.wrap_ImGuiWindowStackData_SetWindow(selfArg, vArg)
}

func (self *WindowStackData) Window() *Window {
	selfArg, selfFin := self.handle()

	defer func() {
		selfFin()
	}()
	return newWindowFromC(C.wrap_ImGuiWindowStackData_GetWindow(selfArg))
}

func (self WindowStackData) SetParentLastItemDataBackup(v LastItemData) {
	vArg, _ := v.c()

	selfArg, selfFin := self.handle()
	defer selfFin()
	C.wrap_ImGuiWindowStackData_SetParentLastItemDataBackup(selfArg, vArg)
}

func (self *WindowStackData) ParentLastItemDataBackup() LastItemData {
	selfArg, selfFin := self.handle()

	defer func() {
		selfFin()
	}()

	result := C.wrap_ImGuiWindowStackData_GetParentLastItemDataBackup(selfArg)
	return *newLastItemDataFromC(func() *C.ImGuiLastItemData { result := result; return &result }())
}

func (self WindowStackData) SetStackSizesOnBegin(v StackSizes) {
	vArg, _ := v.c()

	selfArg, selfFin := self.handle()
	defer selfFin()
	C.wrap_ImGuiWindowStackData_SetStackSizesOnBegin(selfArg, vArg)
}

func (self *WindowStackData) StackSizesOnBegin() StackSizes {
	selfArg, selfFin := self.handle()

	defer func() {
		selfFin()
	}()

	result := C.wrap_ImGuiWindowStackData_GetStackSizesOnBegin(selfArg)
	return *newStackSizesFromC(func() *C.ImGuiStackSizes { result := result; return &result }())
}

func (self WindowTempData) SetCursorPos(v Vec2) {
	selfArg, selfFin := self.handle()
	defer selfFin()
	C.wrap_ImGuiWindowTempData_SetCursorPos(selfArg, v.toC())
}

func (self *WindowTempData) CursorPos() Vec2 {
	selfArg, selfFin := self.handle()

	defer func() {
		selfFin()
	}()
	return *(&Vec2{}).fromC(C.wrap_ImGuiWindowTempData_GetCursorPos(selfArg))
}

func (self WindowTempData) SetCursorPosPrevLine(v Vec2) {
	selfArg, selfFin := self.handle()
	defer selfFin()
	C.wrap_ImGuiWindowTempData_SetCursorPosPrevLine(selfArg, v.toC())
}

func (self *WindowTempData) CursorPosPrevLine() Vec2 {
	selfArg, selfFin := self.handle()

	defer func() {
		selfFin()
	}()
	return *(&Vec2{}).fromC(C.wrap_ImGuiWindowTempData_GetCursorPosPrevLine(selfArg))
}

func (self WindowTempData) SetCursorStartPos(v Vec2) {
	selfArg, selfFin := self.handle()
	defer selfFin()
	C.wrap_ImGuiWindowTempData_SetCursorStartPos(selfArg, v.toC())
}

func (self *WindowTempData) CursorStartPos() Vec2 {
	selfArg, selfFin := self.handle()

	defer func() {
		selfFin()
	}()
	return *(&Vec2{}).fromC(C.wrap_ImGuiWindowTempData_GetCursorStartPos(selfArg))
}

func (self WindowTempData) SetCursorMaxPos(v Vec2) {
	selfArg, selfFin := self.handle()
	defer selfFin()
	C.wrap_ImGuiWindowTempData_SetCursorMaxPos(selfArg, v.toC())
}

func (self *WindowTempData) CursorMaxPos() Vec2 {
	selfArg, selfFin := self.handle()

	defer func() {
		selfFin()
	}()
	return *(&Vec2{}).fromC(C.wrap_ImGuiWindowTempData_GetCursorMaxPos(selfArg))
}

func (self WindowTempData) SetIdealMaxPos(v Vec2) {
	selfArg, selfFin := self.handle()
	defer selfFin()
	C.wrap_ImGuiWindowTempData_SetIdealMaxPos(selfArg, v.toC())
}

func (self *WindowTempData) IdealMaxPos() Vec2 {
	selfArg, selfFin := self.handle()

	defer func() {
		selfFin()
	}()
	return *(&Vec2{}).fromC(C.wrap_ImGuiWindowTempData_GetIdealMaxPos(selfArg))
}

func (self WindowTempData) SetCurrLineSize(v Vec2) {
	selfArg, selfFin := self.handle()
	defer selfFin()
	C.wrap_ImGuiWindowTempData_SetCurrLineSize(selfArg, v.toC())
}

func (self *WindowTempData) CurrLineSize() Vec2 {
	selfArg, selfFin := self.handle()

	defer func() {
		selfFin()
	}()
	return *(&Vec2{}).fromC(C.wrap_ImGuiWindowTempData_GetCurrLineSize(selfArg))
}

func (self WindowTempData) SetPrevLineSize(v Vec2) {
	selfArg, selfFin := self.handle()
	defer selfFin()
	C.wrap_ImGuiWindowTempData_SetPrevLineSize(selfArg, v.toC())
}

func (self *WindowTempData) PrevLineSize() Vec2 {
	selfArg, selfFin := self.handle()

	defer func() {
		selfFin()
	}()
	return *(&Vec2{}).fromC(C.wrap_ImGuiWindowTempData_GetPrevLineSize(selfArg))
}

func (self WindowTempData) SetCurrLineTextBaseOffset(v float32) {
	selfArg, selfFin := self.handle()
	defer selfFin()
	C.wrap_ImGuiWindowTempData_SetCurrLineTextBaseOffset(selfArg, C.float(v))
}

func (self *WindowTempData) CurrLineTextBaseOffset() float32 {
	selfArg, selfFin := self.handle()

	defer func() {
		selfFin()
	}()
	return float32(C.wrap_ImGuiWindowTempData_GetCurrLineTextBaseOffset(selfArg))
}

func (self WindowTempData) SetPrevLineTextBaseOffset(v float32) {
	selfArg, selfFin := self.handle()
	defer selfFin()
	C.wrap_ImGuiWindowTempData_SetPrevLineTextBaseOffset(selfArg, C.float(v))
}

func (self *WindowTempData) PrevLineTextBaseOffset() float32 {
	selfArg, selfFin := self.handle()

	defer func() {
		selfFin()
	}()
	return float32(C.wrap_ImGuiWindowTempData_GetPrevLineTextBaseOffset(selfArg))
}

func (self WindowTempData) SetIsSameLine(v bool) {
	selfArg, selfFin := self.handle()
	defer selfFin()
	C.wrap_ImGuiWindowTempData_SetIsSameLine(selfArg, C.bool(v))
}

func (self *WindowTempData) IsSameLine() bool {
	selfArg, selfFin := self.handle()

	defer func() {
		selfFin()
	}()
	return C.wrap_ImGuiWindowTempData_GetIsSameLine(selfArg) == C.bool(true)
}

func (self WindowTempData) SetIsSetPos(v bool) {
	selfArg, selfFin := self.handle()
	defer selfFin()
	C.wrap_ImGuiWindowTempData_SetIsSetPos(selfArg, C.bool(v))
}

func (self *WindowTempData) IsSetPos() bool {
	selfArg, selfFin := self.handle()

	defer func() {
		selfFin()
	}()
	return C.wrap_ImGuiWindowTempData_GetIsSetPos(selfArg) == C.bool(true)
}

func (self WindowTempData) SetIndent(v Vec1) {
	vArg, _ := v.c()

	selfArg, selfFin := self.handle()
	defer selfFin()
	C.wrap_ImGuiWindowTempData_SetIndent(selfArg, vArg)
}

func (self *WindowTempData) Indent() Vec1 {
	selfArg, selfFin := self.handle()

	defer func() {
		selfFin()
	}()

	result := C.wrap_ImGuiWindowTempData_GetIndent(selfArg)
	return *newVec1FromC(func() *C.ImVec1 { result := result; return &result }())
}

func (self WindowTempData) SetColumnsOffset(v Vec1) {
	vArg, _ := v.c()

	selfArg, selfFin := self.handle()
	defer selfFin()
	C.wrap_ImGuiWindowTempData_SetColumnsOffset(selfArg, vArg)
}

func (self *WindowTempData) ColumnsOffset() Vec1 {
	selfArg, selfFin := self.handle()

	defer func() {
		selfFin()
	}()

	result := C.wrap_ImGuiWindowTempData_GetColumnsOffset(selfArg)
	return *newVec1FromC(func() *C.ImVec1 { result := result; return &result }())
}

func (self WindowTempData) SetGroupOffset(v Vec1) {
	vArg, _ := v.c()

	selfArg, selfFin := self.handle()
	defer selfFin()
	C.wrap_ImGuiWindowTempData_SetGroupOffset(selfArg, vArg)
}

func (self *WindowTempData) GroupOffset() Vec1 {
	selfArg, selfFin := self.handle()

	defer func() {
		selfFin()
	}()

	result := C.wrap_ImGuiWindowTempData_GetGroupOffset(selfArg)
	return *newVec1FromC(func() *C.ImVec1 { result := result; return &result }())
}

func (self WindowTempData) SetCursorStartPosLossyness(v Vec2) {
	selfArg, selfFin := self.handle()
	defer selfFin()
	C.wrap_ImGuiWindowTempData_SetCursorStartPosLossyness(selfArg, v.toC())
}

func (self *WindowTempData) CursorStartPosLossyness() Vec2 {
	selfArg, selfFin := self.handle()

	defer func() {
		selfFin()
	}()
	return *(&Vec2{}).fromC(C.wrap_ImGuiWindowTempData_GetCursorStartPosLossyness(selfArg))
}

func (self WindowTempData) SetNavLayerCurrent(v NavLayer) {
	selfArg, selfFin := self.handle()
	defer selfFin()
	C.wrap_ImGuiWindowTempData_SetNavLayerCurrent(selfArg, C.ImGuiNavLayer(v))
}

func (self *WindowTempData) NavLayerCurrent() NavLayer {
	selfArg, selfFin := self.handle()

	defer func() {
		selfFin()
	}()
	return NavLayer(C.wrap_ImGuiWindowTempData_GetNavLayerCurrent(selfArg))
}

func (self WindowTempData) SetNavLayersActiveMask(v int16) {
	selfArg, selfFin := self.handle()
	defer selfFin()
	C.wrap_ImGuiWindowTempData_SetNavLayersActiveMask(selfArg, C.short(v))
}

func (self *WindowTempData) NavLayersActiveMask() int16 {
	selfArg, selfFin := self.handle()

	defer func() {
		selfFin()
	}()
	return int16(C.wrap_ImGuiWindowTempData_GetNavLayersActiveMask(selfArg))
}

func (self WindowTempData) SetNavLayersActiveMaskNext(v int16) {
	selfArg, selfFin := self.handle()
	defer selfFin()
	C.wrap_ImGuiWindowTempData_SetNavLayersActiveMaskNext(selfArg, C.short(v))
}

func (self *WindowTempData) NavLayersActiveMaskNext() int16 {
	selfArg, selfFin := self.handle()

	defer func() {
		selfFin()
	}()
	return int16(C.wrap_ImGuiWindowTempData_GetNavLayersActiveMaskNext(selfArg))
}

func (self WindowTempData) SetNavIsScrollPushableX(v bool) {
	selfArg, selfFin := self.handle()
	defer selfFin()
	C.wrap_ImGuiWindowTempData_SetNavIsScrollPushableX(selfArg, C.bool(v))
}

func (self *WindowTempData) NavIsScrollPushableX() bool {
	selfArg, selfFin := self.handle()

	defer func() {
		selfFin()
	}()
	return C.wrap_ImGuiWindowTempData_GetNavIsScrollPushableX(selfArg) == C.bool(true)
}

func (self WindowTempData) SetNavHideHighlightOneFrame(v bool) {
	selfArg, selfFin := self.handle()
	defer selfFin()
	C.wrap_ImGuiWindowTempData_SetNavHideHighlightOneFrame(selfArg, C.bool(v))
}

func (self *WindowTempData) NavHideHighlightOneFrame() bool {
	selfArg, selfFin := self.handle()

	defer func() {
		selfFin()
	}()
	return C.wrap_ImGuiWindowTempData_GetNavHideHighlightOneFrame(selfArg) == C.bool(true)
}

func (self WindowTempData) SetNavWindowHasScrollY(v bool) {
	selfArg, selfFin := self.handle()
	defer selfFin()
	C.wrap_ImGuiWindowTempData_SetNavWindowHasScrollY(selfArg, C.bool(v))
}

func (self *WindowTempData) NavWindowHasScrollY() bool {
	selfArg, selfFin := self.handle()

	defer func() {
		selfFin()
	}()
	return C.wrap_ImGuiWindowTempData_GetNavWindowHasScrollY(selfArg) == C.bool(true)
}

func (self WindowTempData) SetMenuBarAppending(v bool) {
	selfArg, selfFin := self.handle()
	defer selfFin()
	C.wrap_ImGuiWindowTempData_SetMenuBarAppending(selfArg, C.bool(v))
}

func (self *WindowTempData) MenuBarAppending() bool {
	selfArg, selfFin := self.handle()

	defer func() {
		selfFin()
	}()
	return C.wrap_ImGuiWindowTempData_GetMenuBarAppending(selfArg) == C.bool(true)
}

func (self WindowTempData) SetMenuBarOffset(v Vec2) {
	selfArg, selfFin := self.handle()
	defer selfFin()
	C.wrap_ImGuiWindowTempData_SetMenuBarOffset(selfArg, v.toC())
}

func (self *WindowTempData) MenuBarOffset() Vec2 {
	selfArg, selfFin := self.handle()

	defer func() {
		selfFin()
	}()
	return *(&Vec2{}).fromC(C.wrap_ImGuiWindowTempData_GetMenuBarOffset(selfArg))
}

func (self WindowTempData) SetMenuColumns(v MenuColumns) {
	vArg, _ := v.c()

	selfArg, selfFin := self.handle()
	defer selfFin()
	C.wrap_ImGuiWindowTempData_SetMenuColumns(selfArg, vArg)
}

func (self *WindowTempData) MenuColumns() MenuColumns {
	selfArg, selfFin := self.handle()

	defer func() {
		selfFin()
	}()

	result := C.wrap_ImGuiWindowTempData_GetMenuColumns(selfArg)
	return *newMenuColumnsFromC(func() *C.ImGuiMenuColumns { result := result; return &result }())
}

func (self WindowTempData) SetTreeDepth(v int32) {
	selfArg, selfFin := self.handle()
	defer selfFin()
	C.wrap_ImGuiWindowTempData_SetTreeDepth(selfArg, C.int(v))
}

func (self *WindowTempData) TreeDepth() int32 {
	selfArg, selfFin := self.handle()

	defer func() {
		selfFin()
	}()
	return int32(C.wrap_ImGuiWindowTempData_GetTreeDepth(selfArg))
}

func (self WindowTempData) SetTreeJumpToParentOnPopMask(v uint32) {
	selfArg, selfFin := self.handle()
	defer selfFin()
	C.wrap_ImGuiWindowTempData_SetTreeJumpToParentOnPopMask(selfArg, C.ImU32(v))
}

func (self *WindowTempData) TreeJumpToParentOnPopMask() uint32 {
	selfArg, selfFin := self.handle()

	defer func() {
		selfFin()
	}()
	return uint32(C.wrap_ImGuiWindowTempData_GetTreeJumpToParentOnPopMask(selfArg))
}

func (self WindowTempData) SetStateStorage(v *Storage) {
	vArg, _ := v.handle()

	selfArg, selfFin := self.handle()
	defer selfFin()
	C.wrap_ImGuiWindowTempData_SetStateStorage(selfArg, vArg)
}

func (self *WindowTempData) StateStorage() *Storage {
	selfArg, selfFin := self.handle()

	defer func() {
		selfFin()
	}()
	return newStorageFromC(C.wrap_ImGuiWindowTempData_GetStateStorage(selfArg))
}

func (self WindowTempData) SetCurrentColumns(v *OldColumns) {
	vArg, _ := v.handle()

	selfArg, selfFin := self.handle()
	defer selfFin()
	C.wrap_ImGuiWindowTempData_SetCurrentColumns(selfArg, vArg)
}

func (self *WindowTempData) CurrentColumns() *OldColumns {
	selfArg, selfFin := self.handle()

	defer func() {
		selfFin()
	}()
	return newOldColumnsFromC(C.wrap_ImGuiWindowTempData_GetCurrentColumns(selfArg))
}

func (self WindowTempData) SetCurrentTableIdx(v int32) {
	selfArg, selfFin := self.handle()
	defer selfFin()
	C.wrap_ImGuiWindowTempData_SetCurrentTableIdx(selfArg, C.int(v))
}

func (self *WindowTempData) CurrentTableIdx() int32 {
	selfArg, selfFin := self.handle()

	defer func() {
		selfFin()
	}()
	return int32(C.wrap_ImGuiWindowTempData_GetCurrentTableIdx(selfArg))
}

func (self WindowTempData) SetLayoutType(v LayoutType) {
	selfArg, selfFin := self.handle()
	defer selfFin()
	C.wrap_ImGuiWindowTempData_SetLayoutType(selfArg, C.ImGuiLayoutType(v))
}

func (self *WindowTempData) LayoutType() LayoutType {
	selfArg, selfFin := self.handle()

	defer func() {
		selfFin()
	}()
	return LayoutType(C.wrap_ImGuiWindowTempData_GetLayoutType(selfArg))
}

func (self WindowTempData) SetParentLayoutType(v LayoutType) {
	selfArg, selfFin := self.handle()
	defer selfFin()
	C.wrap_ImGuiWindowTempData_SetParentLayoutType(selfArg, C.ImGuiLayoutType(v))
}

func (self *WindowTempData) ParentLayoutType() LayoutType {
	selfArg, selfFin := self.handle()

	defer func() {
		selfFin()
	}()
	return LayoutType(C.wrap_ImGuiWindowTempData_GetParentLayoutType(selfArg))
}

func (self WindowTempData) SetItemWidth(v float32) {
	selfArg, selfFin := self.handle()
	defer selfFin()
	C.wrap_ImGuiWindowTempData_SetItemWidth(selfArg, C.float(v))
}

func (self *WindowTempData) ItemWidth() float32 {
	selfArg, selfFin := self.handle()

	defer func() {
		selfFin()
	}()
	return float32(C.wrap_ImGuiWindowTempData_GetItemWidth(selfArg))
}

func (self WindowTempData) SetTextWrapPos(v float32) {
	selfArg, selfFin := self.handle()
	defer selfFin()
	C.wrap_ImGuiWindowTempData_SetTextWrapPos(selfArg, C.float(v))
}

func (self *WindowTempData) TextWrapPos() float32 {
	selfArg, selfFin := self.handle()

	defer func() {
		selfFin()
	}()
	return float32(C.wrap_ImGuiWindowTempData_GetTextWrapPos(selfArg))
}

func (self WindowTempData) SetItemWidthStack(v Vector[*float32]) {
	vData := v.Data
	vDataArg, _ := WrapNumberPtr[C.float, float32](vData)
	vVecArg := new(C.ImVector_float)
	vVecArg.Size = C.int(v.Size)
	vVecArg.Capacity = C.int(v.Capacity)
	vVecArg.Data = vDataArg
	v.pinner.Pin(vVecArg.Data)

	selfArg, selfFin := self.handle()
	defer selfFin()
	C.wrap_ImGuiWindowTempData_SetItemWidthStack(selfArg, *vVecArg)
}

func (self *WindowTempData) ItemWidthStack() Vector[*float32] {
	selfArg, selfFin := self.handle()

	defer func() {
		selfFin()
	}()
	return newVectorFromC(C.wrap_ImGuiWindowTempData_GetItemWidthStack(selfArg).Size, C.wrap_ImGuiWindowTempData_GetItemWidthStack(selfArg).Capacity, (*float32)(C.wrap_ImGuiWindowTempData_GetItemWidthStack(selfArg).Data))
}

func (self WindowTempData) SetTextWrapPosStack(v Vector[*float32]) {
	vData := v.Data
	vDataArg, _ := WrapNumberPtr[C.float, float32](vData)
	vVecArg := new(C.ImVector_float)
	vVecArg.Size = C.int(v.Size)
	vVecArg.Capacity = C.int(v.Capacity)
	vVecArg.Data = vDataArg
	v.pinner.Pin(vVecArg.Data)

	selfArg, selfFin := self.handle()
	defer selfFin()
	C.wrap_ImGuiWindowTempData_SetTextWrapPosStack(selfArg, *vVecArg)
}

func (self *WindowTempData) TextWrapPosStack() Vector[*float32] {
	selfArg, selfFin := self.handle()

	defer func() {
		selfFin()
	}()
	return newVectorFromC(C.wrap_ImGuiWindowTempData_GetTextWrapPosStack(selfArg).Size, C.wrap_ImGuiWindowTempData_GetTextWrapPosStack(selfArg).Capacity, (*float32)(C.wrap_ImGuiWindowTempData_GetTextWrapPosStack(selfArg).Data))
}

func (self *STBTexteditState) TexteditStateGetCursor() int32 {
	selfArg, selfFin := self.handle()

	defer func() {
		selfFin()
	}()
	return int32(C.wrap_STB_TexteditState_GetCursor(selfArg))
}

func (self *STBTexteditState) TexteditStateGetSelectstart() int32 {
	selfArg, selfFin := self.handle()

	defer func() {
		selfFin()
	}()
	return int32(C.wrap_STB_TexteditState_GetSelect_start(selfArg))
}

func (self *STBTexteditState) TexteditStateGetSelectend() int32 {
	selfArg, selfFin := self.handle()

	defer func() {
		selfFin()
	}()
	return int32(C.wrap_STB_TexteditState_GetSelect_end(selfArg))
}

func (self *STBTexteditState) TexteditStateGetInsertmode() uint {
	selfArg, selfFin := self.handle()

	defer func() {
		selfFin()
	}()
	return uint(C.wrap_STB_TexteditState_GetInsert_mode(selfArg))
}

func (self *STBTexteditState) TexteditStateGetRowcountperpage() int32 {
	selfArg, selfFin := self.handle()

	defer func() {
		selfFin()
	}()
	return int32(C.wrap_STB_TexteditState_GetRow_count_per_page(selfArg))
}

func (self *STBTexteditState) TexteditStateGetCursoratendofline() uint {
	selfArg, selfFin := self.handle()

	defer func() {
		selfFin()
	}()
	return uint(C.wrap_STB_TexteditState_GetCursor_at_end_of_line(selfArg))
}

func (self *STBTexteditState) TexteditStateGetInitialized() uint {
	selfArg, selfFin := self.handle()

	defer func() {
		selfFin()
	}()
	return uint(C.wrap_STB_TexteditState_GetInitialized(selfArg))
}

func (self *STBTexteditState) TexteditStateGetHaspreferredx() uint {
	selfArg, selfFin := self.handle()

	defer func() {
		selfFin()
	}()
	return uint(C.wrap_STB_TexteditState_GetHas_preferred_x(selfArg))
}

func (self *STBTexteditState) TexteditStateGetSingleline() uint {
	selfArg, selfFin := self.handle()

	defer func() {
		selfFin()
	}()
	return uint(C.wrap_STB_TexteditState_GetSingle_line(selfArg))
}

func (self *STBTexteditState) TexteditStateGetPadding1() uint {
	selfArg, selfFin := self.handle()

	defer func() {
		selfFin()
	}()
	return uint(C.wrap_STB_TexteditState_GetPadding1(selfArg))
}

func (self *STBTexteditState) TexteditStateGetPadding2() uint {
	selfArg, selfFin := self.handle()

	defer func() {
		selfFin()
	}()
	return uint(C.wrap_STB_TexteditState_GetPadding2(selfArg))
}

func (self *STBTexteditState) TexteditStateGetPadding3() uint {
	selfArg, selfFin := self.handle()

	defer func() {
		selfFin()
	}()
	return uint(C.wrap_STB_TexteditState_GetPadding3(selfArg))
}

func (self *STBTexteditState) TexteditStateGetPreferredx() float32 {
	selfArg, selfFin := self.handle()

	defer func() {
		selfFin()
	}()
	return float32(C.wrap_STB_TexteditState_GetPreferred_x(selfArg))
}

func (self *STBTexteditState) TexteditStateGetUndostate() StbUndoState {
	selfArg, selfFin := self.handle()

	defer func() {
		selfFin()
	}()

	result := C.wrap_STB_TexteditState_GetUndostate(selfArg)
	return *newStbUndoStateFromC(func() *C.StbUndoState { result := result; return &result }())
}

func (self StbTexteditRow) SetX0(v float32) {
	selfArg, selfFin := self.handle()
	defer selfFin()
	C.wrap_StbTexteditRow_SetX0(selfArg, C.float(v))
}

func (self *StbTexteditRow) X0() float32 {
	selfArg, selfFin := self.handle()

	defer func() {
		selfFin()
	}()
	return float32(C.wrap_StbTexteditRow_GetX0(selfArg))
}

func (self StbTexteditRow) SetX1(v float32) {
	selfArg, selfFin := self.handle()
	defer selfFin()
	C.wrap_StbTexteditRow_SetX1(selfArg, C.float(v))
}

func (self *StbTexteditRow) X1() float32 {
	selfArg, selfFin := self.handle()

	defer func() {
		selfFin()
	}()
	return float32(C.wrap_StbTexteditRow_GetX1(selfArg))
}

func (self StbTexteditRow) SetBaselineydelta(v float32) {
	selfArg, selfFin := self.handle()
	defer selfFin()
	C.wrap_StbTexteditRow_SetBaseline_y_delta(selfArg, C.float(v))
}

func (self *StbTexteditRow) Baselineydelta() float32 {
	selfArg, selfFin := self.handle()

	defer func() {
		selfFin()
	}()
	return float32(C.wrap_StbTexteditRow_GetBaseline_y_delta(selfArg))
}

func (self StbTexteditRow) SetYmin(v float32) {
	selfArg, selfFin := self.handle()
	defer selfFin()
	C.wrap_StbTexteditRow_SetYmin(selfArg, C.float(v))
}

func (self *StbTexteditRow) Ymin() float32 {
	selfArg, selfFin := self.handle()

	defer func() {
		selfFin()
	}()
	return float32(C.wrap_StbTexteditRow_GetYmin(selfArg))
}

func (self StbTexteditRow) SetYmax(v float32) {
	selfArg, selfFin := self.handle()
	defer selfFin()
	C.wrap_StbTexteditRow_SetYmax(selfArg, C.float(v))
}

func (self *StbTexteditRow) Ymax() float32 {
	selfArg, selfFin := self.handle()

	defer func() {
		selfFin()
	}()
	return float32(C.wrap_StbTexteditRow_GetYmax(selfArg))
}

func (self StbTexteditRow) SetNumchars(v int32) {
	selfArg, selfFin := self.handle()
	defer selfFin()
	C.wrap_StbTexteditRow_SetNum_chars(selfArg, C.int(v))
}

func (self *StbTexteditRow) Numchars() int32 {
	selfArg, selfFin := self.handle()

	defer func() {
		selfFin()
	}()
	return int32(C.wrap_StbTexteditRow_GetNum_chars(selfArg))
}

func (self StbUndoRecord) SetWhere(v int32) {
	selfArg, selfFin := self.handle()
	defer selfFin()
	C.wrap_StbUndoRecord_SetWhere(selfArg, C.int(v))
}

func (self *StbUndoRecord) Where() int32 {
	selfArg, selfFin := self.handle()

	defer func() {
		selfFin()
	}()
	return int32(C.wrap_StbUndoRecord_GetWhere(selfArg))
}

func (self StbUndoRecord) SetInsertlength(v int32) {
	selfArg, selfFin := self.handle()
	defer selfFin()
	C.wrap_StbUndoRecord_SetInsert_length(selfArg, C.int(v))
}

func (self *StbUndoRecord) Insertlength() int32 {
	selfArg, selfFin := self.handle()

	defer func() {
		selfFin()
	}()
	return int32(C.wrap_StbUndoRecord_GetInsert_length(selfArg))
}

func (self StbUndoRecord) SetDeletelength(v int32) {
	selfArg, selfFin := self.handle()
	defer selfFin()
	C.wrap_StbUndoRecord_SetDelete_length(selfArg, C.int(v))
}

func (self *StbUndoRecord) Deletelength() int32 {
	selfArg, selfFin := self.handle()

	defer func() {
		selfFin()
	}()
	return int32(C.wrap_StbUndoRecord_GetDelete_length(selfArg))
}

func (self StbUndoRecord) SetCharstorage(v int32) {
	selfArg, selfFin := self.handle()
	defer selfFin()
	C.wrap_StbUndoRecord_SetChar_storage(selfArg, C.int(v))
}

func (self *StbUndoRecord) Charstorage() int32 {
	selfArg, selfFin := self.handle()

	defer func() {
		selfFin()
	}()
	return int32(C.wrap_StbUndoRecord_GetChar_storage(selfArg))
}

func (self StbUndoState) SetUndopoint(v int16) {
	selfArg, selfFin := self.handle()
	defer selfFin()
	C.wrap_StbUndoState_SetUndo_point(selfArg, C.short(v))
}

func (self *StbUndoState) Undopoint() int16 {
	selfArg, selfFin := self.handle()

	defer func() {
		selfFin()
	}()
	return int16(C.wrap_StbUndoState_GetUndo_point(selfArg))
}

func (self StbUndoState) SetRedopoint(v int16) {
	selfArg, selfFin := self.handle()
	defer selfFin()
	C.wrap_StbUndoState_SetRedo_point(selfArg, C.short(v))
}

func (self *StbUndoState) Redopoint() int16 {
	selfArg, selfFin := self.handle()

	defer func() {
		selfFin()
	}()
	return int16(C.wrap_StbUndoState_GetRedo_point(selfArg))
}

func (self StbUndoState) SetUndocharpoint(v int32) {
	selfArg, selfFin := self.handle()
	defer selfFin()
	C.wrap_StbUndoState_SetUndo_char_point(selfArg, C.int(v))
}

func (self *StbUndoState) Undocharpoint() int32 {
	selfArg, selfFin := self.handle()

	defer func() {
		selfFin()
	}()
	return int32(C.wrap_StbUndoState_GetUndo_char_point(selfArg))
}

func (self StbUndoState) SetRedocharpoint(v int32) {
	selfArg, selfFin := self.handle()
	defer selfFin()
	C.wrap_StbUndoState_SetRedo_char_point(selfArg, C.int(v))
}

func (self *StbUndoState) Redocharpoint() int32 {
	selfArg, selfFin := self.handle()

	defer func() {
		selfFin()
	}()
	return int32(C.wrap_StbUndoState_GetRedo_char_point(selfArg))
}
