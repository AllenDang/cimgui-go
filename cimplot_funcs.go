// Code generated by cmd/codegen from https://github.com/AllenDang/cimgui-go.
// DO NOT EDIT.

package imgui

// #include "extra_types.h"
// #include "cimplot_structs_accessor.h"
// #include "cimplot_wrapper.h"
import "C"
import "unsafe"

func (self *PlotAlignmentData) Begin() {
	selfArg, selfFin := self.handle()
	C.ImPlotAlignmentData_Begin(selfArg)

	selfFin()
}

func (self *PlotAlignmentData) End() {
	selfArg, selfFin := self.handle()
	C.ImPlotAlignmentData_End(selfArg)

	selfFin()
}

func NewPlotAlignmentData() *PlotAlignmentData {
	return newPlotAlignmentDataFromC(C.ImPlotAlignmentData_ImPlotAlignmentData())
}

func (self *PlotAlignmentData) Reset() {
	selfArg, selfFin := self.handle()
	C.ImPlotAlignmentData_Reset(selfArg)

	selfFin()
}

func (self *PlotAlignmentData) Update(pad_a *float32, pad_b *float32, delta_a *float32, delta_b *float32) {
	selfArg, selfFin := self.handle()
	pad_aArg, pad_aFin := WrapNumberPtr[C.float, float32](pad_a)
	pad_bArg, pad_bFin := WrapNumberPtr[C.float, float32](pad_b)
	delta_aArg, delta_aFin := WrapNumberPtr[C.float, float32](delta_a)
	delta_bArg, delta_bFin := WrapNumberPtr[C.float, float32](delta_b)
	C.ImPlotAlignmentData_Update(selfArg, pad_aArg, pad_bArg, delta_aArg, delta_bArg)

	selfFin()
	pad_aFin()
	pad_bFin()
	delta_aFin()
	delta_bFin()
}

func (self *PlotAlignmentData) Destroy() {
	selfArg, selfFin := self.handle()
	C.ImPlotAlignmentData_destroy(selfArg)

	selfFin()
}

func (self *PlotAnnotationCollection) Append(pos Vec2, off Vec2, bg uint32, fg uint32, clamp bool, fmt string) {
	selfArg, selfFin := self.handle()
	fmtArg, fmtFin := WrapString(fmt)
	C.wrap_ImPlotAnnotationCollection_Append(selfArg, pos.toC(), off.toC(), C.ImU32(bg), C.ImU32(fg), C.bool(clamp), fmtArg)

	selfFin()
	fmtFin()
}

func (self *PlotAnnotationCollection) Text(idx int32) string {
	selfArg, selfFin := self.handle()

	defer func() {
		selfFin()
	}()
	return C.GoString(C.ImPlotAnnotationCollection_GetText(selfArg, C.int(idx)))
}

func NewPlotAnnotationCollection() *PlotAnnotationCollection {
	return newPlotAnnotationCollectionFromC(C.ImPlotAnnotationCollection_ImPlotAnnotationCollection())
}

func (self *PlotAnnotationCollection) Reset() {
	selfArg, selfFin := self.handle()
	C.ImPlotAnnotationCollection_Reset(selfArg)

	selfFin()
}

func (self *PlotAnnotationCollection) Destroy() {
	selfArg, selfFin := self.handle()
	C.ImPlotAnnotationCollection_destroy(selfArg)

	selfFin()
}

func NewPlotAnnotation() *PlotAnnotation {
	return newPlotAnnotationFromC(C.ImPlotAnnotation_ImPlotAnnotation())
}

func (self *PlotAnnotation) Destroy() {
	selfArg, selfFin := self.handle()
	C.ImPlotAnnotation_destroy(selfArg)

	selfFin()
}

func (self *PlotAxis) ApplyFit(padding float32) {
	selfArg, selfFin := self.handle()
	C.ImPlotAxis_ApplyFit(selfArg, C.float(padding))

	selfFin()
}

func (self *PlotAxis) CanInitFit() bool {
	selfArg, selfFin := self.handle()

	defer func() {
		selfFin()
	}()
	return C.ImPlotAxis_CanInitFit(selfArg) == C.bool(true)
}

func (self *PlotAxis) Constrain() {
	selfArg, selfFin := self.handle()
	C.ImPlotAxis_Constrain(selfArg)

	selfFin()
}

func (self *PlotAxis) ExtendFit(v float64) {
	selfArg, selfFin := self.handle()
	C.ImPlotAxis_ExtendFit(selfArg, C.double(v))

	selfFin()
}

func (self *PlotAxis) ExtendFitWith(alt *PlotAxis, v float64, v_alt float64) {
	selfArg, selfFin := self.handle()
	altArg, altFin := alt.handle()
	C.ImPlotAxis_ExtendFitWith(selfArg, altArg, C.double(v), C.double(v_alt))

	selfFin()
	altFin()
}

func (self *PlotAxis) Aspect() float64 {
	selfArg, selfFin := self.handle()

	defer func() {
		selfFin()
	}()
	return float64(C.ImPlotAxis_GetAspect(selfArg))
}

func (self *PlotAxis) HasGridLines() bool {
	selfArg, selfFin := self.handle()

	defer func() {
		selfFin()
	}()
	return C.ImPlotAxis_HasGridLines(selfArg) == C.bool(true)
}

func (self *PlotAxis) HasLabel() bool {
	selfArg, selfFin := self.handle()

	defer func() {
		selfFin()
	}()
	return C.ImPlotAxis_HasLabel(selfArg) == C.bool(true)
}

func (self *PlotAxis) HasMenus() bool {
	selfArg, selfFin := self.handle()

	defer func() {
		selfFin()
	}()
	return C.ImPlotAxis_HasMenus(selfArg) == C.bool(true)
}

func (self *PlotAxis) HasTickLabels() bool {
	selfArg, selfFin := self.handle()

	defer func() {
		selfFin()
	}()
	return C.ImPlotAxis_HasTickLabels(selfArg) == C.bool(true)
}

func (self *PlotAxis) HasTickMarks() bool {
	selfArg, selfFin := self.handle()

	defer func() {
		selfFin()
	}()
	return C.ImPlotAxis_HasTickMarks(selfArg) == C.bool(true)
}

func NewPlotAxis() *PlotAxis {
	return newPlotAxisFromC(C.ImPlotAxis_ImPlotAxis())
}

func (self *PlotAxis) IsAutoFitting() bool {
	selfArg, selfFin := self.handle()

	defer func() {
		selfFin()
	}()
	return C.ImPlotAxis_IsAutoFitting(selfArg) == C.bool(true)
}

func (self *PlotAxis) IsForeground() bool {
	selfArg, selfFin := self.handle()

	defer func() {
		selfFin()
	}()
	return C.ImPlotAxis_IsForeground(selfArg) == C.bool(true)
}

func (self *PlotAxis) IsInputLocked() bool {
	selfArg, selfFin := self.handle()

	defer func() {
		selfFin()
	}()
	return C.ImPlotAxis_IsInputLocked(selfArg) == C.bool(true)
}

func (self *PlotAxis) IsInputLockedMax() bool {
	selfArg, selfFin := self.handle()

	defer func() {
		selfFin()
	}()
	return C.ImPlotAxis_IsInputLockedMax(selfArg) == C.bool(true)
}

func (self *PlotAxis) IsInputLockedMin() bool {
	selfArg, selfFin := self.handle()

	defer func() {
		selfFin()
	}()
	return C.ImPlotAxis_IsInputLockedMin(selfArg) == C.bool(true)
}

func (self *PlotAxis) IsInverted() bool {
	selfArg, selfFin := self.handle()

	defer func() {
		selfFin()
	}()
	return C.ImPlotAxis_IsInverted(selfArg) == C.bool(true)
}

func (self *PlotAxis) IsLocked() bool {
	selfArg, selfFin := self.handle()

	defer func() {
		selfFin()
	}()
	return C.ImPlotAxis_IsLocked(selfArg) == C.bool(true)
}

func (self *PlotAxis) IsLockedMax() bool {
	selfArg, selfFin := self.handle()

	defer func() {
		selfFin()
	}()
	return C.ImPlotAxis_IsLockedMax(selfArg) == C.bool(true)
}

func (self *PlotAxis) IsLockedMin() bool {
	selfArg, selfFin := self.handle()

	defer func() {
		selfFin()
	}()
	return C.ImPlotAxis_IsLockedMin(selfArg) == C.bool(true)
}

func (self *PlotAxis) IsOpposite() bool {
	selfArg, selfFin := self.handle()

	defer func() {
		selfFin()
	}()
	return C.ImPlotAxis_IsOpposite(selfArg) == C.bool(true)
}

func (self *PlotAxis) IsPanLocked(increasing bool) bool {
	selfArg, selfFin := self.handle()

	defer func() {
		selfFin()
	}()
	return C.ImPlotAxis_IsPanLocked(selfArg, C.bool(increasing)) == C.bool(true)
}

func (self *PlotAxis) IsRangeLocked() bool {
	selfArg, selfFin := self.handle()

	defer func() {
		selfFin()
	}()
	return C.ImPlotAxis_IsRangeLocked(selfArg) == C.bool(true)
}

func (self *PlotAxis) PixelSize() float32 {
	selfArg, selfFin := self.handle()

	defer func() {
		selfFin()
	}()
	return float32(C.ImPlotAxis_PixelSize(selfArg))
}

func (self *PlotAxis) PixelsToPlot(pix float32) float64 {
	selfArg, selfFin := self.handle()

	defer func() {
		selfFin()
	}()
	return float64(C.ImPlotAxis_PixelsToPlot(selfArg, C.float(pix)))
}

func (self *PlotAxis) PlotToPixels(plt float64) float32 {
	selfArg, selfFin := self.handle()

	defer func() {
		selfFin()
	}()
	return float32(C.ImPlotAxis_PlotToPixels(selfArg, C.double(plt)))
}

func (self *PlotAxis) PullLinks() {
	selfArg, selfFin := self.handle()
	C.ImPlotAxis_PullLinks(selfArg)

	selfFin()
}

func (self *PlotAxis) PushLinks() {
	selfArg, selfFin := self.handle()
	C.ImPlotAxis_PushLinks(selfArg)

	selfFin()
}

func (self *PlotAxis) Reset() {
	selfArg, selfFin := self.handle()
	C.ImPlotAxis_Reset(selfArg)

	selfFin()
}

func (self *PlotAxis) SetAspect(unit_per_pix float64) {
	selfArg, selfFin := self.handle()
	C.ImPlotAxis_SetAspect(selfArg, C.double(unit_per_pix))

	selfFin()
}

// SetMaxV parameter default value hint:
// force: false
func (self *PlotAxis) SetMaxV(_max float64, force bool) bool {
	selfArg, selfFin := self.handle()

	defer func() {
		selfFin()
	}()
	return C.ImPlotAxis_SetMax(selfArg, C.double(_max), C.bool(force)) == C.bool(true)
}

// SetMinV parameter default value hint:
// force: false
func (self *PlotAxis) SetMinV(_min float64, force bool) bool {
	selfArg, selfFin := self.handle()

	defer func() {
		selfFin()
	}()
	return C.ImPlotAxis_SetMin(selfArg, C.double(_min), C.bool(force)) == C.bool(true)
}

func (self *PlotAxis) SetRangePlotRange(rangeArg PlotRange) {
	selfArg, selfFin := self.handle()
	rangeArgArg, rangeArgFin := rangeArg.c()
	C.ImPlotAxis_SetRange_PlotRange(selfArg, rangeArgArg)

	selfFin()
	rangeArgFin()
}

func (self *PlotAxis) SetRangedouble(v1 float64, v2 float64) {
	selfArg, selfFin := self.handle()
	C.ImPlotAxis_SetRange_double(selfArg, C.double(v1), C.double(v2))

	selfFin()
}

func (self *PlotAxis) UpdateTransformCache() {
	selfArg, selfFin := self.handle()
	C.ImPlotAxis_UpdateTransformCache(selfArg)

	selfFin()
}

func (self *PlotAxis) WillRender() bool {
	selfArg, selfFin := self.handle()

	defer func() {
		selfFin()
	}()
	return C.ImPlotAxis_WillRender(selfArg) == C.bool(true)
}

func (self *PlotAxis) Destroy() {
	selfArg, selfFin := self.handle()
	C.ImPlotAxis_destroy(selfArg)

	selfFin()
}

func (self *PlotColormapData) Append(name string, keys *[]uint32, count int32, qual bool) int32 {
	selfArg, selfFin := self.handle()
	nameArg, nameFin := WrapString(name)
	keysArg := make([]C.ImU32, len(*keys))
	for i, keysV := range *keys {
		keysArg[i] = C.ImU32(keysV)
	}

	defer func() {
		selfFin()
		nameFin()

		for i, keysV := range keysArg {
			(*keys)[i] = uint32(keysV)
		}
	}()
	return int32(C.ImPlotColormapData_Append(selfArg, nameArg, (*C.ImU32)(&keysArg[0]), C.int(count), C.bool(qual)))
}

func (self *PlotColormapData) Index(name string) PlotColormap {
	selfArg, selfFin := self.handle()
	nameArg, nameFin := WrapString(name)

	defer func() {
		selfFin()
		nameFin()
	}()
	return PlotColormap(C.ImPlotColormapData_GetIndex(selfArg, nameArg))
}

func (self *PlotColormapData) KeyColor(cmap PlotColormap, idx int32) uint32 {
	selfArg, selfFin := self.handle()

	defer func() {
		selfFin()
	}()
	return uint32(C.ImPlotColormapData_GetKeyColor(selfArg, C.ImPlotColormap(cmap), C.int(idx)))
}

func (self *PlotColormapData) KeyCount(cmap PlotColormap) int32 {
	selfArg, selfFin := self.handle()

	defer func() {
		selfFin()
	}()
	return int32(C.ImPlotColormapData_GetKeyCount(selfArg, C.ImPlotColormap(cmap)))
}

func (self *PlotColormapData) Name(cmap PlotColormap) string {
	selfArg, selfFin := self.handle()

	defer func() {
		selfFin()
	}()
	return C.GoString(C.ImPlotColormapData_GetName(selfArg, C.ImPlotColormap(cmap)))
}

func (self *PlotColormapData) TableColor(cmap PlotColormap, idx int32) uint32 {
	selfArg, selfFin := self.handle()

	defer func() {
		selfFin()
	}()
	return uint32(C.ImPlotColormapData_GetTableColor(selfArg, C.ImPlotColormap(cmap), C.int(idx)))
}

func (self *PlotColormapData) TableSize(cmap PlotColormap) int32 {
	selfArg, selfFin := self.handle()

	defer func() {
		selfFin()
	}()
	return int32(C.ImPlotColormapData_GetTableSize(selfArg, C.ImPlotColormap(cmap)))
}

func NewPlotColormapData() *PlotColormapData {
	return newPlotColormapDataFromC(C.ImPlotColormapData_ImPlotColormapData())
}

func (self *PlotColormapData) IsQual(cmap PlotColormap) bool {
	selfArg, selfFin := self.handle()

	defer func() {
		selfFin()
	}()
	return C.ImPlotColormapData_IsQual(selfArg, C.ImPlotColormap(cmap)) == C.bool(true)
}

func (self *PlotColormapData) LerpTable(cmap PlotColormap, t float32) uint32 {
	selfArg, selfFin := self.handle()

	defer func() {
		selfFin()
	}()
	return uint32(C.ImPlotColormapData_LerpTable(selfArg, C.ImPlotColormap(cmap), C.float(t)))
}

func (self *PlotColormapData) RebuildTables() {
	selfArg, selfFin := self.handle()
	C.ImPlotColormapData_RebuildTables(selfArg)

	selfFin()
}

func (self *PlotColormapData) SetKeyColor(cmap PlotColormap, idx int32, value uint32) {
	selfArg, selfFin := self.handle()
	C.ImPlotColormapData_SetKeyColor(selfArg, C.ImPlotColormap(cmap), C.int(idx), C.ImU32(value))

	selfFin()
}

func (self *PlotColormapData) AppendTable(cmap PlotColormap) {
	selfArg, selfFin := self.handle()
	C.ImPlotColormapData__AppendTable(selfArg, C.ImPlotColormap(cmap))

	selfFin()
}

func (self *PlotColormapData) Destroy() {
	selfArg, selfFin := self.handle()
	C.ImPlotColormapData_destroy(selfArg)

	selfFin()
}

func NewPlotDateTimeSpecNil() *PlotDateTimeSpec {
	return newPlotDateTimeSpecFromC(C.ImPlotDateTimeSpec_ImPlotDateTimeSpec_Nil())
}

// NewPlotDateTimeSpecPlotDateFmt parameter default value hint:
// use_24_hr_clk: false
// use_iso_8601: false
func NewPlotDateTimeSpecPlotDateFmt(date_fmt PlotDateFmt, time_fmt PlotTimeFmt, use_24_hr_clk bool, use_iso_8601 bool) *PlotDateTimeSpec {
	return newPlotDateTimeSpecFromC(C.ImPlotDateTimeSpec_ImPlotDateTimeSpec_PlotDateFmt(C.ImPlotDateFmt(date_fmt), C.ImPlotTimeFmt(time_fmt), C.bool(use_24_hr_clk), C.bool(use_iso_8601)))
}

func (self *PlotDateTimeSpec) Destroy() {
	selfArg, selfFin := self.handle()
	C.ImPlotDateTimeSpec_destroy(selfArg)

	selfFin()
}

func NewPlotInputMap() *PlotInputMap {
	return newPlotInputMapFromC(C.ImPlotInputMap_ImPlotInputMap())
}

func (self *PlotInputMap) Destroy() {
	selfArg, selfFin := self.handle()
	C.ImPlotInputMap_destroy(selfArg)

	selfFin()
}

func (self *PlotItemGroup) ItemByIndex(i int32) *PlotItem {
	selfArg, selfFin := self.handle()

	defer func() {
		selfFin()
	}()
	return newPlotItemFromC(C.ImPlotItemGroup_GetItemByIndex(selfArg, C.int(i)))
}

func (self *PlotItemGroup) ItemCount() int32 {
	selfArg, selfFin := self.handle()

	defer func() {
		selfFin()
	}()
	return int32(C.ImPlotItemGroup_GetItemCount(selfArg))
}

func (self *PlotItemGroup) ItemIndex(item *PlotItem) int32 {
	selfArg, selfFin := self.handle()
	itemArg, itemFin := item.handle()

	defer func() {
		selfFin()
		itemFin()
	}()
	return int32(C.ImPlotItemGroup_GetItemIndex(selfArg, itemArg))
}

func (self *PlotItemGroup) ItemStr(label_id string) *PlotItem {
	selfArg, selfFin := self.handle()
	label_idArg, label_idFin := WrapString(label_id)

	defer func() {
		selfFin()
		label_idFin()
	}()
	return newPlotItemFromC(C.ImPlotItemGroup_GetItem_Str(selfArg, label_idArg))
}

func (self *PlotItemGroup) LegendCount() int32 {
	selfArg, selfFin := self.handle()

	defer func() {
		selfFin()
	}()
	return int32(C.ImPlotItemGroup_GetLegendCount(selfArg))
}

func (self *PlotItemGroup) LegendItem(i int32) *PlotItem {
	selfArg, selfFin := self.handle()

	defer func() {
		selfFin()
	}()
	return newPlotItemFromC(C.ImPlotItemGroup_GetLegendItem(selfArg, C.int(i)))
}

func (self *PlotItemGroup) LegendLabel(i int32) string {
	selfArg, selfFin := self.handle()

	defer func() {
		selfFin()
	}()
	return C.GoString(C.ImPlotItemGroup_GetLegendLabel(selfArg, C.int(i)))
}

func NewPlotItemGroup() *PlotItemGroup {
	return newPlotItemGroupFromC(C.ImPlotItemGroup_ImPlotItemGroup())
}

func (self *PlotItemGroup) Reset() {
	selfArg, selfFin := self.handle()
	C.ImPlotItemGroup_Reset(selfArg)

	selfFin()
}

func (self *PlotItemGroup) Destroy() {
	selfArg, selfFin := self.handle()
	C.ImPlotItemGroup_destroy(selfArg)

	selfFin()
}

func NewPlotItem() *PlotItem {
	return newPlotItemFromC(C.ImPlotItem_ImPlotItem())
}

func (self *PlotItem) Destroy() {
	selfArg, selfFin := self.handle()
	C.ImPlotItem_destroy(selfArg)

	selfFin()
}

func NewPlotLegend() *PlotLegend {
	return newPlotLegendFromC(C.ImPlotLegend_ImPlotLegend())
}

func (self *PlotLegend) Reset() {
	selfArg, selfFin := self.handle()
	C.ImPlotLegend_Reset(selfArg)

	selfFin()
}

func (self *PlotLegend) Destroy() {
	selfArg, selfFin := self.handle()
	C.ImPlotLegend_destroy(selfArg)

	selfFin()
}

func NewPlotNextItemData() *PlotNextItemData {
	return newPlotNextItemDataFromC(C.ImPlotNextItemData_ImPlotNextItemData())
}

func (self *PlotNextItemData) Reset() {
	selfArg, selfFin := self.handle()
	C.ImPlotNextItemData_Reset(selfArg)

	selfFin()
}

func (self *PlotNextItemData) Destroy() {
	selfArg, selfFin := self.handle()
	C.ImPlotNextItemData_destroy(selfArg)

	selfFin()
}

func NewPlotNextPlotData() *PlotNextPlotData {
	return newPlotNextPlotDataFromC(C.ImPlotNextPlotData_ImPlotNextPlotData())
}

func (self *PlotNextPlotData) Reset() {
	selfArg, selfFin := self.handle()
	C.ImPlotNextPlotData_Reset(selfArg)

	selfFin()
}

func (self *PlotNextPlotData) Destroy() {
	selfArg, selfFin := self.handle()
	C.ImPlotNextPlotData_destroy(selfArg)

	selfFin()
}

func (self *PlotPlot) ClearTextBuffer() {
	selfArg, selfFin := self.handle()
	C.ImPlotPlot_ClearTextBuffer(selfArg)

	selfFin()
}

func (self *PlotPlot) EnabledAxesX() int32 {
	selfArg, selfFin := self.handle()

	defer func() {
		selfFin()
	}()
	return int32(C.ImPlotPlot_EnabledAxesX(selfArg))
}

func (self *PlotPlot) EnabledAxesY() int32 {
	selfArg, selfFin := self.handle()

	defer func() {
		selfFin()
	}()
	return int32(C.ImPlotPlot_EnabledAxesY(selfArg))
}

func (self *PlotPlot) AxisLabel(axis PlotAxis) string {
	selfArg, selfFin := self.handle()
	axisArg, axisFin := axis.c()

	defer func() {
		selfFin()
		axisFin()
	}()
	return C.GoString(C.ImPlotPlot_GetAxisLabel(selfArg, axisArg))
}

func (self *PlotPlot) Title() string {
	selfArg, selfFin := self.handle()

	defer func() {
		selfFin()
	}()
	return C.GoString(C.ImPlotPlot_GetTitle(selfArg))
}

func (self *PlotPlot) HasTitle() bool {
	selfArg, selfFin := self.handle()

	defer func() {
		selfFin()
	}()
	return C.ImPlotPlot_HasTitle(selfArg) == C.bool(true)
}

func NewPlotPlot() *PlotPlot {
	return newPlotPlotFromC(C.ImPlotPlot_ImPlotPlot())
}

func (self *PlotPlot) IsInputLocked() bool {
	selfArg, selfFin := self.handle()

	defer func() {
		selfFin()
	}()
	return C.ImPlotPlot_IsInputLocked(selfArg) == C.bool(true)
}

func (self *PlotPlot) SetAxisLabel(axis *PlotAxis, label string) {
	selfArg, selfFin := self.handle()
	axisArg, axisFin := axis.handle()
	labelArg, labelFin := WrapString(label)
	C.ImPlotPlot_SetAxisLabel(selfArg, axisArg, labelArg)

	selfFin()
	axisFin()
	labelFin()
}

func (self *PlotPlot) SetTitle(title string) {
	selfArg, selfFin := self.handle()
	titleArg, titleFin := WrapString(title)
	C.ImPlotPlot_SetTitle(selfArg, titleArg)

	selfFin()
	titleFin()
}

func (self *PlotPlot) XAxisNil(i int32) *PlotAxis {
	selfArg, selfFin := self.handle()

	defer func() {
		selfFin()
	}()
	return newPlotAxisFromC(C.ImPlotPlot_XAxis_Nil(selfArg, C.int(i)))
}

func (self *PlotPlot) XAxisconst(i int32) *PlotAxis {
	selfArg, selfFin := self.handle()

	defer func() {
		selfFin()
	}()
	return newPlotAxisFromC(C.ImPlotPlot_XAxis__const(selfArg, C.int(i)))
}

func (self *PlotPlot) YAxisNil(i int32) *PlotAxis {
	selfArg, selfFin := self.handle()

	defer func() {
		selfFin()
	}()
	return newPlotAxisFromC(C.ImPlotPlot_YAxis_Nil(selfArg, C.int(i)))
}

func (self *PlotPlot) YAxisconst(i int32) *PlotAxis {
	selfArg, selfFin := self.handle()

	defer func() {
		selfFin()
	}()
	return newPlotAxisFromC(C.ImPlotPlot_YAxis__const(selfArg, C.int(i)))
}

func (self *PlotPlot) Destroy() {
	selfArg, selfFin := self.handle()
	C.ImPlotPlot_destroy(selfArg)

	selfFin()
}

func NewPlotPointError(x float64, y float64, neg float64, pos float64) *PlotPointError {
	return newPlotPointErrorFromC(C.ImPlotPointError_ImPlotPointError(C.double(x), C.double(y), C.double(neg), C.double(pos)))
}

func (self *PlotPointError) Destroy() {
	selfArg, selfFin := self.handle()
	C.ImPlotPointError_destroy(selfArg)

	selfFin()
}

func (self *PlotPoint) Destroy() {
	selfArg, selfFin := wrap[C.ImPlotPoint, *PlotPoint](self)
	C.ImPlotPoint_destroy(selfArg)

	selfFin()
}

func (self *PlotRange) Clamp(value float64) float64 {
	selfArg, selfFin := self.handle()

	defer func() {
		selfFin()
	}()
	return float64(C.ImPlotRange_Clamp(selfArg, C.double(value)))
}

func (self *PlotRange) Contains(value float64) bool {
	selfArg, selfFin := self.handle()

	defer func() {
		selfFin()
	}()
	return C.ImPlotRange_Contains(selfArg, C.double(value)) == C.bool(true)
}

func NewPlotRangeNil() *PlotRange {
	return newPlotRangeFromC(C.ImPlotRange_ImPlotRange_Nil())
}

func NewPlotRangedouble(_min float64, _max float64) *PlotRange {
	return newPlotRangeFromC(C.ImPlotRange_ImPlotRange_double(C.double(_min), C.double(_max)))
}

func (self *PlotRange) Size() float64 {
	selfArg, selfFin := self.handle()

	defer func() {
		selfFin()
	}()
	return float64(C.ImPlotRange_Size(selfArg))
}

func (self *PlotRange) Destroy() {
	selfArg, selfFin := self.handle()
	C.ImPlotRange_destroy(selfArg)

	selfFin()
}

func (self *PlotRect) ClampPlotPoInt(p PlotPoint) PlotPoint {
	pOut := new(PlotPoint)
	pOutArg, pOutFin := wrap[C.ImPlotPoint, *PlotPoint](pOut)

	selfArg, selfFin := self.handle()
	C.ImPlotRect_Clamp_PlotPoInt(pOutArg, selfArg, p.toC())

	pOutFin()
	selfFin()

	return *pOut
}

func (self *PlotRect) Clampdouble(x float64, y float64) PlotPoint {
	pOut := new(PlotPoint)
	pOutArg, pOutFin := wrap[C.ImPlotPoint, *PlotPoint](pOut)

	selfArg, selfFin := self.handle()
	C.ImPlotRect_Clamp_double(pOutArg, selfArg, C.double(x), C.double(y))

	pOutFin()
	selfFin()

	return *pOut
}

func (self *PlotRect) ContainsPlotPoInt(p PlotPoint) bool {
	selfArg, selfFin := self.handle()

	defer func() {
		selfFin()
	}()
	return C.ImPlotRect_Contains_PlotPoInt(selfArg, p.toC()) == C.bool(true)
}

func (self *PlotRect) Containsdouble(x float64, y float64) bool {
	selfArg, selfFin := self.handle()

	defer func() {
		selfFin()
	}()
	return C.ImPlotRect_Contains_double(selfArg, C.double(x), C.double(y)) == C.bool(true)
}

func NewPlotRectNil() *PlotRect {
	return newPlotRectFromC(C.ImPlotRect_ImPlotRect_Nil())
}

func NewPlotRectdouble(x_min float64, x_max float64, y_min float64, y_max float64) *PlotRect {
	return newPlotRectFromC(C.ImPlotRect_ImPlotRect_double(C.double(x_min), C.double(x_max), C.double(y_min), C.double(y_max)))
}

func (self *PlotRect) Max() PlotPoint {
	pOut := new(PlotPoint)
	pOutArg, pOutFin := wrap[C.ImPlotPoint, *PlotPoint](pOut)

	selfArg, selfFin := self.handle()
	C.ImPlotRect_Max(pOutArg, selfArg)

	pOutFin()
	selfFin()

	return *pOut
}

func (self *PlotRect) Min() PlotPoint {
	pOut := new(PlotPoint)
	pOutArg, pOutFin := wrap[C.ImPlotPoint, *PlotPoint](pOut)

	selfArg, selfFin := self.handle()
	C.ImPlotRect_Min(pOutArg, selfArg)

	pOutFin()
	selfFin()

	return *pOut
}

func (self *PlotRect) Size() PlotPoint {
	pOut := new(PlotPoint)
	pOutArg, pOutFin := wrap[C.ImPlotPoint, *PlotPoint](pOut)

	selfArg, selfFin := self.handle()
	C.ImPlotRect_Size(pOutArg, selfArg)

	pOutFin()
	selfFin()

	return *pOut
}

func (self *PlotRect) Destroy() {
	selfArg, selfFin := self.handle()
	C.ImPlotRect_destroy(selfArg)

	selfFin()
}

func NewPlotStyle() *PlotStyle {
	return newPlotStyleFromC(C.ImPlotStyle_ImPlotStyle())
}

func (self *PlotStyle) Destroy() {
	selfArg, selfFin := self.handle()
	C.ImPlotStyle_destroy(selfArg)

	selfFin()
}

func NewPlotSubplot() *PlotSubplot {
	return newPlotSubplotFromC(C.ImPlotSubplot_ImPlotSubplot())
}

func (self *PlotSubplot) Destroy() {
	selfArg, selfFin := self.handle()
	C.ImPlotSubplot_destroy(selfArg)

	selfFin()
}

func (self *PlotTagCollection) Append(axis PlotAxisEnum, value float64, bg uint32, fg uint32, fmt string) {
	selfArg, selfFin := self.handle()
	fmtArg, fmtFin := WrapString(fmt)
	C.wrap_ImPlotTagCollection_Append(selfArg, C.ImAxis(axis), C.double(value), C.ImU32(bg), C.ImU32(fg), fmtArg)

	selfFin()
	fmtFin()
}

func (self *PlotTagCollection) Text(idx int32) string {
	selfArg, selfFin := self.handle()

	defer func() {
		selfFin()
	}()
	return C.GoString(C.ImPlotTagCollection_GetText(selfArg, C.int(idx)))
}

func NewPlotTagCollection() *PlotTagCollection {
	return newPlotTagCollectionFromC(C.ImPlotTagCollection_ImPlotTagCollection())
}

func (self *PlotTagCollection) Reset() {
	selfArg, selfFin := self.handle()
	C.ImPlotTagCollection_Reset(selfArg)

	selfFin()
}

func (self *PlotTagCollection) Destroy() {
	selfArg, selfFin := self.handle()
	C.ImPlotTagCollection_destroy(selfArg)

	selfFin()
}

func NewPlotTick(value float64, major bool, level int32, show_label bool) *PlotTick {
	return newPlotTickFromC(C.ImPlotTick_ImPlotTick(C.double(value), C.bool(major), C.int(level), C.bool(show_label)))
}

func (self *PlotTick) Destroy() {
	selfArg, selfFin := self.handle()
	C.ImPlotTick_destroy(selfArg)

	selfFin()
}

func (self *PlotTicker) AddTickPlotTick(tick PlotTick) *PlotTick {
	selfArg, selfFin := self.handle()
	tickArg, tickFin := tick.c()

	defer func() {
		selfFin()
		tickFin()
	}()
	return newPlotTickFromC(C.ImPlotTicker_AddTick_PlotTick(selfArg, tickArg))
}

func (self *PlotTicker) AddTickdoubleStr(value float64, major bool, level int32, show_label bool, label string) *PlotTick {
	selfArg, selfFin := self.handle()
	labelArg, labelFin := WrapString(label)

	defer func() {
		selfFin()
		labelFin()
	}()
	return newPlotTickFromC(C.ImPlotTicker_AddTick_doubleStr(selfArg, C.double(value), C.bool(major), C.int(level), C.bool(show_label), labelArg))
}

func (self *PlotTicker) TextInt(idx int32) string {
	selfArg, selfFin := self.handle()

	defer func() {
		selfFin()
	}()
	return C.GoString(C.ImPlotTicker_GetText_Int(selfArg, C.int(idx)))
}

func (self *PlotTicker) TextPlotTick(tick PlotTick) string {
	selfArg, selfFin := self.handle()
	tickArg, tickFin := tick.c()

	defer func() {
		selfFin()
		tickFin()
	}()
	return C.GoString(C.ImPlotTicker_GetText_PlotTick(selfArg, tickArg))
}

func NewPlotTicker() *PlotTicker {
	return newPlotTickerFromC(C.ImPlotTicker_ImPlotTicker())
}

func (self *PlotTicker) OverrideSizeLate(size Vec2) {
	selfArg, selfFin := self.handle()
	C.ImPlotTicker_OverrideSizeLate(selfArg, size.toC())

	selfFin()
}

func (self *PlotTicker) Reset() {
	selfArg, selfFin := self.handle()
	C.ImPlotTicker_Reset(selfArg)

	selfFin()
}

func (self *PlotTicker) TickCount() int32 {
	selfArg, selfFin := self.handle()

	defer func() {
		selfFin()
	}()
	return int32(C.ImPlotTicker_TickCount(selfArg))
}

func (self *PlotTicker) Destroy() {
	selfArg, selfFin := self.handle()
	C.ImPlotTicker_destroy(selfArg)

	selfFin()
}

func PlotTimeFromDouble(t float64) PlotTime {
	pOut := new(PlotTime)
	pOutArg, pOutFin := wrap[C.ImPlotTime, *PlotTime](pOut)

	C.ImPlotTime_FromDouble(pOutArg, C.double(t))

	pOutFin()

	return *pOut
}

func (self *PlotTime) RollOver() {
	selfArg, selfFin := wrap[C.ImPlotTime, *PlotTime](self)
	C.ImPlotTime_RollOver(selfArg)

	selfFin()
}

func (self *PlotTime) ToDouble() float64 {
	selfArg, selfFin := wrap[C.ImPlotTime, *PlotTime](self)

	defer func() {
		selfFin()
	}()
	return float64(C.ImPlotTime_ToDouble(selfArg))
}

func (self *PlotTime) Destroy() {
	selfArg, selfFin := wrap[C.ImPlotTime, *PlotTime](self)
	C.ImPlotTime_destroy(selfArg)

	selfFin()
}

// PlotAddColormapU32PtrV parameter default value hint:
// qual: true
func PlotAddColormapU32PtrV(name string, cols *[]uint32, size int32, qual bool) PlotColormap {
	nameArg, nameFin := WrapString(name)
	colsArg := make([]C.ImU32, len(*cols))
	for i, colsV := range *cols {
		colsArg[i] = C.ImU32(colsV)
	}

	defer func() {
		nameFin()

		for i, colsV := range colsArg {
			(*cols)[i] = uint32(colsV)
		}
	}()
	return PlotColormap(C.ImPlot_AddColormap_U32Ptr(nameArg, (*C.ImU32)(&colsArg[0]), C.int(size), C.bool(qual)))
}

// PlotAddColormapVec4PtrV parameter default value hint:
// qual: true
func PlotAddColormapVec4PtrV(name string, cols *Vec4, size int32, qual bool) PlotColormap {
	nameArg, nameFin := WrapString(name)
	colsArg, colsFin := wrap[C.ImVec4, *Vec4](cols)

	defer func() {
		nameFin()
		colsFin()
	}()
	return PlotColormap(C.ImPlot_AddColormap_Vec4Ptr(nameArg, colsArg, C.int(size), C.bool(qual)))
}

// PlotAddTextCenteredV parameter default value hint:
func PlotAddTextCenteredV(DrawList *DrawList, top_center Vec2, col uint32, text_begin string) {
	DrawListArg, DrawListFin := DrawList.handle()
	text_beginArg, text_beginFin := WrapString(text_begin)
	C.wrap_ImPlot_AddTextCenteredV(DrawListArg, top_center.toC(), C.ImU32(col), text_beginArg)

	DrawListFin()
	text_beginFin()
}

// PlotAddTextVerticalV parameter default value hint:
func PlotAddTextVerticalV(DrawList *DrawList, pos Vec2, col uint32, text_begin string) {
	DrawListArg, DrawListFin := DrawList.handle()
	text_beginArg, text_beginFin := WrapString(text_begin)
	C.wrap_ImPlot_AddTextVerticalV(DrawListArg, pos.toC(), C.ImU32(col), text_beginArg)

	DrawListFin()
	text_beginFin()
}

func PlotAddTime(t PlotTime, unit PlotTimeUnit, count int32) PlotTime {
	pOut := new(PlotTime)
	pOutArg, pOutFin := wrap[C.ImPlotTime, *PlotTime](pOut)

	C.ImPlot_AddTime(pOutArg, t.toC(), C.ImPlotTimeUnit(unit), C.int(count))

	pOutFin()

	return *pOut
}

func PlotAllAxesInputLocked(axes *PlotAxis, count int32) bool {
	axesArg, axesFin := axes.handle()

	defer func() {
		axesFin()
	}()
	return C.ImPlot_AllAxesInputLocked(axesArg, C.int(count)) == C.bool(true)
}

// PlotAnnotationBoolV parameter default value hint:
// round: false
func PlotAnnotationBoolV(x float64, y float64, col Vec4, pix_offset Vec2, clamp bool, round bool) {
	C.ImPlot_Annotation_Bool(C.double(x), C.double(y), col.toC(), pix_offset.toC(), C.bool(clamp), C.bool(round))
}

func PlotAnnotationStr(x float64, y float64, col Vec4, pix_offset Vec2, clamp bool, fmt string) {
	fmtArg, fmtFin := WrapString(fmt)
	C.wrap_ImPlot_Annotation_Str(C.double(x), C.double(y), col.toC(), pix_offset.toC(), C.bool(clamp), fmtArg)

	fmtFin()
}

func PlotAnyAxesHeld(axes *PlotAxis, count int32) bool {
	axesArg, axesFin := axes.handle()

	defer func() {
		axesFin()
	}()
	return C.ImPlot_AnyAxesHeld(axesArg, C.int(count)) == C.bool(true)
}

func PlotAnyAxesHovered(axes *PlotAxis, count int32) bool {
	axesArg, axesFin := axes.handle()

	defer func() {
		axesFin()
	}()
	return C.ImPlot_AnyAxesHovered(axesArg, C.int(count)) == C.bool(true)
}

func PlotAnyAxesInputLocked(axes *PlotAxis, count int32) bool {
	axesArg, axesFin := axes.handle()

	defer func() {
		axesFin()
	}()
	return C.ImPlot_AnyAxesInputLocked(axesArg, C.int(count)) == C.bool(true)
}

// PlotBeginAlignedPlotsV parameter default value hint:
// vertical: true
func PlotBeginAlignedPlotsV(group_id string, vertical bool) bool {
	group_idArg, group_idFin := WrapString(group_id)

	defer func() {
		group_idFin()
	}()
	return C.ImPlot_BeginAlignedPlots(group_idArg, C.bool(vertical)) == C.bool(true)
}

// PlotBeginDragDropSourceAxisV parameter default value hint:
// flags: 0
func PlotBeginDragDropSourceAxisV(axis PlotAxisEnum, flags DragDropFlags) bool {
	return C.ImPlot_BeginDragDropSourceAxis(C.ImAxis(axis), C.ImGuiDragDropFlags(flags)) == C.bool(true)
}

// PlotBeginDragDropSourceItemV parameter default value hint:
// flags: 0
func PlotBeginDragDropSourceItemV(label_id string, flags DragDropFlags) bool {
	label_idArg, label_idFin := WrapString(label_id)

	defer func() {
		label_idFin()
	}()
	return C.ImPlot_BeginDragDropSourceItem(label_idArg, C.ImGuiDragDropFlags(flags)) == C.bool(true)
}

// PlotBeginDragDropSourcePlotV parameter default value hint:
// flags: 0
func PlotBeginDragDropSourcePlotV(flags DragDropFlags) bool {
	return C.ImPlot_BeginDragDropSourcePlot(C.ImGuiDragDropFlags(flags)) == C.bool(true)
}

func PlotBeginDragDropTargetAxis(axis PlotAxisEnum) bool {
	return C.ImPlot_BeginDragDropTargetAxis(C.ImAxis(axis)) == C.bool(true)
}

func PlotBeginDragDropTargetLegend() bool {
	return C.ImPlot_BeginDragDropTargetLegend() == C.bool(true)
}

func PlotBeginDragDropTargetPlot() bool {
	return C.ImPlot_BeginDragDropTargetPlot() == C.bool(true)
}

// PlotBeginItemV parameter default value hint:
// flags: 0
// recolor_from: -1
func PlotBeginItemV(label_id string, flags PlotItemFlags, recolor_from PlotCol) bool {
	label_idArg, label_idFin := WrapString(label_id)

	defer func() {
		label_idFin()
	}()
	return C.ImPlot_BeginItem(label_idArg, C.ImPlotItemFlags(flags), C.ImPlotCol(recolor_from)) == C.bool(true)
}

// PlotBeginLegendPopupV parameter default value hint:
// mouse_button: 1
func PlotBeginLegendPopupV(label_id string, mouse_button MouseButton) bool {
	label_idArg, label_idFin := WrapString(label_id)

	defer func() {
		label_idFin()
	}()
	return C.ImPlot_BeginLegendPopup(label_idArg, C.ImGuiMouseButton(mouse_button)) == C.bool(true)
}

// PlotBeginPlotV parameter default value hint:
// size: ImVec2(-1,0)
// flags: 0
func PlotBeginPlotV(title_id string, size Vec2, flags PlotFlags) bool {
	title_idArg, title_idFin := WrapString(title_id)

	defer func() {
		title_idFin()
	}()
	return C.ImPlot_BeginPlot(title_idArg, size.toC(), C.ImPlotFlags(flags)) == C.bool(true)
}

// PlotBeginSubplotsV parameter default value hint:
// flags: 0
// row_ratios: nullptr
// col_ratios: nullptr
func PlotBeginSubplotsV(title_id string, rows int32, cols int32, size Vec2, flags PlotSubplotFlags, row_ratios *float32, col_ratios *float32) bool {
	title_idArg, title_idFin := WrapString(title_id)
	row_ratiosArg, row_ratiosFin := WrapNumberPtr[C.float, float32](row_ratios)
	col_ratiosArg, col_ratiosFin := WrapNumberPtr[C.float, float32](col_ratios)

	defer func() {
		title_idFin()
		row_ratiosFin()
		col_ratiosFin()
	}()
	return C.ImPlot_BeginSubplots(title_idArg, C.int(rows), C.int(cols), size.toC(), C.ImPlotSubplotFlags(flags), row_ratiosArg, col_ratiosArg) == C.bool(true)
}

// PlotBustColorCacheV parameter default value hint:
// plot_title_id: nullptr
func PlotBustColorCacheV(plot_title_id string) {
	plot_title_idArg, plot_title_idFin := WrapString(plot_title_id)
	C.ImPlot_BustColorCache(plot_title_idArg)

	plot_title_idFin()
}

func PlotBustItemCache() {
	C.ImPlot_BustItemCache()
}

func PlotBustPlotCache() {
	C.ImPlot_BustPlotCache()
}

func PlotCalcHoverColor(col uint32) uint32 {
	return uint32(C.ImPlot_CalcHoverColor(C.ImU32(col)))
}

func PlotCalcLegendSize(items *PlotItemGroup, pad Vec2, spacing Vec2, vertical bool) Vec2 {
	pOut := new(Vec2)
	pOutArg, pOutFin := wrap[C.ImVec2, *Vec2](pOut)

	itemsArg, itemsFin := items.handle()
	C.ImPlot_CalcLegendSize(pOutArg, itemsArg, pad.toC(), spacing.toC(), C.bool(vertical))

	pOutFin()
	itemsFin()

	return *pOut
}

func PlotCalcTextColorU32(bg uint32) uint32 {
	return uint32(C.ImPlot_CalcTextColor_U32(C.ImU32(bg)))
}

func PlotCalcTextColorVec4(bg Vec4) uint32 {
	return uint32(C.ImPlot_CalcTextColor_Vec4(bg.toC()))
}

func PlotCalcTextSizeVertical(text string) Vec2 {
	pOut := new(Vec2)
	pOutArg, pOutFin := wrap[C.ImVec2, *Vec2](pOut)

	textArg, textFin := WrapString(text)
	C.ImPlot_CalcTextSizeVertical(pOutArg, textArg)

	pOutFin()
	textFin()

	return *pOut
}

func PlotCalculateBinsFloatPtr(values []float32, count int32, meth PlotBin, rangeArg PlotRange, bins_out *int32, width_out *float64) {
	rangeArgArg, rangeArgFin := rangeArg.c()
	bins_outArg, bins_outFin := WrapNumberPtr[C.int, int32](bins_out)
	width_outArg, width_outFin := WrapNumberPtr[C.double, float64](width_out)
	C.ImPlot_CalculateBins_FloatPtr((*C.float)(&(values[0])), C.int(count), C.ImPlotBin(meth), rangeArgArg, bins_outArg, width_outArg)

	rangeArgFin()
	bins_outFin()
	width_outFin()
}

func PlotCalculateBinsS16Ptr(values *[]int, count int32, meth PlotBin, rangeArg PlotRange, bins_out *int32, width_out *float64) {
	valuesArg := make([]C.ImS16, len(*values))
	for i, valuesV := range *values {
		valuesArg[i] = C.ImS16(valuesV)
	}

	rangeArgArg, rangeArgFin := rangeArg.c()
	bins_outArg, bins_outFin := WrapNumberPtr[C.int, int32](bins_out)
	width_outArg, width_outFin := WrapNumberPtr[C.double, float64](width_out)
	C.ImPlot_CalculateBins_S16Ptr((*C.ImS16)(&valuesArg[0]), C.int(count), C.ImPlotBin(meth), rangeArgArg, bins_outArg, width_outArg)

	for i, valuesV := range valuesArg {
		(*values)[i] = int(valuesV)
	}

	rangeArgFin()
	bins_outFin()
	width_outFin()
}

func PlotCalculateBinsS32Ptr(values *[]int32, count int32, meth PlotBin, rangeArg PlotRange, bins_out *int32, width_out *float64) {
	valuesArg := make([]C.ImS32, len(*values))
	for i, valuesV := range *values {
		valuesArg[i] = C.ImS32(valuesV)
	}

	rangeArgArg, rangeArgFin := rangeArg.c()
	bins_outArg, bins_outFin := WrapNumberPtr[C.int, int32](bins_out)
	width_outArg, width_outFin := WrapNumberPtr[C.double, float64](width_out)
	C.ImPlot_CalculateBins_S32Ptr((*C.ImS32)(&valuesArg[0]), C.int(count), C.ImPlotBin(meth), rangeArgArg, bins_outArg, width_outArg)

	for i, valuesV := range valuesArg {
		(*values)[i] = int32(valuesV)
	}

	rangeArgFin()
	bins_outFin()
	width_outFin()
}

func PlotCalculateBinsS64Ptr(values []int64, count int32, meth PlotBin, rangeArg PlotRange, bins_out *int32, width_out *float64) {
	rangeArgArg, rangeArgFin := rangeArg.c()
	bins_outArg, bins_outFin := WrapNumberPtr[C.int, int32](bins_out)
	width_outArg, width_outFin := WrapNumberPtr[C.double, float64](width_out)
	C.ImPlot_CalculateBins_S64Ptr((*C.longlong)(&(values[0])), C.int(count), C.ImPlotBin(meth), rangeArgArg, bins_outArg, width_outArg)

	rangeArgFin()
	bins_outFin()
	width_outFin()
}

func PlotCalculateBinsS8Ptr(values *[]int8, count int32, meth PlotBin, rangeArg PlotRange, bins_out *int32, width_out *float64) {
	valuesArg := make([]C.ImS8, len(*values))
	for i, valuesV := range *values {
		valuesArg[i] = C.ImS8(valuesV)
	}

	rangeArgArg, rangeArgFin := rangeArg.c()
	bins_outArg, bins_outFin := WrapNumberPtr[C.int, int32](bins_out)
	width_outArg, width_outFin := WrapNumberPtr[C.double, float64](width_out)
	C.ImPlot_CalculateBins_S8Ptr((*C.ImS8)(&valuesArg[0]), C.int(count), C.ImPlotBin(meth), rangeArgArg, bins_outArg, width_outArg)

	for i, valuesV := range valuesArg {
		(*values)[i] = int8(valuesV)
	}

	rangeArgFin()
	bins_outFin()
	width_outFin()
}

func PlotCalculateBinsU16Ptr(values *[]uint16, count int32, meth PlotBin, rangeArg PlotRange, bins_out *int32, width_out *float64) {
	valuesArg := make([]C.ImU16, len(*values))
	for i, valuesV := range *values {
		valuesArg[i] = C.ImU16(valuesV)
	}

	rangeArgArg, rangeArgFin := rangeArg.c()
	bins_outArg, bins_outFin := WrapNumberPtr[C.int, int32](bins_out)
	width_outArg, width_outFin := WrapNumberPtr[C.double, float64](width_out)
	C.ImPlot_CalculateBins_U16Ptr((*C.ImU16)(&valuesArg[0]), C.int(count), C.ImPlotBin(meth), rangeArgArg, bins_outArg, width_outArg)

	for i, valuesV := range valuesArg {
		(*values)[i] = uint16(valuesV)
	}

	rangeArgFin()
	bins_outFin()
	width_outFin()
}

func PlotCalculateBinsU32Ptr(values *[]uint32, count int32, meth PlotBin, rangeArg PlotRange, bins_out *int32, width_out *float64) {
	valuesArg := make([]C.ImU32, len(*values))
	for i, valuesV := range *values {
		valuesArg[i] = C.ImU32(valuesV)
	}

	rangeArgArg, rangeArgFin := rangeArg.c()
	bins_outArg, bins_outFin := WrapNumberPtr[C.int, int32](bins_out)
	width_outArg, width_outFin := WrapNumberPtr[C.double, float64](width_out)
	C.ImPlot_CalculateBins_U32Ptr((*C.ImU32)(&valuesArg[0]), C.int(count), C.ImPlotBin(meth), rangeArgArg, bins_outArg, width_outArg)

	for i, valuesV := range valuesArg {
		(*values)[i] = uint32(valuesV)
	}

	rangeArgFin()
	bins_outFin()
	width_outFin()
}

func PlotCalculateBinsU64Ptr(values []uint64, count int32, meth PlotBin, rangeArg PlotRange, bins_out *int32, width_out *float64) {
	rangeArgArg, rangeArgFin := rangeArg.c()
	bins_outArg, bins_outFin := WrapNumberPtr[C.int, int32](bins_out)
	width_outArg, width_outFin := WrapNumberPtr[C.double, float64](width_out)
	C.ImPlot_CalculateBins_U64Ptr((*C.ulonglong)(&(values[0])), C.int(count), C.ImPlotBin(meth), rangeArgArg, bins_outArg, width_outArg)

	rangeArgFin()
	bins_outFin()
	width_outFin()
}

func PlotCalculateBinsU8Ptr(values *[]byte, count int32, meth PlotBin, rangeArg PlotRange, bins_out *int32, width_out *float64) {
	valuesArg := make([]C.ImU8, len(*values))
	for i, valuesV := range *values {
		valuesArg[i] = C.ImU8(valuesV)
	}

	rangeArgArg, rangeArgFin := rangeArg.c()
	bins_outArg, bins_outFin := WrapNumberPtr[C.int, int32](bins_out)
	width_outArg, width_outFin := WrapNumberPtr[C.double, float64](width_out)
	C.ImPlot_CalculateBins_U8Ptr((*C.ImU8)(&valuesArg[0]), C.int(count), C.ImPlotBin(meth), rangeArgArg, bins_outArg, width_outArg)

	for i, valuesV := range valuesArg {
		(*values)[i] = byte(valuesV)
	}

	rangeArgFin()
	bins_outFin()
	width_outFin()
}

func PlotCalculateBinsdoublePtr(values *[]float64, count int32, meth PlotBin, rangeArg PlotRange, bins_out *int32, width_out *float64) {
	valuesArg := make([]C.double, len(*values))
	for i, valuesV := range *values {
		valuesArg[i] = C.double(valuesV)
	}

	rangeArgArg, rangeArgFin := rangeArg.c()
	bins_outArg, bins_outFin := WrapNumberPtr[C.int, int32](bins_out)
	width_outArg, width_outFin := WrapNumberPtr[C.double, float64](width_out)
	C.ImPlot_CalculateBins_doublePtr((*C.double)(&valuesArg[0]), C.int(count), C.ImPlotBin(meth), rangeArgArg, bins_outArg, width_outArg)

	for i, valuesV := range valuesArg {
		(*values)[i] = float64(valuesV)
	}

	rangeArgFin()
	bins_outFin()
	width_outFin()
}

func PlotCancelPlotSelection() {
	C.ImPlot_CancelPlotSelection()
}

func PlotCeilTime(t PlotTime, unit PlotTimeUnit) PlotTime {
	pOut := new(PlotTime)
	pOutArg, pOutFin := wrap[C.ImPlotTime, *PlotTime](pOut)

	C.ImPlot_CeilTime(pOutArg, t.toC(), C.ImPlotTimeUnit(unit))

	pOutFin()

	return *pOut
}

func PlotClampLabelPos(pos Vec2, size Vec2, Min Vec2, Max Vec2) Vec2 {
	pOut := new(Vec2)
	pOutArg, pOutFin := wrap[C.ImVec2, *Vec2](pOut)

	C.ImPlot_ClampLabelPos(pOutArg, pos.toC(), size.toC(), Min.toC(), Max.toC())

	pOutFin()

	return *pOut
}

func PlotClampLegendRect(legend_rect *Rect, outer_rect Rect, pad Vec2) bool {
	legend_rectArg, legend_rectFin := wrap[C.ImRect, *Rect](legend_rect)

	defer func() {
		legend_rectFin()
	}()
	return C.ImPlot_ClampLegendRect(legend_rectArg, outer_rect.toC(), pad.toC()) == C.bool(true)
}

// PlotColormapButtonV parameter default value hint:
// size: ImVec2(0,0)
// cmap: -1
func PlotColormapButtonV(label string, size Vec2, cmap PlotColormap) bool {
	labelArg, labelFin := WrapString(label)

	defer func() {
		labelFin()
	}()
	return C.ImPlot_ColormapButton(labelArg, size.toC(), C.ImPlotColormap(cmap)) == C.bool(true)
}

func PlotColormapIcon(cmap PlotColormap) {
	C.ImPlot_ColormapIcon(C.ImPlotColormap(cmap))
}

// PlotColormapScaleV parameter default value hint:
// size: ImVec2(0,0)
// format: "%g"
// flags: 0
// cmap: -1
func PlotColormapScaleV(label string, scale_min float64, scale_max float64, size Vec2, format string, flags PlotColormapScaleFlags, cmap PlotColormap) {
	labelArg, labelFin := WrapString(label)
	formatArg, formatFin := WrapString(format)
	C.ImPlot_ColormapScale(labelArg, C.double(scale_min), C.double(scale_max), size.toC(), formatArg, C.ImPlotColormapScaleFlags(flags), C.ImPlotColormap(cmap))

	labelFin()
	formatFin()
}

// PlotColormapSliderV parameter default value hint:
// out: nullptr
// format: ""
// cmap: -1
func PlotColormapSliderV(label string, t *float32, out *Vec4, format string, cmap PlotColormap) bool {
	labelArg, labelFin := WrapString(label)
	tArg, tFin := WrapNumberPtr[C.float, float32](t)
	outArg, outFin := wrap[C.ImVec4, *Vec4](out)
	formatArg, formatFin := WrapString(format)

	defer func() {
		labelFin()
		tFin()
		outFin()
		formatFin()
	}()
	return C.ImPlot_ColormapSlider(labelArg, tArg, outArg, formatArg, C.ImPlotColormap(cmap)) == C.bool(true)
}

func PlotCombineDateTime(date_part PlotTime, time_part PlotTime) PlotTime {
	pOut := new(PlotTime)
	pOutArg, pOutFin := wrap[C.ImPlotTime, *PlotTime](pOut)

	C.ImPlot_CombineDateTime(pOutArg, date_part.toC(), time_part.toC())

	pOutFin()

	return *pOut
}

func PlotCreateContext() *PlotContext {
	return newPlotContextFromC(C.ImPlot_CreateContext())
}

// PlotDestroyContextV parameter default value hint:
// ctx: nullptr
func PlotDestroyContextV(ctx *PlotContext) {
	ctxArg, ctxFin := ctx.handle()
	C.ImPlot_DestroyContext(ctxArg)

	ctxFin()
}

// PlotDragLineXV parameter default value hint:
// thickness: 1
// flags: 0
// out_clicked: nullptr
// out_hovered: nullptr
// held: nullptr
func PlotDragLineXV(id int32, x *float64, col Vec4, thickness float32, flags PlotDragToolFlags, out_clicked *bool, out_hovered *bool, held *bool) bool {
	xArg, xFin := WrapNumberPtr[C.double, float64](x)
	out_clickedArg, out_clickedFin := WrapBool(out_clicked)
	out_hoveredArg, out_hoveredFin := WrapBool(out_hovered)
	heldArg, heldFin := WrapBool(held)

	defer func() {
		xFin()
		out_clickedFin()
		out_hoveredFin()
		heldFin()
	}()
	return C.ImPlot_DragLineX(C.int(id), xArg, col.toC(), C.float(thickness), C.ImPlotDragToolFlags(flags), out_clickedArg, out_hoveredArg, heldArg) == C.bool(true)
}

// PlotDragLineYV parameter default value hint:
// thickness: 1
// flags: 0
// out_clicked: nullptr
// out_hovered: nullptr
// held: nullptr
func PlotDragLineYV(id int32, y *float64, col Vec4, thickness float32, flags PlotDragToolFlags, out_clicked *bool, out_hovered *bool, held *bool) bool {
	yArg, yFin := WrapNumberPtr[C.double, float64](y)
	out_clickedArg, out_clickedFin := WrapBool(out_clicked)
	out_hoveredArg, out_hoveredFin := WrapBool(out_hovered)
	heldArg, heldFin := WrapBool(held)

	defer func() {
		yFin()
		out_clickedFin()
		out_hoveredFin()
		heldFin()
	}()
	return C.ImPlot_DragLineY(C.int(id), yArg, col.toC(), C.float(thickness), C.ImPlotDragToolFlags(flags), out_clickedArg, out_hoveredArg, heldArg) == C.bool(true)
}

// PlotDragPointV parameter default value hint:
// size: 4
// flags: 0
// out_clicked: nullptr
// out_hovered: nullptr
// held: nullptr
func PlotDragPointV(id int32, x *float64, y *float64, col Vec4, size float32, flags PlotDragToolFlags, out_clicked *bool, out_hovered *bool, held *bool) bool {
	xArg, xFin := WrapNumberPtr[C.double, float64](x)
	yArg, yFin := WrapNumberPtr[C.double, float64](y)
	out_clickedArg, out_clickedFin := WrapBool(out_clicked)
	out_hoveredArg, out_hoveredFin := WrapBool(out_hovered)
	heldArg, heldFin := WrapBool(held)

	defer func() {
		xFin()
		yFin()
		out_clickedFin()
		out_hoveredFin()
		heldFin()
	}()
	return C.ImPlot_DragPoint(C.int(id), xArg, yArg, col.toC(), C.float(size), C.ImPlotDragToolFlags(flags), out_clickedArg, out_hoveredArg, heldArg) == C.bool(true)
}

// PlotDragRectV parameter default value hint:
// flags: 0
// out_clicked: nullptr
// out_hovered: nullptr
// held: nullptr
func PlotDragRectV(id int32, x1 *float64, y1 *float64, x2 *float64, y2 *float64, col Vec4, flags PlotDragToolFlags, out_clicked *bool, out_hovered *bool, held *bool) bool {
	x1Arg, x1Fin := WrapNumberPtr[C.double, float64](x1)
	y1Arg, y1Fin := WrapNumberPtr[C.double, float64](y1)
	x2Arg, x2Fin := WrapNumberPtr[C.double, float64](x2)
	y2Arg, y2Fin := WrapNumberPtr[C.double, float64](y2)
	out_clickedArg, out_clickedFin := WrapBool(out_clicked)
	out_hoveredArg, out_hoveredFin := WrapBool(out_hovered)
	heldArg, heldFin := WrapBool(held)

	defer func() {
		x1Fin()
		y1Fin()
		x2Fin()
		y2Fin()
		out_clickedFin()
		out_hoveredFin()
		heldFin()
	}()
	return C.ImPlot_DragRect(C.int(id), x1Arg, y1Arg, x2Arg, y2Arg, col.toC(), C.ImPlotDragToolFlags(flags), out_clickedArg, out_hoveredArg, heldArg) == C.bool(true)
}

func PlotEndAlignedPlots() {
	C.ImPlot_EndAlignedPlots()
}

func PlotEndDragDropSource() {
	C.ImPlot_EndDragDropSource()
}

func PlotEndDragDropTarget() {
	C.ImPlot_EndDragDropTarget()
}

func PlotEndItem() {
	C.ImPlot_EndItem()
}

func PlotEndLegendPopup() {
	C.ImPlot_EndLegendPopup()
}

func PlotEndPlot() {
	C.ImPlot_EndPlot()
}

func PlotEndSubplots() {
	C.ImPlot_EndSubplots()
}

func PlotFitPoint(p PlotPoint) {
	C.ImPlot_FitPoint(p.toC())
}

func PlotFitPointX(x float64) {
	C.ImPlot_FitPointX(C.double(x))
}

func PlotFitPointY(y float64) {
	C.ImPlot_FitPointY(C.double(y))
}

func PlotFitThisFrame() bool {
	return C.ImPlot_FitThisFrame() == C.bool(true)
}

func PlotFloorTime(t PlotTime, unit PlotTimeUnit) PlotTime {
	pOut := new(PlotTime)
	pOutArg, pOutFin := wrap[C.ImPlotTime, *PlotTime](pOut)

	C.ImPlot_FloorTime(pOutArg, t.toC(), C.ImPlotTimeUnit(unit))

	pOutFin()

	return *pOut
}

func PlotFormatDate(t PlotTime, buffer string, size int32, fmt PlotDateFmt, use_iso_8601 bool) int32 {
	bufferArg, bufferFin := WrapString(buffer)

	defer func() {
		bufferFin()
	}()
	return int32(C.ImPlot_FormatDate(t.toC(), bufferArg, C.int(size), C.ImPlotDateFmt(fmt), C.bool(use_iso_8601)))
}

func PlotFormatDateTime(t PlotTime, buffer string, size int32, fmt PlotDateTimeSpec) int32 {
	bufferArg, bufferFin := WrapString(buffer)
	fmtArg, fmtFin := fmt.c()

	defer func() {
		bufferFin()
		fmtFin()
	}()
	return int32(C.ImPlot_FormatDateTime(t.toC(), bufferArg, C.int(size), fmtArg))
}

func PlotFormatTime(t PlotTime, buffer string, size int32, fmt PlotTimeFmt, use_24_hr_clk bool) int32 {
	bufferArg, bufferFin := WrapString(buffer)

	defer func() {
		bufferFin()
	}()
	return int32(C.ImPlot_FormatTime(t.toC(), bufferArg, C.int(size), C.ImPlotTimeFmt(fmt), C.bool(use_24_hr_clk)))
}

func PlotFormatterDefault(value float64, buff string, size int32, data unsafe.Pointer) int32 {
	buffArg, buffFin := WrapString(buff)
	dataArg, dataFin := WrapVoidPtr(data)

	defer func() {
		buffFin()
		dataFin()
	}()
	return int32(C.ImPlot_Formatter_Default(C.double(value), buffArg, C.int(size), dataArg))
}

func PlotFormatterLogit(value float64, buff string, size int32, noname1 unsafe.Pointer) int32 {
	buffArg, buffFin := WrapString(buff)
	noname1Arg, noname1Fin := WrapVoidPtr(noname1)

	defer func() {
		buffFin()
		noname1Fin()
	}()
	return int32(C.ImPlot_Formatter_Logit(C.double(value), buffArg, C.int(size), noname1Arg))
}

func PlotFormatterTime(noname1 float64, buff string, size int32, data unsafe.Pointer) int32 {
	buffArg, buffFin := WrapString(buff)
	dataArg, dataFin := WrapVoidPtr(data)

	defer func() {
		buffFin()
		dataFin()
	}()
	return int32(C.ImPlot_Formatter_Time(C.double(noname1), buffArg, C.int(size), dataArg))
}

func PlotGetAutoColor(idx PlotCol) Vec4 {
	pOut := new(Vec4)
	pOutArg, pOutFin := wrap[C.ImVec4, *Vec4](pOut)

	C.ImPlot_GetAutoColor(pOutArg, C.ImPlotCol(idx))

	pOutFin()

	return *pOut
}

// PlotGetColormapColorV parameter default value hint:
// cmap: -1
func PlotGetColormapColorV(idx int32, cmap PlotColormap) Vec4 {
	pOut := new(Vec4)
	pOutArg, pOutFin := wrap[C.ImVec4, *Vec4](pOut)

	C.ImPlot_GetColormapColor(pOutArg, C.int(idx), C.ImPlotColormap(cmap))

	pOutFin()

	return *pOut
}

func PlotGetColormapColorU32(idx int32, cmap PlotColormap) uint32 {
	return uint32(C.ImPlot_GetColormapColorU32(C.int(idx), C.ImPlotColormap(cmap)))
}

func PlotGetColormapCount() int32 {
	return int32(C.ImPlot_GetColormapCount())
}

func PlotGetColormapIndex(name string) PlotColormap {
	nameArg, nameFin := WrapString(name)

	defer func() {
		nameFin()
	}()
	return PlotColormap(C.ImPlot_GetColormapIndex(nameArg))
}

func PlotGetColormapName(cmap PlotColormap) string {
	return C.GoString(C.ImPlot_GetColormapName(C.ImPlotColormap(cmap)))
}

// PlotGetColormapSizeV parameter default value hint:
// cmap: -1
func PlotGetColormapSizeV(cmap PlotColormap) int32 {
	return int32(C.ImPlot_GetColormapSize(C.ImPlotColormap(cmap)))
}

func PlotGetCurrentContext() *PlotContext {
	return newPlotContextFromC(C.ImPlot_GetCurrentContext())
}

func PlotGetCurrentItem() *PlotItem {
	return newPlotItemFromC(C.ImPlot_GetCurrentItem())
}

func PlotGetCurrentPlot() *PlotPlot {
	return newPlotPlotFromC(C.ImPlot_GetCurrentPlot())
}

func PlotGetDaysInMonth(year int32, month int32) int32 {
	return int32(C.ImPlot_GetDaysInMonth(C.int(year), C.int(month)))
}

func PlotGetInputMap() *PlotInputMap {
	return newPlotInputMapFromC(C.ImPlot_GetInputMap())
}

func PlotGetItem(label_id string) *PlotItem {
	label_idArg, label_idFin := WrapString(label_id)

	defer func() {
		label_idFin()
	}()
	return newPlotItemFromC(C.ImPlot_GetItem(label_idArg))
}

func PlotGetItemData() *PlotNextItemData {
	return newPlotNextItemDataFromC(C.ImPlot_GetItemData())
}

func PlotGetLastItemColor() Vec4 {
	pOut := new(Vec4)
	pOutArg, pOutFin := wrap[C.ImVec4, *Vec4](pOut)

	C.ImPlot_GetLastItemColor(pOutArg)

	pOutFin()

	return *pOut
}

// PlotGetLocationPosV parameter default value hint:
// pad: ImVec2(0,0)
func PlotGetLocationPosV(outer_rect Rect, inner_size Vec2, location PlotLocation, pad Vec2) Vec2 {
	pOut := new(Vec2)
	pOutArg, pOutFin := wrap[C.ImVec2, *Vec2](pOut)

	C.ImPlot_GetLocationPos(pOutArg, outer_rect.toC(), inner_size.toC(), C.ImPlotLocation(location), pad.toC())

	pOutFin()

	return *pOut
}

func PlotGetMarkerName(idx PlotMarker) string {
	return C.GoString(C.ImPlot_GetMarkerName(C.ImPlotMarker(idx)))
}

func PlotGetPlot(title string) *PlotPlot {
	titleArg, titleFin := WrapString(title)

	defer func() {
		titleFin()
	}()
	return newPlotPlotFromC(C.ImPlot_GetPlot(titleArg))
}

func PlotGetPlotDrawList() *DrawList {
	return newDrawListFromC(C.ImPlot_GetPlotDrawList())
}

// PlotGetPlotLimitsV parameter default value hint:
// x_axis: -1
// y_axis: -1
func PlotGetPlotLimitsV(x_axis PlotAxisEnum, y_axis PlotAxisEnum) PlotRect {
	pOut := new(PlotRect)
	pOutArg, pOutFin := pOut.handle()

	C.ImPlot_GetPlotLimits(pOutArg, C.ImAxis(x_axis), C.ImAxis(y_axis))

	pOutFin()

	return *pOut
}

// PlotGetPlotMousePosV parameter default value hint:
// x_axis: -1
// y_axis: -1
func PlotGetPlotMousePosV(x_axis PlotAxisEnum, y_axis PlotAxisEnum) PlotPoint {
	pOut := new(PlotPoint)
	pOutArg, pOutFin := wrap[C.ImPlotPoint, *PlotPoint](pOut)

	C.ImPlot_GetPlotMousePos(pOutArg, C.ImAxis(x_axis), C.ImAxis(y_axis))

	pOutFin()

	return *pOut
}

func PlotGetPlotPos() Vec2 {
	pOut := new(Vec2)
	pOutArg, pOutFin := wrap[C.ImVec2, *Vec2](pOut)

	C.ImPlot_GetPlotPos(pOutArg)

	pOutFin()

	return *pOut
}

// PlotGetPlotSelectionV parameter default value hint:
// x_axis: -1
// y_axis: -1
func PlotGetPlotSelectionV(x_axis PlotAxisEnum, y_axis PlotAxisEnum) PlotRect {
	pOut := new(PlotRect)
	pOutArg, pOutFin := pOut.handle()

	C.ImPlot_GetPlotSelection(pOutArg, C.ImAxis(x_axis), C.ImAxis(y_axis))

	pOutFin()

	return *pOut
}

func PlotGetPlotSize() Vec2 {
	pOut := new(Vec2)
	pOutArg, pOutFin := wrap[C.ImVec2, *Vec2](pOut)

	C.ImPlot_GetPlotSize(pOutArg)

	pOutFin()

	return *pOut
}

func PlotGetStyle() *PlotStyle {
	return newPlotStyleFromC(C.ImPlot_GetStyle())
}

func PlotGetStyleColorName(idx PlotCol) string {
	return C.GoString(C.ImPlot_GetStyleColorName(C.ImPlotCol(idx)))
}

func PlotGetStyleColorU32(idx PlotCol) uint32 {
	return uint32(C.ImPlot_GetStyleColorU32(C.ImPlotCol(idx)))
}

func PlotGetStyleColorVec4(idx PlotCol) Vec4 {
	pOut := new(Vec4)
	pOutArg, pOutFin := wrap[C.ImVec4, *Vec4](pOut)

	C.ImPlot_GetStyleColorVec4(pOutArg, C.ImPlotCol(idx))

	pOutFin()

	return *pOut
}

func PlotGetYear(t PlotTime) int32 {
	return int32(C.ImPlot_GetYear(t.toC()))
}

// PlotHideNextItemV parameter default value hint:
// hidden: true
// cond: ImPlotCond_Once
func PlotHideNextItemV(hidden bool, cond PlotCond) {
	C.ImPlot_HideNextItem(C.bool(hidden), C.ImPlotCond(cond))
}

// PlotImAlmostEqualV parameter default value hint:
// ulp: 2
func PlotImAlmostEqualV(v1 float64, v2 float64, ulp int32) bool {
	return C.ImPlot_ImAlmostEqual(C.double(v1), C.double(v2), C.int(ulp)) == C.bool(true)
}

func PlotImAlphaU32(col uint32, alpha float32) uint32 {
	return uint32(C.ImPlot_ImAlphaU32(C.ImU32(col), C.float(alpha)))
}

func PlotImAsinhFloat(x float32) float32 {
	return float32(C.ImPlot_ImAsinh_Float(C.float(x)))
}

func PlotImAsinhdouble(x float64) float64 {
	return float64(C.ImPlot_ImAsinh_double(C.double(x)))
}

func PlotImConstrainInf(val float64) float64 {
	return float64(C.ImPlot_ImConstrainInf(C.double(val)))
}

func PlotImConstrainLog(val float64) float64 {
	return float64(C.ImPlot_ImConstrainLog(C.double(val)))
}

func PlotImConstrainNan(val float64) float64 {
	return float64(C.ImPlot_ImConstrainNan(C.double(val)))
}

func PlotImConstrainTime(val float64) float64 {
	return float64(C.ImPlot_ImConstrainTime(C.double(val)))
}

func PlotImLerpU32(colors *[]uint32, size int32, t float32) uint32 {
	colorsArg := make([]C.ImU32, len(*colors))
	for i, colorsV := range *colors {
		colorsArg[i] = C.ImU32(colorsV)
	}

	defer func() {
		for i, colorsV := range colorsArg {
			(*colors)[i] = uint32(colorsV)
		}
	}()
	return uint32(C.ImPlot_ImLerpU32((*C.ImU32)(&colorsArg[0]), C.int(size), C.float(t)))
}

func PlotImLog10Float(x float32) float32 {
	return float32(C.ImPlot_ImLog10_Float(C.float(x)))
}

func PlotImLog10double(x float64) float64 {
	return float64(C.ImPlot_ImLog10_double(C.double(x)))
}

func PlotImMaxArrayFloatPtr(values []float32, count int32) float32 {
	return float32(C.ImPlot_ImMaxArray_FloatPtr((*C.float)(&(values[0])), C.int(count)))
}

func PlotImMaxArrayS16Ptr(values *[]int, count int32) int {
	valuesArg := make([]C.ImS16, len(*values))
	for i, valuesV := range *values {
		valuesArg[i] = C.ImS16(valuesV)
	}

	defer func() {
		for i, valuesV := range valuesArg {
			(*values)[i] = int(valuesV)
		}
	}()
	return int(C.ImPlot_ImMaxArray_S16Ptr((*C.ImS16)(&valuesArg[0]), C.int(count)))
}

func PlotImMaxArrayS32Ptr(values *[]int32, count int32) int {
	valuesArg := make([]C.ImS32, len(*values))
	for i, valuesV := range *values {
		valuesArg[i] = C.ImS32(valuesV)
	}

	defer func() {
		for i, valuesV := range valuesArg {
			(*values)[i] = int32(valuesV)
		}
	}()
	return int(C.ImPlot_ImMaxArray_S32Ptr((*C.ImS32)(&valuesArg[0]), C.int(count)))
}

func PlotImMaxArrayS64Ptr(values []int64, count int32) int64 {
	return int64(C.ImPlot_ImMaxArray_S64Ptr((*C.longlong)(&(values[0])), C.int(count)))
}

func PlotImMaxArrayS8Ptr(values *[]int8, count int32) int {
	valuesArg := make([]C.ImS8, len(*values))
	for i, valuesV := range *values {
		valuesArg[i] = C.ImS8(valuesV)
	}

	defer func() {
		for i, valuesV := range valuesArg {
			(*values)[i] = int8(valuesV)
		}
	}()
	return int(C.ImPlot_ImMaxArray_S8Ptr((*C.ImS8)(&valuesArg[0]), C.int(count)))
}

func PlotImMaxArrayU16Ptr(values *[]uint16, count int32) uint16 {
	valuesArg := make([]C.ImU16, len(*values))
	for i, valuesV := range *values {
		valuesArg[i] = C.ImU16(valuesV)
	}

	defer func() {
		for i, valuesV := range valuesArg {
			(*values)[i] = uint16(valuesV)
		}
	}()
	return uint16(C.ImPlot_ImMaxArray_U16Ptr((*C.ImU16)(&valuesArg[0]), C.int(count)))
}

func PlotImMaxArrayU32Ptr(values *[]uint32, count int32) uint32 {
	valuesArg := make([]C.ImU32, len(*values))
	for i, valuesV := range *values {
		valuesArg[i] = C.ImU32(valuesV)
	}

	defer func() {
		for i, valuesV := range valuesArg {
			(*values)[i] = uint32(valuesV)
		}
	}()
	return uint32(C.ImPlot_ImMaxArray_U32Ptr((*C.ImU32)(&valuesArg[0]), C.int(count)))
}

func PlotImMaxArrayU64Ptr(values []uint64, count int32) uint64 {
	return uint64(C.ImPlot_ImMaxArray_U64Ptr((*C.ulonglong)(&(values[0])), C.int(count)))
}

func PlotImMaxArrayU8Ptr(values *[]byte, count int32) byte {
	valuesArg := make([]C.ImU8, len(*values))
	for i, valuesV := range *values {
		valuesArg[i] = C.ImU8(valuesV)
	}

	defer func() {
		for i, valuesV := range valuesArg {
			(*values)[i] = byte(valuesV)
		}
	}()
	return byte(C.ImPlot_ImMaxArray_U8Ptr((*C.ImU8)(&valuesArg[0]), C.int(count)))
}

func PlotImMaxArraydoublePtr(values *[]float64, count int32) float64 {
	valuesArg := make([]C.double, len(*values))
	for i, valuesV := range *values {
		valuesArg[i] = C.double(valuesV)
	}

	defer func() {
		for i, valuesV := range valuesArg {
			(*values)[i] = float64(valuesV)
		}
	}()
	return float64(C.ImPlot_ImMaxArray_doublePtr((*C.double)(&valuesArg[0]), C.int(count)))
}

func PlotImMeanFloatPtr(values []float32, count int32) float64 {
	return float64(C.ImPlot_ImMean_FloatPtr((*C.float)(&(values[0])), C.int(count)))
}

func PlotImMeanS16Ptr(values *[]int, count int32) float64 {
	valuesArg := make([]C.ImS16, len(*values))
	for i, valuesV := range *values {
		valuesArg[i] = C.ImS16(valuesV)
	}

	defer func() {
		for i, valuesV := range valuesArg {
			(*values)[i] = int(valuesV)
		}
	}()
	return float64(C.ImPlot_ImMean_S16Ptr((*C.ImS16)(&valuesArg[0]), C.int(count)))
}

func PlotImMeanS32Ptr(values *[]int32, count int32) float64 {
	valuesArg := make([]C.ImS32, len(*values))
	for i, valuesV := range *values {
		valuesArg[i] = C.ImS32(valuesV)
	}

	defer func() {
		for i, valuesV := range valuesArg {
			(*values)[i] = int32(valuesV)
		}
	}()
	return float64(C.ImPlot_ImMean_S32Ptr((*C.ImS32)(&valuesArg[0]), C.int(count)))
}

func PlotImMeanS64Ptr(values []int64, count int32) float64 {
	return float64(C.ImPlot_ImMean_S64Ptr((*C.longlong)(&(values[0])), C.int(count)))
}

func PlotImMeanS8Ptr(values *[]int8, count int32) float64 {
	valuesArg := make([]C.ImS8, len(*values))
	for i, valuesV := range *values {
		valuesArg[i] = C.ImS8(valuesV)
	}

	defer func() {
		for i, valuesV := range valuesArg {
			(*values)[i] = int8(valuesV)
		}
	}()
	return float64(C.ImPlot_ImMean_S8Ptr((*C.ImS8)(&valuesArg[0]), C.int(count)))
}

func PlotImMeanU16Ptr(values *[]uint16, count int32) float64 {
	valuesArg := make([]C.ImU16, len(*values))
	for i, valuesV := range *values {
		valuesArg[i] = C.ImU16(valuesV)
	}

	defer func() {
		for i, valuesV := range valuesArg {
			(*values)[i] = uint16(valuesV)
		}
	}()
	return float64(C.ImPlot_ImMean_U16Ptr((*C.ImU16)(&valuesArg[0]), C.int(count)))
}

func PlotImMeanU32Ptr(values *[]uint32, count int32) float64 {
	valuesArg := make([]C.ImU32, len(*values))
	for i, valuesV := range *values {
		valuesArg[i] = C.ImU32(valuesV)
	}

	defer func() {
		for i, valuesV := range valuesArg {
			(*values)[i] = uint32(valuesV)
		}
	}()
	return float64(C.ImPlot_ImMean_U32Ptr((*C.ImU32)(&valuesArg[0]), C.int(count)))
}

func PlotImMeanU64Ptr(values []uint64, count int32) float64 {
	return float64(C.ImPlot_ImMean_U64Ptr((*C.ulonglong)(&(values[0])), C.int(count)))
}

func PlotImMeanU8Ptr(values *[]byte, count int32) float64 {
	valuesArg := make([]C.ImU8, len(*values))
	for i, valuesV := range *values {
		valuesArg[i] = C.ImU8(valuesV)
	}

	defer func() {
		for i, valuesV := range valuesArg {
			(*values)[i] = byte(valuesV)
		}
	}()
	return float64(C.ImPlot_ImMean_U8Ptr((*C.ImU8)(&valuesArg[0]), C.int(count)))
}

func PlotImMeandoublePtr(values *[]float64, count int32) float64 {
	valuesArg := make([]C.double, len(*values))
	for i, valuesV := range *values {
		valuesArg[i] = C.double(valuesV)
	}

	defer func() {
		for i, valuesV := range valuesArg {
			(*values)[i] = float64(valuesV)
		}
	}()
	return float64(C.ImPlot_ImMean_doublePtr((*C.double)(&valuesArg[0]), C.int(count)))
}

func PlotImMinArrayFloatPtr(values []float32, count int32) float32 {
	return float32(C.ImPlot_ImMinArray_FloatPtr((*C.float)(&(values[0])), C.int(count)))
}

func PlotImMinArrayS16Ptr(values *[]int, count int32) int {
	valuesArg := make([]C.ImS16, len(*values))
	for i, valuesV := range *values {
		valuesArg[i] = C.ImS16(valuesV)
	}

	defer func() {
		for i, valuesV := range valuesArg {
			(*values)[i] = int(valuesV)
		}
	}()
	return int(C.ImPlot_ImMinArray_S16Ptr((*C.ImS16)(&valuesArg[0]), C.int(count)))
}

func PlotImMinArrayS32Ptr(values *[]int32, count int32) int {
	valuesArg := make([]C.ImS32, len(*values))
	for i, valuesV := range *values {
		valuesArg[i] = C.ImS32(valuesV)
	}

	defer func() {
		for i, valuesV := range valuesArg {
			(*values)[i] = int32(valuesV)
		}
	}()
	return int(C.ImPlot_ImMinArray_S32Ptr((*C.ImS32)(&valuesArg[0]), C.int(count)))
}

func PlotImMinArrayS64Ptr(values []int64, count int32) int64 {
	return int64(C.ImPlot_ImMinArray_S64Ptr((*C.longlong)(&(values[0])), C.int(count)))
}

func PlotImMinArrayS8Ptr(values *[]int8, count int32) int {
	valuesArg := make([]C.ImS8, len(*values))
	for i, valuesV := range *values {
		valuesArg[i] = C.ImS8(valuesV)
	}

	defer func() {
		for i, valuesV := range valuesArg {
			(*values)[i] = int8(valuesV)
		}
	}()
	return int(C.ImPlot_ImMinArray_S8Ptr((*C.ImS8)(&valuesArg[0]), C.int(count)))
}

func PlotImMinArrayU16Ptr(values *[]uint16, count int32) uint16 {
	valuesArg := make([]C.ImU16, len(*values))
	for i, valuesV := range *values {
		valuesArg[i] = C.ImU16(valuesV)
	}

	defer func() {
		for i, valuesV := range valuesArg {
			(*values)[i] = uint16(valuesV)
		}
	}()
	return uint16(C.ImPlot_ImMinArray_U16Ptr((*C.ImU16)(&valuesArg[0]), C.int(count)))
}

func PlotImMinArrayU32Ptr(values *[]uint32, count int32) uint32 {
	valuesArg := make([]C.ImU32, len(*values))
	for i, valuesV := range *values {
		valuesArg[i] = C.ImU32(valuesV)
	}

	defer func() {
		for i, valuesV := range valuesArg {
			(*values)[i] = uint32(valuesV)
		}
	}()
	return uint32(C.ImPlot_ImMinArray_U32Ptr((*C.ImU32)(&valuesArg[0]), C.int(count)))
}

func PlotImMinArrayU64Ptr(values []uint64, count int32) uint64 {
	return uint64(C.ImPlot_ImMinArray_U64Ptr((*C.ulonglong)(&(values[0])), C.int(count)))
}

func PlotImMinArrayU8Ptr(values *[]byte, count int32) byte {
	valuesArg := make([]C.ImU8, len(*values))
	for i, valuesV := range *values {
		valuesArg[i] = C.ImU8(valuesV)
	}

	defer func() {
		for i, valuesV := range valuesArg {
			(*values)[i] = byte(valuesV)
		}
	}()
	return byte(C.ImPlot_ImMinArray_U8Ptr((*C.ImU8)(&valuesArg[0]), C.int(count)))
}

func PlotImMinArraydoublePtr(values *[]float64, count int32) float64 {
	valuesArg := make([]C.double, len(*values))
	for i, valuesV := range *values {
		valuesArg[i] = C.double(valuesV)
	}

	defer func() {
		for i, valuesV := range valuesArg {
			(*values)[i] = float64(valuesV)
		}
	}()
	return float64(C.ImPlot_ImMinArray_doublePtr((*C.double)(&valuesArg[0]), C.int(count)))
}

func PlotImMinMaxArrayFloatPtr(values []float32, count int32, min_out *float32, max_out *float32) {
	min_outArg, min_outFin := WrapNumberPtr[C.float, float32](min_out)
	max_outArg, max_outFin := WrapNumberPtr[C.float, float32](max_out)
	C.ImPlot_ImMinMaxArray_FloatPtr((*C.float)(&(values[0])), C.int(count), min_outArg, max_outArg)

	min_outFin()
	max_outFin()
}

func PlotImMinMaxArrayS16Ptr(values *[]int, count int32, min_out *[]int, max_out *[]int) {
	valuesArg := make([]C.ImS16, len(*values))
	for i, valuesV := range *values {
		valuesArg[i] = C.ImS16(valuesV)
	}

	min_outArg := make([]C.ImS16, len(*min_out))
	for i, min_outV := range *min_out {
		min_outArg[i] = C.ImS16(min_outV)
	}

	max_outArg := make([]C.ImS16, len(*max_out))
	for i, max_outV := range *max_out {
		max_outArg[i] = C.ImS16(max_outV)
	}

	C.ImPlot_ImMinMaxArray_S16Ptr((*C.ImS16)(&valuesArg[0]), C.int(count), (*C.ImS16)(&min_outArg[0]), (*C.ImS16)(&max_outArg[0]))

	for i, valuesV := range valuesArg {
		(*values)[i] = int(valuesV)
	}

	for i, min_outV := range min_outArg {
		(*min_out)[i] = int(min_outV)
	}

	for i, max_outV := range max_outArg {
		(*max_out)[i] = int(max_outV)
	}
}

func PlotImMinMaxArrayS32Ptr(values *[]int32, count int32, min_out *[]int32, max_out *[]int32) {
	valuesArg := make([]C.ImS32, len(*values))
	for i, valuesV := range *values {
		valuesArg[i] = C.ImS32(valuesV)
	}

	min_outArg := make([]C.ImS32, len(*min_out))
	for i, min_outV := range *min_out {
		min_outArg[i] = C.ImS32(min_outV)
	}

	max_outArg := make([]C.ImS32, len(*max_out))
	for i, max_outV := range *max_out {
		max_outArg[i] = C.ImS32(max_outV)
	}

	C.ImPlot_ImMinMaxArray_S32Ptr((*C.ImS32)(&valuesArg[0]), C.int(count), (*C.ImS32)(&min_outArg[0]), (*C.ImS32)(&max_outArg[0]))

	for i, valuesV := range valuesArg {
		(*values)[i] = int32(valuesV)
	}

	for i, min_outV := range min_outArg {
		(*min_out)[i] = int32(min_outV)
	}

	for i, max_outV := range max_outArg {
		(*max_out)[i] = int32(max_outV)
	}
}

func PlotImMinMaxArrayS64Ptr(values []int64, count int32, min_out *int64, max_out *int64) {
	min_outArg, min_outFin := WrapNumberPtr[C.ImS64, int64](min_out)
	max_outArg, max_outFin := WrapNumberPtr[C.ImS64, int64](max_out)
	C.ImPlot_ImMinMaxArray_S64Ptr((*C.longlong)(&(values[0])), C.int(count), min_outArg, max_outArg)

	min_outFin()
	max_outFin()
}

func PlotImMinMaxArrayS8Ptr(values *[]int8, count int32, min_out *[]int8, max_out *[]int8) {
	valuesArg := make([]C.ImS8, len(*values))
	for i, valuesV := range *values {
		valuesArg[i] = C.ImS8(valuesV)
	}

	min_outArg := make([]C.ImS8, len(*min_out))
	for i, min_outV := range *min_out {
		min_outArg[i] = C.ImS8(min_outV)
	}

	max_outArg := make([]C.ImS8, len(*max_out))
	for i, max_outV := range *max_out {
		max_outArg[i] = C.ImS8(max_outV)
	}

	C.ImPlot_ImMinMaxArray_S8Ptr((*C.ImS8)(&valuesArg[0]), C.int(count), (*C.ImS8)(&min_outArg[0]), (*C.ImS8)(&max_outArg[0]))

	for i, valuesV := range valuesArg {
		(*values)[i] = int8(valuesV)
	}

	for i, min_outV := range min_outArg {
		(*min_out)[i] = int8(min_outV)
	}

	for i, max_outV := range max_outArg {
		(*max_out)[i] = int8(max_outV)
	}
}

func PlotImMinMaxArrayU16Ptr(values *[]uint16, count int32, min_out *uint16, max_out *uint16) {
	valuesArg := make([]C.ImU16, len(*values))
	for i, valuesV := range *values {
		valuesArg[i] = C.ImU16(valuesV)
	}

	min_outArg, min_outFin := WrapNumberPtr[C.ImU16, uint16](min_out)
	max_outArg, max_outFin := WrapNumberPtr[C.ImU16, uint16](max_out)
	C.ImPlot_ImMinMaxArray_U16Ptr((*C.ImU16)(&valuesArg[0]), C.int(count), min_outArg, max_outArg)

	for i, valuesV := range valuesArg {
		(*values)[i] = uint16(valuesV)
	}

	min_outFin()
	max_outFin()
}

func PlotImMinMaxArrayU32Ptr(values *[]uint32, count int32, min_out *uint32, max_out *uint32) {
	valuesArg := make([]C.ImU32, len(*values))
	for i, valuesV := range *values {
		valuesArg[i] = C.ImU32(valuesV)
	}

	min_outArg, min_outFin := WrapNumberPtr[C.ImU32, uint32](min_out)
	max_outArg, max_outFin := WrapNumberPtr[C.ImU32, uint32](max_out)
	C.ImPlot_ImMinMaxArray_U32Ptr((*C.ImU32)(&valuesArg[0]), C.int(count), min_outArg, max_outArg)

	for i, valuesV := range valuesArg {
		(*values)[i] = uint32(valuesV)
	}

	min_outFin()
	max_outFin()
}

func PlotImMinMaxArrayU64Ptr(values []uint64, count int32, min_out *[]uint64, max_out *[]uint64) {
	min_outArg := make([]C.ImU64, len(*min_out))
	for i, min_outV := range *min_out {
		min_outArg[i] = C.ImU64(min_outV)
	}

	max_outArg := make([]C.ImU64, len(*max_out))
	for i, max_outV := range *max_out {
		max_outArg[i] = C.ImU64(max_outV)
	}

	C.ImPlot_ImMinMaxArray_U64Ptr((*C.ulonglong)(&(values[0])), C.int(count), (*C.ImU64)(&min_outArg[0]), (*C.ImU64)(&max_outArg[0]))

	for i, min_outV := range min_outArg {
		(*min_out)[i] = uint64(min_outV)
	}

	for i, max_outV := range max_outArg {
		(*max_out)[i] = uint64(max_outV)
	}
}

func PlotImMinMaxArrayU8Ptr(values *[]byte, count int32, min_out *byte, max_out *byte) {
	valuesArg := make([]C.ImU8, len(*values))
	for i, valuesV := range *values {
		valuesArg[i] = C.ImU8(valuesV)
	}

	min_outArg, min_outFin := WrapNumberPtr[C.ImU8, byte](min_out)
	max_outArg, max_outFin := WrapNumberPtr[C.ImU8, byte](max_out)
	C.ImPlot_ImMinMaxArray_U8Ptr((*C.ImU8)(&valuesArg[0]), C.int(count), min_outArg, max_outArg)

	for i, valuesV := range valuesArg {
		(*values)[i] = byte(valuesV)
	}

	min_outFin()
	max_outFin()
}

func PlotImMinMaxArraydoublePtr(values *[]float64, count int32, min_out *float64, max_out *float64) {
	valuesArg := make([]C.double, len(*values))
	for i, valuesV := range *values {
		valuesArg[i] = C.double(valuesV)
	}

	min_outArg, min_outFin := WrapNumberPtr[C.double, float64](min_out)
	max_outArg, max_outFin := WrapNumberPtr[C.double, float64](max_out)
	C.ImPlot_ImMinMaxArray_doublePtr((*C.double)(&valuesArg[0]), C.int(count), min_outArg, max_outArg)

	for i, valuesV := range valuesArg {
		(*values)[i] = float64(valuesV)
	}

	min_outFin()
	max_outFin()
}

func PlotImMixU32(a uint32, b uint32, s uint32) uint32 {
	return uint32(C.ImPlot_ImMixU32(C.ImU32(a), C.ImU32(b), C.ImU32(s)))
}

func PlotImNan(val float64) bool {
	return C.ImPlot_ImNan(C.double(val)) == C.bool(true)
}

func PlotImNanOrInf(val float64) bool {
	return C.ImPlot_ImNanOrInf(C.double(val)) == C.bool(true)
}

func PlotImOverlapsFloat(min_a float32, max_a float32, min_b float32, max_b float32) bool {
	return C.ImPlot_ImOverlaps_Float(C.float(min_a), C.float(max_a), C.float(min_b), C.float(max_b)) == C.bool(true)
}

func PlotImOverlapsS16(min_a int, max_a int, min_b int, max_b int) bool {
	return C.ImPlot_ImOverlaps_S16(C.ImS16(min_a), C.ImS16(max_a), C.ImS16(min_b), C.ImS16(max_b)) == C.bool(true)
}

func PlotImOverlapsS32(min_a int, max_a int, min_b int, max_b int) bool {
	return C.ImPlot_ImOverlaps_S32(C.ImS32(min_a), C.ImS32(max_a), C.ImS32(min_b), C.ImS32(max_b)) == C.bool(true)
}

func PlotImOverlapsS64(min_a int64, max_a int64, min_b int64, max_b int64) bool {
	return C.ImPlot_ImOverlaps_S64(C.ImS64(min_a), C.ImS64(max_a), C.ImS64(min_b), C.ImS64(max_b)) == C.bool(true)
}

func PlotImOverlapsS8(min_a int, max_a int, min_b int, max_b int) bool {
	return C.ImPlot_ImOverlaps_S8(C.ImS8(min_a), C.ImS8(max_a), C.ImS8(min_b), C.ImS8(max_b)) == C.bool(true)
}

func PlotImOverlapsU16(min_a uint16, max_a uint16, min_b uint16, max_b uint16) bool {
	return C.ImPlot_ImOverlaps_U16(C.ImU16(min_a), C.ImU16(max_a), C.ImU16(min_b), C.ImU16(max_b)) == C.bool(true)
}

func PlotImOverlapsU32(min_a uint32, max_a uint32, min_b uint32, max_b uint32) bool {
	return C.ImPlot_ImOverlaps_U32(C.ImU32(min_a), C.ImU32(max_a), C.ImU32(min_b), C.ImU32(max_b)) == C.bool(true)
}

func PlotImOverlapsU64(min_a uint64, max_a uint64, min_b uint64, max_b uint64) bool {
	return C.ImPlot_ImOverlaps_U64(C.ImU64(min_a), C.ImU64(max_a), C.ImU64(min_b), C.ImU64(max_b)) == C.bool(true)
}

func PlotImOverlapsU8(min_a byte, max_a byte, min_b byte, max_b byte) bool {
	return C.ImPlot_ImOverlaps_U8(C.ImU8(min_a), C.ImU8(max_a), C.ImU8(min_b), C.ImU8(max_b)) == C.bool(true)
}

func PlotImOverlapsdouble(min_a float64, max_a float64, min_b float64, max_b float64) bool {
	return C.ImPlot_ImOverlaps_double(C.double(min_a), C.double(max_a), C.double(min_b), C.double(max_b)) == C.bool(true)
}

func PlotImPosMod(l int32, r int32) int32 {
	return int32(C.ImPlot_ImPosMod(C.int(l), C.int(r)))
}

func PlotImRemap01Float(x float32, x0 float32, x1 float32) float32 {
	return float32(C.ImPlot_ImRemap01_Float(C.float(x), C.float(x0), C.float(x1)))
}

func PlotImRemap01S16(x int, x0 int, x1 int) int {
	return int(C.ImPlot_ImRemap01_S16(C.ImS16(x), C.ImS16(x0), C.ImS16(x1)))
}

func PlotImRemap01S32(x int, x0 int, x1 int) int {
	return int(C.ImPlot_ImRemap01_S32(C.ImS32(x), C.ImS32(x0), C.ImS32(x1)))
}

func PlotImRemap01S64(x int64, x0 int64, x1 int64) int64 {
	return int64(C.ImPlot_ImRemap01_S64(C.ImS64(x), C.ImS64(x0), C.ImS64(x1)))
}

func PlotImRemap01S8(x int, x0 int, x1 int) int {
	return int(C.ImPlot_ImRemap01_S8(C.ImS8(x), C.ImS8(x0), C.ImS8(x1)))
}

func PlotImRemap01U16(x uint16, x0 uint16, x1 uint16) uint16 {
	return uint16(C.ImPlot_ImRemap01_U16(C.ImU16(x), C.ImU16(x0), C.ImU16(x1)))
}

func PlotImRemap01U32(x uint32, x0 uint32, x1 uint32) uint32 {
	return uint32(C.ImPlot_ImRemap01_U32(C.ImU32(x), C.ImU32(x0), C.ImU32(x1)))
}

func PlotImRemap01U64(x uint64, x0 uint64, x1 uint64) uint64 {
	return uint64(C.ImPlot_ImRemap01_U64(C.ImU64(x), C.ImU64(x0), C.ImU64(x1)))
}

func PlotImRemap01U8(x byte, x0 byte, x1 byte) byte {
	return byte(C.ImPlot_ImRemap01_U8(C.ImU8(x), C.ImU8(x0), C.ImU8(x1)))
}

func PlotImRemap01double(x float64, x0 float64, x1 float64) float64 {
	return float64(C.ImPlot_ImRemap01_double(C.double(x), C.double(x0), C.double(x1)))
}

func PlotImRemapFloat(x float32, x0 float32, x1 float32, y0 float32, y1 float32) float32 {
	return float32(C.ImPlot_ImRemap_Float(C.float(x), C.float(x0), C.float(x1), C.float(y0), C.float(y1)))
}

func PlotImRemapS16(x int, x0 int, x1 int, y0 int, y1 int) int {
	return int(C.ImPlot_ImRemap_S16(C.ImS16(x), C.ImS16(x0), C.ImS16(x1), C.ImS16(y0), C.ImS16(y1)))
}

func PlotImRemapS32(x int, x0 int, x1 int, y0 int, y1 int) int {
	return int(C.ImPlot_ImRemap_S32(C.ImS32(x), C.ImS32(x0), C.ImS32(x1), C.ImS32(y0), C.ImS32(y1)))
}

func PlotImRemapS64(x int64, x0 int64, x1 int64, y0 int64, y1 int64) int64 {
	return int64(C.ImPlot_ImRemap_S64(C.ImS64(x), C.ImS64(x0), C.ImS64(x1), C.ImS64(y0), C.ImS64(y1)))
}

func PlotImRemapS8(x int, x0 int, x1 int, y0 int, y1 int) int {
	return int(C.ImPlot_ImRemap_S8(C.ImS8(x), C.ImS8(x0), C.ImS8(x1), C.ImS8(y0), C.ImS8(y1)))
}

func PlotImRemapU16(x uint16, x0 uint16, x1 uint16, y0 uint16, y1 uint16) uint16 {
	return uint16(C.ImPlot_ImRemap_U16(C.ImU16(x), C.ImU16(x0), C.ImU16(x1), C.ImU16(y0), C.ImU16(y1)))
}

func PlotImRemapU32(x uint32, x0 uint32, x1 uint32, y0 uint32, y1 uint32) uint32 {
	return uint32(C.ImPlot_ImRemap_U32(C.ImU32(x), C.ImU32(x0), C.ImU32(x1), C.ImU32(y0), C.ImU32(y1)))
}

func PlotImRemapU64(x uint64, x0 uint64, x1 uint64, y0 uint64, y1 uint64) uint64 {
	return uint64(C.ImPlot_ImRemap_U64(C.ImU64(x), C.ImU64(x0), C.ImU64(x1), C.ImU64(y0), C.ImU64(y1)))
}

func PlotImRemapU8(x byte, x0 byte, x1 byte, y0 byte, y1 byte) byte {
	return byte(C.ImPlot_ImRemap_U8(C.ImU8(x), C.ImU8(x0), C.ImU8(x1), C.ImU8(y0), C.ImU8(y1)))
}

func PlotImRemapdouble(x float64, x0 float64, x1 float64, y0 float64, y1 float64) float64 {
	return float64(C.ImPlot_ImRemap_double(C.double(x), C.double(x0), C.double(x1), C.double(y0), C.double(y1)))
}

func PlotImSinhFloat(x float32) float32 {
	return float32(C.ImPlot_ImSinh_Float(C.float(x)))
}

func PlotImSinhdouble(x float64) float64 {
	return float64(C.ImPlot_ImSinh_double(C.double(x)))
}

func PlotImStdDevFloatPtr(values []float32, count int32) float64 {
	return float64(C.ImPlot_ImStdDev_FloatPtr((*C.float)(&(values[0])), C.int(count)))
}

func PlotImStdDevS16Ptr(values *[]int, count int32) float64 {
	valuesArg := make([]C.ImS16, len(*values))
	for i, valuesV := range *values {
		valuesArg[i] = C.ImS16(valuesV)
	}

	defer func() {
		for i, valuesV := range valuesArg {
			(*values)[i] = int(valuesV)
		}
	}()
	return float64(C.ImPlot_ImStdDev_S16Ptr((*C.ImS16)(&valuesArg[0]), C.int(count)))
}

func PlotImStdDevS32Ptr(values *[]int32, count int32) float64 {
	valuesArg := make([]C.ImS32, len(*values))
	for i, valuesV := range *values {
		valuesArg[i] = C.ImS32(valuesV)
	}

	defer func() {
		for i, valuesV := range valuesArg {
			(*values)[i] = int32(valuesV)
		}
	}()
	return float64(C.ImPlot_ImStdDev_S32Ptr((*C.ImS32)(&valuesArg[0]), C.int(count)))
}

func PlotImStdDevS64Ptr(values []int64, count int32) float64 {
	return float64(C.ImPlot_ImStdDev_S64Ptr((*C.longlong)(&(values[0])), C.int(count)))
}

func PlotImStdDevS8Ptr(values *[]int8, count int32) float64 {
	valuesArg := make([]C.ImS8, len(*values))
	for i, valuesV := range *values {
		valuesArg[i] = C.ImS8(valuesV)
	}

	defer func() {
		for i, valuesV := range valuesArg {
			(*values)[i] = int8(valuesV)
		}
	}()
	return float64(C.ImPlot_ImStdDev_S8Ptr((*C.ImS8)(&valuesArg[0]), C.int(count)))
}

func PlotImStdDevU16Ptr(values *[]uint16, count int32) float64 {
	valuesArg := make([]C.ImU16, len(*values))
	for i, valuesV := range *values {
		valuesArg[i] = C.ImU16(valuesV)
	}

	defer func() {
		for i, valuesV := range valuesArg {
			(*values)[i] = uint16(valuesV)
		}
	}()
	return float64(C.ImPlot_ImStdDev_U16Ptr((*C.ImU16)(&valuesArg[0]), C.int(count)))
}

func PlotImStdDevU32Ptr(values *[]uint32, count int32) float64 {
	valuesArg := make([]C.ImU32, len(*values))
	for i, valuesV := range *values {
		valuesArg[i] = C.ImU32(valuesV)
	}

	defer func() {
		for i, valuesV := range valuesArg {
			(*values)[i] = uint32(valuesV)
		}
	}()
	return float64(C.ImPlot_ImStdDev_U32Ptr((*C.ImU32)(&valuesArg[0]), C.int(count)))
}

func PlotImStdDevU64Ptr(values []uint64, count int32) float64 {
	return float64(C.ImPlot_ImStdDev_U64Ptr((*C.ulonglong)(&(values[0])), C.int(count)))
}

func PlotImStdDevU8Ptr(values *[]byte, count int32) float64 {
	valuesArg := make([]C.ImU8, len(*values))
	for i, valuesV := range *values {
		valuesArg[i] = C.ImU8(valuesV)
	}

	defer func() {
		for i, valuesV := range valuesArg {
			(*values)[i] = byte(valuesV)
		}
	}()
	return float64(C.ImPlot_ImStdDev_U8Ptr((*C.ImU8)(&valuesArg[0]), C.int(count)))
}

func PlotImStdDevdoublePtr(values *[]float64, count int32) float64 {
	valuesArg := make([]C.double, len(*values))
	for i, valuesV := range *values {
		valuesArg[i] = C.double(valuesV)
	}

	defer func() {
		for i, valuesV := range valuesArg {
			(*values)[i] = float64(valuesV)
		}
	}()
	return float64(C.ImPlot_ImStdDev_doublePtr((*C.double)(&valuesArg[0]), C.int(count)))
}

func PlotImSumFloatPtr(values []float32, count int32) float32 {
	return float32(C.ImPlot_ImSum_FloatPtr((*C.float)(&(values[0])), C.int(count)))
}

func PlotImSumS16Ptr(values *[]int, count int32) int {
	valuesArg := make([]C.ImS16, len(*values))
	for i, valuesV := range *values {
		valuesArg[i] = C.ImS16(valuesV)
	}

	defer func() {
		for i, valuesV := range valuesArg {
			(*values)[i] = int(valuesV)
		}
	}()
	return int(C.ImPlot_ImSum_S16Ptr((*C.ImS16)(&valuesArg[0]), C.int(count)))
}

func PlotImSumS32Ptr(values *[]int32, count int32) int {
	valuesArg := make([]C.ImS32, len(*values))
	for i, valuesV := range *values {
		valuesArg[i] = C.ImS32(valuesV)
	}

	defer func() {
		for i, valuesV := range valuesArg {
			(*values)[i] = int32(valuesV)
		}
	}()
	return int(C.ImPlot_ImSum_S32Ptr((*C.ImS32)(&valuesArg[0]), C.int(count)))
}

func PlotImSumS64Ptr(values []int64, count int32) int64 {
	return int64(C.ImPlot_ImSum_S64Ptr((*C.longlong)(&(values[0])), C.int(count)))
}

func PlotImSumS8Ptr(values *[]int8, count int32) int {
	valuesArg := make([]C.ImS8, len(*values))
	for i, valuesV := range *values {
		valuesArg[i] = C.ImS8(valuesV)
	}

	defer func() {
		for i, valuesV := range valuesArg {
			(*values)[i] = int8(valuesV)
		}
	}()
	return int(C.ImPlot_ImSum_S8Ptr((*C.ImS8)(&valuesArg[0]), C.int(count)))
}

func PlotImSumU16Ptr(values *[]uint16, count int32) uint16 {
	valuesArg := make([]C.ImU16, len(*values))
	for i, valuesV := range *values {
		valuesArg[i] = C.ImU16(valuesV)
	}

	defer func() {
		for i, valuesV := range valuesArg {
			(*values)[i] = uint16(valuesV)
		}
	}()
	return uint16(C.ImPlot_ImSum_U16Ptr((*C.ImU16)(&valuesArg[0]), C.int(count)))
}

func PlotImSumU32Ptr(values *[]uint32, count int32) uint32 {
	valuesArg := make([]C.ImU32, len(*values))
	for i, valuesV := range *values {
		valuesArg[i] = C.ImU32(valuesV)
	}

	defer func() {
		for i, valuesV := range valuesArg {
			(*values)[i] = uint32(valuesV)
		}
	}()
	return uint32(C.ImPlot_ImSum_U32Ptr((*C.ImU32)(&valuesArg[0]), C.int(count)))
}

func PlotImSumU64Ptr(values []uint64, count int32) uint64 {
	return uint64(C.ImPlot_ImSum_U64Ptr((*C.ulonglong)(&(values[0])), C.int(count)))
}

func PlotImSumU8Ptr(values *[]byte, count int32) byte {
	valuesArg := make([]C.ImU8, len(*values))
	for i, valuesV := range *values {
		valuesArg[i] = C.ImU8(valuesV)
	}

	defer func() {
		for i, valuesV := range valuesArg {
			(*values)[i] = byte(valuesV)
		}
	}()
	return byte(C.ImPlot_ImSum_U8Ptr((*C.ImU8)(&valuesArg[0]), C.int(count)))
}

func PlotImSumdoublePtr(values *[]float64, count int32) float64 {
	valuesArg := make([]C.double, len(*values))
	for i, valuesV := range *values {
		valuesArg[i] = C.double(valuesV)
	}

	defer func() {
		for i, valuesV := range valuesArg {
			(*values)[i] = float64(valuesV)
		}
	}()
	return float64(C.ImPlot_ImSum_doublePtr((*C.double)(&valuesArg[0]), C.int(count)))
}

func PlotInitialize(ctx *PlotContext) {
	ctxArg, ctxFin := ctx.handle()
	C.ImPlot_Initialize(ctxArg)

	ctxFin()
}

func PlotIntersection(a1 Vec2, a2 Vec2, b1 Vec2, b2 Vec2) Vec2 {
	pOut := new(Vec2)
	pOutArg, pOutFin := wrap[C.ImVec2, *Vec2](pOut)

	C.ImPlot_Intersection(pOutArg, a1.toC(), a2.toC(), b1.toC(), b2.toC())

	pOutFin()

	return *pOut
}

func PlotIsAxisHovered(axis PlotAxisEnum) bool {
	return C.ImPlot_IsAxisHovered(C.ImAxis(axis)) == C.bool(true)
}

func PlotIsColorAutoPlotCol(idx PlotCol) bool {
	return C.ImPlot_IsColorAuto_PlotCol(C.ImPlotCol(idx)) == C.bool(true)
}

func PlotIsColorAutoVec4(col Vec4) bool {
	return C.ImPlot_IsColorAuto_Vec4(col.toC()) == C.bool(true)
}

func PlotIsLeapYear(year int32) bool {
	return C.ImPlot_IsLeapYear(C.int(year)) == C.bool(true)
}

func PlotIsLegendEntryHovered(label_id string) bool {
	label_idArg, label_idFin := WrapString(label_id)

	defer func() {
		label_idFin()
	}()
	return C.ImPlot_IsLegendEntryHovered(label_idArg) == C.bool(true)
}

func PlotIsPlotHovered() bool {
	return C.ImPlot_IsPlotHovered() == C.bool(true)
}

func PlotIsPlotSelected() bool {
	return C.ImPlot_IsPlotSelected() == C.bool(true)
}

func PlotIsSubplotsHovered() bool {
	return C.ImPlot_IsSubplotsHovered() == C.bool(true)
}

func PlotItemIconU32(col uint32) {
	C.ImPlot_ItemIcon_U32(C.ImU32(col))
}

func PlotItemIconVec4(col Vec4) {
	C.ImPlot_ItemIcon_Vec4(col.toC())
}

// PlotLabelAxisValueV parameter default value hint:
// round: false
func PlotLabelAxisValueV(axis PlotAxis, value float64, buff string, size int32, round bool) {
	axisArg, axisFin := axis.c()
	buffArg, buffFin := WrapString(buff)
	C.ImPlot_LabelAxisValue(axisArg, C.double(value), buffArg, C.int(size), C.bool(round))

	axisFin()
	buffFin()
}

// PlotMakeTimeV parameter default value hint:
// month: 0
// day: 1
// hour: 0
// min: 0
// sec: 0
// us: 0
func PlotMakeTimeV(year int32, month int32, day int32, hour int32, min int32, sec int32, us int32) PlotTime {
	pOut := new(PlotTime)
	pOutArg, pOutFin := wrap[C.ImPlotTime, *PlotTime](pOut)

	C.ImPlot_MakeTime(pOutArg, C.int(year), C.int(month), C.int(day), C.int(hour), C.int(min), C.int(sec), C.int(us))

	pOutFin()

	return *pOut
}

// PlotMapInputDefaultV parameter default value hint:
// dst: nullptr
func PlotMapInputDefaultV(dst *PlotInputMap) {
	dstArg, dstFin := dst.handle()
	C.ImPlot_MapInputDefault(dstArg)

	dstFin()
}

// PlotMapInputReverseV parameter default value hint:
// dst: nullptr
func PlotMapInputReverseV(dst *PlotInputMap) {
	dstArg, dstFin := dst.handle()
	C.ImPlot_MapInputReverse(dstArg)

	dstFin()
}

func PlotNextColormapColor() Vec4 {
	pOut := new(Vec4)
	pOutArg, pOutFin := wrap[C.ImVec4, *Vec4](pOut)

	C.ImPlot_NextColormapColor(pOutArg)

	pOutFin()

	return *pOut
}

func PlotNextColormapColorU32() uint32 {
	return uint32(C.ImPlot_NextColormapColorU32())
}

func PlotNiceNum(x float64, round bool) float64 {
	return float64(C.ImPlot_NiceNum(C.double(x), C.bool(round)))
}

func PlotOrderOfMagnitude(val float64) int32 {
	return int32(C.ImPlot_OrderOfMagnitude(C.double(val)))
}

func PlotOrderToPrecision(order int32) int32 {
	return int32(C.ImPlot_OrderToPrecision(C.int(order)))
}

// PlotPixelsToPlotFloatV parameter default value hint:
// x_axis: -1
// y_axis: -1
func PlotPixelsToPlotFloatV(x float32, y float32, x_axis PlotAxisEnum, y_axis PlotAxisEnum) PlotPoint {
	pOut := new(PlotPoint)
	pOutArg, pOutFin := wrap[C.ImPlotPoint, *PlotPoint](pOut)

	C.ImPlot_PixelsToPlot_Float(pOutArg, C.float(x), C.float(y), C.ImAxis(x_axis), C.ImAxis(y_axis))

	pOutFin()

	return *pOut
}

// PlotPixelsToPlotVec2V parameter default value hint:
// x_axis: -1
// y_axis: -1
func PlotPixelsToPlotVec2V(pix Vec2, x_axis PlotAxisEnum, y_axis PlotAxisEnum) PlotPoint {
	pOut := new(PlotPoint)
	pOutArg, pOutFin := wrap[C.ImPlotPoint, *PlotPoint](pOut)

	C.ImPlot_PixelsToPlot_Vec2(pOutArg, pix.toC(), C.ImAxis(x_axis), C.ImAxis(y_axis))

	pOutFin()

	return *pOut
}

// PlotPlotBarGroupsFloatPtrV parameter default value hint:
// group_size: 0.67
// shift: 0
// flags: 0
func PlotPlotBarGroupsFloatPtrV(label_ids []string, values []float32, item_count int32, group_count int32, group_size float64, shift float64, flags PlotBarGroupsFlags) {
	label_idsArg, label_idsFin := WrapStringList(label_ids)
	C.ImPlot_PlotBarGroups_FloatPtr(label_idsArg, (*C.float)(&(values[0])), C.int(item_count), C.int(group_count), C.double(group_size), C.double(shift), C.ImPlotBarGroupsFlags(flags))

	label_idsFin()
}

// PlotPlotBarGroupsS16PtrV parameter default value hint:
// group_size: 0.67
// shift: 0
// flags: 0
func PlotPlotBarGroupsS16PtrV(label_ids []string, values *[]int, item_count int32, group_count int32, group_size float64, shift float64, flags PlotBarGroupsFlags) {
	label_idsArg, label_idsFin := WrapStringList(label_ids)
	valuesArg := make([]C.ImS16, len(*values))
	for i, valuesV := range *values {
		valuesArg[i] = C.ImS16(valuesV)
	}

	C.ImPlot_PlotBarGroups_S16Ptr(label_idsArg, (*C.ImS16)(&valuesArg[0]), C.int(item_count), C.int(group_count), C.double(group_size), C.double(shift), C.ImPlotBarGroupsFlags(flags))

	label_idsFin()

	for i, valuesV := range valuesArg {
		(*values)[i] = int(valuesV)
	}
}

// PlotPlotBarGroupsS32PtrV parameter default value hint:
// group_size: 0.67
// shift: 0
// flags: 0
func PlotPlotBarGroupsS32PtrV(label_ids []string, values *[]int32, item_count int32, group_count int32, group_size float64, shift float64, flags PlotBarGroupsFlags) {
	label_idsArg, label_idsFin := WrapStringList(label_ids)
	valuesArg := make([]C.ImS32, len(*values))
	for i, valuesV := range *values {
		valuesArg[i] = C.ImS32(valuesV)
	}

	C.ImPlot_PlotBarGroups_S32Ptr(label_idsArg, (*C.ImS32)(&valuesArg[0]), C.int(item_count), C.int(group_count), C.double(group_size), C.double(shift), C.ImPlotBarGroupsFlags(flags))

	label_idsFin()

	for i, valuesV := range valuesArg {
		(*values)[i] = int32(valuesV)
	}
}

// PlotPlotBarGroupsS64PtrV parameter default value hint:
// group_size: 0.67
// shift: 0
// flags: 0
func PlotPlotBarGroupsS64PtrV(label_ids []string, values []int64, item_count int32, group_count int32, group_size float64, shift float64, flags PlotBarGroupsFlags) {
	label_idsArg, label_idsFin := WrapStringList(label_ids)
	C.ImPlot_PlotBarGroups_S64Ptr(label_idsArg, (*C.longlong)(&(values[0])), C.int(item_count), C.int(group_count), C.double(group_size), C.double(shift), C.ImPlotBarGroupsFlags(flags))

	label_idsFin()
}

// PlotPlotBarGroupsS8PtrV parameter default value hint:
// group_size: 0.67
// shift: 0
// flags: 0
func PlotPlotBarGroupsS8PtrV(label_ids []string, values *[]int8, item_count int32, group_count int32, group_size float64, shift float64, flags PlotBarGroupsFlags) {
	label_idsArg, label_idsFin := WrapStringList(label_ids)
	valuesArg := make([]C.ImS8, len(*values))
	for i, valuesV := range *values {
		valuesArg[i] = C.ImS8(valuesV)
	}

	C.ImPlot_PlotBarGroups_S8Ptr(label_idsArg, (*C.ImS8)(&valuesArg[0]), C.int(item_count), C.int(group_count), C.double(group_size), C.double(shift), C.ImPlotBarGroupsFlags(flags))

	label_idsFin()

	for i, valuesV := range valuesArg {
		(*values)[i] = int8(valuesV)
	}
}

// PlotPlotBarGroupsU16PtrV parameter default value hint:
// group_size: 0.67
// shift: 0
// flags: 0
func PlotPlotBarGroupsU16PtrV(label_ids []string, values *[]uint16, item_count int32, group_count int32, group_size float64, shift float64, flags PlotBarGroupsFlags) {
	label_idsArg, label_idsFin := WrapStringList(label_ids)
	valuesArg := make([]C.ImU16, len(*values))
	for i, valuesV := range *values {
		valuesArg[i] = C.ImU16(valuesV)
	}

	C.ImPlot_PlotBarGroups_U16Ptr(label_idsArg, (*C.ImU16)(&valuesArg[0]), C.int(item_count), C.int(group_count), C.double(group_size), C.double(shift), C.ImPlotBarGroupsFlags(flags))

	label_idsFin()

	for i, valuesV := range valuesArg {
		(*values)[i] = uint16(valuesV)
	}
}

// PlotPlotBarGroupsU32PtrV parameter default value hint:
// group_size: 0.67
// shift: 0
// flags: 0
func PlotPlotBarGroupsU32PtrV(label_ids []string, values *[]uint32, item_count int32, group_count int32, group_size float64, shift float64, flags PlotBarGroupsFlags) {
	label_idsArg, label_idsFin := WrapStringList(label_ids)
	valuesArg := make([]C.ImU32, len(*values))
	for i, valuesV := range *values {
		valuesArg[i] = C.ImU32(valuesV)
	}

	C.ImPlot_PlotBarGroups_U32Ptr(label_idsArg, (*C.ImU32)(&valuesArg[0]), C.int(item_count), C.int(group_count), C.double(group_size), C.double(shift), C.ImPlotBarGroupsFlags(flags))

	label_idsFin()

	for i, valuesV := range valuesArg {
		(*values)[i] = uint32(valuesV)
	}
}

// PlotPlotBarGroupsU64PtrV parameter default value hint:
// group_size: 0.67
// shift: 0
// flags: 0
func PlotPlotBarGroupsU64PtrV(label_ids []string, values []uint64, item_count int32, group_count int32, group_size float64, shift float64, flags PlotBarGroupsFlags) {
	label_idsArg, label_idsFin := WrapStringList(label_ids)
	C.ImPlot_PlotBarGroups_U64Ptr(label_idsArg, (*C.ulonglong)(&(values[0])), C.int(item_count), C.int(group_count), C.double(group_size), C.double(shift), C.ImPlotBarGroupsFlags(flags))

	label_idsFin()
}

// PlotPlotBarGroupsU8PtrV parameter default value hint:
// group_size: 0.67
// shift: 0
// flags: 0
func PlotPlotBarGroupsU8PtrV(label_ids []string, values *[]byte, item_count int32, group_count int32, group_size float64, shift float64, flags PlotBarGroupsFlags) {
	label_idsArg, label_idsFin := WrapStringList(label_ids)
	valuesArg := make([]C.ImU8, len(*values))
	for i, valuesV := range *values {
		valuesArg[i] = C.ImU8(valuesV)
	}

	C.ImPlot_PlotBarGroups_U8Ptr(label_idsArg, (*C.ImU8)(&valuesArg[0]), C.int(item_count), C.int(group_count), C.double(group_size), C.double(shift), C.ImPlotBarGroupsFlags(flags))

	label_idsFin()

	for i, valuesV := range valuesArg {
		(*values)[i] = byte(valuesV)
	}
}

// PlotPlotBarGroupsdoublePtrV parameter default value hint:
// group_size: 0.67
// shift: 0
// flags: 0
func PlotPlotBarGroupsdoublePtrV(label_ids []string, values *[]float64, item_count int32, group_count int32, group_size float64, shift float64, flags PlotBarGroupsFlags) {
	label_idsArg, label_idsFin := WrapStringList(label_ids)
	valuesArg := make([]C.double, len(*values))
	for i, valuesV := range *values {
		valuesArg[i] = C.double(valuesV)
	}

	C.ImPlot_PlotBarGroups_doublePtr(label_idsArg, (*C.double)(&valuesArg[0]), C.int(item_count), C.int(group_count), C.double(group_size), C.double(shift), C.ImPlotBarGroupsFlags(flags))

	label_idsFin()

	for i, valuesV := range valuesArg {
		(*values)[i] = float64(valuesV)
	}
}

// PlotPlotBarsFloatPtrFloatPtrV parameter default value hint:
// flags: 0
// offset: 0
// stride: sizeof(float)
func PlotPlotBarsFloatPtrFloatPtrV(label_id string, xs []float32, ys []float32, count int32, bar_size float64, flags PlotBarsFlags, offset int32, stride int32) {
	label_idArg, label_idFin := WrapString(label_id)
	C.ImPlot_PlotBars_FloatPtrFloatPtr(label_idArg, (*C.float)(&(xs[0])), (*C.float)(&(ys[0])), C.int(count), C.double(bar_size), C.ImPlotBarsFlags(flags), C.int(offset), C.int(stride))

	label_idFin()
}

// PlotPlotBarsFloatPtrIntV parameter default value hint:
// bar_size: 0.67
// shift: 0
// flags: 0
// offset: 0
// stride: sizeof(float)
func PlotPlotBarsFloatPtrIntV(label_id string, values []float32, count int32, bar_size float64, shift float64, flags PlotBarsFlags, offset int32, stride int32) {
	label_idArg, label_idFin := WrapString(label_id)
	C.ImPlot_PlotBars_FloatPtrInt(label_idArg, (*C.float)(&(values[0])), C.int(count), C.double(bar_size), C.double(shift), C.ImPlotBarsFlags(flags), C.int(offset), C.int(stride))

	label_idFin()
}

// PlotPlotBarsS16PtrIntV parameter default value hint:
// bar_size: 0.67
// shift: 0
// flags: 0
// offset: 0
// stride: sizeof(ImS16)
func PlotPlotBarsS16PtrIntV(label_id string, values *[]int, count int32, bar_size float64, shift float64, flags PlotBarsFlags, offset int32, stride int32) {
	label_idArg, label_idFin := WrapString(label_id)
	valuesArg := make([]C.ImS16, len(*values))
	for i, valuesV := range *values {
		valuesArg[i] = C.ImS16(valuesV)
	}

	C.ImPlot_PlotBars_S16PtrInt(label_idArg, (*C.ImS16)(&valuesArg[0]), C.int(count), C.double(bar_size), C.double(shift), C.ImPlotBarsFlags(flags), C.int(offset), C.int(stride))

	label_idFin()

	for i, valuesV := range valuesArg {
		(*values)[i] = int(valuesV)
	}
}

// PlotPlotBarsS16PtrS16PtrV parameter default value hint:
// flags: 0
// offset: 0
// stride: sizeof(ImS16)
func PlotPlotBarsS16PtrS16PtrV(label_id string, xs *[]int, ys *[]int, count int32, bar_size float64, flags PlotBarsFlags, offset int32, stride int32) {
	label_idArg, label_idFin := WrapString(label_id)
	xsArg := make([]C.ImS16, len(*xs))
	for i, xsV := range *xs {
		xsArg[i] = C.ImS16(xsV)
	}

	ysArg := make([]C.ImS16, len(*ys))
	for i, ysV := range *ys {
		ysArg[i] = C.ImS16(ysV)
	}

	C.ImPlot_PlotBars_S16PtrS16Ptr(label_idArg, (*C.ImS16)(&xsArg[0]), (*C.ImS16)(&ysArg[0]), C.int(count), C.double(bar_size), C.ImPlotBarsFlags(flags), C.int(offset), C.int(stride))

	label_idFin()

	for i, xsV := range xsArg {
		(*xs)[i] = int(xsV)
	}

	for i, ysV := range ysArg {
		(*ys)[i] = int(ysV)
	}
}

// PlotPlotBarsS32PtrIntV parameter default value hint:
// bar_size: 0.67
// shift: 0
// flags: 0
// offset: 0
// stride: sizeof(ImS32)
func PlotPlotBarsS32PtrIntV(label_id string, values *[]int32, count int32, bar_size float64, shift float64, flags PlotBarsFlags, offset int32, stride int32) {
	label_idArg, label_idFin := WrapString(label_id)
	valuesArg := make([]C.ImS32, len(*values))
	for i, valuesV := range *values {
		valuesArg[i] = C.ImS32(valuesV)
	}

	C.ImPlot_PlotBars_S32PtrInt(label_idArg, (*C.ImS32)(&valuesArg[0]), C.int(count), C.double(bar_size), C.double(shift), C.ImPlotBarsFlags(flags), C.int(offset), C.int(stride))

	label_idFin()

	for i, valuesV := range valuesArg {
		(*values)[i] = int32(valuesV)
	}
}

// PlotPlotBarsS32PtrS32PtrV parameter default value hint:
// flags: 0
// offset: 0
// stride: sizeof(ImS32)
func PlotPlotBarsS32PtrS32PtrV(label_id string, xs *[]int32, ys *[]int32, count int32, bar_size float64, flags PlotBarsFlags, offset int32, stride int32) {
	label_idArg, label_idFin := WrapString(label_id)
	xsArg := make([]C.ImS32, len(*xs))
	for i, xsV := range *xs {
		xsArg[i] = C.ImS32(xsV)
	}

	ysArg := make([]C.ImS32, len(*ys))
	for i, ysV := range *ys {
		ysArg[i] = C.ImS32(ysV)
	}

	C.ImPlot_PlotBars_S32PtrS32Ptr(label_idArg, (*C.ImS32)(&xsArg[0]), (*C.ImS32)(&ysArg[0]), C.int(count), C.double(bar_size), C.ImPlotBarsFlags(flags), C.int(offset), C.int(stride))

	label_idFin()

	for i, xsV := range xsArg {
		(*xs)[i] = int32(xsV)
	}

	for i, ysV := range ysArg {
		(*ys)[i] = int32(ysV)
	}
}

// PlotPlotBarsS64PtrIntV parameter default value hint:
// bar_size: 0.67
// shift: 0
// flags: 0
// offset: 0
// stride: sizeof(ImS64)
func PlotPlotBarsS64PtrIntV(label_id string, values []int64, count int32, bar_size float64, shift float64, flags PlotBarsFlags, offset int32, stride int32) {
	label_idArg, label_idFin := WrapString(label_id)
	C.ImPlot_PlotBars_S64PtrInt(label_idArg, (*C.longlong)(&(values[0])), C.int(count), C.double(bar_size), C.double(shift), C.ImPlotBarsFlags(flags), C.int(offset), C.int(stride))

	label_idFin()
}

// PlotPlotBarsS64PtrS64PtrV parameter default value hint:
// flags: 0
// offset: 0
// stride: sizeof(ImS64)
func PlotPlotBarsS64PtrS64PtrV(label_id string, xs []int64, ys []int64, count int32, bar_size float64, flags PlotBarsFlags, offset int32, stride int32) {
	label_idArg, label_idFin := WrapString(label_id)
	C.ImPlot_PlotBars_S64PtrS64Ptr(label_idArg, (*C.longlong)(&(xs[0])), (*C.longlong)(&(ys[0])), C.int(count), C.double(bar_size), C.ImPlotBarsFlags(flags), C.int(offset), C.int(stride))

	label_idFin()
}

// PlotPlotBarsS8PtrIntV parameter default value hint:
// bar_size: 0.67
// shift: 0
// flags: 0
// offset: 0
// stride: sizeof(ImS8)
func PlotPlotBarsS8PtrIntV(label_id string, values *[]int8, count int32, bar_size float64, shift float64, flags PlotBarsFlags, offset int32, stride int32) {
	label_idArg, label_idFin := WrapString(label_id)
	valuesArg := make([]C.ImS8, len(*values))
	for i, valuesV := range *values {
		valuesArg[i] = C.ImS8(valuesV)
	}

	C.ImPlot_PlotBars_S8PtrInt(label_idArg, (*C.ImS8)(&valuesArg[0]), C.int(count), C.double(bar_size), C.double(shift), C.ImPlotBarsFlags(flags), C.int(offset), C.int(stride))

	label_idFin()

	for i, valuesV := range valuesArg {
		(*values)[i] = int8(valuesV)
	}
}

// PlotPlotBarsS8PtrS8PtrV parameter default value hint:
// flags: 0
// offset: 0
// stride: sizeof(ImS8)
func PlotPlotBarsS8PtrS8PtrV(label_id string, xs *[]int8, ys *[]int8, count int32, bar_size float64, flags PlotBarsFlags, offset int32, stride int32) {
	label_idArg, label_idFin := WrapString(label_id)
	xsArg := make([]C.ImS8, len(*xs))
	for i, xsV := range *xs {
		xsArg[i] = C.ImS8(xsV)
	}

	ysArg := make([]C.ImS8, len(*ys))
	for i, ysV := range *ys {
		ysArg[i] = C.ImS8(ysV)
	}

	C.ImPlot_PlotBars_S8PtrS8Ptr(label_idArg, (*C.ImS8)(&xsArg[0]), (*C.ImS8)(&ysArg[0]), C.int(count), C.double(bar_size), C.ImPlotBarsFlags(flags), C.int(offset), C.int(stride))

	label_idFin()

	for i, xsV := range xsArg {
		(*xs)[i] = int8(xsV)
	}

	for i, ysV := range ysArg {
		(*ys)[i] = int8(ysV)
	}
}

// PlotPlotBarsU16PtrIntV parameter default value hint:
// bar_size: 0.67
// shift: 0
// flags: 0
// offset: 0
// stride: sizeof(ImU16)
func PlotPlotBarsU16PtrIntV(label_id string, values *[]uint16, count int32, bar_size float64, shift float64, flags PlotBarsFlags, offset int32, stride int32) {
	label_idArg, label_idFin := WrapString(label_id)
	valuesArg := make([]C.ImU16, len(*values))
	for i, valuesV := range *values {
		valuesArg[i] = C.ImU16(valuesV)
	}

	C.ImPlot_PlotBars_U16PtrInt(label_idArg, (*C.ImU16)(&valuesArg[0]), C.int(count), C.double(bar_size), C.double(shift), C.ImPlotBarsFlags(flags), C.int(offset), C.int(stride))

	label_idFin()

	for i, valuesV := range valuesArg {
		(*values)[i] = uint16(valuesV)
	}
}

// PlotPlotBarsU16PtrU16PtrV parameter default value hint:
// flags: 0
// offset: 0
// stride: sizeof(ImU16)
func PlotPlotBarsU16PtrU16PtrV(label_id string, xs *[]uint16, ys *[]uint16, count int32, bar_size float64, flags PlotBarsFlags, offset int32, stride int32) {
	label_idArg, label_idFin := WrapString(label_id)
	xsArg := make([]C.ImU16, len(*xs))
	for i, xsV := range *xs {
		xsArg[i] = C.ImU16(xsV)
	}

	ysArg := make([]C.ImU16, len(*ys))
	for i, ysV := range *ys {
		ysArg[i] = C.ImU16(ysV)
	}

	C.ImPlot_PlotBars_U16PtrU16Ptr(label_idArg, (*C.ImU16)(&xsArg[0]), (*C.ImU16)(&ysArg[0]), C.int(count), C.double(bar_size), C.ImPlotBarsFlags(flags), C.int(offset), C.int(stride))

	label_idFin()

	for i, xsV := range xsArg {
		(*xs)[i] = uint16(xsV)
	}

	for i, ysV := range ysArg {
		(*ys)[i] = uint16(ysV)
	}
}

// PlotPlotBarsU32PtrIntV parameter default value hint:
// bar_size: 0.67
// shift: 0
// flags: 0
// offset: 0
// stride: sizeof(ImU32)
func PlotPlotBarsU32PtrIntV(label_id string, values *[]uint32, count int32, bar_size float64, shift float64, flags PlotBarsFlags, offset int32, stride int32) {
	label_idArg, label_idFin := WrapString(label_id)
	valuesArg := make([]C.ImU32, len(*values))
	for i, valuesV := range *values {
		valuesArg[i] = C.ImU32(valuesV)
	}

	C.ImPlot_PlotBars_U32PtrInt(label_idArg, (*C.ImU32)(&valuesArg[0]), C.int(count), C.double(bar_size), C.double(shift), C.ImPlotBarsFlags(flags), C.int(offset), C.int(stride))

	label_idFin()

	for i, valuesV := range valuesArg {
		(*values)[i] = uint32(valuesV)
	}
}

// PlotPlotBarsU32PtrU32PtrV parameter default value hint:
// flags: 0
// offset: 0
// stride: sizeof(ImU32)
func PlotPlotBarsU32PtrU32PtrV(label_id string, xs *[]uint32, ys *[]uint32, count int32, bar_size float64, flags PlotBarsFlags, offset int32, stride int32) {
	label_idArg, label_idFin := WrapString(label_id)
	xsArg := make([]C.ImU32, len(*xs))
	for i, xsV := range *xs {
		xsArg[i] = C.ImU32(xsV)
	}

	ysArg := make([]C.ImU32, len(*ys))
	for i, ysV := range *ys {
		ysArg[i] = C.ImU32(ysV)
	}

	C.ImPlot_PlotBars_U32PtrU32Ptr(label_idArg, (*C.ImU32)(&xsArg[0]), (*C.ImU32)(&ysArg[0]), C.int(count), C.double(bar_size), C.ImPlotBarsFlags(flags), C.int(offset), C.int(stride))

	label_idFin()

	for i, xsV := range xsArg {
		(*xs)[i] = uint32(xsV)
	}

	for i, ysV := range ysArg {
		(*ys)[i] = uint32(ysV)
	}
}

// PlotPlotBarsU64PtrIntV parameter default value hint:
// bar_size: 0.67
// shift: 0
// flags: 0
// offset: 0
// stride: sizeof(ImU64)
func PlotPlotBarsU64PtrIntV(label_id string, values []uint64, count int32, bar_size float64, shift float64, flags PlotBarsFlags, offset int32, stride int32) {
	label_idArg, label_idFin := WrapString(label_id)
	C.ImPlot_PlotBars_U64PtrInt(label_idArg, (*C.ulonglong)(&(values[0])), C.int(count), C.double(bar_size), C.double(shift), C.ImPlotBarsFlags(flags), C.int(offset), C.int(stride))

	label_idFin()
}

// PlotPlotBarsU64PtrU64PtrV parameter default value hint:
// flags: 0
// offset: 0
// stride: sizeof(ImU64)
func PlotPlotBarsU64PtrU64PtrV(label_id string, xs []uint64, ys []uint64, count int32, bar_size float64, flags PlotBarsFlags, offset int32, stride int32) {
	label_idArg, label_idFin := WrapString(label_id)
	C.ImPlot_PlotBars_U64PtrU64Ptr(label_idArg, (*C.ulonglong)(&(xs[0])), (*C.ulonglong)(&(ys[0])), C.int(count), C.double(bar_size), C.ImPlotBarsFlags(flags), C.int(offset), C.int(stride))

	label_idFin()
}

// PlotPlotBarsU8PtrIntV parameter default value hint:
// bar_size: 0.67
// shift: 0
// flags: 0
// offset: 0
// stride: sizeof(ImU8)
func PlotPlotBarsU8PtrIntV(label_id string, values *[]byte, count int32, bar_size float64, shift float64, flags PlotBarsFlags, offset int32, stride int32) {
	label_idArg, label_idFin := WrapString(label_id)
	valuesArg := make([]C.ImU8, len(*values))
	for i, valuesV := range *values {
		valuesArg[i] = C.ImU8(valuesV)
	}

	C.ImPlot_PlotBars_U8PtrInt(label_idArg, (*C.ImU8)(&valuesArg[0]), C.int(count), C.double(bar_size), C.double(shift), C.ImPlotBarsFlags(flags), C.int(offset), C.int(stride))

	label_idFin()

	for i, valuesV := range valuesArg {
		(*values)[i] = byte(valuesV)
	}
}

// PlotPlotBarsU8PtrU8PtrV parameter default value hint:
// flags: 0
// offset: 0
// stride: sizeof(ImU8)
func PlotPlotBarsU8PtrU8PtrV(label_id string, xs *[]byte, ys *[]byte, count int32, bar_size float64, flags PlotBarsFlags, offset int32, stride int32) {
	label_idArg, label_idFin := WrapString(label_id)
	xsArg := make([]C.ImU8, len(*xs))
	for i, xsV := range *xs {
		xsArg[i] = C.ImU8(xsV)
	}

	ysArg := make([]C.ImU8, len(*ys))
	for i, ysV := range *ys {
		ysArg[i] = C.ImU8(ysV)
	}

	C.ImPlot_PlotBars_U8PtrU8Ptr(label_idArg, (*C.ImU8)(&xsArg[0]), (*C.ImU8)(&ysArg[0]), C.int(count), C.double(bar_size), C.ImPlotBarsFlags(flags), C.int(offset), C.int(stride))

	label_idFin()

	for i, xsV := range xsArg {
		(*xs)[i] = byte(xsV)
	}

	for i, ysV := range ysArg {
		(*ys)[i] = byte(ysV)
	}
}

// PlotPlotBarsdoublePtrIntV parameter default value hint:
// bar_size: 0.67
// shift: 0
// flags: 0
// offset: 0
// stride: sizeof(double)
func PlotPlotBarsdoublePtrIntV(label_id string, values *[]float64, count int32, bar_size float64, shift float64, flags PlotBarsFlags, offset int32, stride int32) {
	label_idArg, label_idFin := WrapString(label_id)
	valuesArg := make([]C.double, len(*values))
	for i, valuesV := range *values {
		valuesArg[i] = C.double(valuesV)
	}

	C.ImPlot_PlotBars_doublePtrInt(label_idArg, (*C.double)(&valuesArg[0]), C.int(count), C.double(bar_size), C.double(shift), C.ImPlotBarsFlags(flags), C.int(offset), C.int(stride))

	label_idFin()

	for i, valuesV := range valuesArg {
		(*values)[i] = float64(valuesV)
	}
}

// PlotPlotBarsdoublePtrdoublePtrV parameter default value hint:
// flags: 0
// offset: 0
// stride: sizeof(double)
func PlotPlotBarsdoublePtrdoublePtrV(label_id string, xs *[]float64, ys *[]float64, count int32, bar_size float64, flags PlotBarsFlags, offset int32, stride int32) {
	label_idArg, label_idFin := WrapString(label_id)
	xsArg := make([]C.double, len(*xs))
	for i, xsV := range *xs {
		xsArg[i] = C.double(xsV)
	}

	ysArg := make([]C.double, len(*ys))
	for i, ysV := range *ys {
		ysArg[i] = C.double(ysV)
	}

	C.ImPlot_PlotBars_doublePtrdoublePtr(label_idArg, (*C.double)(&xsArg[0]), (*C.double)(&ysArg[0]), C.int(count), C.double(bar_size), C.ImPlotBarsFlags(flags), C.int(offset), C.int(stride))

	label_idFin()

	for i, xsV := range xsArg {
		(*xs)[i] = float64(xsV)
	}

	for i, ysV := range ysArg {
		(*ys)[i] = float64(ysV)
	}
}

// PlotPlotDigitalFloatPtrV parameter default value hint:
// flags: 0
// offset: 0
// stride: sizeof(float)
func PlotPlotDigitalFloatPtrV(label_id string, xs []float32, ys []float32, count int32, flags PlotDigitalFlags, offset int32, stride int32) {
	label_idArg, label_idFin := WrapString(label_id)
	C.ImPlot_PlotDigital_FloatPtr(label_idArg, (*C.float)(&(xs[0])), (*C.float)(&(ys[0])), C.int(count), C.ImPlotDigitalFlags(flags), C.int(offset), C.int(stride))

	label_idFin()
}

// PlotPlotDigitalS16PtrV parameter default value hint:
// flags: 0
// offset: 0
// stride: sizeof(ImS16)
func PlotPlotDigitalS16PtrV(label_id string, xs *[]int, ys *[]int, count int32, flags PlotDigitalFlags, offset int32, stride int32) {
	label_idArg, label_idFin := WrapString(label_id)
	xsArg := make([]C.ImS16, len(*xs))
	for i, xsV := range *xs {
		xsArg[i] = C.ImS16(xsV)
	}

	ysArg := make([]C.ImS16, len(*ys))
	for i, ysV := range *ys {
		ysArg[i] = C.ImS16(ysV)
	}

	C.ImPlot_PlotDigital_S16Ptr(label_idArg, (*C.ImS16)(&xsArg[0]), (*C.ImS16)(&ysArg[0]), C.int(count), C.ImPlotDigitalFlags(flags), C.int(offset), C.int(stride))

	label_idFin()

	for i, xsV := range xsArg {
		(*xs)[i] = int(xsV)
	}

	for i, ysV := range ysArg {
		(*ys)[i] = int(ysV)
	}
}

// PlotPlotDigitalS32PtrV parameter default value hint:
// flags: 0
// offset: 0
// stride: sizeof(ImS32)
func PlotPlotDigitalS32PtrV(label_id string, xs *[]int32, ys *[]int32, count int32, flags PlotDigitalFlags, offset int32, stride int32) {
	label_idArg, label_idFin := WrapString(label_id)
	xsArg := make([]C.ImS32, len(*xs))
	for i, xsV := range *xs {
		xsArg[i] = C.ImS32(xsV)
	}

	ysArg := make([]C.ImS32, len(*ys))
	for i, ysV := range *ys {
		ysArg[i] = C.ImS32(ysV)
	}

	C.ImPlot_PlotDigital_S32Ptr(label_idArg, (*C.ImS32)(&xsArg[0]), (*C.ImS32)(&ysArg[0]), C.int(count), C.ImPlotDigitalFlags(flags), C.int(offset), C.int(stride))

	label_idFin()

	for i, xsV := range xsArg {
		(*xs)[i] = int32(xsV)
	}

	for i, ysV := range ysArg {
		(*ys)[i] = int32(ysV)
	}
}

// PlotPlotDigitalS64PtrV parameter default value hint:
// flags: 0
// offset: 0
// stride: sizeof(ImS64)
func PlotPlotDigitalS64PtrV(label_id string, xs []int64, ys []int64, count int32, flags PlotDigitalFlags, offset int32, stride int32) {
	label_idArg, label_idFin := WrapString(label_id)
	C.ImPlot_PlotDigital_S64Ptr(label_idArg, (*C.longlong)(&(xs[0])), (*C.longlong)(&(ys[0])), C.int(count), C.ImPlotDigitalFlags(flags), C.int(offset), C.int(stride))

	label_idFin()
}

// PlotPlotDigitalS8PtrV parameter default value hint:
// flags: 0
// offset: 0
// stride: sizeof(ImS8)
func PlotPlotDigitalS8PtrV(label_id string, xs *[]int8, ys *[]int8, count int32, flags PlotDigitalFlags, offset int32, stride int32) {
	label_idArg, label_idFin := WrapString(label_id)
	xsArg := make([]C.ImS8, len(*xs))
	for i, xsV := range *xs {
		xsArg[i] = C.ImS8(xsV)
	}

	ysArg := make([]C.ImS8, len(*ys))
	for i, ysV := range *ys {
		ysArg[i] = C.ImS8(ysV)
	}

	C.ImPlot_PlotDigital_S8Ptr(label_idArg, (*C.ImS8)(&xsArg[0]), (*C.ImS8)(&ysArg[0]), C.int(count), C.ImPlotDigitalFlags(flags), C.int(offset), C.int(stride))

	label_idFin()

	for i, xsV := range xsArg {
		(*xs)[i] = int8(xsV)
	}

	for i, ysV := range ysArg {
		(*ys)[i] = int8(ysV)
	}
}

// PlotPlotDigitalU16PtrV parameter default value hint:
// flags: 0
// offset: 0
// stride: sizeof(ImU16)
func PlotPlotDigitalU16PtrV(label_id string, xs *[]uint16, ys *[]uint16, count int32, flags PlotDigitalFlags, offset int32, stride int32) {
	label_idArg, label_idFin := WrapString(label_id)
	xsArg := make([]C.ImU16, len(*xs))
	for i, xsV := range *xs {
		xsArg[i] = C.ImU16(xsV)
	}

	ysArg := make([]C.ImU16, len(*ys))
	for i, ysV := range *ys {
		ysArg[i] = C.ImU16(ysV)
	}

	C.ImPlot_PlotDigital_U16Ptr(label_idArg, (*C.ImU16)(&xsArg[0]), (*C.ImU16)(&ysArg[0]), C.int(count), C.ImPlotDigitalFlags(flags), C.int(offset), C.int(stride))

	label_idFin()

	for i, xsV := range xsArg {
		(*xs)[i] = uint16(xsV)
	}

	for i, ysV := range ysArg {
		(*ys)[i] = uint16(ysV)
	}
}

// PlotPlotDigitalU32PtrV parameter default value hint:
// flags: 0
// offset: 0
// stride: sizeof(ImU32)
func PlotPlotDigitalU32PtrV(label_id string, xs *[]uint32, ys *[]uint32, count int32, flags PlotDigitalFlags, offset int32, stride int32) {
	label_idArg, label_idFin := WrapString(label_id)
	xsArg := make([]C.ImU32, len(*xs))
	for i, xsV := range *xs {
		xsArg[i] = C.ImU32(xsV)
	}

	ysArg := make([]C.ImU32, len(*ys))
	for i, ysV := range *ys {
		ysArg[i] = C.ImU32(ysV)
	}

	C.ImPlot_PlotDigital_U32Ptr(label_idArg, (*C.ImU32)(&xsArg[0]), (*C.ImU32)(&ysArg[0]), C.int(count), C.ImPlotDigitalFlags(flags), C.int(offset), C.int(stride))

	label_idFin()

	for i, xsV := range xsArg {
		(*xs)[i] = uint32(xsV)
	}

	for i, ysV := range ysArg {
		(*ys)[i] = uint32(ysV)
	}
}

// PlotPlotDigitalU64PtrV parameter default value hint:
// flags: 0
// offset: 0
// stride: sizeof(ImU64)
func PlotPlotDigitalU64PtrV(label_id string, xs []uint64, ys []uint64, count int32, flags PlotDigitalFlags, offset int32, stride int32) {
	label_idArg, label_idFin := WrapString(label_id)
	C.ImPlot_PlotDigital_U64Ptr(label_idArg, (*C.ulonglong)(&(xs[0])), (*C.ulonglong)(&(ys[0])), C.int(count), C.ImPlotDigitalFlags(flags), C.int(offset), C.int(stride))

	label_idFin()
}

// PlotPlotDigitalU8PtrV parameter default value hint:
// flags: 0
// offset: 0
// stride: sizeof(ImU8)
func PlotPlotDigitalU8PtrV(label_id string, xs *[]byte, ys *[]byte, count int32, flags PlotDigitalFlags, offset int32, stride int32) {
	label_idArg, label_idFin := WrapString(label_id)
	xsArg := make([]C.ImU8, len(*xs))
	for i, xsV := range *xs {
		xsArg[i] = C.ImU8(xsV)
	}

	ysArg := make([]C.ImU8, len(*ys))
	for i, ysV := range *ys {
		ysArg[i] = C.ImU8(ysV)
	}

	C.ImPlot_PlotDigital_U8Ptr(label_idArg, (*C.ImU8)(&xsArg[0]), (*C.ImU8)(&ysArg[0]), C.int(count), C.ImPlotDigitalFlags(flags), C.int(offset), C.int(stride))

	label_idFin()

	for i, xsV := range xsArg {
		(*xs)[i] = byte(xsV)
	}

	for i, ysV := range ysArg {
		(*ys)[i] = byte(ysV)
	}
}

// PlotPlotDigitaldoublePtrV parameter default value hint:
// flags: 0
// offset: 0
// stride: sizeof(double)
func PlotPlotDigitaldoublePtrV(label_id string, xs *[]float64, ys *[]float64, count int32, flags PlotDigitalFlags, offset int32, stride int32) {
	label_idArg, label_idFin := WrapString(label_id)
	xsArg := make([]C.double, len(*xs))
	for i, xsV := range *xs {
		xsArg[i] = C.double(xsV)
	}

	ysArg := make([]C.double, len(*ys))
	for i, ysV := range *ys {
		ysArg[i] = C.double(ysV)
	}

	C.ImPlot_PlotDigital_doublePtr(label_idArg, (*C.double)(&xsArg[0]), (*C.double)(&ysArg[0]), C.int(count), C.ImPlotDigitalFlags(flags), C.int(offset), C.int(stride))

	label_idFin()

	for i, xsV := range xsArg {
		(*xs)[i] = float64(xsV)
	}

	for i, ysV := range ysArg {
		(*ys)[i] = float64(ysV)
	}
}

// PlotPlotDummyV parameter default value hint:
// flags: 0
func PlotPlotDummyV(label_id string, flags PlotDummyFlags) {
	label_idArg, label_idFin := WrapString(label_id)
	C.ImPlot_PlotDummy(label_idArg, C.ImPlotDummyFlags(flags))

	label_idFin()
}

// PlotPlotErrorBarsFloatPtrFloatPtrFloatPtrFloatPtrV parameter default value hint:
// flags: 0
// offset: 0
// stride: sizeof(float)
func PlotPlotErrorBarsFloatPtrFloatPtrFloatPtrFloatPtrV(label_id string, xs []float32, ys []float32, neg []float32, pos []float32, count int32, flags PlotErrorBarsFlags, offset int32, stride int32) {
	label_idArg, label_idFin := WrapString(label_id)
	C.ImPlot_PlotErrorBars_FloatPtrFloatPtrFloatPtrFloatPtr(label_idArg, (*C.float)(&(xs[0])), (*C.float)(&(ys[0])), (*C.float)(&(neg[0])), (*C.float)(&(pos[0])), C.int(count), C.ImPlotErrorBarsFlags(flags), C.int(offset), C.int(stride))

	label_idFin()
}

// PlotPlotErrorBarsFloatPtrFloatPtrFloatPtrIntV parameter default value hint:
// flags: 0
// offset: 0
// stride: sizeof(float)
func PlotPlotErrorBarsFloatPtrFloatPtrFloatPtrIntV(label_id string, xs []float32, ys []float32, err []float32, count int32, flags PlotErrorBarsFlags, offset int32, stride int32) {
	label_idArg, label_idFin := WrapString(label_id)
	C.ImPlot_PlotErrorBars_FloatPtrFloatPtrFloatPtrInt(label_idArg, (*C.float)(&(xs[0])), (*C.float)(&(ys[0])), (*C.float)(&(err[0])), C.int(count), C.ImPlotErrorBarsFlags(flags), C.int(offset), C.int(stride))

	label_idFin()
}

// PlotPlotErrorBarsS16PtrS16PtrS16PtrIntV parameter default value hint:
// flags: 0
// offset: 0
// stride: sizeof(ImS16)
func PlotPlotErrorBarsS16PtrS16PtrS16PtrIntV(label_id string, xs *[]int, ys *[]int, err *[]int, count int32, flags PlotErrorBarsFlags, offset int32, stride int32) {
	label_idArg, label_idFin := WrapString(label_id)
	xsArg := make([]C.ImS16, len(*xs))
	for i, xsV := range *xs {
		xsArg[i] = C.ImS16(xsV)
	}

	ysArg := make([]C.ImS16, len(*ys))
	for i, ysV := range *ys {
		ysArg[i] = C.ImS16(ysV)
	}

	errArg := make([]C.ImS16, len(*err))
	for i, errV := range *err {
		errArg[i] = C.ImS16(errV)
	}

	C.ImPlot_PlotErrorBars_S16PtrS16PtrS16PtrInt(label_idArg, (*C.ImS16)(&xsArg[0]), (*C.ImS16)(&ysArg[0]), (*C.ImS16)(&errArg[0]), C.int(count), C.ImPlotErrorBarsFlags(flags), C.int(offset), C.int(stride))

	label_idFin()

	for i, xsV := range xsArg {
		(*xs)[i] = int(xsV)
	}

	for i, ysV := range ysArg {
		(*ys)[i] = int(ysV)
	}

	for i, errV := range errArg {
		(*err)[i] = int(errV)
	}
}

// PlotPlotErrorBarsS16PtrS16PtrS16PtrS16PtrV parameter default value hint:
// flags: 0
// offset: 0
// stride: sizeof(ImS16)
func PlotPlotErrorBarsS16PtrS16PtrS16PtrS16PtrV(label_id string, xs *[]int, ys *[]int, neg *[]int, pos *[]int, count int32, flags PlotErrorBarsFlags, offset int32, stride int32) {
	label_idArg, label_idFin := WrapString(label_id)
	xsArg := make([]C.ImS16, len(*xs))
	for i, xsV := range *xs {
		xsArg[i] = C.ImS16(xsV)
	}

	ysArg := make([]C.ImS16, len(*ys))
	for i, ysV := range *ys {
		ysArg[i] = C.ImS16(ysV)
	}

	negArg := make([]C.ImS16, len(*neg))
	for i, negV := range *neg {
		negArg[i] = C.ImS16(negV)
	}

	posArg := make([]C.ImS16, len(*pos))
	for i, posV := range *pos {
		posArg[i] = C.ImS16(posV)
	}

	C.ImPlot_PlotErrorBars_S16PtrS16PtrS16PtrS16Ptr(label_idArg, (*C.ImS16)(&xsArg[0]), (*C.ImS16)(&ysArg[0]), (*C.ImS16)(&negArg[0]), (*C.ImS16)(&posArg[0]), C.int(count), C.ImPlotErrorBarsFlags(flags), C.int(offset), C.int(stride))

	label_idFin()

	for i, xsV := range xsArg {
		(*xs)[i] = int(xsV)
	}

	for i, ysV := range ysArg {
		(*ys)[i] = int(ysV)
	}

	for i, negV := range negArg {
		(*neg)[i] = int(negV)
	}

	for i, posV := range posArg {
		(*pos)[i] = int(posV)
	}
}

// PlotPlotErrorBarsS32PtrS32PtrS32PtrIntV parameter default value hint:
// flags: 0
// offset: 0
// stride: sizeof(ImS32)
func PlotPlotErrorBarsS32PtrS32PtrS32PtrIntV(label_id string, xs *[]int32, ys *[]int32, err *[]int32, count int32, flags PlotErrorBarsFlags, offset int32, stride int32) {
	label_idArg, label_idFin := WrapString(label_id)
	xsArg := make([]C.ImS32, len(*xs))
	for i, xsV := range *xs {
		xsArg[i] = C.ImS32(xsV)
	}

	ysArg := make([]C.ImS32, len(*ys))
	for i, ysV := range *ys {
		ysArg[i] = C.ImS32(ysV)
	}

	errArg := make([]C.ImS32, len(*err))
	for i, errV := range *err {
		errArg[i] = C.ImS32(errV)
	}

	C.ImPlot_PlotErrorBars_S32PtrS32PtrS32PtrInt(label_idArg, (*C.ImS32)(&xsArg[0]), (*C.ImS32)(&ysArg[0]), (*C.ImS32)(&errArg[0]), C.int(count), C.ImPlotErrorBarsFlags(flags), C.int(offset), C.int(stride))

	label_idFin()

	for i, xsV := range xsArg {
		(*xs)[i] = int32(xsV)
	}

	for i, ysV := range ysArg {
		(*ys)[i] = int32(ysV)
	}

	for i, errV := range errArg {
		(*err)[i] = int32(errV)
	}
}

// PlotPlotErrorBarsS32PtrS32PtrS32PtrS32PtrV parameter default value hint:
// flags: 0
// offset: 0
// stride: sizeof(ImS32)
func PlotPlotErrorBarsS32PtrS32PtrS32PtrS32PtrV(label_id string, xs *[]int32, ys *[]int32, neg *[]int32, pos *[]int32, count int32, flags PlotErrorBarsFlags, offset int32, stride int32) {
	label_idArg, label_idFin := WrapString(label_id)
	xsArg := make([]C.ImS32, len(*xs))
	for i, xsV := range *xs {
		xsArg[i] = C.ImS32(xsV)
	}

	ysArg := make([]C.ImS32, len(*ys))
	for i, ysV := range *ys {
		ysArg[i] = C.ImS32(ysV)
	}

	negArg := make([]C.ImS32, len(*neg))
	for i, negV := range *neg {
		negArg[i] = C.ImS32(negV)
	}

	posArg := make([]C.ImS32, len(*pos))
	for i, posV := range *pos {
		posArg[i] = C.ImS32(posV)
	}

	C.ImPlot_PlotErrorBars_S32PtrS32PtrS32PtrS32Ptr(label_idArg, (*C.ImS32)(&xsArg[0]), (*C.ImS32)(&ysArg[0]), (*C.ImS32)(&negArg[0]), (*C.ImS32)(&posArg[0]), C.int(count), C.ImPlotErrorBarsFlags(flags), C.int(offset), C.int(stride))

	label_idFin()

	for i, xsV := range xsArg {
		(*xs)[i] = int32(xsV)
	}

	for i, ysV := range ysArg {
		(*ys)[i] = int32(ysV)
	}

	for i, negV := range negArg {
		(*neg)[i] = int32(negV)
	}

	for i, posV := range posArg {
		(*pos)[i] = int32(posV)
	}
}

// PlotPlotErrorBarsS64PtrS64PtrS64PtrIntV parameter default value hint:
// flags: 0
// offset: 0
// stride: sizeof(ImS64)
func PlotPlotErrorBarsS64PtrS64PtrS64PtrIntV(label_id string, xs []int64, ys []int64, err []int64, count int32, flags PlotErrorBarsFlags, offset int32, stride int32) {
	label_idArg, label_idFin := WrapString(label_id)
	C.ImPlot_PlotErrorBars_S64PtrS64PtrS64PtrInt(label_idArg, (*C.longlong)(&(xs[0])), (*C.longlong)(&(ys[0])), (*C.longlong)(&(err[0])), C.int(count), C.ImPlotErrorBarsFlags(flags), C.int(offset), C.int(stride))

	label_idFin()
}

// PlotPlotErrorBarsS64PtrS64PtrS64PtrS64PtrV parameter default value hint:
// flags: 0
// offset: 0
// stride: sizeof(ImS64)
func PlotPlotErrorBarsS64PtrS64PtrS64PtrS64PtrV(label_id string, xs []int64, ys []int64, neg []int64, pos []int64, count int32, flags PlotErrorBarsFlags, offset int32, stride int32) {
	label_idArg, label_idFin := WrapString(label_id)
	C.ImPlot_PlotErrorBars_S64PtrS64PtrS64PtrS64Ptr(label_idArg, (*C.longlong)(&(xs[0])), (*C.longlong)(&(ys[0])), (*C.longlong)(&(neg[0])), (*C.longlong)(&(pos[0])), C.int(count), C.ImPlotErrorBarsFlags(flags), C.int(offset), C.int(stride))

	label_idFin()
}

// PlotPlotErrorBarsS8PtrS8PtrS8PtrIntV parameter default value hint:
// flags: 0
// offset: 0
// stride: sizeof(ImS8)
func PlotPlotErrorBarsS8PtrS8PtrS8PtrIntV(label_id string, xs *[]int8, ys *[]int8, err *[]int8, count int32, flags PlotErrorBarsFlags, offset int32, stride int32) {
	label_idArg, label_idFin := WrapString(label_id)
	xsArg := make([]C.ImS8, len(*xs))
	for i, xsV := range *xs {
		xsArg[i] = C.ImS8(xsV)
	}

	ysArg := make([]C.ImS8, len(*ys))
	for i, ysV := range *ys {
		ysArg[i] = C.ImS8(ysV)
	}

	errArg := make([]C.ImS8, len(*err))
	for i, errV := range *err {
		errArg[i] = C.ImS8(errV)
	}

	C.ImPlot_PlotErrorBars_S8PtrS8PtrS8PtrInt(label_idArg, (*C.ImS8)(&xsArg[0]), (*C.ImS8)(&ysArg[0]), (*C.ImS8)(&errArg[0]), C.int(count), C.ImPlotErrorBarsFlags(flags), C.int(offset), C.int(stride))

	label_idFin()

	for i, xsV := range xsArg {
		(*xs)[i] = int8(xsV)
	}

	for i, ysV := range ysArg {
		(*ys)[i] = int8(ysV)
	}

	for i, errV := range errArg {
		(*err)[i] = int8(errV)
	}
}

// PlotPlotErrorBarsS8PtrS8PtrS8PtrS8PtrV parameter default value hint:
// flags: 0
// offset: 0
// stride: sizeof(ImS8)
func PlotPlotErrorBarsS8PtrS8PtrS8PtrS8PtrV(label_id string, xs *[]int8, ys *[]int8, neg *[]int8, pos *[]int8, count int32, flags PlotErrorBarsFlags, offset int32, stride int32) {
	label_idArg, label_idFin := WrapString(label_id)
	xsArg := make([]C.ImS8, len(*xs))
	for i, xsV := range *xs {
		xsArg[i] = C.ImS8(xsV)
	}

	ysArg := make([]C.ImS8, len(*ys))
	for i, ysV := range *ys {
		ysArg[i] = C.ImS8(ysV)
	}

	negArg := make([]C.ImS8, len(*neg))
	for i, negV := range *neg {
		negArg[i] = C.ImS8(negV)
	}

	posArg := make([]C.ImS8, len(*pos))
	for i, posV := range *pos {
		posArg[i] = C.ImS8(posV)
	}

	C.ImPlot_PlotErrorBars_S8PtrS8PtrS8PtrS8Ptr(label_idArg, (*C.ImS8)(&xsArg[0]), (*C.ImS8)(&ysArg[0]), (*C.ImS8)(&negArg[0]), (*C.ImS8)(&posArg[0]), C.int(count), C.ImPlotErrorBarsFlags(flags), C.int(offset), C.int(stride))

	label_idFin()

	for i, xsV := range xsArg {
		(*xs)[i] = int8(xsV)
	}

	for i, ysV := range ysArg {
		(*ys)[i] = int8(ysV)
	}

	for i, negV := range negArg {
		(*neg)[i] = int8(negV)
	}

	for i, posV := range posArg {
		(*pos)[i] = int8(posV)
	}
}

// PlotPlotErrorBarsU16PtrU16PtrU16PtrIntV parameter default value hint:
// flags: 0
// offset: 0
// stride: sizeof(ImU16)
func PlotPlotErrorBarsU16PtrU16PtrU16PtrIntV(label_id string, xs *[]uint16, ys *[]uint16, err *[]uint16, count int32, flags PlotErrorBarsFlags, offset int32, stride int32) {
	label_idArg, label_idFin := WrapString(label_id)
	xsArg := make([]C.ImU16, len(*xs))
	for i, xsV := range *xs {
		xsArg[i] = C.ImU16(xsV)
	}

	ysArg := make([]C.ImU16, len(*ys))
	for i, ysV := range *ys {
		ysArg[i] = C.ImU16(ysV)
	}

	errArg := make([]C.ImU16, len(*err))
	for i, errV := range *err {
		errArg[i] = C.ImU16(errV)
	}

	C.ImPlot_PlotErrorBars_U16PtrU16PtrU16PtrInt(label_idArg, (*C.ImU16)(&xsArg[0]), (*C.ImU16)(&ysArg[0]), (*C.ImU16)(&errArg[0]), C.int(count), C.ImPlotErrorBarsFlags(flags), C.int(offset), C.int(stride))

	label_idFin()

	for i, xsV := range xsArg {
		(*xs)[i] = uint16(xsV)
	}

	for i, ysV := range ysArg {
		(*ys)[i] = uint16(ysV)
	}

	for i, errV := range errArg {
		(*err)[i] = uint16(errV)
	}
}

// PlotPlotErrorBarsU16PtrU16PtrU16PtrU16PtrV parameter default value hint:
// flags: 0
// offset: 0
// stride: sizeof(ImU16)
func PlotPlotErrorBarsU16PtrU16PtrU16PtrU16PtrV(label_id string, xs *[]uint16, ys *[]uint16, neg *[]uint16, pos *[]uint16, count int32, flags PlotErrorBarsFlags, offset int32, stride int32) {
	label_idArg, label_idFin := WrapString(label_id)
	xsArg := make([]C.ImU16, len(*xs))
	for i, xsV := range *xs {
		xsArg[i] = C.ImU16(xsV)
	}

	ysArg := make([]C.ImU16, len(*ys))
	for i, ysV := range *ys {
		ysArg[i] = C.ImU16(ysV)
	}

	negArg := make([]C.ImU16, len(*neg))
	for i, negV := range *neg {
		negArg[i] = C.ImU16(negV)
	}

	posArg := make([]C.ImU16, len(*pos))
	for i, posV := range *pos {
		posArg[i] = C.ImU16(posV)
	}

	C.ImPlot_PlotErrorBars_U16PtrU16PtrU16PtrU16Ptr(label_idArg, (*C.ImU16)(&xsArg[0]), (*C.ImU16)(&ysArg[0]), (*C.ImU16)(&negArg[0]), (*C.ImU16)(&posArg[0]), C.int(count), C.ImPlotErrorBarsFlags(flags), C.int(offset), C.int(stride))

	label_idFin()

	for i, xsV := range xsArg {
		(*xs)[i] = uint16(xsV)
	}

	for i, ysV := range ysArg {
		(*ys)[i] = uint16(ysV)
	}

	for i, negV := range negArg {
		(*neg)[i] = uint16(negV)
	}

	for i, posV := range posArg {
		(*pos)[i] = uint16(posV)
	}
}

// PlotPlotErrorBarsU32PtrU32PtrU32PtrIntV parameter default value hint:
// flags: 0
// offset: 0
// stride: sizeof(ImU32)
func PlotPlotErrorBarsU32PtrU32PtrU32PtrIntV(label_id string, xs *[]uint32, ys *[]uint32, err *[]uint32, count int32, flags PlotErrorBarsFlags, offset int32, stride int32) {
	label_idArg, label_idFin := WrapString(label_id)
	xsArg := make([]C.ImU32, len(*xs))
	for i, xsV := range *xs {
		xsArg[i] = C.ImU32(xsV)
	}

	ysArg := make([]C.ImU32, len(*ys))
	for i, ysV := range *ys {
		ysArg[i] = C.ImU32(ysV)
	}

	errArg := make([]C.ImU32, len(*err))
	for i, errV := range *err {
		errArg[i] = C.ImU32(errV)
	}

	C.ImPlot_PlotErrorBars_U32PtrU32PtrU32PtrInt(label_idArg, (*C.ImU32)(&xsArg[0]), (*C.ImU32)(&ysArg[0]), (*C.ImU32)(&errArg[0]), C.int(count), C.ImPlotErrorBarsFlags(flags), C.int(offset), C.int(stride))

	label_idFin()

	for i, xsV := range xsArg {
		(*xs)[i] = uint32(xsV)
	}

	for i, ysV := range ysArg {
		(*ys)[i] = uint32(ysV)
	}

	for i, errV := range errArg {
		(*err)[i] = uint32(errV)
	}
}

// PlotPlotErrorBarsU32PtrU32PtrU32PtrU32PtrV parameter default value hint:
// flags: 0
// offset: 0
// stride: sizeof(ImU32)
func PlotPlotErrorBarsU32PtrU32PtrU32PtrU32PtrV(label_id string, xs *[]uint32, ys *[]uint32, neg *[]uint32, pos *[]uint32, count int32, flags PlotErrorBarsFlags, offset int32, stride int32) {
	label_idArg, label_idFin := WrapString(label_id)
	xsArg := make([]C.ImU32, len(*xs))
	for i, xsV := range *xs {
		xsArg[i] = C.ImU32(xsV)
	}

	ysArg := make([]C.ImU32, len(*ys))
	for i, ysV := range *ys {
		ysArg[i] = C.ImU32(ysV)
	}

	negArg := make([]C.ImU32, len(*neg))
	for i, negV := range *neg {
		negArg[i] = C.ImU32(negV)
	}

	posArg := make([]C.ImU32, len(*pos))
	for i, posV := range *pos {
		posArg[i] = C.ImU32(posV)
	}

	C.ImPlot_PlotErrorBars_U32PtrU32PtrU32PtrU32Ptr(label_idArg, (*C.ImU32)(&xsArg[0]), (*C.ImU32)(&ysArg[0]), (*C.ImU32)(&negArg[0]), (*C.ImU32)(&posArg[0]), C.int(count), C.ImPlotErrorBarsFlags(flags), C.int(offset), C.int(stride))

	label_idFin()

	for i, xsV := range xsArg {
		(*xs)[i] = uint32(xsV)
	}

	for i, ysV := range ysArg {
		(*ys)[i] = uint32(ysV)
	}

	for i, negV := range negArg {
		(*neg)[i] = uint32(negV)
	}

	for i, posV := range posArg {
		(*pos)[i] = uint32(posV)
	}
}

// PlotPlotErrorBarsU64PtrU64PtrU64PtrIntV parameter default value hint:
// flags: 0
// offset: 0
// stride: sizeof(ImU64)
func PlotPlotErrorBarsU64PtrU64PtrU64PtrIntV(label_id string, xs []uint64, ys []uint64, err []uint64, count int32, flags PlotErrorBarsFlags, offset int32, stride int32) {
	label_idArg, label_idFin := WrapString(label_id)
	C.ImPlot_PlotErrorBars_U64PtrU64PtrU64PtrInt(label_idArg, (*C.ulonglong)(&(xs[0])), (*C.ulonglong)(&(ys[0])), (*C.ulonglong)(&(err[0])), C.int(count), C.ImPlotErrorBarsFlags(flags), C.int(offset), C.int(stride))

	label_idFin()
}

// PlotPlotErrorBarsU64PtrU64PtrU64PtrU64PtrV parameter default value hint:
// flags: 0
// offset: 0
// stride: sizeof(ImU64)
func PlotPlotErrorBarsU64PtrU64PtrU64PtrU64PtrV(label_id string, xs []uint64, ys []uint64, neg []uint64, pos []uint64, count int32, flags PlotErrorBarsFlags, offset int32, stride int32) {
	label_idArg, label_idFin := WrapString(label_id)
	C.ImPlot_PlotErrorBars_U64PtrU64PtrU64PtrU64Ptr(label_idArg, (*C.ulonglong)(&(xs[0])), (*C.ulonglong)(&(ys[0])), (*C.ulonglong)(&(neg[0])), (*C.ulonglong)(&(pos[0])), C.int(count), C.ImPlotErrorBarsFlags(flags), C.int(offset), C.int(stride))

	label_idFin()
}

// PlotPlotErrorBarsU8PtrU8PtrU8PtrIntV parameter default value hint:
// flags: 0
// offset: 0
// stride: sizeof(ImU8)
func PlotPlotErrorBarsU8PtrU8PtrU8PtrIntV(label_id string, xs *[]byte, ys *[]byte, err *[]byte, count int32, flags PlotErrorBarsFlags, offset int32, stride int32) {
	label_idArg, label_idFin := WrapString(label_id)
	xsArg := make([]C.ImU8, len(*xs))
	for i, xsV := range *xs {
		xsArg[i] = C.ImU8(xsV)
	}

	ysArg := make([]C.ImU8, len(*ys))
	for i, ysV := range *ys {
		ysArg[i] = C.ImU8(ysV)
	}

	errArg := make([]C.ImU8, len(*err))
	for i, errV := range *err {
		errArg[i] = C.ImU8(errV)
	}

	C.ImPlot_PlotErrorBars_U8PtrU8PtrU8PtrInt(label_idArg, (*C.ImU8)(&xsArg[0]), (*C.ImU8)(&ysArg[0]), (*C.ImU8)(&errArg[0]), C.int(count), C.ImPlotErrorBarsFlags(flags), C.int(offset), C.int(stride))

	label_idFin()

	for i, xsV := range xsArg {
		(*xs)[i] = byte(xsV)
	}

	for i, ysV := range ysArg {
		(*ys)[i] = byte(ysV)
	}

	for i, errV := range errArg {
		(*err)[i] = byte(errV)
	}
}

// PlotPlotErrorBarsU8PtrU8PtrU8PtrU8PtrV parameter default value hint:
// flags: 0
// offset: 0
// stride: sizeof(ImU8)
func PlotPlotErrorBarsU8PtrU8PtrU8PtrU8PtrV(label_id string, xs *[]byte, ys *[]byte, neg *[]byte, pos *[]byte, count int32, flags PlotErrorBarsFlags, offset int32, stride int32) {
	label_idArg, label_idFin := WrapString(label_id)
	xsArg := make([]C.ImU8, len(*xs))
	for i, xsV := range *xs {
		xsArg[i] = C.ImU8(xsV)
	}

	ysArg := make([]C.ImU8, len(*ys))
	for i, ysV := range *ys {
		ysArg[i] = C.ImU8(ysV)
	}

	negArg := make([]C.ImU8, len(*neg))
	for i, negV := range *neg {
		negArg[i] = C.ImU8(negV)
	}

	posArg := make([]C.ImU8, len(*pos))
	for i, posV := range *pos {
		posArg[i] = C.ImU8(posV)
	}

	C.ImPlot_PlotErrorBars_U8PtrU8PtrU8PtrU8Ptr(label_idArg, (*C.ImU8)(&xsArg[0]), (*C.ImU8)(&ysArg[0]), (*C.ImU8)(&negArg[0]), (*C.ImU8)(&posArg[0]), C.int(count), C.ImPlotErrorBarsFlags(flags), C.int(offset), C.int(stride))

	label_idFin()

	for i, xsV := range xsArg {
		(*xs)[i] = byte(xsV)
	}

	for i, ysV := range ysArg {
		(*ys)[i] = byte(ysV)
	}

	for i, negV := range negArg {
		(*neg)[i] = byte(negV)
	}

	for i, posV := range posArg {
		(*pos)[i] = byte(posV)
	}
}

// PlotPlotErrorBarsdoublePtrdoublePtrdoublePtrIntV parameter default value hint:
// flags: 0
// offset: 0
// stride: sizeof(double)
func PlotPlotErrorBarsdoublePtrdoublePtrdoublePtrIntV(label_id string, xs *[]float64, ys *[]float64, err *[]float64, count int32, flags PlotErrorBarsFlags, offset int32, stride int32) {
	label_idArg, label_idFin := WrapString(label_id)
	xsArg := make([]C.double, len(*xs))
	for i, xsV := range *xs {
		xsArg[i] = C.double(xsV)
	}

	ysArg := make([]C.double, len(*ys))
	for i, ysV := range *ys {
		ysArg[i] = C.double(ysV)
	}

	errArg := make([]C.double, len(*err))
	for i, errV := range *err {
		errArg[i] = C.double(errV)
	}

	C.ImPlot_PlotErrorBars_doublePtrdoublePtrdoublePtrInt(label_idArg, (*C.double)(&xsArg[0]), (*C.double)(&ysArg[0]), (*C.double)(&errArg[0]), C.int(count), C.ImPlotErrorBarsFlags(flags), C.int(offset), C.int(stride))

	label_idFin()

	for i, xsV := range xsArg {
		(*xs)[i] = float64(xsV)
	}

	for i, ysV := range ysArg {
		(*ys)[i] = float64(ysV)
	}

	for i, errV := range errArg {
		(*err)[i] = float64(errV)
	}
}

// PlotPlotErrorBarsdoublePtrdoublePtrdoublePtrdoublePtrV parameter default value hint:
// flags: 0
// offset: 0
// stride: sizeof(double)
func PlotPlotErrorBarsdoublePtrdoublePtrdoublePtrdoublePtrV(label_id string, xs *[]float64, ys *[]float64, neg *[]float64, pos *[]float64, count int32, flags PlotErrorBarsFlags, offset int32, stride int32) {
	label_idArg, label_idFin := WrapString(label_id)
	xsArg := make([]C.double, len(*xs))
	for i, xsV := range *xs {
		xsArg[i] = C.double(xsV)
	}

	ysArg := make([]C.double, len(*ys))
	for i, ysV := range *ys {
		ysArg[i] = C.double(ysV)
	}

	negArg := make([]C.double, len(*neg))
	for i, negV := range *neg {
		negArg[i] = C.double(negV)
	}

	posArg := make([]C.double, len(*pos))
	for i, posV := range *pos {
		posArg[i] = C.double(posV)
	}

	C.ImPlot_PlotErrorBars_doublePtrdoublePtrdoublePtrdoublePtr(label_idArg, (*C.double)(&xsArg[0]), (*C.double)(&ysArg[0]), (*C.double)(&negArg[0]), (*C.double)(&posArg[0]), C.int(count), C.ImPlotErrorBarsFlags(flags), C.int(offset), C.int(stride))

	label_idFin()

	for i, xsV := range xsArg {
		(*xs)[i] = float64(xsV)
	}

	for i, ysV := range ysArg {
		(*ys)[i] = float64(ysV)
	}

	for i, negV := range negArg {
		(*neg)[i] = float64(negV)
	}

	for i, posV := range posArg {
		(*pos)[i] = float64(posV)
	}
}

// PlotPlotHeatmapFloatPtrV parameter default value hint:
// scale_min: 0
// scale_max: 0
// label_fmt: "%.1f"
// bounds_min: ImPlotPoint(0,0)
// bounds_max: ImPlotPoint(1,1)
// flags: 0
func PlotPlotHeatmapFloatPtrV(label_id string, values []float32, rows int32, cols int32, scale_min float64, scale_max float64, label_fmt string, bounds_min PlotPoint, bounds_max PlotPoint, flags PlotHeatmapFlags) {
	label_idArg, label_idFin := WrapString(label_id)
	label_fmtArg, label_fmtFin := WrapString(label_fmt)
	C.ImPlot_PlotHeatmap_FloatPtr(label_idArg, (*C.float)(&(values[0])), C.int(rows), C.int(cols), C.double(scale_min), C.double(scale_max), label_fmtArg, bounds_min.toC(), bounds_max.toC(), C.ImPlotHeatmapFlags(flags))

	label_idFin()
	label_fmtFin()
}

// PlotPlotHeatmapS16PtrV parameter default value hint:
// scale_min: 0
// scale_max: 0
// label_fmt: "%.1f"
// bounds_min: ImPlotPoint(0,0)
// bounds_max: ImPlotPoint(1,1)
// flags: 0
func PlotPlotHeatmapS16PtrV(label_id string, values *[]int, rows int32, cols int32, scale_min float64, scale_max float64, label_fmt string, bounds_min PlotPoint, bounds_max PlotPoint, flags PlotHeatmapFlags) {
	label_idArg, label_idFin := WrapString(label_id)
	valuesArg := make([]C.ImS16, len(*values))
	for i, valuesV := range *values {
		valuesArg[i] = C.ImS16(valuesV)
	}

	label_fmtArg, label_fmtFin := WrapString(label_fmt)
	C.ImPlot_PlotHeatmap_S16Ptr(label_idArg, (*C.ImS16)(&valuesArg[0]), C.int(rows), C.int(cols), C.double(scale_min), C.double(scale_max), label_fmtArg, bounds_min.toC(), bounds_max.toC(), C.ImPlotHeatmapFlags(flags))

	label_idFin()

	for i, valuesV := range valuesArg {
		(*values)[i] = int(valuesV)
	}

	label_fmtFin()
}

// PlotPlotHeatmapS32PtrV parameter default value hint:
// scale_min: 0
// scale_max: 0
// label_fmt: "%.1f"
// bounds_min: ImPlotPoint(0,0)
// bounds_max: ImPlotPoint(1,1)
// flags: 0
func PlotPlotHeatmapS32PtrV(label_id string, values *[]int32, rows int32, cols int32, scale_min float64, scale_max float64, label_fmt string, bounds_min PlotPoint, bounds_max PlotPoint, flags PlotHeatmapFlags) {
	label_idArg, label_idFin := WrapString(label_id)
	valuesArg := make([]C.ImS32, len(*values))
	for i, valuesV := range *values {
		valuesArg[i] = C.ImS32(valuesV)
	}

	label_fmtArg, label_fmtFin := WrapString(label_fmt)
	C.ImPlot_PlotHeatmap_S32Ptr(label_idArg, (*C.ImS32)(&valuesArg[0]), C.int(rows), C.int(cols), C.double(scale_min), C.double(scale_max), label_fmtArg, bounds_min.toC(), bounds_max.toC(), C.ImPlotHeatmapFlags(flags))

	label_idFin()

	for i, valuesV := range valuesArg {
		(*values)[i] = int32(valuesV)
	}

	label_fmtFin()
}

// PlotPlotHeatmapS64PtrV parameter default value hint:
// scale_min: 0
// scale_max: 0
// label_fmt: "%.1f"
// bounds_min: ImPlotPoint(0,0)
// bounds_max: ImPlotPoint(1,1)
// flags: 0
func PlotPlotHeatmapS64PtrV(label_id string, values []int64, rows int32, cols int32, scale_min float64, scale_max float64, label_fmt string, bounds_min PlotPoint, bounds_max PlotPoint, flags PlotHeatmapFlags) {
	label_idArg, label_idFin := WrapString(label_id)
	label_fmtArg, label_fmtFin := WrapString(label_fmt)
	C.ImPlot_PlotHeatmap_S64Ptr(label_idArg, (*C.longlong)(&(values[0])), C.int(rows), C.int(cols), C.double(scale_min), C.double(scale_max), label_fmtArg, bounds_min.toC(), bounds_max.toC(), C.ImPlotHeatmapFlags(flags))

	label_idFin()
	label_fmtFin()
}

// PlotPlotHeatmapS8PtrV parameter default value hint:
// scale_min: 0
// scale_max: 0
// label_fmt: "%.1f"
// bounds_min: ImPlotPoint(0,0)
// bounds_max: ImPlotPoint(1,1)
// flags: 0
func PlotPlotHeatmapS8PtrV(label_id string, values *[]int8, rows int32, cols int32, scale_min float64, scale_max float64, label_fmt string, bounds_min PlotPoint, bounds_max PlotPoint, flags PlotHeatmapFlags) {
	label_idArg, label_idFin := WrapString(label_id)
	valuesArg := make([]C.ImS8, len(*values))
	for i, valuesV := range *values {
		valuesArg[i] = C.ImS8(valuesV)
	}

	label_fmtArg, label_fmtFin := WrapString(label_fmt)
	C.ImPlot_PlotHeatmap_S8Ptr(label_idArg, (*C.ImS8)(&valuesArg[0]), C.int(rows), C.int(cols), C.double(scale_min), C.double(scale_max), label_fmtArg, bounds_min.toC(), bounds_max.toC(), C.ImPlotHeatmapFlags(flags))

	label_idFin()

	for i, valuesV := range valuesArg {
		(*values)[i] = int8(valuesV)
	}

	label_fmtFin()
}

// PlotPlotHeatmapU16PtrV parameter default value hint:
// scale_min: 0
// scale_max: 0
// label_fmt: "%.1f"
// bounds_min: ImPlotPoint(0,0)
// bounds_max: ImPlotPoint(1,1)
// flags: 0
func PlotPlotHeatmapU16PtrV(label_id string, values *[]uint16, rows int32, cols int32, scale_min float64, scale_max float64, label_fmt string, bounds_min PlotPoint, bounds_max PlotPoint, flags PlotHeatmapFlags) {
	label_idArg, label_idFin := WrapString(label_id)
	valuesArg := make([]C.ImU16, len(*values))
	for i, valuesV := range *values {
		valuesArg[i] = C.ImU16(valuesV)
	}

	label_fmtArg, label_fmtFin := WrapString(label_fmt)
	C.ImPlot_PlotHeatmap_U16Ptr(label_idArg, (*C.ImU16)(&valuesArg[0]), C.int(rows), C.int(cols), C.double(scale_min), C.double(scale_max), label_fmtArg, bounds_min.toC(), bounds_max.toC(), C.ImPlotHeatmapFlags(flags))

	label_idFin()

	for i, valuesV := range valuesArg {
		(*values)[i] = uint16(valuesV)
	}

	label_fmtFin()
}

// PlotPlotHeatmapU32PtrV parameter default value hint:
// scale_min: 0
// scale_max: 0
// label_fmt: "%.1f"
// bounds_min: ImPlotPoint(0,0)
// bounds_max: ImPlotPoint(1,1)
// flags: 0
func PlotPlotHeatmapU32PtrV(label_id string, values *[]uint32, rows int32, cols int32, scale_min float64, scale_max float64, label_fmt string, bounds_min PlotPoint, bounds_max PlotPoint, flags PlotHeatmapFlags) {
	label_idArg, label_idFin := WrapString(label_id)
	valuesArg := make([]C.ImU32, len(*values))
	for i, valuesV := range *values {
		valuesArg[i] = C.ImU32(valuesV)
	}

	label_fmtArg, label_fmtFin := WrapString(label_fmt)
	C.ImPlot_PlotHeatmap_U32Ptr(label_idArg, (*C.ImU32)(&valuesArg[0]), C.int(rows), C.int(cols), C.double(scale_min), C.double(scale_max), label_fmtArg, bounds_min.toC(), bounds_max.toC(), C.ImPlotHeatmapFlags(flags))

	label_idFin()

	for i, valuesV := range valuesArg {
		(*values)[i] = uint32(valuesV)
	}

	label_fmtFin()
}

// PlotPlotHeatmapU64PtrV parameter default value hint:
// scale_min: 0
// scale_max: 0
// label_fmt: "%.1f"
// bounds_min: ImPlotPoint(0,0)
// bounds_max: ImPlotPoint(1,1)
// flags: 0
func PlotPlotHeatmapU64PtrV(label_id string, values []uint64, rows int32, cols int32, scale_min float64, scale_max float64, label_fmt string, bounds_min PlotPoint, bounds_max PlotPoint, flags PlotHeatmapFlags) {
	label_idArg, label_idFin := WrapString(label_id)
	label_fmtArg, label_fmtFin := WrapString(label_fmt)
	C.ImPlot_PlotHeatmap_U64Ptr(label_idArg, (*C.ulonglong)(&(values[0])), C.int(rows), C.int(cols), C.double(scale_min), C.double(scale_max), label_fmtArg, bounds_min.toC(), bounds_max.toC(), C.ImPlotHeatmapFlags(flags))

	label_idFin()
	label_fmtFin()
}

// PlotPlotHeatmapU8PtrV parameter default value hint:
// scale_min: 0
// scale_max: 0
// label_fmt: "%.1f"
// bounds_min: ImPlotPoint(0,0)
// bounds_max: ImPlotPoint(1,1)
// flags: 0
func PlotPlotHeatmapU8PtrV(label_id string, values *[]byte, rows int32, cols int32, scale_min float64, scale_max float64, label_fmt string, bounds_min PlotPoint, bounds_max PlotPoint, flags PlotHeatmapFlags) {
	label_idArg, label_idFin := WrapString(label_id)
	valuesArg := make([]C.ImU8, len(*values))
	for i, valuesV := range *values {
		valuesArg[i] = C.ImU8(valuesV)
	}

	label_fmtArg, label_fmtFin := WrapString(label_fmt)
	C.ImPlot_PlotHeatmap_U8Ptr(label_idArg, (*C.ImU8)(&valuesArg[0]), C.int(rows), C.int(cols), C.double(scale_min), C.double(scale_max), label_fmtArg, bounds_min.toC(), bounds_max.toC(), C.ImPlotHeatmapFlags(flags))

	label_idFin()

	for i, valuesV := range valuesArg {
		(*values)[i] = byte(valuesV)
	}

	label_fmtFin()
}

// PlotPlotHeatmapdoublePtrV parameter default value hint:
// scale_min: 0
// scale_max: 0
// label_fmt: "%.1f"
// bounds_min: ImPlotPoint(0,0)
// bounds_max: ImPlotPoint(1,1)
// flags: 0
func PlotPlotHeatmapdoublePtrV(label_id string, values *[]float64, rows int32, cols int32, scale_min float64, scale_max float64, label_fmt string, bounds_min PlotPoint, bounds_max PlotPoint, flags PlotHeatmapFlags) {
	label_idArg, label_idFin := WrapString(label_id)
	valuesArg := make([]C.double, len(*values))
	for i, valuesV := range *values {
		valuesArg[i] = C.double(valuesV)
	}

	label_fmtArg, label_fmtFin := WrapString(label_fmt)
	C.ImPlot_PlotHeatmap_doublePtr(label_idArg, (*C.double)(&valuesArg[0]), C.int(rows), C.int(cols), C.double(scale_min), C.double(scale_max), label_fmtArg, bounds_min.toC(), bounds_max.toC(), C.ImPlotHeatmapFlags(flags))

	label_idFin()

	for i, valuesV := range valuesArg {
		(*values)[i] = float64(valuesV)
	}

	label_fmtFin()
}

// PlotPlotHistogram2DFloatPtrV parameter default value hint:
// x_bins: ImPlotBin_Sturges
// y_bins: ImPlotBin_Sturges
// flags: 0
func PlotPlotHistogram2DFloatPtrV(label_id string, xs []float32, ys []float32, count int32, x_bins int32, y_bins int32, rangeArg PlotRect, flags PlotHistogramFlags) float64 {
	label_idArg, label_idFin := WrapString(label_id)
	rangeArgArg, rangeArgFin := rangeArg.c()

	defer func() {
		label_idFin()
		rangeArgFin()
	}()
	return float64(C.ImPlot_PlotHistogram2D_FloatPtr(label_idArg, (*C.float)(&(xs[0])), (*C.float)(&(ys[0])), C.int(count), C.int(x_bins), C.int(y_bins), rangeArgArg, C.ImPlotHistogramFlags(flags)))
}

// PlotPlotHistogram2DS16PtrV parameter default value hint:
// x_bins: ImPlotBin_Sturges
// y_bins: ImPlotBin_Sturges
// flags: 0
func PlotPlotHistogram2DS16PtrV(label_id string, xs *[]int, ys *[]int, count int32, x_bins int32, y_bins int32, rangeArg PlotRect, flags PlotHistogramFlags) float64 {
	label_idArg, label_idFin := WrapString(label_id)
	xsArg := make([]C.ImS16, len(*xs))
	for i, xsV := range *xs {
		xsArg[i] = C.ImS16(xsV)
	}

	ysArg := make([]C.ImS16, len(*ys))
	for i, ysV := range *ys {
		ysArg[i] = C.ImS16(ysV)
	}

	rangeArgArg, rangeArgFin := rangeArg.c()

	defer func() {
		label_idFin()

		for i, xsV := range xsArg {
			(*xs)[i] = int(xsV)
		}

		for i, ysV := range ysArg {
			(*ys)[i] = int(ysV)
		}

		rangeArgFin()
	}()
	return float64(C.ImPlot_PlotHistogram2D_S16Ptr(label_idArg, (*C.ImS16)(&xsArg[0]), (*C.ImS16)(&ysArg[0]), C.int(count), C.int(x_bins), C.int(y_bins), rangeArgArg, C.ImPlotHistogramFlags(flags)))
}

// PlotPlotHistogram2DS32PtrV parameter default value hint:
// x_bins: ImPlotBin_Sturges
// y_bins: ImPlotBin_Sturges
// flags: 0
func PlotPlotHistogram2DS32PtrV(label_id string, xs *[]int32, ys *[]int32, count int32, x_bins int32, y_bins int32, rangeArg PlotRect, flags PlotHistogramFlags) float64 {
	label_idArg, label_idFin := WrapString(label_id)
	xsArg := make([]C.ImS32, len(*xs))
	for i, xsV := range *xs {
		xsArg[i] = C.ImS32(xsV)
	}

	ysArg := make([]C.ImS32, len(*ys))
	for i, ysV := range *ys {
		ysArg[i] = C.ImS32(ysV)
	}

	rangeArgArg, rangeArgFin := rangeArg.c()

	defer func() {
		label_idFin()

		for i, xsV := range xsArg {
			(*xs)[i] = int32(xsV)
		}

		for i, ysV := range ysArg {
			(*ys)[i] = int32(ysV)
		}

		rangeArgFin()
	}()
	return float64(C.ImPlot_PlotHistogram2D_S32Ptr(label_idArg, (*C.ImS32)(&xsArg[0]), (*C.ImS32)(&ysArg[0]), C.int(count), C.int(x_bins), C.int(y_bins), rangeArgArg, C.ImPlotHistogramFlags(flags)))
}

// PlotPlotHistogram2DS64PtrV parameter default value hint:
// x_bins: ImPlotBin_Sturges
// y_bins: ImPlotBin_Sturges
// flags: 0
func PlotPlotHistogram2DS64PtrV(label_id string, xs []int64, ys []int64, count int32, x_bins int32, y_bins int32, rangeArg PlotRect, flags PlotHistogramFlags) float64 {
	label_idArg, label_idFin := WrapString(label_id)
	rangeArgArg, rangeArgFin := rangeArg.c()

	defer func() {
		label_idFin()
		rangeArgFin()
	}()
	return float64(C.ImPlot_PlotHistogram2D_S64Ptr(label_idArg, (*C.longlong)(&(xs[0])), (*C.longlong)(&(ys[0])), C.int(count), C.int(x_bins), C.int(y_bins), rangeArgArg, C.ImPlotHistogramFlags(flags)))
}

// PlotPlotHistogram2DS8PtrV parameter default value hint:
// x_bins: ImPlotBin_Sturges
// y_bins: ImPlotBin_Sturges
// flags: 0
func PlotPlotHistogram2DS8PtrV(label_id string, xs *[]int8, ys *[]int8, count int32, x_bins int32, y_bins int32, rangeArg PlotRect, flags PlotHistogramFlags) float64 {
	label_idArg, label_idFin := WrapString(label_id)
	xsArg := make([]C.ImS8, len(*xs))
	for i, xsV := range *xs {
		xsArg[i] = C.ImS8(xsV)
	}

	ysArg := make([]C.ImS8, len(*ys))
	for i, ysV := range *ys {
		ysArg[i] = C.ImS8(ysV)
	}

	rangeArgArg, rangeArgFin := rangeArg.c()

	defer func() {
		label_idFin()

		for i, xsV := range xsArg {
			(*xs)[i] = int8(xsV)
		}

		for i, ysV := range ysArg {
			(*ys)[i] = int8(ysV)
		}

		rangeArgFin()
	}()
	return float64(C.ImPlot_PlotHistogram2D_S8Ptr(label_idArg, (*C.ImS8)(&xsArg[0]), (*C.ImS8)(&ysArg[0]), C.int(count), C.int(x_bins), C.int(y_bins), rangeArgArg, C.ImPlotHistogramFlags(flags)))
}

// PlotPlotHistogram2DU16PtrV parameter default value hint:
// x_bins: ImPlotBin_Sturges
// y_bins: ImPlotBin_Sturges
// flags: 0
func PlotPlotHistogram2DU16PtrV(label_id string, xs *[]uint16, ys *[]uint16, count int32, x_bins int32, y_bins int32, rangeArg PlotRect, flags PlotHistogramFlags) float64 {
	label_idArg, label_idFin := WrapString(label_id)
	xsArg := make([]C.ImU16, len(*xs))
	for i, xsV := range *xs {
		xsArg[i] = C.ImU16(xsV)
	}

	ysArg := make([]C.ImU16, len(*ys))
	for i, ysV := range *ys {
		ysArg[i] = C.ImU16(ysV)
	}

	rangeArgArg, rangeArgFin := rangeArg.c()

	defer func() {
		label_idFin()

		for i, xsV := range xsArg {
			(*xs)[i] = uint16(xsV)
		}

		for i, ysV := range ysArg {
			(*ys)[i] = uint16(ysV)
		}

		rangeArgFin()
	}()
	return float64(C.ImPlot_PlotHistogram2D_U16Ptr(label_idArg, (*C.ImU16)(&xsArg[0]), (*C.ImU16)(&ysArg[0]), C.int(count), C.int(x_bins), C.int(y_bins), rangeArgArg, C.ImPlotHistogramFlags(flags)))
}

// PlotPlotHistogram2DU32PtrV parameter default value hint:
// x_bins: ImPlotBin_Sturges
// y_bins: ImPlotBin_Sturges
// flags: 0
func PlotPlotHistogram2DU32PtrV(label_id string, xs *[]uint32, ys *[]uint32, count int32, x_bins int32, y_bins int32, rangeArg PlotRect, flags PlotHistogramFlags) float64 {
	label_idArg, label_idFin := WrapString(label_id)
	xsArg := make([]C.ImU32, len(*xs))
	for i, xsV := range *xs {
		xsArg[i] = C.ImU32(xsV)
	}

	ysArg := make([]C.ImU32, len(*ys))
	for i, ysV := range *ys {
		ysArg[i] = C.ImU32(ysV)
	}

	rangeArgArg, rangeArgFin := rangeArg.c()

	defer func() {
		label_idFin()

		for i, xsV := range xsArg {
			(*xs)[i] = uint32(xsV)
		}

		for i, ysV := range ysArg {
			(*ys)[i] = uint32(ysV)
		}

		rangeArgFin()
	}()
	return float64(C.ImPlot_PlotHistogram2D_U32Ptr(label_idArg, (*C.ImU32)(&xsArg[0]), (*C.ImU32)(&ysArg[0]), C.int(count), C.int(x_bins), C.int(y_bins), rangeArgArg, C.ImPlotHistogramFlags(flags)))
}

// PlotPlotHistogram2DU64PtrV parameter default value hint:
// x_bins: ImPlotBin_Sturges
// y_bins: ImPlotBin_Sturges
// flags: 0
func PlotPlotHistogram2DU64PtrV(label_id string, xs []uint64, ys []uint64, count int32, x_bins int32, y_bins int32, rangeArg PlotRect, flags PlotHistogramFlags) float64 {
	label_idArg, label_idFin := WrapString(label_id)
	rangeArgArg, rangeArgFin := rangeArg.c()

	defer func() {
		label_idFin()
		rangeArgFin()
	}()
	return float64(C.ImPlot_PlotHistogram2D_U64Ptr(label_idArg, (*C.ulonglong)(&(xs[0])), (*C.ulonglong)(&(ys[0])), C.int(count), C.int(x_bins), C.int(y_bins), rangeArgArg, C.ImPlotHistogramFlags(flags)))
}

// PlotPlotHistogram2DU8PtrV parameter default value hint:
// x_bins: ImPlotBin_Sturges
// y_bins: ImPlotBin_Sturges
// flags: 0
func PlotPlotHistogram2DU8PtrV(label_id string, xs *[]byte, ys *[]byte, count int32, x_bins int32, y_bins int32, rangeArg PlotRect, flags PlotHistogramFlags) float64 {
	label_idArg, label_idFin := WrapString(label_id)
	xsArg := make([]C.ImU8, len(*xs))
	for i, xsV := range *xs {
		xsArg[i] = C.ImU8(xsV)
	}

	ysArg := make([]C.ImU8, len(*ys))
	for i, ysV := range *ys {
		ysArg[i] = C.ImU8(ysV)
	}

	rangeArgArg, rangeArgFin := rangeArg.c()

	defer func() {
		label_idFin()

		for i, xsV := range xsArg {
			(*xs)[i] = byte(xsV)
		}

		for i, ysV := range ysArg {
			(*ys)[i] = byte(ysV)
		}

		rangeArgFin()
	}()
	return float64(C.ImPlot_PlotHistogram2D_U8Ptr(label_idArg, (*C.ImU8)(&xsArg[0]), (*C.ImU8)(&ysArg[0]), C.int(count), C.int(x_bins), C.int(y_bins), rangeArgArg, C.ImPlotHistogramFlags(flags)))
}

// PlotPlotHistogram2DdoublePtrV parameter default value hint:
// x_bins: ImPlotBin_Sturges
// y_bins: ImPlotBin_Sturges
// flags: 0
func PlotPlotHistogram2DdoublePtrV(label_id string, xs *[]float64, ys *[]float64, count int32, x_bins int32, y_bins int32, rangeArg PlotRect, flags PlotHistogramFlags) float64 {
	label_idArg, label_idFin := WrapString(label_id)
	xsArg := make([]C.double, len(*xs))
	for i, xsV := range *xs {
		xsArg[i] = C.double(xsV)
	}

	ysArg := make([]C.double, len(*ys))
	for i, ysV := range *ys {
		ysArg[i] = C.double(ysV)
	}

	rangeArgArg, rangeArgFin := rangeArg.c()

	defer func() {
		label_idFin()

		for i, xsV := range xsArg {
			(*xs)[i] = float64(xsV)
		}

		for i, ysV := range ysArg {
			(*ys)[i] = float64(ysV)
		}

		rangeArgFin()
	}()
	return float64(C.ImPlot_PlotHistogram2D_doublePtr(label_idArg, (*C.double)(&xsArg[0]), (*C.double)(&ysArg[0]), C.int(count), C.int(x_bins), C.int(y_bins), rangeArgArg, C.ImPlotHistogramFlags(flags)))
}

// PlotPlotHistogramFloatPtrV parameter default value hint:
// bins: ImPlotBin_Sturges
// bar_scale: 1.0
// flags: 0
func PlotPlotHistogramFloatPtrV(label_id string, values []float32, count int32, bins int32, bar_scale float64, rangeArg PlotRange, flags PlotHistogramFlags) float64 {
	label_idArg, label_idFin := WrapString(label_id)
	rangeArgArg, rangeArgFin := rangeArg.c()

	defer func() {
		label_idFin()
		rangeArgFin()
	}()
	return float64(C.ImPlot_PlotHistogram_FloatPtr(label_idArg, (*C.float)(&(values[0])), C.int(count), C.int(bins), C.double(bar_scale), rangeArgArg, C.ImPlotHistogramFlags(flags)))
}

// PlotPlotHistogramS16PtrV parameter default value hint:
// bins: ImPlotBin_Sturges
// bar_scale: 1.0
// flags: 0
func PlotPlotHistogramS16PtrV(label_id string, values *[]int, count int32, bins int32, bar_scale float64, rangeArg PlotRange, flags PlotHistogramFlags) float64 {
	label_idArg, label_idFin := WrapString(label_id)
	valuesArg := make([]C.ImS16, len(*values))
	for i, valuesV := range *values {
		valuesArg[i] = C.ImS16(valuesV)
	}

	rangeArgArg, rangeArgFin := rangeArg.c()

	defer func() {
		label_idFin()

		for i, valuesV := range valuesArg {
			(*values)[i] = int(valuesV)
		}

		rangeArgFin()
	}()
	return float64(C.ImPlot_PlotHistogram_S16Ptr(label_idArg, (*C.ImS16)(&valuesArg[0]), C.int(count), C.int(bins), C.double(bar_scale), rangeArgArg, C.ImPlotHistogramFlags(flags)))
}

// PlotPlotHistogramS32PtrV parameter default value hint:
// bins: ImPlotBin_Sturges
// bar_scale: 1.0
// flags: 0
func PlotPlotHistogramS32PtrV(label_id string, values *[]int32, count int32, bins int32, bar_scale float64, rangeArg PlotRange, flags PlotHistogramFlags) float64 {
	label_idArg, label_idFin := WrapString(label_id)
	valuesArg := make([]C.ImS32, len(*values))
	for i, valuesV := range *values {
		valuesArg[i] = C.ImS32(valuesV)
	}

	rangeArgArg, rangeArgFin := rangeArg.c()

	defer func() {
		label_idFin()

		for i, valuesV := range valuesArg {
			(*values)[i] = int32(valuesV)
		}

		rangeArgFin()
	}()
	return float64(C.ImPlot_PlotHistogram_S32Ptr(label_idArg, (*C.ImS32)(&valuesArg[0]), C.int(count), C.int(bins), C.double(bar_scale), rangeArgArg, C.ImPlotHistogramFlags(flags)))
}

// PlotPlotHistogramS64PtrV parameter default value hint:
// bins: ImPlotBin_Sturges
// bar_scale: 1.0
// flags: 0
func PlotPlotHistogramS64PtrV(label_id string, values []int64, count int32, bins int32, bar_scale float64, rangeArg PlotRange, flags PlotHistogramFlags) float64 {
	label_idArg, label_idFin := WrapString(label_id)
	rangeArgArg, rangeArgFin := rangeArg.c()

	defer func() {
		label_idFin()
		rangeArgFin()
	}()
	return float64(C.ImPlot_PlotHistogram_S64Ptr(label_idArg, (*C.longlong)(&(values[0])), C.int(count), C.int(bins), C.double(bar_scale), rangeArgArg, C.ImPlotHistogramFlags(flags)))
}

// PlotPlotHistogramS8PtrV parameter default value hint:
// bins: ImPlotBin_Sturges
// bar_scale: 1.0
// flags: 0
func PlotPlotHistogramS8PtrV(label_id string, values *[]int8, count int32, bins int32, bar_scale float64, rangeArg PlotRange, flags PlotHistogramFlags) float64 {
	label_idArg, label_idFin := WrapString(label_id)
	valuesArg := make([]C.ImS8, len(*values))
	for i, valuesV := range *values {
		valuesArg[i] = C.ImS8(valuesV)
	}

	rangeArgArg, rangeArgFin := rangeArg.c()

	defer func() {
		label_idFin()

		for i, valuesV := range valuesArg {
			(*values)[i] = int8(valuesV)
		}

		rangeArgFin()
	}()
	return float64(C.ImPlot_PlotHistogram_S8Ptr(label_idArg, (*C.ImS8)(&valuesArg[0]), C.int(count), C.int(bins), C.double(bar_scale), rangeArgArg, C.ImPlotHistogramFlags(flags)))
}

// PlotPlotHistogramU16PtrV parameter default value hint:
// bins: ImPlotBin_Sturges
// bar_scale: 1.0
// flags: 0
func PlotPlotHistogramU16PtrV(label_id string, values *[]uint16, count int32, bins int32, bar_scale float64, rangeArg PlotRange, flags PlotHistogramFlags) float64 {
	label_idArg, label_idFin := WrapString(label_id)
	valuesArg := make([]C.ImU16, len(*values))
	for i, valuesV := range *values {
		valuesArg[i] = C.ImU16(valuesV)
	}

	rangeArgArg, rangeArgFin := rangeArg.c()

	defer func() {
		label_idFin()

		for i, valuesV := range valuesArg {
			(*values)[i] = uint16(valuesV)
		}

		rangeArgFin()
	}()
	return float64(C.ImPlot_PlotHistogram_U16Ptr(label_idArg, (*C.ImU16)(&valuesArg[0]), C.int(count), C.int(bins), C.double(bar_scale), rangeArgArg, C.ImPlotHistogramFlags(flags)))
}

// PlotPlotHistogramU32PtrV parameter default value hint:
// bins: ImPlotBin_Sturges
// bar_scale: 1.0
// flags: 0
func PlotPlotHistogramU32PtrV(label_id string, values *[]uint32, count int32, bins int32, bar_scale float64, rangeArg PlotRange, flags PlotHistogramFlags) float64 {
	label_idArg, label_idFin := WrapString(label_id)
	valuesArg := make([]C.ImU32, len(*values))
	for i, valuesV := range *values {
		valuesArg[i] = C.ImU32(valuesV)
	}

	rangeArgArg, rangeArgFin := rangeArg.c()

	defer func() {
		label_idFin()

		for i, valuesV := range valuesArg {
			(*values)[i] = uint32(valuesV)
		}

		rangeArgFin()
	}()
	return float64(C.ImPlot_PlotHistogram_U32Ptr(label_idArg, (*C.ImU32)(&valuesArg[0]), C.int(count), C.int(bins), C.double(bar_scale), rangeArgArg, C.ImPlotHistogramFlags(flags)))
}

// PlotPlotHistogramU64PtrV parameter default value hint:
// bins: ImPlotBin_Sturges
// bar_scale: 1.0
// flags: 0
func PlotPlotHistogramU64PtrV(label_id string, values []uint64, count int32, bins int32, bar_scale float64, rangeArg PlotRange, flags PlotHistogramFlags) float64 {
	label_idArg, label_idFin := WrapString(label_id)
	rangeArgArg, rangeArgFin := rangeArg.c()

	defer func() {
		label_idFin()
		rangeArgFin()
	}()
	return float64(C.ImPlot_PlotHistogram_U64Ptr(label_idArg, (*C.ulonglong)(&(values[0])), C.int(count), C.int(bins), C.double(bar_scale), rangeArgArg, C.ImPlotHistogramFlags(flags)))
}

// PlotPlotHistogramU8PtrV parameter default value hint:
// bins: ImPlotBin_Sturges
// bar_scale: 1.0
// flags: 0
func PlotPlotHistogramU8PtrV(label_id string, values *[]byte, count int32, bins int32, bar_scale float64, rangeArg PlotRange, flags PlotHistogramFlags) float64 {
	label_idArg, label_idFin := WrapString(label_id)
	valuesArg := make([]C.ImU8, len(*values))
	for i, valuesV := range *values {
		valuesArg[i] = C.ImU8(valuesV)
	}

	rangeArgArg, rangeArgFin := rangeArg.c()

	defer func() {
		label_idFin()

		for i, valuesV := range valuesArg {
			(*values)[i] = byte(valuesV)
		}

		rangeArgFin()
	}()
	return float64(C.ImPlot_PlotHistogram_U8Ptr(label_idArg, (*C.ImU8)(&valuesArg[0]), C.int(count), C.int(bins), C.double(bar_scale), rangeArgArg, C.ImPlotHistogramFlags(flags)))
}

// PlotPlotHistogramdoublePtrV parameter default value hint:
// bins: ImPlotBin_Sturges
// bar_scale: 1.0
// flags: 0
func PlotPlotHistogramdoublePtrV(label_id string, values *[]float64, count int32, bins int32, bar_scale float64, rangeArg PlotRange, flags PlotHistogramFlags) float64 {
	label_idArg, label_idFin := WrapString(label_id)
	valuesArg := make([]C.double, len(*values))
	for i, valuesV := range *values {
		valuesArg[i] = C.double(valuesV)
	}

	rangeArgArg, rangeArgFin := rangeArg.c()

	defer func() {
		label_idFin()

		for i, valuesV := range valuesArg {
			(*values)[i] = float64(valuesV)
		}

		rangeArgFin()
	}()
	return float64(C.ImPlot_PlotHistogram_doublePtr(label_idArg, (*C.double)(&valuesArg[0]), C.int(count), C.int(bins), C.double(bar_scale), rangeArgArg, C.ImPlotHistogramFlags(flags)))
}

// PlotPlotInfLinesFloatPtrV parameter default value hint:
// flags: 0
// offset: 0
// stride: sizeof(float)
func PlotPlotInfLinesFloatPtrV(label_id string, values []float32, count int32, flags PlotInfLinesFlags, offset int32, stride int32) {
	label_idArg, label_idFin := WrapString(label_id)
	C.ImPlot_PlotInfLines_FloatPtr(label_idArg, (*C.float)(&(values[0])), C.int(count), C.ImPlotInfLinesFlags(flags), C.int(offset), C.int(stride))

	label_idFin()
}

// PlotPlotInfLinesS16PtrV parameter default value hint:
// flags: 0
// offset: 0
// stride: sizeof(ImS16)
func PlotPlotInfLinesS16PtrV(label_id string, values *[]int, count int32, flags PlotInfLinesFlags, offset int32, stride int32) {
	label_idArg, label_idFin := WrapString(label_id)
	valuesArg := make([]C.ImS16, len(*values))
	for i, valuesV := range *values {
		valuesArg[i] = C.ImS16(valuesV)
	}

	C.ImPlot_PlotInfLines_S16Ptr(label_idArg, (*C.ImS16)(&valuesArg[0]), C.int(count), C.ImPlotInfLinesFlags(flags), C.int(offset), C.int(stride))

	label_idFin()

	for i, valuesV := range valuesArg {
		(*values)[i] = int(valuesV)
	}
}

// PlotPlotInfLinesS32PtrV parameter default value hint:
// flags: 0
// offset: 0
// stride: sizeof(ImS32)
func PlotPlotInfLinesS32PtrV(label_id string, values *[]int32, count int32, flags PlotInfLinesFlags, offset int32, stride int32) {
	label_idArg, label_idFin := WrapString(label_id)
	valuesArg := make([]C.ImS32, len(*values))
	for i, valuesV := range *values {
		valuesArg[i] = C.ImS32(valuesV)
	}

	C.ImPlot_PlotInfLines_S32Ptr(label_idArg, (*C.ImS32)(&valuesArg[0]), C.int(count), C.ImPlotInfLinesFlags(flags), C.int(offset), C.int(stride))

	label_idFin()

	for i, valuesV := range valuesArg {
		(*values)[i] = int32(valuesV)
	}
}

// PlotPlotInfLinesS64PtrV parameter default value hint:
// flags: 0
// offset: 0
// stride: sizeof(ImS64)
func PlotPlotInfLinesS64PtrV(label_id string, values []int64, count int32, flags PlotInfLinesFlags, offset int32, stride int32) {
	label_idArg, label_idFin := WrapString(label_id)
	C.ImPlot_PlotInfLines_S64Ptr(label_idArg, (*C.longlong)(&(values[0])), C.int(count), C.ImPlotInfLinesFlags(flags), C.int(offset), C.int(stride))

	label_idFin()
}

// PlotPlotInfLinesS8PtrV parameter default value hint:
// flags: 0
// offset: 0
// stride: sizeof(ImS8)
func PlotPlotInfLinesS8PtrV(label_id string, values *[]int8, count int32, flags PlotInfLinesFlags, offset int32, stride int32) {
	label_idArg, label_idFin := WrapString(label_id)
	valuesArg := make([]C.ImS8, len(*values))
	for i, valuesV := range *values {
		valuesArg[i] = C.ImS8(valuesV)
	}

	C.ImPlot_PlotInfLines_S8Ptr(label_idArg, (*C.ImS8)(&valuesArg[0]), C.int(count), C.ImPlotInfLinesFlags(flags), C.int(offset), C.int(stride))

	label_idFin()

	for i, valuesV := range valuesArg {
		(*values)[i] = int8(valuesV)
	}
}

// PlotPlotInfLinesU16PtrV parameter default value hint:
// flags: 0
// offset: 0
// stride: sizeof(ImU16)
func PlotPlotInfLinesU16PtrV(label_id string, values *[]uint16, count int32, flags PlotInfLinesFlags, offset int32, stride int32) {
	label_idArg, label_idFin := WrapString(label_id)
	valuesArg := make([]C.ImU16, len(*values))
	for i, valuesV := range *values {
		valuesArg[i] = C.ImU16(valuesV)
	}

	C.ImPlot_PlotInfLines_U16Ptr(label_idArg, (*C.ImU16)(&valuesArg[0]), C.int(count), C.ImPlotInfLinesFlags(flags), C.int(offset), C.int(stride))

	label_idFin()

	for i, valuesV := range valuesArg {
		(*values)[i] = uint16(valuesV)
	}
}

// PlotPlotInfLinesU32PtrV parameter default value hint:
// flags: 0
// offset: 0
// stride: sizeof(ImU32)
func PlotPlotInfLinesU32PtrV(label_id string, values *[]uint32, count int32, flags PlotInfLinesFlags, offset int32, stride int32) {
	label_idArg, label_idFin := WrapString(label_id)
	valuesArg := make([]C.ImU32, len(*values))
	for i, valuesV := range *values {
		valuesArg[i] = C.ImU32(valuesV)
	}

	C.ImPlot_PlotInfLines_U32Ptr(label_idArg, (*C.ImU32)(&valuesArg[0]), C.int(count), C.ImPlotInfLinesFlags(flags), C.int(offset), C.int(stride))

	label_idFin()

	for i, valuesV := range valuesArg {
		(*values)[i] = uint32(valuesV)
	}
}

// PlotPlotInfLinesU64PtrV parameter default value hint:
// flags: 0
// offset: 0
// stride: sizeof(ImU64)
func PlotPlotInfLinesU64PtrV(label_id string, values []uint64, count int32, flags PlotInfLinesFlags, offset int32, stride int32) {
	label_idArg, label_idFin := WrapString(label_id)
	C.ImPlot_PlotInfLines_U64Ptr(label_idArg, (*C.ulonglong)(&(values[0])), C.int(count), C.ImPlotInfLinesFlags(flags), C.int(offset), C.int(stride))

	label_idFin()
}

// PlotPlotInfLinesU8PtrV parameter default value hint:
// flags: 0
// offset: 0
// stride: sizeof(ImU8)
func PlotPlotInfLinesU8PtrV(label_id string, values *[]byte, count int32, flags PlotInfLinesFlags, offset int32, stride int32) {
	label_idArg, label_idFin := WrapString(label_id)
	valuesArg := make([]C.ImU8, len(*values))
	for i, valuesV := range *values {
		valuesArg[i] = C.ImU8(valuesV)
	}

	C.ImPlot_PlotInfLines_U8Ptr(label_idArg, (*C.ImU8)(&valuesArg[0]), C.int(count), C.ImPlotInfLinesFlags(flags), C.int(offset), C.int(stride))

	label_idFin()

	for i, valuesV := range valuesArg {
		(*values)[i] = byte(valuesV)
	}
}

// PlotPlotInfLinesdoublePtrV parameter default value hint:
// flags: 0
// offset: 0
// stride: sizeof(double)
func PlotPlotInfLinesdoublePtrV(label_id string, values *[]float64, count int32, flags PlotInfLinesFlags, offset int32, stride int32) {
	label_idArg, label_idFin := WrapString(label_id)
	valuesArg := make([]C.double, len(*values))
	for i, valuesV := range *values {
		valuesArg[i] = C.double(valuesV)
	}

	C.ImPlot_PlotInfLines_doublePtr(label_idArg, (*C.double)(&valuesArg[0]), C.int(count), C.ImPlotInfLinesFlags(flags), C.int(offset), C.int(stride))

	label_idFin()

	for i, valuesV := range valuesArg {
		(*values)[i] = float64(valuesV)
	}
}

// PlotPlotLineFloatPtrFloatPtrV parameter default value hint:
// flags: 0
// offset: 0
// stride: sizeof(float)
func PlotPlotLineFloatPtrFloatPtrV(label_id string, xs []float32, ys []float32, count int32, flags PlotLineFlags, offset int32, stride int32) {
	label_idArg, label_idFin := WrapString(label_id)
	C.ImPlot_PlotLine_FloatPtrFloatPtr(label_idArg, (*C.float)(&(xs[0])), (*C.float)(&(ys[0])), C.int(count), C.ImPlotLineFlags(flags), C.int(offset), C.int(stride))

	label_idFin()
}

// PlotPlotLineFloatPtrIntV parameter default value hint:
// xscale: 1
// xstart: 0
// flags: 0
// offset: 0
// stride: sizeof(float)
func PlotPlotLineFloatPtrIntV(label_id string, values []float32, count int32, xscale float64, xstart float64, flags PlotLineFlags, offset int32, stride int32) {
	label_idArg, label_idFin := WrapString(label_id)
	C.ImPlot_PlotLine_FloatPtrInt(label_idArg, (*C.float)(&(values[0])), C.int(count), C.double(xscale), C.double(xstart), C.ImPlotLineFlags(flags), C.int(offset), C.int(stride))

	label_idFin()
}

// PlotPlotLineS16PtrIntV parameter default value hint:
// xscale: 1
// xstart: 0
// flags: 0
// offset: 0
// stride: sizeof(ImS16)
func PlotPlotLineS16PtrIntV(label_id string, values *[]int, count int32, xscale float64, xstart float64, flags PlotLineFlags, offset int32, stride int32) {
	label_idArg, label_idFin := WrapString(label_id)
	valuesArg := make([]C.ImS16, len(*values))
	for i, valuesV := range *values {
		valuesArg[i] = C.ImS16(valuesV)
	}

	C.ImPlot_PlotLine_S16PtrInt(label_idArg, (*C.ImS16)(&valuesArg[0]), C.int(count), C.double(xscale), C.double(xstart), C.ImPlotLineFlags(flags), C.int(offset), C.int(stride))

	label_idFin()

	for i, valuesV := range valuesArg {
		(*values)[i] = int(valuesV)
	}
}

// PlotPlotLineS16PtrS16PtrV parameter default value hint:
// flags: 0
// offset: 0
// stride: sizeof(ImS16)
func PlotPlotLineS16PtrS16PtrV(label_id string, xs *[]int, ys *[]int, count int32, flags PlotLineFlags, offset int32, stride int32) {
	label_idArg, label_idFin := WrapString(label_id)
	xsArg := make([]C.ImS16, len(*xs))
	for i, xsV := range *xs {
		xsArg[i] = C.ImS16(xsV)
	}

	ysArg := make([]C.ImS16, len(*ys))
	for i, ysV := range *ys {
		ysArg[i] = C.ImS16(ysV)
	}

	C.ImPlot_PlotLine_S16PtrS16Ptr(label_idArg, (*C.ImS16)(&xsArg[0]), (*C.ImS16)(&ysArg[0]), C.int(count), C.ImPlotLineFlags(flags), C.int(offset), C.int(stride))

	label_idFin()

	for i, xsV := range xsArg {
		(*xs)[i] = int(xsV)
	}

	for i, ysV := range ysArg {
		(*ys)[i] = int(ysV)
	}
}

// PlotPlotLineS32PtrIntV parameter default value hint:
// xscale: 1
// xstart: 0
// flags: 0
// offset: 0
// stride: sizeof(ImS32)
func PlotPlotLineS32PtrIntV(label_id string, values *[]int32, count int32, xscale float64, xstart float64, flags PlotLineFlags, offset int32, stride int32) {
	label_idArg, label_idFin := WrapString(label_id)
	valuesArg := make([]C.ImS32, len(*values))
	for i, valuesV := range *values {
		valuesArg[i] = C.ImS32(valuesV)
	}

	C.ImPlot_PlotLine_S32PtrInt(label_idArg, (*C.ImS32)(&valuesArg[0]), C.int(count), C.double(xscale), C.double(xstart), C.ImPlotLineFlags(flags), C.int(offset), C.int(stride))

	label_idFin()

	for i, valuesV := range valuesArg {
		(*values)[i] = int32(valuesV)
	}
}

// PlotPlotLineS32PtrS32PtrV parameter default value hint:
// flags: 0
// offset: 0
// stride: sizeof(ImS32)
func PlotPlotLineS32PtrS32PtrV(label_id string, xs *[]int32, ys *[]int32, count int32, flags PlotLineFlags, offset int32, stride int32) {
	label_idArg, label_idFin := WrapString(label_id)
	xsArg := make([]C.ImS32, len(*xs))
	for i, xsV := range *xs {
		xsArg[i] = C.ImS32(xsV)
	}

	ysArg := make([]C.ImS32, len(*ys))
	for i, ysV := range *ys {
		ysArg[i] = C.ImS32(ysV)
	}

	C.ImPlot_PlotLine_S32PtrS32Ptr(label_idArg, (*C.ImS32)(&xsArg[0]), (*C.ImS32)(&ysArg[0]), C.int(count), C.ImPlotLineFlags(flags), C.int(offset), C.int(stride))

	label_idFin()

	for i, xsV := range xsArg {
		(*xs)[i] = int32(xsV)
	}

	for i, ysV := range ysArg {
		(*ys)[i] = int32(ysV)
	}
}

// PlotPlotLineS64PtrIntV parameter default value hint:
// xscale: 1
// xstart: 0
// flags: 0
// offset: 0
// stride: sizeof(ImS64)
func PlotPlotLineS64PtrIntV(label_id string, values []int64, count int32, xscale float64, xstart float64, flags PlotLineFlags, offset int32, stride int32) {
	label_idArg, label_idFin := WrapString(label_id)
	C.ImPlot_PlotLine_S64PtrInt(label_idArg, (*C.longlong)(&(values[0])), C.int(count), C.double(xscale), C.double(xstart), C.ImPlotLineFlags(flags), C.int(offset), C.int(stride))

	label_idFin()
}

// PlotPlotLineS64PtrS64PtrV parameter default value hint:
// flags: 0
// offset: 0
// stride: sizeof(ImS64)
func PlotPlotLineS64PtrS64PtrV(label_id string, xs []int64, ys []int64, count int32, flags PlotLineFlags, offset int32, stride int32) {
	label_idArg, label_idFin := WrapString(label_id)
	C.ImPlot_PlotLine_S64PtrS64Ptr(label_idArg, (*C.longlong)(&(xs[0])), (*C.longlong)(&(ys[0])), C.int(count), C.ImPlotLineFlags(flags), C.int(offset), C.int(stride))

	label_idFin()
}

// PlotPlotLineS8PtrIntV parameter default value hint:
// xscale: 1
// xstart: 0
// flags: 0
// offset: 0
// stride: sizeof(ImS8)
func PlotPlotLineS8PtrIntV(label_id string, values *[]int8, count int32, xscale float64, xstart float64, flags PlotLineFlags, offset int32, stride int32) {
	label_idArg, label_idFin := WrapString(label_id)
	valuesArg := make([]C.ImS8, len(*values))
	for i, valuesV := range *values {
		valuesArg[i] = C.ImS8(valuesV)
	}

	C.ImPlot_PlotLine_S8PtrInt(label_idArg, (*C.ImS8)(&valuesArg[0]), C.int(count), C.double(xscale), C.double(xstart), C.ImPlotLineFlags(flags), C.int(offset), C.int(stride))

	label_idFin()

	for i, valuesV := range valuesArg {
		(*values)[i] = int8(valuesV)
	}
}

// PlotPlotLineS8PtrS8PtrV parameter default value hint:
// flags: 0
// offset: 0
// stride: sizeof(ImS8)
func PlotPlotLineS8PtrS8PtrV(label_id string, xs *[]int8, ys *[]int8, count int32, flags PlotLineFlags, offset int32, stride int32) {
	label_idArg, label_idFin := WrapString(label_id)
	xsArg := make([]C.ImS8, len(*xs))
	for i, xsV := range *xs {
		xsArg[i] = C.ImS8(xsV)
	}

	ysArg := make([]C.ImS8, len(*ys))
	for i, ysV := range *ys {
		ysArg[i] = C.ImS8(ysV)
	}

	C.ImPlot_PlotLine_S8PtrS8Ptr(label_idArg, (*C.ImS8)(&xsArg[0]), (*C.ImS8)(&ysArg[0]), C.int(count), C.ImPlotLineFlags(flags), C.int(offset), C.int(stride))

	label_idFin()

	for i, xsV := range xsArg {
		(*xs)[i] = int8(xsV)
	}

	for i, ysV := range ysArg {
		(*ys)[i] = int8(ysV)
	}
}

// PlotPlotLineU16PtrIntV parameter default value hint:
// xscale: 1
// xstart: 0
// flags: 0
// offset: 0
// stride: sizeof(ImU16)
func PlotPlotLineU16PtrIntV(label_id string, values *[]uint16, count int32, xscale float64, xstart float64, flags PlotLineFlags, offset int32, stride int32) {
	label_idArg, label_idFin := WrapString(label_id)
	valuesArg := make([]C.ImU16, len(*values))
	for i, valuesV := range *values {
		valuesArg[i] = C.ImU16(valuesV)
	}

	C.ImPlot_PlotLine_U16PtrInt(label_idArg, (*C.ImU16)(&valuesArg[0]), C.int(count), C.double(xscale), C.double(xstart), C.ImPlotLineFlags(flags), C.int(offset), C.int(stride))

	label_idFin()

	for i, valuesV := range valuesArg {
		(*values)[i] = uint16(valuesV)
	}
}

// PlotPlotLineU16PtrU16PtrV parameter default value hint:
// flags: 0
// offset: 0
// stride: sizeof(ImU16)
func PlotPlotLineU16PtrU16PtrV(label_id string, xs *[]uint16, ys *[]uint16, count int32, flags PlotLineFlags, offset int32, stride int32) {
	label_idArg, label_idFin := WrapString(label_id)
	xsArg := make([]C.ImU16, len(*xs))
	for i, xsV := range *xs {
		xsArg[i] = C.ImU16(xsV)
	}

	ysArg := make([]C.ImU16, len(*ys))
	for i, ysV := range *ys {
		ysArg[i] = C.ImU16(ysV)
	}

	C.ImPlot_PlotLine_U16PtrU16Ptr(label_idArg, (*C.ImU16)(&xsArg[0]), (*C.ImU16)(&ysArg[0]), C.int(count), C.ImPlotLineFlags(flags), C.int(offset), C.int(stride))

	label_idFin()

	for i, xsV := range xsArg {
		(*xs)[i] = uint16(xsV)
	}

	for i, ysV := range ysArg {
		(*ys)[i] = uint16(ysV)
	}
}

// PlotPlotLineU32PtrIntV parameter default value hint:
// xscale: 1
// xstart: 0
// flags: 0
// offset: 0
// stride: sizeof(ImU32)
func PlotPlotLineU32PtrIntV(label_id string, values *[]uint32, count int32, xscale float64, xstart float64, flags PlotLineFlags, offset int32, stride int32) {
	label_idArg, label_idFin := WrapString(label_id)
	valuesArg := make([]C.ImU32, len(*values))
	for i, valuesV := range *values {
		valuesArg[i] = C.ImU32(valuesV)
	}

	C.ImPlot_PlotLine_U32PtrInt(label_idArg, (*C.ImU32)(&valuesArg[0]), C.int(count), C.double(xscale), C.double(xstart), C.ImPlotLineFlags(flags), C.int(offset), C.int(stride))

	label_idFin()

	for i, valuesV := range valuesArg {
		(*values)[i] = uint32(valuesV)
	}
}

// PlotPlotLineU32PtrU32PtrV parameter default value hint:
// flags: 0
// offset: 0
// stride: sizeof(ImU32)
func PlotPlotLineU32PtrU32PtrV(label_id string, xs *[]uint32, ys *[]uint32, count int32, flags PlotLineFlags, offset int32, stride int32) {
	label_idArg, label_idFin := WrapString(label_id)
	xsArg := make([]C.ImU32, len(*xs))
	for i, xsV := range *xs {
		xsArg[i] = C.ImU32(xsV)
	}

	ysArg := make([]C.ImU32, len(*ys))
	for i, ysV := range *ys {
		ysArg[i] = C.ImU32(ysV)
	}

	C.ImPlot_PlotLine_U32PtrU32Ptr(label_idArg, (*C.ImU32)(&xsArg[0]), (*C.ImU32)(&ysArg[0]), C.int(count), C.ImPlotLineFlags(flags), C.int(offset), C.int(stride))

	label_idFin()

	for i, xsV := range xsArg {
		(*xs)[i] = uint32(xsV)
	}

	for i, ysV := range ysArg {
		(*ys)[i] = uint32(ysV)
	}
}

// PlotPlotLineU64PtrIntV parameter default value hint:
// xscale: 1
// xstart: 0
// flags: 0
// offset: 0
// stride: sizeof(ImU64)
func PlotPlotLineU64PtrIntV(label_id string, values []uint64, count int32, xscale float64, xstart float64, flags PlotLineFlags, offset int32, stride int32) {
	label_idArg, label_idFin := WrapString(label_id)
	C.ImPlot_PlotLine_U64PtrInt(label_idArg, (*C.ulonglong)(&(values[0])), C.int(count), C.double(xscale), C.double(xstart), C.ImPlotLineFlags(flags), C.int(offset), C.int(stride))

	label_idFin()
}

// PlotPlotLineU64PtrU64PtrV parameter default value hint:
// flags: 0
// offset: 0
// stride: sizeof(ImU64)
func PlotPlotLineU64PtrU64PtrV(label_id string, xs []uint64, ys []uint64, count int32, flags PlotLineFlags, offset int32, stride int32) {
	label_idArg, label_idFin := WrapString(label_id)
	C.ImPlot_PlotLine_U64PtrU64Ptr(label_idArg, (*C.ulonglong)(&(xs[0])), (*C.ulonglong)(&(ys[0])), C.int(count), C.ImPlotLineFlags(flags), C.int(offset), C.int(stride))

	label_idFin()
}

// PlotPlotLineU8PtrIntV parameter default value hint:
// xscale: 1
// xstart: 0
// flags: 0
// offset: 0
// stride: sizeof(ImU8)
func PlotPlotLineU8PtrIntV(label_id string, values *[]byte, count int32, xscale float64, xstart float64, flags PlotLineFlags, offset int32, stride int32) {
	label_idArg, label_idFin := WrapString(label_id)
	valuesArg := make([]C.ImU8, len(*values))
	for i, valuesV := range *values {
		valuesArg[i] = C.ImU8(valuesV)
	}

	C.ImPlot_PlotLine_U8PtrInt(label_idArg, (*C.ImU8)(&valuesArg[0]), C.int(count), C.double(xscale), C.double(xstart), C.ImPlotLineFlags(flags), C.int(offset), C.int(stride))

	label_idFin()

	for i, valuesV := range valuesArg {
		(*values)[i] = byte(valuesV)
	}
}

// PlotPlotLineU8PtrU8PtrV parameter default value hint:
// flags: 0
// offset: 0
// stride: sizeof(ImU8)
func PlotPlotLineU8PtrU8PtrV(label_id string, xs *[]byte, ys *[]byte, count int32, flags PlotLineFlags, offset int32, stride int32) {
	label_idArg, label_idFin := WrapString(label_id)
	xsArg := make([]C.ImU8, len(*xs))
	for i, xsV := range *xs {
		xsArg[i] = C.ImU8(xsV)
	}

	ysArg := make([]C.ImU8, len(*ys))
	for i, ysV := range *ys {
		ysArg[i] = C.ImU8(ysV)
	}

	C.ImPlot_PlotLine_U8PtrU8Ptr(label_idArg, (*C.ImU8)(&xsArg[0]), (*C.ImU8)(&ysArg[0]), C.int(count), C.ImPlotLineFlags(flags), C.int(offset), C.int(stride))

	label_idFin()

	for i, xsV := range xsArg {
		(*xs)[i] = byte(xsV)
	}

	for i, ysV := range ysArg {
		(*ys)[i] = byte(ysV)
	}
}

// PlotPlotLinedoublePtrIntV parameter default value hint:
// xscale: 1
// xstart: 0
// flags: 0
// offset: 0
// stride: sizeof(double)
func PlotPlotLinedoublePtrIntV(label_id string, values *[]float64, count int32, xscale float64, xstart float64, flags PlotLineFlags, offset int32, stride int32) {
	label_idArg, label_idFin := WrapString(label_id)
	valuesArg := make([]C.double, len(*values))
	for i, valuesV := range *values {
		valuesArg[i] = C.double(valuesV)
	}

	C.ImPlot_PlotLine_doublePtrInt(label_idArg, (*C.double)(&valuesArg[0]), C.int(count), C.double(xscale), C.double(xstart), C.ImPlotLineFlags(flags), C.int(offset), C.int(stride))

	label_idFin()

	for i, valuesV := range valuesArg {
		(*values)[i] = float64(valuesV)
	}
}

// PlotPlotLinedoublePtrdoublePtrV parameter default value hint:
// flags: 0
// offset: 0
// stride: sizeof(double)
func PlotPlotLinedoublePtrdoublePtrV(label_id string, xs *[]float64, ys *[]float64, count int32, flags PlotLineFlags, offset int32, stride int32) {
	label_idArg, label_idFin := WrapString(label_id)
	xsArg := make([]C.double, len(*xs))
	for i, xsV := range *xs {
		xsArg[i] = C.double(xsV)
	}

	ysArg := make([]C.double, len(*ys))
	for i, ysV := range *ys {
		ysArg[i] = C.double(ysV)
	}

	C.ImPlot_PlotLine_doublePtrdoublePtr(label_idArg, (*C.double)(&xsArg[0]), (*C.double)(&ysArg[0]), C.int(count), C.ImPlotLineFlags(flags), C.int(offset), C.int(stride))

	label_idFin()

	for i, xsV := range xsArg {
		(*xs)[i] = float64(xsV)
	}

	for i, ysV := range ysArg {
		(*ys)[i] = float64(ysV)
	}
}

// PlotPlotPieChartFloatPtrV parameter default value hint:
// label_fmt: "%.1f"
// angle0: 90
// flags: 0
func PlotPlotPieChartFloatPtrV(label_ids []string, values []float32, count int32, x float64, y float64, radius float64, label_fmt string, angle0 float64, flags PlotPieChartFlags) {
	label_idsArg, label_idsFin := WrapStringList(label_ids)
	label_fmtArg, label_fmtFin := WrapString(label_fmt)
	C.ImPlot_PlotPieChart_FloatPtr(label_idsArg, (*C.float)(&(values[0])), C.int(count), C.double(x), C.double(y), C.double(radius), label_fmtArg, C.double(angle0), C.ImPlotPieChartFlags(flags))

	label_idsFin()
	label_fmtFin()
}

// PlotPlotPieChartS16PtrV parameter default value hint:
// label_fmt: "%.1f"
// angle0: 90
// flags: 0
func PlotPlotPieChartS16PtrV(label_ids []string, values *[]int, count int32, x float64, y float64, radius float64, label_fmt string, angle0 float64, flags PlotPieChartFlags) {
	label_idsArg, label_idsFin := WrapStringList(label_ids)
	valuesArg := make([]C.ImS16, len(*values))
	for i, valuesV := range *values {
		valuesArg[i] = C.ImS16(valuesV)
	}

	label_fmtArg, label_fmtFin := WrapString(label_fmt)
	C.ImPlot_PlotPieChart_S16Ptr(label_idsArg, (*C.ImS16)(&valuesArg[0]), C.int(count), C.double(x), C.double(y), C.double(radius), label_fmtArg, C.double(angle0), C.ImPlotPieChartFlags(flags))

	label_idsFin()

	for i, valuesV := range valuesArg {
		(*values)[i] = int(valuesV)
	}

	label_fmtFin()
}

// PlotPlotPieChartS32PtrV parameter default value hint:
// label_fmt: "%.1f"
// angle0: 90
// flags: 0
func PlotPlotPieChartS32PtrV(label_ids []string, values *[]int32, count int32, x float64, y float64, radius float64, label_fmt string, angle0 float64, flags PlotPieChartFlags) {
	label_idsArg, label_idsFin := WrapStringList(label_ids)
	valuesArg := make([]C.ImS32, len(*values))
	for i, valuesV := range *values {
		valuesArg[i] = C.ImS32(valuesV)
	}

	label_fmtArg, label_fmtFin := WrapString(label_fmt)
	C.ImPlot_PlotPieChart_S32Ptr(label_idsArg, (*C.ImS32)(&valuesArg[0]), C.int(count), C.double(x), C.double(y), C.double(radius), label_fmtArg, C.double(angle0), C.ImPlotPieChartFlags(flags))

	label_idsFin()

	for i, valuesV := range valuesArg {
		(*values)[i] = int32(valuesV)
	}

	label_fmtFin()
}

// PlotPlotPieChartS64PtrV parameter default value hint:
// label_fmt: "%.1f"
// angle0: 90
// flags: 0
func PlotPlotPieChartS64PtrV(label_ids []string, values []int64, count int32, x float64, y float64, radius float64, label_fmt string, angle0 float64, flags PlotPieChartFlags) {
	label_idsArg, label_idsFin := WrapStringList(label_ids)
	label_fmtArg, label_fmtFin := WrapString(label_fmt)
	C.ImPlot_PlotPieChart_S64Ptr(label_idsArg, (*C.longlong)(&(values[0])), C.int(count), C.double(x), C.double(y), C.double(radius), label_fmtArg, C.double(angle0), C.ImPlotPieChartFlags(flags))

	label_idsFin()
	label_fmtFin()
}

// PlotPlotPieChartS8PtrV parameter default value hint:
// label_fmt: "%.1f"
// angle0: 90
// flags: 0
func PlotPlotPieChartS8PtrV(label_ids []string, values *[]int8, count int32, x float64, y float64, radius float64, label_fmt string, angle0 float64, flags PlotPieChartFlags) {
	label_idsArg, label_idsFin := WrapStringList(label_ids)
	valuesArg := make([]C.ImS8, len(*values))
	for i, valuesV := range *values {
		valuesArg[i] = C.ImS8(valuesV)
	}

	label_fmtArg, label_fmtFin := WrapString(label_fmt)
	C.ImPlot_PlotPieChart_S8Ptr(label_idsArg, (*C.ImS8)(&valuesArg[0]), C.int(count), C.double(x), C.double(y), C.double(radius), label_fmtArg, C.double(angle0), C.ImPlotPieChartFlags(flags))

	label_idsFin()

	for i, valuesV := range valuesArg {
		(*values)[i] = int8(valuesV)
	}

	label_fmtFin()
}

// PlotPlotPieChartU16PtrV parameter default value hint:
// label_fmt: "%.1f"
// angle0: 90
// flags: 0
func PlotPlotPieChartU16PtrV(label_ids []string, values *[]uint16, count int32, x float64, y float64, radius float64, label_fmt string, angle0 float64, flags PlotPieChartFlags) {
	label_idsArg, label_idsFin := WrapStringList(label_ids)
	valuesArg := make([]C.ImU16, len(*values))
	for i, valuesV := range *values {
		valuesArg[i] = C.ImU16(valuesV)
	}

	label_fmtArg, label_fmtFin := WrapString(label_fmt)
	C.ImPlot_PlotPieChart_U16Ptr(label_idsArg, (*C.ImU16)(&valuesArg[0]), C.int(count), C.double(x), C.double(y), C.double(radius), label_fmtArg, C.double(angle0), C.ImPlotPieChartFlags(flags))

	label_idsFin()

	for i, valuesV := range valuesArg {
		(*values)[i] = uint16(valuesV)
	}

	label_fmtFin()
}

// PlotPlotPieChartU32PtrV parameter default value hint:
// label_fmt: "%.1f"
// angle0: 90
// flags: 0
func PlotPlotPieChartU32PtrV(label_ids []string, values *[]uint32, count int32, x float64, y float64, radius float64, label_fmt string, angle0 float64, flags PlotPieChartFlags) {
	label_idsArg, label_idsFin := WrapStringList(label_ids)
	valuesArg := make([]C.ImU32, len(*values))
	for i, valuesV := range *values {
		valuesArg[i] = C.ImU32(valuesV)
	}

	label_fmtArg, label_fmtFin := WrapString(label_fmt)
	C.ImPlot_PlotPieChart_U32Ptr(label_idsArg, (*C.ImU32)(&valuesArg[0]), C.int(count), C.double(x), C.double(y), C.double(radius), label_fmtArg, C.double(angle0), C.ImPlotPieChartFlags(flags))

	label_idsFin()

	for i, valuesV := range valuesArg {
		(*values)[i] = uint32(valuesV)
	}

	label_fmtFin()
}

// PlotPlotPieChartU64PtrV parameter default value hint:
// label_fmt: "%.1f"
// angle0: 90
// flags: 0
func PlotPlotPieChartU64PtrV(label_ids []string, values []uint64, count int32, x float64, y float64, radius float64, label_fmt string, angle0 float64, flags PlotPieChartFlags) {
	label_idsArg, label_idsFin := WrapStringList(label_ids)
	label_fmtArg, label_fmtFin := WrapString(label_fmt)
	C.ImPlot_PlotPieChart_U64Ptr(label_idsArg, (*C.ulonglong)(&(values[0])), C.int(count), C.double(x), C.double(y), C.double(radius), label_fmtArg, C.double(angle0), C.ImPlotPieChartFlags(flags))

	label_idsFin()
	label_fmtFin()
}

// PlotPlotPieChartU8PtrV parameter default value hint:
// label_fmt: "%.1f"
// angle0: 90
// flags: 0
func PlotPlotPieChartU8PtrV(label_ids []string, values *[]byte, count int32, x float64, y float64, radius float64, label_fmt string, angle0 float64, flags PlotPieChartFlags) {
	label_idsArg, label_idsFin := WrapStringList(label_ids)
	valuesArg := make([]C.ImU8, len(*values))
	for i, valuesV := range *values {
		valuesArg[i] = C.ImU8(valuesV)
	}

	label_fmtArg, label_fmtFin := WrapString(label_fmt)
	C.ImPlot_PlotPieChart_U8Ptr(label_idsArg, (*C.ImU8)(&valuesArg[0]), C.int(count), C.double(x), C.double(y), C.double(radius), label_fmtArg, C.double(angle0), C.ImPlotPieChartFlags(flags))

	label_idsFin()

	for i, valuesV := range valuesArg {
		(*values)[i] = byte(valuesV)
	}

	label_fmtFin()
}

// PlotPlotPieChartdoublePtrV parameter default value hint:
// label_fmt: "%.1f"
// angle0: 90
// flags: 0
func PlotPlotPieChartdoublePtrV(label_ids []string, values *[]float64, count int32, x float64, y float64, radius float64, label_fmt string, angle0 float64, flags PlotPieChartFlags) {
	label_idsArg, label_idsFin := WrapStringList(label_ids)
	valuesArg := make([]C.double, len(*values))
	for i, valuesV := range *values {
		valuesArg[i] = C.double(valuesV)
	}

	label_fmtArg, label_fmtFin := WrapString(label_fmt)
	C.ImPlot_PlotPieChart_doublePtr(label_idsArg, (*C.double)(&valuesArg[0]), C.int(count), C.double(x), C.double(y), C.double(radius), label_fmtArg, C.double(angle0), C.ImPlotPieChartFlags(flags))

	label_idsFin()

	for i, valuesV := range valuesArg {
		(*values)[i] = float64(valuesV)
	}

	label_fmtFin()
}

// PlotPlotScatterFloatPtrFloatPtrV parameter default value hint:
// flags: 0
// offset: 0
// stride: sizeof(float)
func PlotPlotScatterFloatPtrFloatPtrV(label_id string, xs []float32, ys []float32, count int32, flags PlotScatterFlags, offset int32, stride int32) {
	label_idArg, label_idFin := WrapString(label_id)
	C.ImPlot_PlotScatter_FloatPtrFloatPtr(label_idArg, (*C.float)(&(xs[0])), (*C.float)(&(ys[0])), C.int(count), C.ImPlotScatterFlags(flags), C.int(offset), C.int(stride))

	label_idFin()
}

// PlotPlotScatterFloatPtrIntV parameter default value hint:
// xscale: 1
// xstart: 0
// flags: 0
// offset: 0
// stride: sizeof(float)
func PlotPlotScatterFloatPtrIntV(label_id string, values []float32, count int32, xscale float64, xstart float64, flags PlotScatterFlags, offset int32, stride int32) {
	label_idArg, label_idFin := WrapString(label_id)
	C.ImPlot_PlotScatter_FloatPtrInt(label_idArg, (*C.float)(&(values[0])), C.int(count), C.double(xscale), C.double(xstart), C.ImPlotScatterFlags(flags), C.int(offset), C.int(stride))

	label_idFin()
}

// PlotPlotScatterS16PtrIntV parameter default value hint:
// xscale: 1
// xstart: 0
// flags: 0
// offset: 0
// stride: sizeof(ImS16)
func PlotPlotScatterS16PtrIntV(label_id string, values *[]int, count int32, xscale float64, xstart float64, flags PlotScatterFlags, offset int32, stride int32) {
	label_idArg, label_idFin := WrapString(label_id)
	valuesArg := make([]C.ImS16, len(*values))
	for i, valuesV := range *values {
		valuesArg[i] = C.ImS16(valuesV)
	}

	C.ImPlot_PlotScatter_S16PtrInt(label_idArg, (*C.ImS16)(&valuesArg[0]), C.int(count), C.double(xscale), C.double(xstart), C.ImPlotScatterFlags(flags), C.int(offset), C.int(stride))

	label_idFin()

	for i, valuesV := range valuesArg {
		(*values)[i] = int(valuesV)
	}
}

// PlotPlotScatterS16PtrS16PtrV parameter default value hint:
// flags: 0
// offset: 0
// stride: sizeof(ImS16)
func PlotPlotScatterS16PtrS16PtrV(label_id string, xs *[]int, ys *[]int, count int32, flags PlotScatterFlags, offset int32, stride int32) {
	label_idArg, label_idFin := WrapString(label_id)
	xsArg := make([]C.ImS16, len(*xs))
	for i, xsV := range *xs {
		xsArg[i] = C.ImS16(xsV)
	}

	ysArg := make([]C.ImS16, len(*ys))
	for i, ysV := range *ys {
		ysArg[i] = C.ImS16(ysV)
	}

	C.ImPlot_PlotScatter_S16PtrS16Ptr(label_idArg, (*C.ImS16)(&xsArg[0]), (*C.ImS16)(&ysArg[0]), C.int(count), C.ImPlotScatterFlags(flags), C.int(offset), C.int(stride))

	label_idFin()

	for i, xsV := range xsArg {
		(*xs)[i] = int(xsV)
	}

	for i, ysV := range ysArg {
		(*ys)[i] = int(ysV)
	}
}

// PlotPlotScatterS32PtrIntV parameter default value hint:
// xscale: 1
// xstart: 0
// flags: 0
// offset: 0
// stride: sizeof(ImS32)
func PlotPlotScatterS32PtrIntV(label_id string, values *[]int32, count int32, xscale float64, xstart float64, flags PlotScatterFlags, offset int32, stride int32) {
	label_idArg, label_idFin := WrapString(label_id)
	valuesArg := make([]C.ImS32, len(*values))
	for i, valuesV := range *values {
		valuesArg[i] = C.ImS32(valuesV)
	}

	C.ImPlot_PlotScatter_S32PtrInt(label_idArg, (*C.ImS32)(&valuesArg[0]), C.int(count), C.double(xscale), C.double(xstart), C.ImPlotScatterFlags(flags), C.int(offset), C.int(stride))

	label_idFin()

	for i, valuesV := range valuesArg {
		(*values)[i] = int32(valuesV)
	}
}

// PlotPlotScatterS32PtrS32PtrV parameter default value hint:
// flags: 0
// offset: 0
// stride: sizeof(ImS32)
func PlotPlotScatterS32PtrS32PtrV(label_id string, xs *[]int32, ys *[]int32, count int32, flags PlotScatterFlags, offset int32, stride int32) {
	label_idArg, label_idFin := WrapString(label_id)
	xsArg := make([]C.ImS32, len(*xs))
	for i, xsV := range *xs {
		xsArg[i] = C.ImS32(xsV)
	}

	ysArg := make([]C.ImS32, len(*ys))
	for i, ysV := range *ys {
		ysArg[i] = C.ImS32(ysV)
	}

	C.ImPlot_PlotScatter_S32PtrS32Ptr(label_idArg, (*C.ImS32)(&xsArg[0]), (*C.ImS32)(&ysArg[0]), C.int(count), C.ImPlotScatterFlags(flags), C.int(offset), C.int(stride))

	label_idFin()

	for i, xsV := range xsArg {
		(*xs)[i] = int32(xsV)
	}

	for i, ysV := range ysArg {
		(*ys)[i] = int32(ysV)
	}
}

// PlotPlotScatterS64PtrIntV parameter default value hint:
// xscale: 1
// xstart: 0
// flags: 0
// offset: 0
// stride: sizeof(ImS64)
func PlotPlotScatterS64PtrIntV(label_id string, values []int64, count int32, xscale float64, xstart float64, flags PlotScatterFlags, offset int32, stride int32) {
	label_idArg, label_idFin := WrapString(label_id)
	C.ImPlot_PlotScatter_S64PtrInt(label_idArg, (*C.longlong)(&(values[0])), C.int(count), C.double(xscale), C.double(xstart), C.ImPlotScatterFlags(flags), C.int(offset), C.int(stride))

	label_idFin()
}

// PlotPlotScatterS64PtrS64PtrV parameter default value hint:
// flags: 0
// offset: 0
// stride: sizeof(ImS64)
func PlotPlotScatterS64PtrS64PtrV(label_id string, xs []int64, ys []int64, count int32, flags PlotScatterFlags, offset int32, stride int32) {
	label_idArg, label_idFin := WrapString(label_id)
	C.ImPlot_PlotScatter_S64PtrS64Ptr(label_idArg, (*C.longlong)(&(xs[0])), (*C.longlong)(&(ys[0])), C.int(count), C.ImPlotScatterFlags(flags), C.int(offset), C.int(stride))

	label_idFin()
}

// PlotPlotScatterS8PtrIntV parameter default value hint:
// xscale: 1
// xstart: 0
// flags: 0
// offset: 0
// stride: sizeof(ImS8)
func PlotPlotScatterS8PtrIntV(label_id string, values *[]int8, count int32, xscale float64, xstart float64, flags PlotScatterFlags, offset int32, stride int32) {
	label_idArg, label_idFin := WrapString(label_id)
	valuesArg := make([]C.ImS8, len(*values))
	for i, valuesV := range *values {
		valuesArg[i] = C.ImS8(valuesV)
	}

	C.ImPlot_PlotScatter_S8PtrInt(label_idArg, (*C.ImS8)(&valuesArg[0]), C.int(count), C.double(xscale), C.double(xstart), C.ImPlotScatterFlags(flags), C.int(offset), C.int(stride))

	label_idFin()

	for i, valuesV := range valuesArg {
		(*values)[i] = int8(valuesV)
	}
}

// PlotPlotScatterS8PtrS8PtrV parameter default value hint:
// flags: 0
// offset: 0
// stride: sizeof(ImS8)
func PlotPlotScatterS8PtrS8PtrV(label_id string, xs *[]int8, ys *[]int8, count int32, flags PlotScatterFlags, offset int32, stride int32) {
	label_idArg, label_idFin := WrapString(label_id)
	xsArg := make([]C.ImS8, len(*xs))
	for i, xsV := range *xs {
		xsArg[i] = C.ImS8(xsV)
	}

	ysArg := make([]C.ImS8, len(*ys))
	for i, ysV := range *ys {
		ysArg[i] = C.ImS8(ysV)
	}

	C.ImPlot_PlotScatter_S8PtrS8Ptr(label_idArg, (*C.ImS8)(&xsArg[0]), (*C.ImS8)(&ysArg[0]), C.int(count), C.ImPlotScatterFlags(flags), C.int(offset), C.int(stride))

	label_idFin()

	for i, xsV := range xsArg {
		(*xs)[i] = int8(xsV)
	}

	for i, ysV := range ysArg {
		(*ys)[i] = int8(ysV)
	}
}

// PlotPlotScatterU16PtrIntV parameter default value hint:
// xscale: 1
// xstart: 0
// flags: 0
// offset: 0
// stride: sizeof(ImU16)
func PlotPlotScatterU16PtrIntV(label_id string, values *[]uint16, count int32, xscale float64, xstart float64, flags PlotScatterFlags, offset int32, stride int32) {
	label_idArg, label_idFin := WrapString(label_id)
	valuesArg := make([]C.ImU16, len(*values))
	for i, valuesV := range *values {
		valuesArg[i] = C.ImU16(valuesV)
	}

	C.ImPlot_PlotScatter_U16PtrInt(label_idArg, (*C.ImU16)(&valuesArg[0]), C.int(count), C.double(xscale), C.double(xstart), C.ImPlotScatterFlags(flags), C.int(offset), C.int(stride))

	label_idFin()

	for i, valuesV := range valuesArg {
		(*values)[i] = uint16(valuesV)
	}
}

// PlotPlotScatterU16PtrU16PtrV parameter default value hint:
// flags: 0
// offset: 0
// stride: sizeof(ImU16)
func PlotPlotScatterU16PtrU16PtrV(label_id string, xs *[]uint16, ys *[]uint16, count int32, flags PlotScatterFlags, offset int32, stride int32) {
	label_idArg, label_idFin := WrapString(label_id)
	xsArg := make([]C.ImU16, len(*xs))
	for i, xsV := range *xs {
		xsArg[i] = C.ImU16(xsV)
	}

	ysArg := make([]C.ImU16, len(*ys))
	for i, ysV := range *ys {
		ysArg[i] = C.ImU16(ysV)
	}

	C.ImPlot_PlotScatter_U16PtrU16Ptr(label_idArg, (*C.ImU16)(&xsArg[0]), (*C.ImU16)(&ysArg[0]), C.int(count), C.ImPlotScatterFlags(flags), C.int(offset), C.int(stride))

	label_idFin()

	for i, xsV := range xsArg {
		(*xs)[i] = uint16(xsV)
	}

	for i, ysV := range ysArg {
		(*ys)[i] = uint16(ysV)
	}
}

// PlotPlotScatterU32PtrIntV parameter default value hint:
// xscale: 1
// xstart: 0
// flags: 0
// offset: 0
// stride: sizeof(ImU32)
func PlotPlotScatterU32PtrIntV(label_id string, values *[]uint32, count int32, xscale float64, xstart float64, flags PlotScatterFlags, offset int32, stride int32) {
	label_idArg, label_idFin := WrapString(label_id)
	valuesArg := make([]C.ImU32, len(*values))
	for i, valuesV := range *values {
		valuesArg[i] = C.ImU32(valuesV)
	}

	C.ImPlot_PlotScatter_U32PtrInt(label_idArg, (*C.ImU32)(&valuesArg[0]), C.int(count), C.double(xscale), C.double(xstart), C.ImPlotScatterFlags(flags), C.int(offset), C.int(stride))

	label_idFin()

	for i, valuesV := range valuesArg {
		(*values)[i] = uint32(valuesV)
	}
}

// PlotPlotScatterU32PtrU32PtrV parameter default value hint:
// flags: 0
// offset: 0
// stride: sizeof(ImU32)
func PlotPlotScatterU32PtrU32PtrV(label_id string, xs *[]uint32, ys *[]uint32, count int32, flags PlotScatterFlags, offset int32, stride int32) {
	label_idArg, label_idFin := WrapString(label_id)
	xsArg := make([]C.ImU32, len(*xs))
	for i, xsV := range *xs {
		xsArg[i] = C.ImU32(xsV)
	}

	ysArg := make([]C.ImU32, len(*ys))
	for i, ysV := range *ys {
		ysArg[i] = C.ImU32(ysV)
	}

	C.ImPlot_PlotScatter_U32PtrU32Ptr(label_idArg, (*C.ImU32)(&xsArg[0]), (*C.ImU32)(&ysArg[0]), C.int(count), C.ImPlotScatterFlags(flags), C.int(offset), C.int(stride))

	label_idFin()

	for i, xsV := range xsArg {
		(*xs)[i] = uint32(xsV)
	}

	for i, ysV := range ysArg {
		(*ys)[i] = uint32(ysV)
	}
}

// PlotPlotScatterU64PtrIntV parameter default value hint:
// xscale: 1
// xstart: 0
// flags: 0
// offset: 0
// stride: sizeof(ImU64)
func PlotPlotScatterU64PtrIntV(label_id string, values []uint64, count int32, xscale float64, xstart float64, flags PlotScatterFlags, offset int32, stride int32) {
	label_idArg, label_idFin := WrapString(label_id)
	C.ImPlot_PlotScatter_U64PtrInt(label_idArg, (*C.ulonglong)(&(values[0])), C.int(count), C.double(xscale), C.double(xstart), C.ImPlotScatterFlags(flags), C.int(offset), C.int(stride))

	label_idFin()
}

// PlotPlotScatterU64PtrU64PtrV parameter default value hint:
// flags: 0
// offset: 0
// stride: sizeof(ImU64)
func PlotPlotScatterU64PtrU64PtrV(label_id string, xs []uint64, ys []uint64, count int32, flags PlotScatterFlags, offset int32, stride int32) {
	label_idArg, label_idFin := WrapString(label_id)
	C.ImPlot_PlotScatter_U64PtrU64Ptr(label_idArg, (*C.ulonglong)(&(xs[0])), (*C.ulonglong)(&(ys[0])), C.int(count), C.ImPlotScatterFlags(flags), C.int(offset), C.int(stride))

	label_idFin()
}

// PlotPlotScatterU8PtrIntV parameter default value hint:
// xscale: 1
// xstart: 0
// flags: 0
// offset: 0
// stride: sizeof(ImU8)
func PlotPlotScatterU8PtrIntV(label_id string, values *[]byte, count int32, xscale float64, xstart float64, flags PlotScatterFlags, offset int32, stride int32) {
	label_idArg, label_idFin := WrapString(label_id)
	valuesArg := make([]C.ImU8, len(*values))
	for i, valuesV := range *values {
		valuesArg[i] = C.ImU8(valuesV)
	}

	C.ImPlot_PlotScatter_U8PtrInt(label_idArg, (*C.ImU8)(&valuesArg[0]), C.int(count), C.double(xscale), C.double(xstart), C.ImPlotScatterFlags(flags), C.int(offset), C.int(stride))

	label_idFin()

	for i, valuesV := range valuesArg {
		(*values)[i] = byte(valuesV)
	}
}

// PlotPlotScatterU8PtrU8PtrV parameter default value hint:
// flags: 0
// offset: 0
// stride: sizeof(ImU8)
func PlotPlotScatterU8PtrU8PtrV(label_id string, xs *[]byte, ys *[]byte, count int32, flags PlotScatterFlags, offset int32, stride int32) {
	label_idArg, label_idFin := WrapString(label_id)
	xsArg := make([]C.ImU8, len(*xs))
	for i, xsV := range *xs {
		xsArg[i] = C.ImU8(xsV)
	}

	ysArg := make([]C.ImU8, len(*ys))
	for i, ysV := range *ys {
		ysArg[i] = C.ImU8(ysV)
	}

	C.ImPlot_PlotScatter_U8PtrU8Ptr(label_idArg, (*C.ImU8)(&xsArg[0]), (*C.ImU8)(&ysArg[0]), C.int(count), C.ImPlotScatterFlags(flags), C.int(offset), C.int(stride))

	label_idFin()

	for i, xsV := range xsArg {
		(*xs)[i] = byte(xsV)
	}

	for i, ysV := range ysArg {
		(*ys)[i] = byte(ysV)
	}
}

// PlotPlotScatterdoublePtrIntV parameter default value hint:
// xscale: 1
// xstart: 0
// flags: 0
// offset: 0
// stride: sizeof(double)
func PlotPlotScatterdoublePtrIntV(label_id string, values *[]float64, count int32, xscale float64, xstart float64, flags PlotScatterFlags, offset int32, stride int32) {
	label_idArg, label_idFin := WrapString(label_id)
	valuesArg := make([]C.double, len(*values))
	for i, valuesV := range *values {
		valuesArg[i] = C.double(valuesV)
	}

	C.ImPlot_PlotScatter_doublePtrInt(label_idArg, (*C.double)(&valuesArg[0]), C.int(count), C.double(xscale), C.double(xstart), C.ImPlotScatterFlags(flags), C.int(offset), C.int(stride))

	label_idFin()

	for i, valuesV := range valuesArg {
		(*values)[i] = float64(valuesV)
	}
}

// PlotPlotScatterdoublePtrdoublePtrV parameter default value hint:
// flags: 0
// offset: 0
// stride: sizeof(double)
func PlotPlotScatterdoublePtrdoublePtrV(label_id string, xs *[]float64, ys *[]float64, count int32, flags PlotScatterFlags, offset int32, stride int32) {
	label_idArg, label_idFin := WrapString(label_id)
	xsArg := make([]C.double, len(*xs))
	for i, xsV := range *xs {
		xsArg[i] = C.double(xsV)
	}

	ysArg := make([]C.double, len(*ys))
	for i, ysV := range *ys {
		ysArg[i] = C.double(ysV)
	}

	C.ImPlot_PlotScatter_doublePtrdoublePtr(label_idArg, (*C.double)(&xsArg[0]), (*C.double)(&ysArg[0]), C.int(count), C.ImPlotScatterFlags(flags), C.int(offset), C.int(stride))

	label_idFin()

	for i, xsV := range xsArg {
		(*xs)[i] = float64(xsV)
	}

	for i, ysV := range ysArg {
		(*ys)[i] = float64(ysV)
	}
}

// PlotPlotShadedFloatPtrFloatPtrFloatPtrV parameter default value hint:
// flags: 0
// offset: 0
// stride: sizeof(float)
func PlotPlotShadedFloatPtrFloatPtrFloatPtrV(label_id string, xs []float32, ys1 []float32, ys2 []float32, count int32, flags PlotShadedFlags, offset int32, stride int32) {
	label_idArg, label_idFin := WrapString(label_id)
	C.ImPlot_PlotShaded_FloatPtrFloatPtrFloatPtr(label_idArg, (*C.float)(&(xs[0])), (*C.float)(&(ys1[0])), (*C.float)(&(ys2[0])), C.int(count), C.ImPlotShadedFlags(flags), C.int(offset), C.int(stride))

	label_idFin()
}

// PlotPlotShadedFloatPtrFloatPtrIntV parameter default value hint:
// yref: 0
// flags: 0
// offset: 0
// stride: sizeof(float)
func PlotPlotShadedFloatPtrFloatPtrIntV(label_id string, xs []float32, ys []float32, count int32, yref float64, flags PlotShadedFlags, offset int32, stride int32) {
	label_idArg, label_idFin := WrapString(label_id)
	C.ImPlot_PlotShaded_FloatPtrFloatPtrInt(label_idArg, (*C.float)(&(xs[0])), (*C.float)(&(ys[0])), C.int(count), C.double(yref), C.ImPlotShadedFlags(flags), C.int(offset), C.int(stride))

	label_idFin()
}

// PlotPlotShadedFloatPtrIntV parameter default value hint:
// yref: 0
// xscale: 1
// xstart: 0
// flags: 0
// offset: 0
// stride: sizeof(float)
func PlotPlotShadedFloatPtrIntV(label_id string, values []float32, count int32, yref float64, xscale float64, xstart float64, flags PlotShadedFlags, offset int32, stride int32) {
	label_idArg, label_idFin := WrapString(label_id)
	C.ImPlot_PlotShaded_FloatPtrInt(label_idArg, (*C.float)(&(values[0])), C.int(count), C.double(yref), C.double(xscale), C.double(xstart), C.ImPlotShadedFlags(flags), C.int(offset), C.int(stride))

	label_idFin()
}

// PlotPlotShadedS16PtrIntV parameter default value hint:
// yref: 0
// xscale: 1
// xstart: 0
// flags: 0
// offset: 0
// stride: sizeof(ImS16)
func PlotPlotShadedS16PtrIntV(label_id string, values *[]int, count int32, yref float64, xscale float64, xstart float64, flags PlotShadedFlags, offset int32, stride int32) {
	label_idArg, label_idFin := WrapString(label_id)
	valuesArg := make([]C.ImS16, len(*values))
	for i, valuesV := range *values {
		valuesArg[i] = C.ImS16(valuesV)
	}

	C.ImPlot_PlotShaded_S16PtrInt(label_idArg, (*C.ImS16)(&valuesArg[0]), C.int(count), C.double(yref), C.double(xscale), C.double(xstart), C.ImPlotShadedFlags(flags), C.int(offset), C.int(stride))

	label_idFin()

	for i, valuesV := range valuesArg {
		(*values)[i] = int(valuesV)
	}
}

// PlotPlotShadedS16PtrS16PtrIntV parameter default value hint:
// yref: 0
// flags: 0
// offset: 0
// stride: sizeof(ImS16)
func PlotPlotShadedS16PtrS16PtrIntV(label_id string, xs *[]int, ys *[]int, count int32, yref float64, flags PlotShadedFlags, offset int32, stride int32) {
	label_idArg, label_idFin := WrapString(label_id)
	xsArg := make([]C.ImS16, len(*xs))
	for i, xsV := range *xs {
		xsArg[i] = C.ImS16(xsV)
	}

	ysArg := make([]C.ImS16, len(*ys))
	for i, ysV := range *ys {
		ysArg[i] = C.ImS16(ysV)
	}

	C.ImPlot_PlotShaded_S16PtrS16PtrInt(label_idArg, (*C.ImS16)(&xsArg[0]), (*C.ImS16)(&ysArg[0]), C.int(count), C.double(yref), C.ImPlotShadedFlags(flags), C.int(offset), C.int(stride))

	label_idFin()

	for i, xsV := range xsArg {
		(*xs)[i] = int(xsV)
	}

	for i, ysV := range ysArg {
		(*ys)[i] = int(ysV)
	}
}

// PlotPlotShadedS16PtrS16PtrS16PtrV parameter default value hint:
// flags: 0
// offset: 0
// stride: sizeof(ImS16)
func PlotPlotShadedS16PtrS16PtrS16PtrV(label_id string, xs *[]int, ys1 *[]int, ys2 *[]int, count int32, flags PlotShadedFlags, offset int32, stride int32) {
	label_idArg, label_idFin := WrapString(label_id)
	xsArg := make([]C.ImS16, len(*xs))
	for i, xsV := range *xs {
		xsArg[i] = C.ImS16(xsV)
	}

	ys1Arg := make([]C.ImS16, len(*ys1))
	for i, ys1V := range *ys1 {
		ys1Arg[i] = C.ImS16(ys1V)
	}

	ys2Arg := make([]C.ImS16, len(*ys2))
	for i, ys2V := range *ys2 {
		ys2Arg[i] = C.ImS16(ys2V)
	}

	C.ImPlot_PlotShaded_S16PtrS16PtrS16Ptr(label_idArg, (*C.ImS16)(&xsArg[0]), (*C.ImS16)(&ys1Arg[0]), (*C.ImS16)(&ys2Arg[0]), C.int(count), C.ImPlotShadedFlags(flags), C.int(offset), C.int(stride))

	label_idFin()

	for i, xsV := range xsArg {
		(*xs)[i] = int(xsV)
	}

	for i, ys1V := range ys1Arg {
		(*ys1)[i] = int(ys1V)
	}

	for i, ys2V := range ys2Arg {
		(*ys2)[i] = int(ys2V)
	}
}

// PlotPlotShadedS32PtrIntV parameter default value hint:
// yref: 0
// xscale: 1
// xstart: 0
// flags: 0
// offset: 0
// stride: sizeof(ImS32)
func PlotPlotShadedS32PtrIntV(label_id string, values *[]int32, count int32, yref float64, xscale float64, xstart float64, flags PlotShadedFlags, offset int32, stride int32) {
	label_idArg, label_idFin := WrapString(label_id)
	valuesArg := make([]C.ImS32, len(*values))
	for i, valuesV := range *values {
		valuesArg[i] = C.ImS32(valuesV)
	}

	C.ImPlot_PlotShaded_S32PtrInt(label_idArg, (*C.ImS32)(&valuesArg[0]), C.int(count), C.double(yref), C.double(xscale), C.double(xstart), C.ImPlotShadedFlags(flags), C.int(offset), C.int(stride))

	label_idFin()

	for i, valuesV := range valuesArg {
		(*values)[i] = int32(valuesV)
	}
}

// PlotPlotShadedS32PtrS32PtrIntV parameter default value hint:
// yref: 0
// flags: 0
// offset: 0
// stride: sizeof(ImS32)
func PlotPlotShadedS32PtrS32PtrIntV(label_id string, xs *[]int32, ys *[]int32, count int32, yref float64, flags PlotShadedFlags, offset int32, stride int32) {
	label_idArg, label_idFin := WrapString(label_id)
	xsArg := make([]C.ImS32, len(*xs))
	for i, xsV := range *xs {
		xsArg[i] = C.ImS32(xsV)
	}

	ysArg := make([]C.ImS32, len(*ys))
	for i, ysV := range *ys {
		ysArg[i] = C.ImS32(ysV)
	}

	C.ImPlot_PlotShaded_S32PtrS32PtrInt(label_idArg, (*C.ImS32)(&xsArg[0]), (*C.ImS32)(&ysArg[0]), C.int(count), C.double(yref), C.ImPlotShadedFlags(flags), C.int(offset), C.int(stride))

	label_idFin()

	for i, xsV := range xsArg {
		(*xs)[i] = int32(xsV)
	}

	for i, ysV := range ysArg {
		(*ys)[i] = int32(ysV)
	}
}

// PlotPlotShadedS32PtrS32PtrS32PtrV parameter default value hint:
// flags: 0
// offset: 0
// stride: sizeof(ImS32)
func PlotPlotShadedS32PtrS32PtrS32PtrV(label_id string, xs *[]int32, ys1 *[]int32, ys2 *[]int32, count int32, flags PlotShadedFlags, offset int32, stride int32) {
	label_idArg, label_idFin := WrapString(label_id)
	xsArg := make([]C.ImS32, len(*xs))
	for i, xsV := range *xs {
		xsArg[i] = C.ImS32(xsV)
	}

	ys1Arg := make([]C.ImS32, len(*ys1))
	for i, ys1V := range *ys1 {
		ys1Arg[i] = C.ImS32(ys1V)
	}

	ys2Arg := make([]C.ImS32, len(*ys2))
	for i, ys2V := range *ys2 {
		ys2Arg[i] = C.ImS32(ys2V)
	}

	C.ImPlot_PlotShaded_S32PtrS32PtrS32Ptr(label_idArg, (*C.ImS32)(&xsArg[0]), (*C.ImS32)(&ys1Arg[0]), (*C.ImS32)(&ys2Arg[0]), C.int(count), C.ImPlotShadedFlags(flags), C.int(offset), C.int(stride))

	label_idFin()

	for i, xsV := range xsArg {
		(*xs)[i] = int32(xsV)
	}

	for i, ys1V := range ys1Arg {
		(*ys1)[i] = int32(ys1V)
	}

	for i, ys2V := range ys2Arg {
		(*ys2)[i] = int32(ys2V)
	}
}

// PlotPlotShadedS64PtrIntV parameter default value hint:
// yref: 0
// xscale: 1
// xstart: 0
// flags: 0
// offset: 0
// stride: sizeof(ImS64)
func PlotPlotShadedS64PtrIntV(label_id string, values []int64, count int32, yref float64, xscale float64, xstart float64, flags PlotShadedFlags, offset int32, stride int32) {
	label_idArg, label_idFin := WrapString(label_id)
	C.ImPlot_PlotShaded_S64PtrInt(label_idArg, (*C.longlong)(&(values[0])), C.int(count), C.double(yref), C.double(xscale), C.double(xstart), C.ImPlotShadedFlags(flags), C.int(offset), C.int(stride))

	label_idFin()
}

// PlotPlotShadedS64PtrS64PtrIntV parameter default value hint:
// yref: 0
// flags: 0
// offset: 0
// stride: sizeof(ImS64)
func PlotPlotShadedS64PtrS64PtrIntV(label_id string, xs []int64, ys []int64, count int32, yref float64, flags PlotShadedFlags, offset int32, stride int32) {
	label_idArg, label_idFin := WrapString(label_id)
	C.ImPlot_PlotShaded_S64PtrS64PtrInt(label_idArg, (*C.longlong)(&(xs[0])), (*C.longlong)(&(ys[0])), C.int(count), C.double(yref), C.ImPlotShadedFlags(flags), C.int(offset), C.int(stride))

	label_idFin()
}

// PlotPlotShadedS64PtrS64PtrS64PtrV parameter default value hint:
// flags: 0
// offset: 0
// stride: sizeof(ImS64)
func PlotPlotShadedS64PtrS64PtrS64PtrV(label_id string, xs []int64, ys1 []int64, ys2 []int64, count int32, flags PlotShadedFlags, offset int32, stride int32) {
	label_idArg, label_idFin := WrapString(label_id)
	C.ImPlot_PlotShaded_S64PtrS64PtrS64Ptr(label_idArg, (*C.longlong)(&(xs[0])), (*C.longlong)(&(ys1[0])), (*C.longlong)(&(ys2[0])), C.int(count), C.ImPlotShadedFlags(flags), C.int(offset), C.int(stride))

	label_idFin()
}

// PlotPlotShadedS8PtrIntV parameter default value hint:
// yref: 0
// xscale: 1
// xstart: 0
// flags: 0
// offset: 0
// stride: sizeof(ImS8)
func PlotPlotShadedS8PtrIntV(label_id string, values *[]int8, count int32, yref float64, xscale float64, xstart float64, flags PlotShadedFlags, offset int32, stride int32) {
	label_idArg, label_idFin := WrapString(label_id)
	valuesArg := make([]C.ImS8, len(*values))
	for i, valuesV := range *values {
		valuesArg[i] = C.ImS8(valuesV)
	}

	C.ImPlot_PlotShaded_S8PtrInt(label_idArg, (*C.ImS8)(&valuesArg[0]), C.int(count), C.double(yref), C.double(xscale), C.double(xstart), C.ImPlotShadedFlags(flags), C.int(offset), C.int(stride))

	label_idFin()

	for i, valuesV := range valuesArg {
		(*values)[i] = int8(valuesV)
	}
}

// PlotPlotShadedS8PtrS8PtrIntV parameter default value hint:
// yref: 0
// flags: 0
// offset: 0
// stride: sizeof(ImS8)
func PlotPlotShadedS8PtrS8PtrIntV(label_id string, xs *[]int8, ys *[]int8, count int32, yref float64, flags PlotShadedFlags, offset int32, stride int32) {
	label_idArg, label_idFin := WrapString(label_id)
	xsArg := make([]C.ImS8, len(*xs))
	for i, xsV := range *xs {
		xsArg[i] = C.ImS8(xsV)
	}

	ysArg := make([]C.ImS8, len(*ys))
	for i, ysV := range *ys {
		ysArg[i] = C.ImS8(ysV)
	}

	C.ImPlot_PlotShaded_S8PtrS8PtrInt(label_idArg, (*C.ImS8)(&xsArg[0]), (*C.ImS8)(&ysArg[0]), C.int(count), C.double(yref), C.ImPlotShadedFlags(flags), C.int(offset), C.int(stride))

	label_idFin()

	for i, xsV := range xsArg {
		(*xs)[i] = int8(xsV)
	}

	for i, ysV := range ysArg {
		(*ys)[i] = int8(ysV)
	}
}

// PlotPlotShadedS8PtrS8PtrS8PtrV parameter default value hint:
// flags: 0
// offset: 0
// stride: sizeof(ImS8)
func PlotPlotShadedS8PtrS8PtrS8PtrV(label_id string, xs *[]int8, ys1 *[]int8, ys2 *[]int8, count int32, flags PlotShadedFlags, offset int32, stride int32) {
	label_idArg, label_idFin := WrapString(label_id)
	xsArg := make([]C.ImS8, len(*xs))
	for i, xsV := range *xs {
		xsArg[i] = C.ImS8(xsV)
	}

	ys1Arg := make([]C.ImS8, len(*ys1))
	for i, ys1V := range *ys1 {
		ys1Arg[i] = C.ImS8(ys1V)
	}

	ys2Arg := make([]C.ImS8, len(*ys2))
	for i, ys2V := range *ys2 {
		ys2Arg[i] = C.ImS8(ys2V)
	}

	C.ImPlot_PlotShaded_S8PtrS8PtrS8Ptr(label_idArg, (*C.ImS8)(&xsArg[0]), (*C.ImS8)(&ys1Arg[0]), (*C.ImS8)(&ys2Arg[0]), C.int(count), C.ImPlotShadedFlags(flags), C.int(offset), C.int(stride))

	label_idFin()

	for i, xsV := range xsArg {
		(*xs)[i] = int8(xsV)
	}

	for i, ys1V := range ys1Arg {
		(*ys1)[i] = int8(ys1V)
	}

	for i, ys2V := range ys2Arg {
		(*ys2)[i] = int8(ys2V)
	}
}

// PlotPlotShadedU16PtrIntV parameter default value hint:
// yref: 0
// xscale: 1
// xstart: 0
// flags: 0
// offset: 0
// stride: sizeof(ImU16)
func PlotPlotShadedU16PtrIntV(label_id string, values *[]uint16, count int32, yref float64, xscale float64, xstart float64, flags PlotShadedFlags, offset int32, stride int32) {
	label_idArg, label_idFin := WrapString(label_id)
	valuesArg := make([]C.ImU16, len(*values))
	for i, valuesV := range *values {
		valuesArg[i] = C.ImU16(valuesV)
	}

	C.ImPlot_PlotShaded_U16PtrInt(label_idArg, (*C.ImU16)(&valuesArg[0]), C.int(count), C.double(yref), C.double(xscale), C.double(xstart), C.ImPlotShadedFlags(flags), C.int(offset), C.int(stride))

	label_idFin()

	for i, valuesV := range valuesArg {
		(*values)[i] = uint16(valuesV)
	}
}

// PlotPlotShadedU16PtrU16PtrIntV parameter default value hint:
// yref: 0
// flags: 0
// offset: 0
// stride: sizeof(ImU16)
func PlotPlotShadedU16PtrU16PtrIntV(label_id string, xs *[]uint16, ys *[]uint16, count int32, yref float64, flags PlotShadedFlags, offset int32, stride int32) {
	label_idArg, label_idFin := WrapString(label_id)
	xsArg := make([]C.ImU16, len(*xs))
	for i, xsV := range *xs {
		xsArg[i] = C.ImU16(xsV)
	}

	ysArg := make([]C.ImU16, len(*ys))
	for i, ysV := range *ys {
		ysArg[i] = C.ImU16(ysV)
	}

	C.ImPlot_PlotShaded_U16PtrU16PtrInt(label_idArg, (*C.ImU16)(&xsArg[0]), (*C.ImU16)(&ysArg[0]), C.int(count), C.double(yref), C.ImPlotShadedFlags(flags), C.int(offset), C.int(stride))

	label_idFin()

	for i, xsV := range xsArg {
		(*xs)[i] = uint16(xsV)
	}

	for i, ysV := range ysArg {
		(*ys)[i] = uint16(ysV)
	}
}

// PlotPlotShadedU16PtrU16PtrU16PtrV parameter default value hint:
// flags: 0
// offset: 0
// stride: sizeof(ImU16)
func PlotPlotShadedU16PtrU16PtrU16PtrV(label_id string, xs *[]uint16, ys1 *[]uint16, ys2 *[]uint16, count int32, flags PlotShadedFlags, offset int32, stride int32) {
	label_idArg, label_idFin := WrapString(label_id)
	xsArg := make([]C.ImU16, len(*xs))
	for i, xsV := range *xs {
		xsArg[i] = C.ImU16(xsV)
	}

	ys1Arg := make([]C.ImU16, len(*ys1))
	for i, ys1V := range *ys1 {
		ys1Arg[i] = C.ImU16(ys1V)
	}

	ys2Arg := make([]C.ImU16, len(*ys2))
	for i, ys2V := range *ys2 {
		ys2Arg[i] = C.ImU16(ys2V)
	}

	C.ImPlot_PlotShaded_U16PtrU16PtrU16Ptr(label_idArg, (*C.ImU16)(&xsArg[0]), (*C.ImU16)(&ys1Arg[0]), (*C.ImU16)(&ys2Arg[0]), C.int(count), C.ImPlotShadedFlags(flags), C.int(offset), C.int(stride))

	label_idFin()

	for i, xsV := range xsArg {
		(*xs)[i] = uint16(xsV)
	}

	for i, ys1V := range ys1Arg {
		(*ys1)[i] = uint16(ys1V)
	}

	for i, ys2V := range ys2Arg {
		(*ys2)[i] = uint16(ys2V)
	}
}

// PlotPlotShadedU32PtrIntV parameter default value hint:
// yref: 0
// xscale: 1
// xstart: 0
// flags: 0
// offset: 0
// stride: sizeof(ImU32)
func PlotPlotShadedU32PtrIntV(label_id string, values *[]uint32, count int32, yref float64, xscale float64, xstart float64, flags PlotShadedFlags, offset int32, stride int32) {
	label_idArg, label_idFin := WrapString(label_id)
	valuesArg := make([]C.ImU32, len(*values))
	for i, valuesV := range *values {
		valuesArg[i] = C.ImU32(valuesV)
	}

	C.ImPlot_PlotShaded_U32PtrInt(label_idArg, (*C.ImU32)(&valuesArg[0]), C.int(count), C.double(yref), C.double(xscale), C.double(xstart), C.ImPlotShadedFlags(flags), C.int(offset), C.int(stride))

	label_idFin()

	for i, valuesV := range valuesArg {
		(*values)[i] = uint32(valuesV)
	}
}

// PlotPlotShadedU32PtrU32PtrIntV parameter default value hint:
// yref: 0
// flags: 0
// offset: 0
// stride: sizeof(ImU32)
func PlotPlotShadedU32PtrU32PtrIntV(label_id string, xs *[]uint32, ys *[]uint32, count int32, yref float64, flags PlotShadedFlags, offset int32, stride int32) {
	label_idArg, label_idFin := WrapString(label_id)
	xsArg := make([]C.ImU32, len(*xs))
	for i, xsV := range *xs {
		xsArg[i] = C.ImU32(xsV)
	}

	ysArg := make([]C.ImU32, len(*ys))
	for i, ysV := range *ys {
		ysArg[i] = C.ImU32(ysV)
	}

	C.ImPlot_PlotShaded_U32PtrU32PtrInt(label_idArg, (*C.ImU32)(&xsArg[0]), (*C.ImU32)(&ysArg[0]), C.int(count), C.double(yref), C.ImPlotShadedFlags(flags), C.int(offset), C.int(stride))

	label_idFin()

	for i, xsV := range xsArg {
		(*xs)[i] = uint32(xsV)
	}

	for i, ysV := range ysArg {
		(*ys)[i] = uint32(ysV)
	}
}

// PlotPlotShadedU32PtrU32PtrU32PtrV parameter default value hint:
// flags: 0
// offset: 0
// stride: sizeof(ImU32)
func PlotPlotShadedU32PtrU32PtrU32PtrV(label_id string, xs *[]uint32, ys1 *[]uint32, ys2 *[]uint32, count int32, flags PlotShadedFlags, offset int32, stride int32) {
	label_idArg, label_idFin := WrapString(label_id)
	xsArg := make([]C.ImU32, len(*xs))
	for i, xsV := range *xs {
		xsArg[i] = C.ImU32(xsV)
	}

	ys1Arg := make([]C.ImU32, len(*ys1))
	for i, ys1V := range *ys1 {
		ys1Arg[i] = C.ImU32(ys1V)
	}

	ys2Arg := make([]C.ImU32, len(*ys2))
	for i, ys2V := range *ys2 {
		ys2Arg[i] = C.ImU32(ys2V)
	}

	C.ImPlot_PlotShaded_U32PtrU32PtrU32Ptr(label_idArg, (*C.ImU32)(&xsArg[0]), (*C.ImU32)(&ys1Arg[0]), (*C.ImU32)(&ys2Arg[0]), C.int(count), C.ImPlotShadedFlags(flags), C.int(offset), C.int(stride))

	label_idFin()

	for i, xsV := range xsArg {
		(*xs)[i] = uint32(xsV)
	}

	for i, ys1V := range ys1Arg {
		(*ys1)[i] = uint32(ys1V)
	}

	for i, ys2V := range ys2Arg {
		(*ys2)[i] = uint32(ys2V)
	}
}

// PlotPlotShadedU64PtrIntV parameter default value hint:
// yref: 0
// xscale: 1
// xstart: 0
// flags: 0
// offset: 0
// stride: sizeof(ImU64)
func PlotPlotShadedU64PtrIntV(label_id string, values []uint64, count int32, yref float64, xscale float64, xstart float64, flags PlotShadedFlags, offset int32, stride int32) {
	label_idArg, label_idFin := WrapString(label_id)
	C.ImPlot_PlotShaded_U64PtrInt(label_idArg, (*C.ulonglong)(&(values[0])), C.int(count), C.double(yref), C.double(xscale), C.double(xstart), C.ImPlotShadedFlags(flags), C.int(offset), C.int(stride))

	label_idFin()
}

// PlotPlotShadedU64PtrU64PtrIntV parameter default value hint:
// yref: 0
// flags: 0
// offset: 0
// stride: sizeof(ImU64)
func PlotPlotShadedU64PtrU64PtrIntV(label_id string, xs []uint64, ys []uint64, count int32, yref float64, flags PlotShadedFlags, offset int32, stride int32) {
	label_idArg, label_idFin := WrapString(label_id)
	C.ImPlot_PlotShaded_U64PtrU64PtrInt(label_idArg, (*C.ulonglong)(&(xs[0])), (*C.ulonglong)(&(ys[0])), C.int(count), C.double(yref), C.ImPlotShadedFlags(flags), C.int(offset), C.int(stride))

	label_idFin()
}

// PlotPlotShadedU64PtrU64PtrU64PtrV parameter default value hint:
// flags: 0
// offset: 0
// stride: sizeof(ImU64)
func PlotPlotShadedU64PtrU64PtrU64PtrV(label_id string, xs []uint64, ys1 []uint64, ys2 []uint64, count int32, flags PlotShadedFlags, offset int32, stride int32) {
	label_idArg, label_idFin := WrapString(label_id)
	C.ImPlot_PlotShaded_U64PtrU64PtrU64Ptr(label_idArg, (*C.ulonglong)(&(xs[0])), (*C.ulonglong)(&(ys1[0])), (*C.ulonglong)(&(ys2[0])), C.int(count), C.ImPlotShadedFlags(flags), C.int(offset), C.int(stride))

	label_idFin()
}

// PlotPlotShadedU8PtrIntV parameter default value hint:
// yref: 0
// xscale: 1
// xstart: 0
// flags: 0
// offset: 0
// stride: sizeof(ImU8)
func PlotPlotShadedU8PtrIntV(label_id string, values *[]byte, count int32, yref float64, xscale float64, xstart float64, flags PlotShadedFlags, offset int32, stride int32) {
	label_idArg, label_idFin := WrapString(label_id)
	valuesArg := make([]C.ImU8, len(*values))
	for i, valuesV := range *values {
		valuesArg[i] = C.ImU8(valuesV)
	}

	C.ImPlot_PlotShaded_U8PtrInt(label_idArg, (*C.ImU8)(&valuesArg[0]), C.int(count), C.double(yref), C.double(xscale), C.double(xstart), C.ImPlotShadedFlags(flags), C.int(offset), C.int(stride))

	label_idFin()

	for i, valuesV := range valuesArg {
		(*values)[i] = byte(valuesV)
	}
}

// PlotPlotShadedU8PtrU8PtrIntV parameter default value hint:
// yref: 0
// flags: 0
// offset: 0
// stride: sizeof(ImU8)
func PlotPlotShadedU8PtrU8PtrIntV(label_id string, xs *[]byte, ys *[]byte, count int32, yref float64, flags PlotShadedFlags, offset int32, stride int32) {
	label_idArg, label_idFin := WrapString(label_id)
	xsArg := make([]C.ImU8, len(*xs))
	for i, xsV := range *xs {
		xsArg[i] = C.ImU8(xsV)
	}

	ysArg := make([]C.ImU8, len(*ys))
	for i, ysV := range *ys {
		ysArg[i] = C.ImU8(ysV)
	}

	C.ImPlot_PlotShaded_U8PtrU8PtrInt(label_idArg, (*C.ImU8)(&xsArg[0]), (*C.ImU8)(&ysArg[0]), C.int(count), C.double(yref), C.ImPlotShadedFlags(flags), C.int(offset), C.int(stride))

	label_idFin()

	for i, xsV := range xsArg {
		(*xs)[i] = byte(xsV)
	}

	for i, ysV := range ysArg {
		(*ys)[i] = byte(ysV)
	}
}

// PlotPlotShadedU8PtrU8PtrU8PtrV parameter default value hint:
// flags: 0
// offset: 0
// stride: sizeof(ImU8)
func PlotPlotShadedU8PtrU8PtrU8PtrV(label_id string, xs *[]byte, ys1 *[]byte, ys2 *[]byte, count int32, flags PlotShadedFlags, offset int32, stride int32) {
	label_idArg, label_idFin := WrapString(label_id)
	xsArg := make([]C.ImU8, len(*xs))
	for i, xsV := range *xs {
		xsArg[i] = C.ImU8(xsV)
	}

	ys1Arg := make([]C.ImU8, len(*ys1))
	for i, ys1V := range *ys1 {
		ys1Arg[i] = C.ImU8(ys1V)
	}

	ys2Arg := make([]C.ImU8, len(*ys2))
	for i, ys2V := range *ys2 {
		ys2Arg[i] = C.ImU8(ys2V)
	}

	C.ImPlot_PlotShaded_U8PtrU8PtrU8Ptr(label_idArg, (*C.ImU8)(&xsArg[0]), (*C.ImU8)(&ys1Arg[0]), (*C.ImU8)(&ys2Arg[0]), C.int(count), C.ImPlotShadedFlags(flags), C.int(offset), C.int(stride))

	label_idFin()

	for i, xsV := range xsArg {
		(*xs)[i] = byte(xsV)
	}

	for i, ys1V := range ys1Arg {
		(*ys1)[i] = byte(ys1V)
	}

	for i, ys2V := range ys2Arg {
		(*ys2)[i] = byte(ys2V)
	}
}

// PlotPlotShadeddoublePtrIntV parameter default value hint:
// yref: 0
// xscale: 1
// xstart: 0
// flags: 0
// offset: 0
// stride: sizeof(double)
func PlotPlotShadeddoublePtrIntV(label_id string, values *[]float64, count int32, yref float64, xscale float64, xstart float64, flags PlotShadedFlags, offset int32, stride int32) {
	label_idArg, label_idFin := WrapString(label_id)
	valuesArg := make([]C.double, len(*values))
	for i, valuesV := range *values {
		valuesArg[i] = C.double(valuesV)
	}

	C.ImPlot_PlotShaded_doublePtrInt(label_idArg, (*C.double)(&valuesArg[0]), C.int(count), C.double(yref), C.double(xscale), C.double(xstart), C.ImPlotShadedFlags(flags), C.int(offset), C.int(stride))

	label_idFin()

	for i, valuesV := range valuesArg {
		(*values)[i] = float64(valuesV)
	}
}

// PlotPlotShadeddoublePtrdoublePtrIntV parameter default value hint:
// yref: 0
// flags: 0
// offset: 0
// stride: sizeof(double)
func PlotPlotShadeddoublePtrdoublePtrIntV(label_id string, xs *[]float64, ys *[]float64, count int32, yref float64, flags PlotShadedFlags, offset int32, stride int32) {
	label_idArg, label_idFin := WrapString(label_id)
	xsArg := make([]C.double, len(*xs))
	for i, xsV := range *xs {
		xsArg[i] = C.double(xsV)
	}

	ysArg := make([]C.double, len(*ys))
	for i, ysV := range *ys {
		ysArg[i] = C.double(ysV)
	}

	C.ImPlot_PlotShaded_doublePtrdoublePtrInt(label_idArg, (*C.double)(&xsArg[0]), (*C.double)(&ysArg[0]), C.int(count), C.double(yref), C.ImPlotShadedFlags(flags), C.int(offset), C.int(stride))

	label_idFin()

	for i, xsV := range xsArg {
		(*xs)[i] = float64(xsV)
	}

	for i, ysV := range ysArg {
		(*ys)[i] = float64(ysV)
	}
}

// PlotPlotShadeddoublePtrdoublePtrdoublePtrV parameter default value hint:
// flags: 0
// offset: 0
// stride: sizeof(double)
func PlotPlotShadeddoublePtrdoublePtrdoublePtrV(label_id string, xs *[]float64, ys1 *[]float64, ys2 *[]float64, count int32, flags PlotShadedFlags, offset int32, stride int32) {
	label_idArg, label_idFin := WrapString(label_id)
	xsArg := make([]C.double, len(*xs))
	for i, xsV := range *xs {
		xsArg[i] = C.double(xsV)
	}

	ys1Arg := make([]C.double, len(*ys1))
	for i, ys1V := range *ys1 {
		ys1Arg[i] = C.double(ys1V)
	}

	ys2Arg := make([]C.double, len(*ys2))
	for i, ys2V := range *ys2 {
		ys2Arg[i] = C.double(ys2V)
	}

	C.ImPlot_PlotShaded_doublePtrdoublePtrdoublePtr(label_idArg, (*C.double)(&xsArg[0]), (*C.double)(&ys1Arg[0]), (*C.double)(&ys2Arg[0]), C.int(count), C.ImPlotShadedFlags(flags), C.int(offset), C.int(stride))

	label_idFin()

	for i, xsV := range xsArg {
		(*xs)[i] = float64(xsV)
	}

	for i, ys1V := range ys1Arg {
		(*ys1)[i] = float64(ys1V)
	}

	for i, ys2V := range ys2Arg {
		(*ys2)[i] = float64(ys2V)
	}
}

// PlotPlotStairsFloatPtrFloatPtrV parameter default value hint:
// flags: 0
// offset: 0
// stride: sizeof(float)
func PlotPlotStairsFloatPtrFloatPtrV(label_id string, xs []float32, ys []float32, count int32, flags PlotStairsFlags, offset int32, stride int32) {
	label_idArg, label_idFin := WrapString(label_id)
	C.ImPlot_PlotStairs_FloatPtrFloatPtr(label_idArg, (*C.float)(&(xs[0])), (*C.float)(&(ys[0])), C.int(count), C.ImPlotStairsFlags(flags), C.int(offset), C.int(stride))

	label_idFin()
}

// PlotPlotStairsFloatPtrIntV parameter default value hint:
// xscale: 1
// xstart: 0
// flags: 0
// offset: 0
// stride: sizeof(float)
func PlotPlotStairsFloatPtrIntV(label_id string, values []float32, count int32, xscale float64, xstart float64, flags PlotStairsFlags, offset int32, stride int32) {
	label_idArg, label_idFin := WrapString(label_id)
	C.ImPlot_PlotStairs_FloatPtrInt(label_idArg, (*C.float)(&(values[0])), C.int(count), C.double(xscale), C.double(xstart), C.ImPlotStairsFlags(flags), C.int(offset), C.int(stride))

	label_idFin()
}

// PlotPlotStairsS16PtrIntV parameter default value hint:
// xscale: 1
// xstart: 0
// flags: 0
// offset: 0
// stride: sizeof(ImS16)
func PlotPlotStairsS16PtrIntV(label_id string, values *[]int, count int32, xscale float64, xstart float64, flags PlotStairsFlags, offset int32, stride int32) {
	label_idArg, label_idFin := WrapString(label_id)
	valuesArg := make([]C.ImS16, len(*values))
	for i, valuesV := range *values {
		valuesArg[i] = C.ImS16(valuesV)
	}

	C.ImPlot_PlotStairs_S16PtrInt(label_idArg, (*C.ImS16)(&valuesArg[0]), C.int(count), C.double(xscale), C.double(xstart), C.ImPlotStairsFlags(flags), C.int(offset), C.int(stride))

	label_idFin()

	for i, valuesV := range valuesArg {
		(*values)[i] = int(valuesV)
	}
}

// PlotPlotStairsS16PtrS16PtrV parameter default value hint:
// flags: 0
// offset: 0
// stride: sizeof(ImS16)
func PlotPlotStairsS16PtrS16PtrV(label_id string, xs *[]int, ys *[]int, count int32, flags PlotStairsFlags, offset int32, stride int32) {
	label_idArg, label_idFin := WrapString(label_id)
	xsArg := make([]C.ImS16, len(*xs))
	for i, xsV := range *xs {
		xsArg[i] = C.ImS16(xsV)
	}

	ysArg := make([]C.ImS16, len(*ys))
	for i, ysV := range *ys {
		ysArg[i] = C.ImS16(ysV)
	}

	C.ImPlot_PlotStairs_S16PtrS16Ptr(label_idArg, (*C.ImS16)(&xsArg[0]), (*C.ImS16)(&ysArg[0]), C.int(count), C.ImPlotStairsFlags(flags), C.int(offset), C.int(stride))

	label_idFin()

	for i, xsV := range xsArg {
		(*xs)[i] = int(xsV)
	}

	for i, ysV := range ysArg {
		(*ys)[i] = int(ysV)
	}
}

// PlotPlotStairsS32PtrIntV parameter default value hint:
// xscale: 1
// xstart: 0
// flags: 0
// offset: 0
// stride: sizeof(ImS32)
func PlotPlotStairsS32PtrIntV(label_id string, values *[]int32, count int32, xscale float64, xstart float64, flags PlotStairsFlags, offset int32, stride int32) {
	label_idArg, label_idFin := WrapString(label_id)
	valuesArg := make([]C.ImS32, len(*values))
	for i, valuesV := range *values {
		valuesArg[i] = C.ImS32(valuesV)
	}

	C.ImPlot_PlotStairs_S32PtrInt(label_idArg, (*C.ImS32)(&valuesArg[0]), C.int(count), C.double(xscale), C.double(xstart), C.ImPlotStairsFlags(flags), C.int(offset), C.int(stride))

	label_idFin()

	for i, valuesV := range valuesArg {
		(*values)[i] = int32(valuesV)
	}
}

// PlotPlotStairsS32PtrS32PtrV parameter default value hint:
// flags: 0
// offset: 0
// stride: sizeof(ImS32)
func PlotPlotStairsS32PtrS32PtrV(label_id string, xs *[]int32, ys *[]int32, count int32, flags PlotStairsFlags, offset int32, stride int32) {
	label_idArg, label_idFin := WrapString(label_id)
	xsArg := make([]C.ImS32, len(*xs))
	for i, xsV := range *xs {
		xsArg[i] = C.ImS32(xsV)
	}

	ysArg := make([]C.ImS32, len(*ys))
	for i, ysV := range *ys {
		ysArg[i] = C.ImS32(ysV)
	}

	C.ImPlot_PlotStairs_S32PtrS32Ptr(label_idArg, (*C.ImS32)(&xsArg[0]), (*C.ImS32)(&ysArg[0]), C.int(count), C.ImPlotStairsFlags(flags), C.int(offset), C.int(stride))

	label_idFin()

	for i, xsV := range xsArg {
		(*xs)[i] = int32(xsV)
	}

	for i, ysV := range ysArg {
		(*ys)[i] = int32(ysV)
	}
}

// PlotPlotStairsS64PtrIntV parameter default value hint:
// xscale: 1
// xstart: 0
// flags: 0
// offset: 0
// stride: sizeof(ImS64)
func PlotPlotStairsS64PtrIntV(label_id string, values []int64, count int32, xscale float64, xstart float64, flags PlotStairsFlags, offset int32, stride int32) {
	label_idArg, label_idFin := WrapString(label_id)
	C.ImPlot_PlotStairs_S64PtrInt(label_idArg, (*C.longlong)(&(values[0])), C.int(count), C.double(xscale), C.double(xstart), C.ImPlotStairsFlags(flags), C.int(offset), C.int(stride))

	label_idFin()
}

// PlotPlotStairsS64PtrS64PtrV parameter default value hint:
// flags: 0
// offset: 0
// stride: sizeof(ImS64)
func PlotPlotStairsS64PtrS64PtrV(label_id string, xs []int64, ys []int64, count int32, flags PlotStairsFlags, offset int32, stride int32) {
	label_idArg, label_idFin := WrapString(label_id)
	C.ImPlot_PlotStairs_S64PtrS64Ptr(label_idArg, (*C.longlong)(&(xs[0])), (*C.longlong)(&(ys[0])), C.int(count), C.ImPlotStairsFlags(flags), C.int(offset), C.int(stride))

	label_idFin()
}

// PlotPlotStairsS8PtrIntV parameter default value hint:
// xscale: 1
// xstart: 0
// flags: 0
// offset: 0
// stride: sizeof(ImS8)
func PlotPlotStairsS8PtrIntV(label_id string, values *[]int8, count int32, xscale float64, xstart float64, flags PlotStairsFlags, offset int32, stride int32) {
	label_idArg, label_idFin := WrapString(label_id)
	valuesArg := make([]C.ImS8, len(*values))
	for i, valuesV := range *values {
		valuesArg[i] = C.ImS8(valuesV)
	}

	C.ImPlot_PlotStairs_S8PtrInt(label_idArg, (*C.ImS8)(&valuesArg[0]), C.int(count), C.double(xscale), C.double(xstart), C.ImPlotStairsFlags(flags), C.int(offset), C.int(stride))

	label_idFin()

	for i, valuesV := range valuesArg {
		(*values)[i] = int8(valuesV)
	}
}

// PlotPlotStairsS8PtrS8PtrV parameter default value hint:
// flags: 0
// offset: 0
// stride: sizeof(ImS8)
func PlotPlotStairsS8PtrS8PtrV(label_id string, xs *[]int8, ys *[]int8, count int32, flags PlotStairsFlags, offset int32, stride int32) {
	label_idArg, label_idFin := WrapString(label_id)
	xsArg := make([]C.ImS8, len(*xs))
	for i, xsV := range *xs {
		xsArg[i] = C.ImS8(xsV)
	}

	ysArg := make([]C.ImS8, len(*ys))
	for i, ysV := range *ys {
		ysArg[i] = C.ImS8(ysV)
	}

	C.ImPlot_PlotStairs_S8PtrS8Ptr(label_idArg, (*C.ImS8)(&xsArg[0]), (*C.ImS8)(&ysArg[0]), C.int(count), C.ImPlotStairsFlags(flags), C.int(offset), C.int(stride))

	label_idFin()

	for i, xsV := range xsArg {
		(*xs)[i] = int8(xsV)
	}

	for i, ysV := range ysArg {
		(*ys)[i] = int8(ysV)
	}
}

// PlotPlotStairsU16PtrIntV parameter default value hint:
// xscale: 1
// xstart: 0
// flags: 0
// offset: 0
// stride: sizeof(ImU16)
func PlotPlotStairsU16PtrIntV(label_id string, values *[]uint16, count int32, xscale float64, xstart float64, flags PlotStairsFlags, offset int32, stride int32) {
	label_idArg, label_idFin := WrapString(label_id)
	valuesArg := make([]C.ImU16, len(*values))
	for i, valuesV := range *values {
		valuesArg[i] = C.ImU16(valuesV)
	}

	C.ImPlot_PlotStairs_U16PtrInt(label_idArg, (*C.ImU16)(&valuesArg[0]), C.int(count), C.double(xscale), C.double(xstart), C.ImPlotStairsFlags(flags), C.int(offset), C.int(stride))

	label_idFin()

	for i, valuesV := range valuesArg {
		(*values)[i] = uint16(valuesV)
	}
}

// PlotPlotStairsU16PtrU16PtrV parameter default value hint:
// flags: 0
// offset: 0
// stride: sizeof(ImU16)
func PlotPlotStairsU16PtrU16PtrV(label_id string, xs *[]uint16, ys *[]uint16, count int32, flags PlotStairsFlags, offset int32, stride int32) {
	label_idArg, label_idFin := WrapString(label_id)
	xsArg := make([]C.ImU16, len(*xs))
	for i, xsV := range *xs {
		xsArg[i] = C.ImU16(xsV)
	}

	ysArg := make([]C.ImU16, len(*ys))
	for i, ysV := range *ys {
		ysArg[i] = C.ImU16(ysV)
	}

	C.ImPlot_PlotStairs_U16PtrU16Ptr(label_idArg, (*C.ImU16)(&xsArg[0]), (*C.ImU16)(&ysArg[0]), C.int(count), C.ImPlotStairsFlags(flags), C.int(offset), C.int(stride))

	label_idFin()

	for i, xsV := range xsArg {
		(*xs)[i] = uint16(xsV)
	}

	for i, ysV := range ysArg {
		(*ys)[i] = uint16(ysV)
	}
}

// PlotPlotStairsU32PtrIntV parameter default value hint:
// xscale: 1
// xstart: 0
// flags: 0
// offset: 0
// stride: sizeof(ImU32)
func PlotPlotStairsU32PtrIntV(label_id string, values *[]uint32, count int32, xscale float64, xstart float64, flags PlotStairsFlags, offset int32, stride int32) {
	label_idArg, label_idFin := WrapString(label_id)
	valuesArg := make([]C.ImU32, len(*values))
	for i, valuesV := range *values {
		valuesArg[i] = C.ImU32(valuesV)
	}

	C.ImPlot_PlotStairs_U32PtrInt(label_idArg, (*C.ImU32)(&valuesArg[0]), C.int(count), C.double(xscale), C.double(xstart), C.ImPlotStairsFlags(flags), C.int(offset), C.int(stride))

	label_idFin()

	for i, valuesV := range valuesArg {
		(*values)[i] = uint32(valuesV)
	}
}

// PlotPlotStairsU32PtrU32PtrV parameter default value hint:
// flags: 0
// offset: 0
// stride: sizeof(ImU32)
func PlotPlotStairsU32PtrU32PtrV(label_id string, xs *[]uint32, ys *[]uint32, count int32, flags PlotStairsFlags, offset int32, stride int32) {
	label_idArg, label_idFin := WrapString(label_id)
	xsArg := make([]C.ImU32, len(*xs))
	for i, xsV := range *xs {
		xsArg[i] = C.ImU32(xsV)
	}

	ysArg := make([]C.ImU32, len(*ys))
	for i, ysV := range *ys {
		ysArg[i] = C.ImU32(ysV)
	}

	C.ImPlot_PlotStairs_U32PtrU32Ptr(label_idArg, (*C.ImU32)(&xsArg[0]), (*C.ImU32)(&ysArg[0]), C.int(count), C.ImPlotStairsFlags(flags), C.int(offset), C.int(stride))

	label_idFin()

	for i, xsV := range xsArg {
		(*xs)[i] = uint32(xsV)
	}

	for i, ysV := range ysArg {
		(*ys)[i] = uint32(ysV)
	}
}

// PlotPlotStairsU64PtrIntV parameter default value hint:
// xscale: 1
// xstart: 0
// flags: 0
// offset: 0
// stride: sizeof(ImU64)
func PlotPlotStairsU64PtrIntV(label_id string, values []uint64, count int32, xscale float64, xstart float64, flags PlotStairsFlags, offset int32, stride int32) {
	label_idArg, label_idFin := WrapString(label_id)
	C.ImPlot_PlotStairs_U64PtrInt(label_idArg, (*C.ulonglong)(&(values[0])), C.int(count), C.double(xscale), C.double(xstart), C.ImPlotStairsFlags(flags), C.int(offset), C.int(stride))

	label_idFin()
}

// PlotPlotStairsU64PtrU64PtrV parameter default value hint:
// flags: 0
// offset: 0
// stride: sizeof(ImU64)
func PlotPlotStairsU64PtrU64PtrV(label_id string, xs []uint64, ys []uint64, count int32, flags PlotStairsFlags, offset int32, stride int32) {
	label_idArg, label_idFin := WrapString(label_id)
	C.ImPlot_PlotStairs_U64PtrU64Ptr(label_idArg, (*C.ulonglong)(&(xs[0])), (*C.ulonglong)(&(ys[0])), C.int(count), C.ImPlotStairsFlags(flags), C.int(offset), C.int(stride))

	label_idFin()
}

// PlotPlotStairsU8PtrIntV parameter default value hint:
// xscale: 1
// xstart: 0
// flags: 0
// offset: 0
// stride: sizeof(ImU8)
func PlotPlotStairsU8PtrIntV(label_id string, values *[]byte, count int32, xscale float64, xstart float64, flags PlotStairsFlags, offset int32, stride int32) {
	label_idArg, label_idFin := WrapString(label_id)
	valuesArg := make([]C.ImU8, len(*values))
	for i, valuesV := range *values {
		valuesArg[i] = C.ImU8(valuesV)
	}

	C.ImPlot_PlotStairs_U8PtrInt(label_idArg, (*C.ImU8)(&valuesArg[0]), C.int(count), C.double(xscale), C.double(xstart), C.ImPlotStairsFlags(flags), C.int(offset), C.int(stride))

	label_idFin()

	for i, valuesV := range valuesArg {
		(*values)[i] = byte(valuesV)
	}
}

// PlotPlotStairsU8PtrU8PtrV parameter default value hint:
// flags: 0
// offset: 0
// stride: sizeof(ImU8)
func PlotPlotStairsU8PtrU8PtrV(label_id string, xs *[]byte, ys *[]byte, count int32, flags PlotStairsFlags, offset int32, stride int32) {
	label_idArg, label_idFin := WrapString(label_id)
	xsArg := make([]C.ImU8, len(*xs))
	for i, xsV := range *xs {
		xsArg[i] = C.ImU8(xsV)
	}

	ysArg := make([]C.ImU8, len(*ys))
	for i, ysV := range *ys {
		ysArg[i] = C.ImU8(ysV)
	}

	C.ImPlot_PlotStairs_U8PtrU8Ptr(label_idArg, (*C.ImU8)(&xsArg[0]), (*C.ImU8)(&ysArg[0]), C.int(count), C.ImPlotStairsFlags(flags), C.int(offset), C.int(stride))

	label_idFin()

	for i, xsV := range xsArg {
		(*xs)[i] = byte(xsV)
	}

	for i, ysV := range ysArg {
		(*ys)[i] = byte(ysV)
	}
}

// PlotPlotStairsdoublePtrIntV parameter default value hint:
// xscale: 1
// xstart: 0
// flags: 0
// offset: 0
// stride: sizeof(double)
func PlotPlotStairsdoublePtrIntV(label_id string, values *[]float64, count int32, xscale float64, xstart float64, flags PlotStairsFlags, offset int32, stride int32) {
	label_idArg, label_idFin := WrapString(label_id)
	valuesArg := make([]C.double, len(*values))
	for i, valuesV := range *values {
		valuesArg[i] = C.double(valuesV)
	}

	C.ImPlot_PlotStairs_doublePtrInt(label_idArg, (*C.double)(&valuesArg[0]), C.int(count), C.double(xscale), C.double(xstart), C.ImPlotStairsFlags(flags), C.int(offset), C.int(stride))

	label_idFin()

	for i, valuesV := range valuesArg {
		(*values)[i] = float64(valuesV)
	}
}

// PlotPlotStairsdoublePtrdoublePtrV parameter default value hint:
// flags: 0
// offset: 0
// stride: sizeof(double)
func PlotPlotStairsdoublePtrdoublePtrV(label_id string, xs *[]float64, ys *[]float64, count int32, flags PlotStairsFlags, offset int32, stride int32) {
	label_idArg, label_idFin := WrapString(label_id)
	xsArg := make([]C.double, len(*xs))
	for i, xsV := range *xs {
		xsArg[i] = C.double(xsV)
	}

	ysArg := make([]C.double, len(*ys))
	for i, ysV := range *ys {
		ysArg[i] = C.double(ysV)
	}

	C.ImPlot_PlotStairs_doublePtrdoublePtr(label_idArg, (*C.double)(&xsArg[0]), (*C.double)(&ysArg[0]), C.int(count), C.ImPlotStairsFlags(flags), C.int(offset), C.int(stride))

	label_idFin()

	for i, xsV := range xsArg {
		(*xs)[i] = float64(xsV)
	}

	for i, ysV := range ysArg {
		(*ys)[i] = float64(ysV)
	}
}

// PlotPlotStemsFloatPtrFloatPtrV parameter default value hint:
// ref: 0
// flags: 0
// offset: 0
// stride: sizeof(float)
func PlotPlotStemsFloatPtrFloatPtrV(label_id string, xs []float32, ys []float32, count int32, ref float64, flags PlotStemsFlags, offset int32, stride int32) {
	label_idArg, label_idFin := WrapString(label_id)
	C.ImPlot_PlotStems_FloatPtrFloatPtr(label_idArg, (*C.float)(&(xs[0])), (*C.float)(&(ys[0])), C.int(count), C.double(ref), C.ImPlotStemsFlags(flags), C.int(offset), C.int(stride))

	label_idFin()
}

// PlotPlotStemsFloatPtrIntV parameter default value hint:
// ref: 0
// scale: 1
// start: 0
// flags: 0
// offset: 0
// stride: sizeof(float)
func PlotPlotStemsFloatPtrIntV(label_id string, values []float32, count int32, ref float64, scale float64, start float64, flags PlotStemsFlags, offset int32, stride int32) {
	label_idArg, label_idFin := WrapString(label_id)
	C.ImPlot_PlotStems_FloatPtrInt(label_idArg, (*C.float)(&(values[0])), C.int(count), C.double(ref), C.double(scale), C.double(start), C.ImPlotStemsFlags(flags), C.int(offset), C.int(stride))

	label_idFin()
}

// PlotPlotStemsS16PtrIntV parameter default value hint:
// ref: 0
// scale: 1
// start: 0
// flags: 0
// offset: 0
// stride: sizeof(ImS16)
func PlotPlotStemsS16PtrIntV(label_id string, values *[]int, count int32, ref float64, scale float64, start float64, flags PlotStemsFlags, offset int32, stride int32) {
	label_idArg, label_idFin := WrapString(label_id)
	valuesArg := make([]C.ImS16, len(*values))
	for i, valuesV := range *values {
		valuesArg[i] = C.ImS16(valuesV)
	}

	C.ImPlot_PlotStems_S16PtrInt(label_idArg, (*C.ImS16)(&valuesArg[0]), C.int(count), C.double(ref), C.double(scale), C.double(start), C.ImPlotStemsFlags(flags), C.int(offset), C.int(stride))

	label_idFin()

	for i, valuesV := range valuesArg {
		(*values)[i] = int(valuesV)
	}
}

// PlotPlotStemsS16PtrS16PtrV parameter default value hint:
// ref: 0
// flags: 0
// offset: 0
// stride: sizeof(ImS16)
func PlotPlotStemsS16PtrS16PtrV(label_id string, xs *[]int, ys *[]int, count int32, ref float64, flags PlotStemsFlags, offset int32, stride int32) {
	label_idArg, label_idFin := WrapString(label_id)
	xsArg := make([]C.ImS16, len(*xs))
	for i, xsV := range *xs {
		xsArg[i] = C.ImS16(xsV)
	}

	ysArg := make([]C.ImS16, len(*ys))
	for i, ysV := range *ys {
		ysArg[i] = C.ImS16(ysV)
	}

	C.ImPlot_PlotStems_S16PtrS16Ptr(label_idArg, (*C.ImS16)(&xsArg[0]), (*C.ImS16)(&ysArg[0]), C.int(count), C.double(ref), C.ImPlotStemsFlags(flags), C.int(offset), C.int(stride))

	label_idFin()

	for i, xsV := range xsArg {
		(*xs)[i] = int(xsV)
	}

	for i, ysV := range ysArg {
		(*ys)[i] = int(ysV)
	}
}

// PlotPlotStemsS32PtrIntV parameter default value hint:
// ref: 0
// scale: 1
// start: 0
// flags: 0
// offset: 0
// stride: sizeof(ImS32)
func PlotPlotStemsS32PtrIntV(label_id string, values *[]int32, count int32, ref float64, scale float64, start float64, flags PlotStemsFlags, offset int32, stride int32) {
	label_idArg, label_idFin := WrapString(label_id)
	valuesArg := make([]C.ImS32, len(*values))
	for i, valuesV := range *values {
		valuesArg[i] = C.ImS32(valuesV)
	}

	C.ImPlot_PlotStems_S32PtrInt(label_idArg, (*C.ImS32)(&valuesArg[0]), C.int(count), C.double(ref), C.double(scale), C.double(start), C.ImPlotStemsFlags(flags), C.int(offset), C.int(stride))

	label_idFin()

	for i, valuesV := range valuesArg {
		(*values)[i] = int32(valuesV)
	}
}

// PlotPlotStemsS32PtrS32PtrV parameter default value hint:
// ref: 0
// flags: 0
// offset: 0
// stride: sizeof(ImS32)
func PlotPlotStemsS32PtrS32PtrV(label_id string, xs *[]int32, ys *[]int32, count int32, ref float64, flags PlotStemsFlags, offset int32, stride int32) {
	label_idArg, label_idFin := WrapString(label_id)
	xsArg := make([]C.ImS32, len(*xs))
	for i, xsV := range *xs {
		xsArg[i] = C.ImS32(xsV)
	}

	ysArg := make([]C.ImS32, len(*ys))
	for i, ysV := range *ys {
		ysArg[i] = C.ImS32(ysV)
	}

	C.ImPlot_PlotStems_S32PtrS32Ptr(label_idArg, (*C.ImS32)(&xsArg[0]), (*C.ImS32)(&ysArg[0]), C.int(count), C.double(ref), C.ImPlotStemsFlags(flags), C.int(offset), C.int(stride))

	label_idFin()

	for i, xsV := range xsArg {
		(*xs)[i] = int32(xsV)
	}

	for i, ysV := range ysArg {
		(*ys)[i] = int32(ysV)
	}
}

// PlotPlotStemsS64PtrIntV parameter default value hint:
// ref: 0
// scale: 1
// start: 0
// flags: 0
// offset: 0
// stride: sizeof(ImS64)
func PlotPlotStemsS64PtrIntV(label_id string, values []int64, count int32, ref float64, scale float64, start float64, flags PlotStemsFlags, offset int32, stride int32) {
	label_idArg, label_idFin := WrapString(label_id)
	C.ImPlot_PlotStems_S64PtrInt(label_idArg, (*C.longlong)(&(values[0])), C.int(count), C.double(ref), C.double(scale), C.double(start), C.ImPlotStemsFlags(flags), C.int(offset), C.int(stride))

	label_idFin()
}

// PlotPlotStemsS64PtrS64PtrV parameter default value hint:
// ref: 0
// flags: 0
// offset: 0
// stride: sizeof(ImS64)
func PlotPlotStemsS64PtrS64PtrV(label_id string, xs []int64, ys []int64, count int32, ref float64, flags PlotStemsFlags, offset int32, stride int32) {
	label_idArg, label_idFin := WrapString(label_id)
	C.ImPlot_PlotStems_S64PtrS64Ptr(label_idArg, (*C.longlong)(&(xs[0])), (*C.longlong)(&(ys[0])), C.int(count), C.double(ref), C.ImPlotStemsFlags(flags), C.int(offset), C.int(stride))

	label_idFin()
}

// PlotPlotStemsS8PtrIntV parameter default value hint:
// ref: 0
// scale: 1
// start: 0
// flags: 0
// offset: 0
// stride: sizeof(ImS8)
func PlotPlotStemsS8PtrIntV(label_id string, values *[]int8, count int32, ref float64, scale float64, start float64, flags PlotStemsFlags, offset int32, stride int32) {
	label_idArg, label_idFin := WrapString(label_id)
	valuesArg := make([]C.ImS8, len(*values))
	for i, valuesV := range *values {
		valuesArg[i] = C.ImS8(valuesV)
	}

	C.ImPlot_PlotStems_S8PtrInt(label_idArg, (*C.ImS8)(&valuesArg[0]), C.int(count), C.double(ref), C.double(scale), C.double(start), C.ImPlotStemsFlags(flags), C.int(offset), C.int(stride))

	label_idFin()

	for i, valuesV := range valuesArg {
		(*values)[i] = int8(valuesV)
	}
}

// PlotPlotStemsS8PtrS8PtrV parameter default value hint:
// ref: 0
// flags: 0
// offset: 0
// stride: sizeof(ImS8)
func PlotPlotStemsS8PtrS8PtrV(label_id string, xs *[]int8, ys *[]int8, count int32, ref float64, flags PlotStemsFlags, offset int32, stride int32) {
	label_idArg, label_idFin := WrapString(label_id)
	xsArg := make([]C.ImS8, len(*xs))
	for i, xsV := range *xs {
		xsArg[i] = C.ImS8(xsV)
	}

	ysArg := make([]C.ImS8, len(*ys))
	for i, ysV := range *ys {
		ysArg[i] = C.ImS8(ysV)
	}

	C.ImPlot_PlotStems_S8PtrS8Ptr(label_idArg, (*C.ImS8)(&xsArg[0]), (*C.ImS8)(&ysArg[0]), C.int(count), C.double(ref), C.ImPlotStemsFlags(flags), C.int(offset), C.int(stride))

	label_idFin()

	for i, xsV := range xsArg {
		(*xs)[i] = int8(xsV)
	}

	for i, ysV := range ysArg {
		(*ys)[i] = int8(ysV)
	}
}

// PlotPlotStemsU16PtrIntV parameter default value hint:
// ref: 0
// scale: 1
// start: 0
// flags: 0
// offset: 0
// stride: sizeof(ImU16)
func PlotPlotStemsU16PtrIntV(label_id string, values *[]uint16, count int32, ref float64, scale float64, start float64, flags PlotStemsFlags, offset int32, stride int32) {
	label_idArg, label_idFin := WrapString(label_id)
	valuesArg := make([]C.ImU16, len(*values))
	for i, valuesV := range *values {
		valuesArg[i] = C.ImU16(valuesV)
	}

	C.ImPlot_PlotStems_U16PtrInt(label_idArg, (*C.ImU16)(&valuesArg[0]), C.int(count), C.double(ref), C.double(scale), C.double(start), C.ImPlotStemsFlags(flags), C.int(offset), C.int(stride))

	label_idFin()

	for i, valuesV := range valuesArg {
		(*values)[i] = uint16(valuesV)
	}
}

// PlotPlotStemsU16PtrU16PtrV parameter default value hint:
// ref: 0
// flags: 0
// offset: 0
// stride: sizeof(ImU16)
func PlotPlotStemsU16PtrU16PtrV(label_id string, xs *[]uint16, ys *[]uint16, count int32, ref float64, flags PlotStemsFlags, offset int32, stride int32) {
	label_idArg, label_idFin := WrapString(label_id)
	xsArg := make([]C.ImU16, len(*xs))
	for i, xsV := range *xs {
		xsArg[i] = C.ImU16(xsV)
	}

	ysArg := make([]C.ImU16, len(*ys))
	for i, ysV := range *ys {
		ysArg[i] = C.ImU16(ysV)
	}

	C.ImPlot_PlotStems_U16PtrU16Ptr(label_idArg, (*C.ImU16)(&xsArg[0]), (*C.ImU16)(&ysArg[0]), C.int(count), C.double(ref), C.ImPlotStemsFlags(flags), C.int(offset), C.int(stride))

	label_idFin()

	for i, xsV := range xsArg {
		(*xs)[i] = uint16(xsV)
	}

	for i, ysV := range ysArg {
		(*ys)[i] = uint16(ysV)
	}
}

// PlotPlotStemsU32PtrIntV parameter default value hint:
// ref: 0
// scale: 1
// start: 0
// flags: 0
// offset: 0
// stride: sizeof(ImU32)
func PlotPlotStemsU32PtrIntV(label_id string, values *[]uint32, count int32, ref float64, scale float64, start float64, flags PlotStemsFlags, offset int32, stride int32) {
	label_idArg, label_idFin := WrapString(label_id)
	valuesArg := make([]C.ImU32, len(*values))
	for i, valuesV := range *values {
		valuesArg[i] = C.ImU32(valuesV)
	}

	C.ImPlot_PlotStems_U32PtrInt(label_idArg, (*C.ImU32)(&valuesArg[0]), C.int(count), C.double(ref), C.double(scale), C.double(start), C.ImPlotStemsFlags(flags), C.int(offset), C.int(stride))

	label_idFin()

	for i, valuesV := range valuesArg {
		(*values)[i] = uint32(valuesV)
	}
}

// PlotPlotStemsU32PtrU32PtrV parameter default value hint:
// ref: 0
// flags: 0
// offset: 0
// stride: sizeof(ImU32)
func PlotPlotStemsU32PtrU32PtrV(label_id string, xs *[]uint32, ys *[]uint32, count int32, ref float64, flags PlotStemsFlags, offset int32, stride int32) {
	label_idArg, label_idFin := WrapString(label_id)
	xsArg := make([]C.ImU32, len(*xs))
	for i, xsV := range *xs {
		xsArg[i] = C.ImU32(xsV)
	}

	ysArg := make([]C.ImU32, len(*ys))
	for i, ysV := range *ys {
		ysArg[i] = C.ImU32(ysV)
	}

	C.ImPlot_PlotStems_U32PtrU32Ptr(label_idArg, (*C.ImU32)(&xsArg[0]), (*C.ImU32)(&ysArg[0]), C.int(count), C.double(ref), C.ImPlotStemsFlags(flags), C.int(offset), C.int(stride))

	label_idFin()

	for i, xsV := range xsArg {
		(*xs)[i] = uint32(xsV)
	}

	for i, ysV := range ysArg {
		(*ys)[i] = uint32(ysV)
	}
}

// PlotPlotStemsU64PtrIntV parameter default value hint:
// ref: 0
// scale: 1
// start: 0
// flags: 0
// offset: 0
// stride: sizeof(ImU64)
func PlotPlotStemsU64PtrIntV(label_id string, values []uint64, count int32, ref float64, scale float64, start float64, flags PlotStemsFlags, offset int32, stride int32) {
	label_idArg, label_idFin := WrapString(label_id)
	C.ImPlot_PlotStems_U64PtrInt(label_idArg, (*C.ulonglong)(&(values[0])), C.int(count), C.double(ref), C.double(scale), C.double(start), C.ImPlotStemsFlags(flags), C.int(offset), C.int(stride))

	label_idFin()
}

// PlotPlotStemsU64PtrU64PtrV parameter default value hint:
// ref: 0
// flags: 0
// offset: 0
// stride: sizeof(ImU64)
func PlotPlotStemsU64PtrU64PtrV(label_id string, xs []uint64, ys []uint64, count int32, ref float64, flags PlotStemsFlags, offset int32, stride int32) {
	label_idArg, label_idFin := WrapString(label_id)
	C.ImPlot_PlotStems_U64PtrU64Ptr(label_idArg, (*C.ulonglong)(&(xs[0])), (*C.ulonglong)(&(ys[0])), C.int(count), C.double(ref), C.ImPlotStemsFlags(flags), C.int(offset), C.int(stride))

	label_idFin()
}

// PlotPlotStemsU8PtrIntV parameter default value hint:
// ref: 0
// scale: 1
// start: 0
// flags: 0
// offset: 0
// stride: sizeof(ImU8)
func PlotPlotStemsU8PtrIntV(label_id string, values *[]byte, count int32, ref float64, scale float64, start float64, flags PlotStemsFlags, offset int32, stride int32) {
	label_idArg, label_idFin := WrapString(label_id)
	valuesArg := make([]C.ImU8, len(*values))
	for i, valuesV := range *values {
		valuesArg[i] = C.ImU8(valuesV)
	}

	C.ImPlot_PlotStems_U8PtrInt(label_idArg, (*C.ImU8)(&valuesArg[0]), C.int(count), C.double(ref), C.double(scale), C.double(start), C.ImPlotStemsFlags(flags), C.int(offset), C.int(stride))

	label_idFin()

	for i, valuesV := range valuesArg {
		(*values)[i] = byte(valuesV)
	}
}

// PlotPlotStemsU8PtrU8PtrV parameter default value hint:
// ref: 0
// flags: 0
// offset: 0
// stride: sizeof(ImU8)
func PlotPlotStemsU8PtrU8PtrV(label_id string, xs *[]byte, ys *[]byte, count int32, ref float64, flags PlotStemsFlags, offset int32, stride int32) {
	label_idArg, label_idFin := WrapString(label_id)
	xsArg := make([]C.ImU8, len(*xs))
	for i, xsV := range *xs {
		xsArg[i] = C.ImU8(xsV)
	}

	ysArg := make([]C.ImU8, len(*ys))
	for i, ysV := range *ys {
		ysArg[i] = C.ImU8(ysV)
	}

	C.ImPlot_PlotStems_U8PtrU8Ptr(label_idArg, (*C.ImU8)(&xsArg[0]), (*C.ImU8)(&ysArg[0]), C.int(count), C.double(ref), C.ImPlotStemsFlags(flags), C.int(offset), C.int(stride))

	label_idFin()

	for i, xsV := range xsArg {
		(*xs)[i] = byte(xsV)
	}

	for i, ysV := range ysArg {
		(*ys)[i] = byte(ysV)
	}
}

// PlotPlotStemsdoublePtrIntV parameter default value hint:
// ref: 0
// scale: 1
// start: 0
// flags: 0
// offset: 0
// stride: sizeof(double)
func PlotPlotStemsdoublePtrIntV(label_id string, values *[]float64, count int32, ref float64, scale float64, start float64, flags PlotStemsFlags, offset int32, stride int32) {
	label_idArg, label_idFin := WrapString(label_id)
	valuesArg := make([]C.double, len(*values))
	for i, valuesV := range *values {
		valuesArg[i] = C.double(valuesV)
	}

	C.ImPlot_PlotStems_doublePtrInt(label_idArg, (*C.double)(&valuesArg[0]), C.int(count), C.double(ref), C.double(scale), C.double(start), C.ImPlotStemsFlags(flags), C.int(offset), C.int(stride))

	label_idFin()

	for i, valuesV := range valuesArg {
		(*values)[i] = float64(valuesV)
	}
}

// PlotPlotStemsdoublePtrdoublePtrV parameter default value hint:
// ref: 0
// flags: 0
// offset: 0
// stride: sizeof(double)
func PlotPlotStemsdoublePtrdoublePtrV(label_id string, xs *[]float64, ys *[]float64, count int32, ref float64, flags PlotStemsFlags, offset int32, stride int32) {
	label_idArg, label_idFin := WrapString(label_id)
	xsArg := make([]C.double, len(*xs))
	for i, xsV := range *xs {
		xsArg[i] = C.double(xsV)
	}

	ysArg := make([]C.double, len(*ys))
	for i, ysV := range *ys {
		ysArg[i] = C.double(ysV)
	}

	C.ImPlot_PlotStems_doublePtrdoublePtr(label_idArg, (*C.double)(&xsArg[0]), (*C.double)(&ysArg[0]), C.int(count), C.double(ref), C.ImPlotStemsFlags(flags), C.int(offset), C.int(stride))

	label_idFin()

	for i, xsV := range xsArg {
		(*xs)[i] = float64(xsV)
	}

	for i, ysV := range ysArg {
		(*ys)[i] = float64(ysV)
	}
}

// PlotPlotTextV parameter default value hint:
// pix_offset: ImVec2(0,0)
// flags: 0
func PlotPlotTextV(text string, x float64, y float64, pix_offset Vec2, flags PlotTextFlags) {
	textArg, textFin := WrapString(text)
	C.ImPlot_PlotText(textArg, C.double(x), C.double(y), pix_offset.toC(), C.ImPlotTextFlags(flags))

	textFin()
}

// PlotPlotToPixelsPlotPoIntV parameter default value hint:
// x_axis: -1
// y_axis: -1
func PlotPlotToPixelsPlotPoIntV(plt PlotPoint, x_axis PlotAxisEnum, y_axis PlotAxisEnum) Vec2 {
	pOut := new(Vec2)
	pOutArg, pOutFin := wrap[C.ImVec2, *Vec2](pOut)

	C.ImPlot_PlotToPixels_PlotPoInt(pOutArg, plt.toC(), C.ImAxis(x_axis), C.ImAxis(y_axis))

	pOutFin()

	return *pOut
}

// PlotPlotToPixelsdoubleV parameter default value hint:
// x_axis: -1
// y_axis: -1
func PlotPlotToPixelsdoubleV(x float64, y float64, x_axis PlotAxisEnum, y_axis PlotAxisEnum) Vec2 {
	pOut := new(Vec2)
	pOutArg, pOutFin := wrap[C.ImVec2, *Vec2](pOut)

	C.ImPlot_PlotToPixels_double(pOutArg, C.double(x), C.double(y), C.ImAxis(x_axis), C.ImAxis(y_axis))

	pOutFin()

	return *pOut
}

// PlotPopColormapV parameter default value hint:
// count: 1
func PlotPopColormapV(count int32) {
	C.ImPlot_PopColormap(C.int(count))
}

func PlotPopPlotClipRect() {
	C.ImPlot_PopPlotClipRect()
}

// PlotPopStyleColorV parameter default value hint:
// count: 1
func PlotPopStyleColorV(count int32) {
	C.ImPlot_PopStyleColor(C.int(count))
}

// PlotPopStyleVarV parameter default value hint:
// count: 1
func PlotPopStyleVarV(count int32) {
	C.ImPlot_PopStyleVar(C.int(count))
}

func PlotPrecision(val float64) int32 {
	return int32(C.ImPlot_Precision(C.double(val)))
}

func PlotPushColormapPlotColormap(cmap PlotColormap) {
	C.ImPlot_PushColormap_PlotColormap(C.ImPlotColormap(cmap))
}

func PlotPushColormapStr(name string) {
	nameArg, nameFin := WrapString(name)
	C.ImPlot_PushColormap_Str(nameArg)

	nameFin()
}

// PlotPushPlotClipRectV parameter default value hint:
// expand: 0
func PlotPushPlotClipRectV(expand float32) {
	C.ImPlot_PushPlotClipRect(C.float(expand))
}

func PlotPushStyleColorU32(idx PlotCol, col uint32) {
	C.ImPlot_PushStyleColor_U32(C.ImPlotCol(idx), C.ImU32(col))
}

func PlotPushStyleColorVec4(idx PlotCol, col Vec4) {
	C.ImPlot_PushStyleColor_Vec4(C.ImPlotCol(idx), col.toC())
}

func PlotPushStyleVarFloat(idx PlotStyleVar, val float32) {
	C.ImPlot_PushStyleVar_Float(C.ImPlotStyleVar(idx), C.float(val))
}

func PlotPushStyleVarInt(idx PlotStyleVar, val int32) {
	C.ImPlot_PushStyleVar_Int(C.ImPlotStyleVar(idx), C.int(val))
}

func PlotPushStyleVarVec2(idx PlotStyleVar, val Vec2) {
	C.ImPlot_PushStyleVar_Vec2(C.ImPlotStyleVar(idx), val.toC())
}

func PlotRangesOverlap(r1 PlotRange, r2 PlotRange) bool {
	r1Arg, r1Fin := r1.c()
	r2Arg, r2Fin := r2.c()

	defer func() {
		r1Fin()
		r2Fin()
	}()
	return C.ImPlot_RangesOverlap(r1Arg, r2Arg) == C.bool(true)
}

// PlotRegisterOrGetItemV parameter default value hint:
// just_created: nullptr
func PlotRegisterOrGetItemV(label_id string, flags PlotItemFlags, just_created *bool) *PlotItem {
	label_idArg, label_idFin := WrapString(label_id)
	just_createdArg, just_createdFin := WrapBool(just_created)

	defer func() {
		label_idFin()
		just_createdFin()
	}()
	return newPlotItemFromC(C.ImPlot_RegisterOrGetItem(label_idArg, C.ImPlotItemFlags(flags), just_createdArg))
}

func PlotRenderColorBar(colors *[]uint32, size int32, DrawList *DrawList, bounds Rect, vert bool, reversed bool, continuous bool) {
	colorsArg := make([]C.ImU32, len(*colors))
	for i, colorsV := range *colors {
		colorsArg[i] = C.ImU32(colorsV)
	}

	DrawListArg, DrawListFin := DrawList.handle()
	C.ImPlot_RenderColorBar((*C.ImU32)(&colorsArg[0]), C.int(size), DrawListArg, bounds.toC(), C.bool(vert), C.bool(reversed), C.bool(continuous))

	for i, colorsV := range colorsArg {
		(*colors)[i] = uint32(colorsV)
	}

	DrawListFin()
}

func PlotResetCtxForNextAlignedPlots(ctx *PlotContext) {
	ctxArg, ctxFin := ctx.handle()
	C.ImPlot_ResetCtxForNextAlignedPlots(ctxArg)

	ctxFin()
}

func PlotResetCtxForNextPlot(ctx *PlotContext) {
	ctxArg, ctxFin := ctx.handle()
	C.ImPlot_ResetCtxForNextPlot(ctxArg)

	ctxFin()
}

func PlotResetCtxForNextSubplot(ctx *PlotContext) {
	ctxArg, ctxFin := ctx.handle()
	C.ImPlot_ResetCtxForNextSubplot(ctxArg)

	ctxFin()
}

func PlotRoundTime(t PlotTime, unit PlotTimeUnit) PlotTime {
	pOut := new(PlotTime)
	pOutArg, pOutFin := wrap[C.ImPlotTime, *PlotTime](pOut)

	C.ImPlot_RoundTime(pOutArg, t.toC(), C.ImPlotTimeUnit(unit))

	pOutFin()

	return *pOut
}

func PlotRoundTo(val float64, prec int32) float64 {
	return float64(C.ImPlot_RoundTo(C.double(val), C.int(prec)))
}

// PlotSampleColormapV parameter default value hint:
// cmap: -1
func PlotSampleColormapV(t float32, cmap PlotColormap) Vec4 {
	pOut := new(Vec4)
	pOutArg, pOutFin := wrap[C.ImVec4, *Vec4](pOut)

	C.ImPlot_SampleColormap(pOutArg, C.float(t), C.ImPlotColormap(cmap))

	pOutFin()

	return *pOut
}

func PlotSampleColormapU32(t float32, cmap PlotColormap) uint32 {
	return uint32(C.ImPlot_SampleColormapU32(C.float(t), C.ImPlotColormap(cmap)))
}

func PlotSetAxes(x_axis PlotAxisEnum, y_axis PlotAxisEnum) {
	C.ImPlot_SetAxes(C.ImAxis(x_axis), C.ImAxis(y_axis))
}

func PlotSetAxis(axis PlotAxisEnum) {
	C.ImPlot_SetAxis(C.ImAxis(axis))
}

func PlotSetCurrentContext(ctx *PlotContext) {
	ctxArg, ctxFin := ctx.handle()
	C.ImPlot_SetCurrentContext(ctxArg)

	ctxFin()
}

func PlotSetImGuiContext(ctx *Context) {
	ctxArg, ctxFin := ctx.handle()
	C.ImPlot_SetImGuiContext(ctxArg)

	ctxFin()
}

// PlotSetNextAxesLimitsV parameter default value hint:
// cond: ImPlotCond_Once
func PlotSetNextAxesLimitsV(x_min float64, x_max float64, y_min float64, y_max float64, cond PlotCond) {
	C.ImPlot_SetNextAxesLimits(C.double(x_min), C.double(x_max), C.double(y_min), C.double(y_max), C.ImPlotCond(cond))
}

func PlotSetNextAxesToFit() {
	C.ImPlot_SetNextAxesToFit()
}

// PlotSetNextAxisLimitsV parameter default value hint:
// cond: ImPlotCond_Once
func PlotSetNextAxisLimitsV(axis PlotAxisEnum, v_min float64, v_max float64, cond PlotCond) {
	C.ImPlot_SetNextAxisLimits(C.ImAxis(axis), C.double(v_min), C.double(v_max), C.ImPlotCond(cond))
}

func PlotSetNextAxisLinks(axis PlotAxisEnum, link_min *float64, link_max *float64) {
	link_minArg, link_minFin := WrapNumberPtr[C.double, float64](link_min)
	link_maxArg, link_maxFin := WrapNumberPtr[C.double, float64](link_max)
	C.ImPlot_SetNextAxisLinks(C.ImAxis(axis), link_minArg, link_maxArg)

	link_minFin()
	link_maxFin()
}

func PlotSetNextAxisToFit(axis PlotAxisEnum) {
	C.ImPlot_SetNextAxisToFit(C.ImAxis(axis))
}

// PlotSetNextErrorBarStyleV parameter default value hint:
// col: ImVec4(0,0,0,-1)
// size: -1
// weight: -1
func PlotSetNextErrorBarStyleV(col Vec4, size float32, weight float32) {
	C.ImPlot_SetNextErrorBarStyle(col.toC(), C.float(size), C.float(weight))
}

// PlotSetNextFillStyleV parameter default value hint:
// col: ImVec4(0,0,0,-1)
// alpha_mod: -1
func PlotSetNextFillStyleV(col Vec4, alpha_mod float32) {
	C.ImPlot_SetNextFillStyle(col.toC(), C.float(alpha_mod))
}

// PlotSetNextLineStyleV parameter default value hint:
// col: ImVec4(0,0,0,-1)
// weight: -1
func PlotSetNextLineStyleV(col Vec4, weight float32) {
	C.ImPlot_SetNextLineStyle(col.toC(), C.float(weight))
}

// PlotSetNextMarkerStyleV parameter default value hint:
// marker: -1
// size: -1
// fill: ImVec4(0,0,0,-1)
// weight: -1
// outline: ImVec4(0,0,0,-1)
func PlotSetNextMarkerStyleV(marker PlotMarker, size float32, fill Vec4, weight float32, outline Vec4) {
	C.ImPlot_SetNextMarkerStyle(C.ImPlotMarker(marker), C.float(size), fill.toC(), C.float(weight), outline.toC())
}

// PlotSetupAxesV parameter default value hint:
// x_flags: 0
// y_flags: 0
func PlotSetupAxesV(x_label string, y_label string, x_flags PlotAxisFlags, y_flags PlotAxisFlags) {
	x_labelArg, x_labelFin := WrapString(x_label)
	y_labelArg, y_labelFin := WrapString(y_label)
	C.ImPlot_SetupAxes(x_labelArg, y_labelArg, C.ImPlotAxisFlags(x_flags), C.ImPlotAxisFlags(y_flags))

	x_labelFin()
	y_labelFin()
}

// PlotSetupAxesLimitsV parameter default value hint:
// cond: ImPlotCond_Once
func PlotSetupAxesLimitsV(x_min float64, x_max float64, y_min float64, y_max float64, cond PlotCond) {
	C.ImPlot_SetupAxesLimits(C.double(x_min), C.double(x_max), C.double(y_min), C.double(y_max), C.ImPlotCond(cond))
}

// PlotSetupAxisV parameter default value hint:
// label: nullptr
// flags: 0
func PlotSetupAxisV(axis PlotAxisEnum, label string, flags PlotAxisFlags) {
	labelArg, labelFin := WrapString(label)
	C.ImPlot_SetupAxis(C.ImAxis(axis), labelArg, C.ImPlotAxisFlags(flags))

	labelFin()
}

func PlotSetupAxisFormatStr(axis PlotAxisEnum, fmt string) {
	fmtArg, fmtFin := WrapString(fmt)
	C.ImPlot_SetupAxisFormat_Str(C.ImAxis(axis), fmtArg)

	fmtFin()
}

// PlotSetupAxisLimitsV parameter default value hint:
// cond: ImPlotCond_Once
func PlotSetupAxisLimitsV(axis PlotAxisEnum, v_min float64, v_max float64, cond PlotCond) {
	C.ImPlot_SetupAxisLimits(C.ImAxis(axis), C.double(v_min), C.double(v_max), C.ImPlotCond(cond))
}

func PlotSetupAxisLimitsConstraints(axis PlotAxisEnum, v_min float64, v_max float64) {
	C.ImPlot_SetupAxisLimitsConstraints(C.ImAxis(axis), C.double(v_min), C.double(v_max))
}

func PlotSetupAxisLinks(axis PlotAxisEnum, link_min *float64, link_max *float64) {
	link_minArg, link_minFin := WrapNumberPtr[C.double, float64](link_min)
	link_maxArg, link_maxFin := WrapNumberPtr[C.double, float64](link_max)
	C.ImPlot_SetupAxisLinks(C.ImAxis(axis), link_minArg, link_maxArg)

	link_minFin()
	link_maxFin()
}

func PlotSetupAxisScalePlotScale(axis PlotAxisEnum, scale PlotScale) {
	C.ImPlot_SetupAxisScale_PlotScale(C.ImAxis(axis), C.ImPlotScale(scale))
}

// PlotSetupAxisTicksdoubleV parameter default value hint:
// labels: nullptr
// keep_default: false
func PlotSetupAxisTicksdoubleV(axis PlotAxisEnum, v_min float64, v_max float64, n_ticks int32, labels []string, keep_default bool) {
	labelsArg, labelsFin := WrapStringList(labels)
	C.ImPlot_SetupAxisTicks_double(C.ImAxis(axis), C.double(v_min), C.double(v_max), C.int(n_ticks), labelsArg, C.bool(keep_default))

	labelsFin()
}

// PlotSetupAxisTicksdoublePtrV parameter default value hint:
// labels: nullptr
// keep_default: false
func PlotSetupAxisTicksdoublePtrV(axis PlotAxisEnum, values *[]float64, n_ticks int32, labels []string, keep_default bool) {
	valuesArg := make([]C.double, len(*values))
	for i, valuesV := range *values {
		valuesArg[i] = C.double(valuesV)
	}

	labelsArg, labelsFin := WrapStringList(labels)
	C.ImPlot_SetupAxisTicks_doublePtr(C.ImAxis(axis), (*C.double)(&valuesArg[0]), C.int(n_ticks), labelsArg, C.bool(keep_default))

	for i, valuesV := range valuesArg {
		(*values)[i] = float64(valuesV)
	}

	labelsFin()
}

func PlotSetupAxisZoomConstraints(axis PlotAxisEnum, z_min float64, z_max float64) {
	C.ImPlot_SetupAxisZoomConstraints(C.ImAxis(axis), C.double(z_min), C.double(z_max))
}

func PlotSetupFinish() {
	C.ImPlot_SetupFinish()
}

// PlotSetupLegendV parameter default value hint:
// flags: 0
func PlotSetupLegendV(location PlotLocation, flags PlotLegendFlags) {
	C.ImPlot_SetupLegend(C.ImPlotLocation(location), C.ImPlotLegendFlags(flags))
}

func PlotSetupLock() {
	C.ImPlot_SetupLock()
}

// PlotSetupMouseTextV parameter default value hint:
// flags: 0
func PlotSetupMouseTextV(location PlotLocation, flags PlotMouseTextFlags) {
	C.ImPlot_SetupMouseText(C.ImPlotLocation(location), C.ImPlotMouseTextFlags(flags))
}

// PlotShowAltLegendV parameter default value hint:
// vertical: true
// size: ImVec2(0,0)
// interactable: true
func PlotShowAltLegendV(title_id string, vertical bool, size Vec2, interactable bool) {
	title_idArg, title_idFin := WrapString(title_id)
	C.ImPlot_ShowAltLegend(title_idArg, C.bool(vertical), size.toC(), C.bool(interactable))

	title_idFin()
}

// PlotShowAxisContextMenuV parameter default value hint:
// time_allowed: false
func PlotShowAxisContextMenuV(axis *PlotAxis, equal_axis *PlotAxis, time_allowed bool) {
	axisArg, axisFin := axis.handle()
	equal_axisArg, equal_axisFin := equal_axis.handle()
	C.ImPlot_ShowAxisContextMenu(axisArg, equal_axisArg, C.bool(time_allowed))

	axisFin()
	equal_axisFin()
}

func PlotShowColormapSelector(label string) bool {
	labelArg, labelFin := WrapString(label)

	defer func() {
		labelFin()
	}()
	return C.ImPlot_ShowColormapSelector(labelArg) == C.bool(true)
}

// PlotShowDatePickerV parameter default value hint:
// t1: nullptr
// t2: nullptr
func PlotShowDatePickerV(id string, level *int32, t *PlotTime, t1 *PlotTime, t2 *PlotTime) bool {
	idArg, idFin := WrapString(id)
	levelArg, levelFin := WrapNumberPtr[C.int, int32](level)
	tArg, tFin := wrap[C.ImPlotTime, *PlotTime](t)
	t1Arg, t1Fin := wrap[C.ImPlotTime, *PlotTime](t1)
	t2Arg, t2Fin := wrap[C.ImPlotTime, *PlotTime](t2)

	defer func() {
		idFin()
		levelFin()
		tFin()
		t1Fin()
		t2Fin()
	}()
	return C.ImPlot_ShowDatePicker(idArg, levelArg, tArg, t1Arg, t2Arg) == C.bool(true)
}

// PlotShowDemoWindowV parameter default value hint:
// p_open: nullptr
func PlotShowDemoWindowV(p_open *bool) {
	p_openArg, p_openFin := WrapBool(p_open)
	C.ImPlot_ShowDemoWindow(p_openArg)

	p_openFin()
}

func PlotShowInputMapSelector(label string) bool {
	labelArg, labelFin := WrapString(label)

	defer func() {
		labelFin()
	}()
	return C.ImPlot_ShowInputMapSelector(labelArg) == C.bool(true)
}

func PlotShowLegendContextMenu(legend *PlotLegend, visible bool) bool {
	legendArg, legendFin := legend.handle()

	defer func() {
		legendFin()
	}()
	return C.ImPlot_ShowLegendContextMenu(legendArg, C.bool(visible)) == C.bool(true)
}

func PlotShowLegendEntries(items *PlotItemGroup, legend_bb Rect, interactable bool, pad Vec2, spacing Vec2, vertical bool, DrawList *DrawList) bool {
	itemsArg, itemsFin := items.handle()
	DrawListArg, DrawListFin := DrawList.handle()

	defer func() {
		itemsFin()
		DrawListFin()
	}()
	return C.ImPlot_ShowLegendEntries(itemsArg, legend_bb.toC(), C.bool(interactable), pad.toC(), spacing.toC(), C.bool(vertical), DrawListArg) == C.bool(true)
}

// PlotShowMetricsWindowV parameter default value hint:
// p_popen: nullptr
func PlotShowMetricsWindowV(p_popen *bool) {
	p_popenArg, p_popenFin := WrapBool(p_popen)
	C.ImPlot_ShowMetricsWindow(p_popenArg)

	p_popenFin()
}

func PlotShowPlotContextMenu(plot *PlotPlot) {
	plotArg, plotFin := plot.handle()
	C.ImPlot_ShowPlotContextMenu(plotArg)

	plotFin()
}

// PlotShowStyleEditorV parameter default value hint:
// ref: nullptr
func PlotShowStyleEditorV(ref *PlotStyle) {
	refArg, refFin := ref.handle()
	C.ImPlot_ShowStyleEditor(refArg)

	refFin()
}

func PlotShowStyleSelector(label string) bool {
	labelArg, labelFin := WrapString(label)

	defer func() {
		labelFin()
	}()
	return C.ImPlot_ShowStyleSelector(labelArg) == C.bool(true)
}

func PlotShowSubplotsContextMenu(subplot *PlotSubplot) {
	subplotArg, subplotFin := subplot.handle()
	C.ImPlot_ShowSubplotsContextMenu(subplotArg)

	subplotFin()
}

func PlotShowTimePicker(id string, t *PlotTime) bool {
	idArg, idFin := WrapString(id)
	tArg, tFin := wrap[C.ImPlotTime, *PlotTime](t)

	defer func() {
		idFin()
		tFin()
	}()
	return C.ImPlot_ShowTimePicker(idArg, tArg) == C.bool(true)
}

func PlotShowUserGuide() {
	C.ImPlot_ShowUserGuide()
}

// PlotStyleColorsAutoV parameter default value hint:
// dst: nullptr
func PlotStyleColorsAutoV(dst *PlotStyle) {
	dstArg, dstFin := dst.handle()
	C.ImPlot_StyleColorsAuto(dstArg)

	dstFin()
}

// PlotStyleColorsClassicV parameter default value hint:
// dst: nullptr
func PlotStyleColorsClassicV(dst *PlotStyle) {
	dstArg, dstFin := dst.handle()
	C.ImPlot_StyleColorsClassic(dstArg)

	dstFin()
}

// PlotStyleColorsDarkV parameter default value hint:
// dst: nullptr
func PlotStyleColorsDarkV(dst *PlotStyle) {
	dstArg, dstFin := dst.handle()
	C.ImPlot_StyleColorsDark(dstArg)

	dstFin()
}

// PlotStyleColorsLightV parameter default value hint:
// dst: nullptr
func PlotStyleColorsLightV(dst *PlotStyle) {
	dstArg, dstFin := dst.handle()
	C.ImPlot_StyleColorsLight(dstArg)

	dstFin()
}

func PlotSubplotNextCell() {
	C.ImPlot_SubplotNextCell()
}

// PlotTagXBoolV parameter default value hint:
// round: false
func PlotTagXBoolV(x float64, col Vec4, round bool) {
	C.ImPlot_TagX_Bool(C.double(x), col.toC(), C.bool(round))
}

func PlotTagXStr(x float64, col Vec4, fmt string) {
	fmtArg, fmtFin := WrapString(fmt)
	C.wrap_ImPlot_TagX_Str(C.double(x), col.toC(), fmtArg)

	fmtFin()
}

// PlotTagYBoolV parameter default value hint:
// round: false
func PlotTagYBoolV(y float64, col Vec4, round bool) {
	C.ImPlot_TagY_Bool(C.double(y), col.toC(), C.bool(round))
}

func PlotTagYStr(y float64, col Vec4, fmt string) {
	fmtArg, fmtFin := WrapString(fmt)
	C.wrap_ImPlot_TagY_Str(C.double(y), col.toC(), fmtArg)

	fmtFin()
}

func PlotTransformForwardLog10(v float64, noname1 unsafe.Pointer) float64 {
	noname1Arg, noname1Fin := WrapVoidPtr(noname1)

	defer func() {
		noname1Fin()
	}()
	return float64(C.ImPlot_TransformForward_Log10(C.double(v), noname1Arg))
}

func PlotTransformForwardLogit(v float64, noname1 unsafe.Pointer) float64 {
	noname1Arg, noname1Fin := WrapVoidPtr(noname1)

	defer func() {
		noname1Fin()
	}()
	return float64(C.ImPlot_TransformForward_Logit(C.double(v), noname1Arg))
}

func PlotTransformForwardSymLog(v float64, noname1 unsafe.Pointer) float64 {
	noname1Arg, noname1Fin := WrapVoidPtr(noname1)

	defer func() {
		noname1Fin()
	}()
	return float64(C.ImPlot_TransformForward_SymLog(C.double(v), noname1Arg))
}

func PlotTransformInverseLog10(v float64, noname1 unsafe.Pointer) float64 {
	noname1Arg, noname1Fin := WrapVoidPtr(noname1)

	defer func() {
		noname1Fin()
	}()
	return float64(C.ImPlot_TransformInverse_Log10(C.double(v), noname1Arg))
}

func PlotTransformInverseLogit(v float64, noname1 unsafe.Pointer) float64 {
	noname1Arg, noname1Fin := WrapVoidPtr(noname1)

	defer func() {
		noname1Fin()
	}()
	return float64(C.ImPlot_TransformInverse_Logit(C.double(v), noname1Arg))
}

func PlotTransformInverseSymLog(v float64, noname1 unsafe.Pointer) float64 {
	noname1Arg, noname1Fin := WrapVoidPtr(noname1)

	defer func() {
		noname1Fin()
	}()
	return float64(C.ImPlot_TransformInverse_SymLog(C.double(v), noname1Arg))
}

func (self *PlotAxis) SetMax(_max float64) bool {
	selfArg, selfFin := self.handle()

	defer func() {
		selfFin()
	}()
	return C.wrap_ImPlotAxis_SetMax(selfArg, C.double(_max)) == C.bool(true)
}

func (self *PlotAxis) SetMin(_min float64) bool {
	selfArg, selfFin := self.handle()

	defer func() {
		selfFin()
	}()
	return C.wrap_ImPlotAxis_SetMin(selfArg, C.double(_min)) == C.bool(true)
}

func PlotAddColormapU32Ptr(name string, cols *[]uint32, size int32) PlotColormap {
	nameArg, nameFin := WrapString(name)
	colsArg := make([]C.ImU32, len(*cols))
	for i, colsV := range *cols {
		colsArg[i] = C.ImU32(colsV)
	}

	defer func() {
		nameFin()

		for i, colsV := range colsArg {
			(*cols)[i] = uint32(colsV)
		}
	}()
	return PlotColormap(C.wrap_ImPlot_AddColormap_U32Ptr(nameArg, (*C.ImU32)(&colsArg[0]), C.int(size)))
}

func PlotAddColormapVec4Ptr(name string, cols *Vec4, size int32) PlotColormap {
	nameArg, nameFin := WrapString(name)
	colsArg, colsFin := wrap[C.ImVec4, *Vec4](cols)

	defer func() {
		nameFin()
		colsFin()
	}()
	return PlotColormap(C.wrap_ImPlot_AddColormap_Vec4Ptr(nameArg, colsArg, C.int(size)))
}

func PlotAddTextCentered(DrawList *DrawList, top_center Vec2, col uint32, text_begin string) {
	DrawListArg, DrawListFin := DrawList.handle()
	text_beginArg, text_beginFin := WrapString(text_begin)
	C.wrap_ImPlot_AddTextCentered(DrawListArg, top_center.toC(), C.ImU32(col), text_beginArg)

	DrawListFin()
	text_beginFin()
}

func PlotAddTextVertical(DrawList *DrawList, pos Vec2, col uint32, text_begin string) {
	DrawListArg, DrawListFin := DrawList.handle()
	text_beginArg, text_beginFin := WrapString(text_begin)
	C.wrap_ImPlot_AddTextVertical(DrawListArg, pos.toC(), C.ImU32(col), text_beginArg)

	DrawListFin()
	text_beginFin()
}

func PlotAnnotationBool(x float64, y float64, col Vec4, pix_offset Vec2, clamp bool) {
	C.wrap_ImPlot_Annotation_Bool(C.double(x), C.double(y), col.toC(), pix_offset.toC(), C.bool(clamp))
}

func PlotBeginAlignedPlots(group_id string) bool {
	group_idArg, group_idFin := WrapString(group_id)

	defer func() {
		group_idFin()
	}()
	return C.wrap_ImPlot_BeginAlignedPlots(group_idArg) == C.bool(true)
}

func PlotBeginDragDropSourceAxis(axis PlotAxisEnum) bool {
	return C.wrap_ImPlot_BeginDragDropSourceAxis(C.ImAxis(axis)) == C.bool(true)
}

func PlotBeginDragDropSourceItem(label_id string) bool {
	label_idArg, label_idFin := WrapString(label_id)

	defer func() {
		label_idFin()
	}()
	return C.wrap_ImPlot_BeginDragDropSourceItem(label_idArg) == C.bool(true)
}

func PlotBeginDragDropSourcePlot() bool {
	return C.wrap_ImPlot_BeginDragDropSourcePlot() == C.bool(true)
}

func PlotBeginItem(label_id string) bool {
	label_idArg, label_idFin := WrapString(label_id)

	defer func() {
		label_idFin()
	}()
	return C.wrap_ImPlot_BeginItem(label_idArg) == C.bool(true)
}

func PlotBeginLegendPopup(label_id string) bool {
	label_idArg, label_idFin := WrapString(label_id)

	defer func() {
		label_idFin()
	}()
	return C.wrap_ImPlot_BeginLegendPopup(label_idArg) == C.bool(true)
}

func PlotBeginPlot(title_id string) bool {
	title_idArg, title_idFin := WrapString(title_id)

	defer func() {
		title_idFin()
	}()
	return C.wrap_ImPlot_BeginPlot(title_idArg) == C.bool(true)
}

func PlotBeginSubplots(title_id string, rows int32, cols int32, size Vec2) bool {
	title_idArg, title_idFin := WrapString(title_id)

	defer func() {
		title_idFin()
	}()
	return C.wrap_ImPlot_BeginSubplots(title_idArg, C.int(rows), C.int(cols), size.toC()) == C.bool(true)
}

func PlotBustColorCache() {
	C.wrap_ImPlot_BustColorCache()
}

func PlotColormapButton(label string) bool {
	labelArg, labelFin := WrapString(label)

	defer func() {
		labelFin()
	}()
	return C.wrap_ImPlot_ColormapButton(labelArg) == C.bool(true)
}

func PlotColormapScale(label string, scale_min float64, scale_max float64) {
	labelArg, labelFin := WrapString(label)
	C.wrap_ImPlot_ColormapScale(labelArg, C.double(scale_min), C.double(scale_max))

	labelFin()
}

func PlotColormapSlider(label string, t *float32) bool {
	labelArg, labelFin := WrapString(label)
	tArg, tFin := WrapNumberPtr[C.float, float32](t)

	defer func() {
		labelFin()
		tFin()
	}()
	return C.wrap_ImPlot_ColormapSlider(labelArg, tArg) == C.bool(true)
}

func PlotDestroyContext() {
	C.wrap_ImPlot_DestroyContext()
}

func PlotDragLineX(id int32, x *float64, col Vec4) bool {
	xArg, xFin := WrapNumberPtr[C.double, float64](x)

	defer func() {
		xFin()
	}()
	return C.wrap_ImPlot_DragLineX(C.int(id), xArg, col.toC()) == C.bool(true)
}

func PlotDragLineY(id int32, y *float64, col Vec4) bool {
	yArg, yFin := WrapNumberPtr[C.double, float64](y)

	defer func() {
		yFin()
	}()
	return C.wrap_ImPlot_DragLineY(C.int(id), yArg, col.toC()) == C.bool(true)
}

func PlotDragPoint(id int32, x *float64, y *float64, col Vec4) bool {
	xArg, xFin := WrapNumberPtr[C.double, float64](x)
	yArg, yFin := WrapNumberPtr[C.double, float64](y)

	defer func() {
		xFin()
		yFin()
	}()
	return C.wrap_ImPlot_DragPoint(C.int(id), xArg, yArg, col.toC()) == C.bool(true)
}

func PlotDragRect(id int32, x1 *float64, y1 *float64, x2 *float64, y2 *float64, col Vec4) bool {
	x1Arg, x1Fin := WrapNumberPtr[C.double, float64](x1)
	y1Arg, y1Fin := WrapNumberPtr[C.double, float64](y1)
	x2Arg, x2Fin := WrapNumberPtr[C.double, float64](x2)
	y2Arg, y2Fin := WrapNumberPtr[C.double, float64](y2)

	defer func() {
		x1Fin()
		y1Fin()
		x2Fin()
		y2Fin()
	}()
	return C.wrap_ImPlot_DragRect(C.int(id), x1Arg, y1Arg, x2Arg, y2Arg, col.toC()) == C.bool(true)
}

func PlotGetColormapColor(idx int32) Vec4 {
	pOut := new(Vec4)
	pOutArg, pOutFin := wrap[C.ImVec4, *Vec4](pOut)

	C.wrap_ImPlot_GetColormapColor(pOutArg, C.int(idx))

	pOutFin()

	return *pOut
}

func PlotGetColormapSize() int32 {
	return int32(C.wrap_ImPlot_GetColormapSize())
}

func PlotGetLocationPos(outer_rect Rect, inner_size Vec2, location PlotLocation) Vec2 {
	pOut := new(Vec2)
	pOutArg, pOutFin := wrap[C.ImVec2, *Vec2](pOut)

	C.wrap_ImPlot_GetLocationPos(pOutArg, outer_rect.toC(), inner_size.toC(), C.ImPlotLocation(location))

	pOutFin()

	return *pOut
}

func PlotGetPlotLimits() PlotRect {
	pOut := new(PlotRect)
	pOutArg, pOutFin := pOut.handle()

	C.wrap_ImPlot_GetPlotLimits(pOutArg)

	pOutFin()

	return *pOut
}

func PlotGetPlotMousePos() PlotPoint {
	pOut := new(PlotPoint)
	pOutArg, pOutFin := wrap[C.ImPlotPoint, *PlotPoint](pOut)

	C.wrap_ImPlot_GetPlotMousePos(pOutArg)

	pOutFin()

	return *pOut
}

func PlotGetPlotSelection() PlotRect {
	pOut := new(PlotRect)
	pOutArg, pOutFin := pOut.handle()

	C.wrap_ImPlot_GetPlotSelection(pOutArg)

	pOutFin()

	return *pOut
}

func PlotHideNextItem() {
	C.wrap_ImPlot_HideNextItem()
}

func PlotImAlmostEqual(v1 float64, v2 float64) bool {
	return C.wrap_ImPlot_ImAlmostEqual(C.double(v1), C.double(v2)) == C.bool(true)
}

func PlotLabelAxisValue(axis PlotAxis, value float64, buff string, size int32) {
	axisArg, axisFin := axis.c()
	buffArg, buffFin := WrapString(buff)
	C.wrap_ImPlot_LabelAxisValue(axisArg, C.double(value), buffArg, C.int(size))

	axisFin()
	buffFin()
}

func PlotMakeTime(year int32) PlotTime {
	pOut := new(PlotTime)
	pOutArg, pOutFin := wrap[C.ImPlotTime, *PlotTime](pOut)

	C.wrap_ImPlot_MakeTime(pOutArg, C.int(year))

	pOutFin()

	return *pOut
}

func PlotMapInputDefault() {
	C.wrap_ImPlot_MapInputDefault()
}

func PlotMapInputReverse() {
	C.wrap_ImPlot_MapInputReverse()
}

func PlotPixelsToPlotFloat(x float32, y float32) PlotPoint {
	pOut := new(PlotPoint)
	pOutArg, pOutFin := wrap[C.ImPlotPoint, *PlotPoint](pOut)

	C.wrap_ImPlot_PixelsToPlot_Float(pOutArg, C.float(x), C.float(y))

	pOutFin()

	return *pOut
}

func PlotPixelsToPlotVec2(pix Vec2) PlotPoint {
	pOut := new(PlotPoint)
	pOutArg, pOutFin := wrap[C.ImPlotPoint, *PlotPoint](pOut)

	C.wrap_ImPlot_PixelsToPlot_Vec2(pOutArg, pix.toC())

	pOutFin()

	return *pOut
}

func PlotPlotBarGroupsFloatPtr(label_ids []string, values []float32, item_count int32, group_count int32) {
	label_idsArg, label_idsFin := WrapStringList(label_ids)
	C.wrap_ImPlot_PlotBarGroups_FloatPtr(label_idsArg, (*C.float)(&(values[0])), C.int(item_count), C.int(group_count))

	label_idsFin()
}

func PlotPlotBarGroupsS16Ptr(label_ids []string, values *[]int, item_count int32, group_count int32) {
	label_idsArg, label_idsFin := WrapStringList(label_ids)
	valuesArg := make([]C.ImS16, len(*values))
	for i, valuesV := range *values {
		valuesArg[i] = C.ImS16(valuesV)
	}

	C.wrap_ImPlot_PlotBarGroups_S16Ptr(label_idsArg, (*C.ImS16)(&valuesArg[0]), C.int(item_count), C.int(group_count))

	label_idsFin()

	for i, valuesV := range valuesArg {
		(*values)[i] = int(valuesV)
	}
}

func PlotPlotBarGroupsS32Ptr(label_ids []string, values *[]int32, item_count int32, group_count int32) {
	label_idsArg, label_idsFin := WrapStringList(label_ids)
	valuesArg := make([]C.ImS32, len(*values))
	for i, valuesV := range *values {
		valuesArg[i] = C.ImS32(valuesV)
	}

	C.wrap_ImPlot_PlotBarGroups_S32Ptr(label_idsArg, (*C.ImS32)(&valuesArg[0]), C.int(item_count), C.int(group_count))

	label_idsFin()

	for i, valuesV := range valuesArg {
		(*values)[i] = int32(valuesV)
	}
}

func PlotPlotBarGroupsS64Ptr(label_ids []string, values []int64, item_count int32, group_count int32) {
	label_idsArg, label_idsFin := WrapStringList(label_ids)
	C.wrap_ImPlot_PlotBarGroups_S64Ptr(label_idsArg, (*C.longlong)(&(values[0])), C.int(item_count), C.int(group_count))

	label_idsFin()
}

func PlotPlotBarGroupsS8Ptr(label_ids []string, values *[]int8, item_count int32, group_count int32) {
	label_idsArg, label_idsFin := WrapStringList(label_ids)
	valuesArg := make([]C.ImS8, len(*values))
	for i, valuesV := range *values {
		valuesArg[i] = C.ImS8(valuesV)
	}

	C.wrap_ImPlot_PlotBarGroups_S8Ptr(label_idsArg, (*C.ImS8)(&valuesArg[0]), C.int(item_count), C.int(group_count))

	label_idsFin()

	for i, valuesV := range valuesArg {
		(*values)[i] = int8(valuesV)
	}
}

func PlotPlotBarGroupsU16Ptr(label_ids []string, values *[]uint16, item_count int32, group_count int32) {
	label_idsArg, label_idsFin := WrapStringList(label_ids)
	valuesArg := make([]C.ImU16, len(*values))
	for i, valuesV := range *values {
		valuesArg[i] = C.ImU16(valuesV)
	}

	C.wrap_ImPlot_PlotBarGroups_U16Ptr(label_idsArg, (*C.ImU16)(&valuesArg[0]), C.int(item_count), C.int(group_count))

	label_idsFin()

	for i, valuesV := range valuesArg {
		(*values)[i] = uint16(valuesV)
	}
}

func PlotPlotBarGroupsU32Ptr(label_ids []string, values *[]uint32, item_count int32, group_count int32) {
	label_idsArg, label_idsFin := WrapStringList(label_ids)
	valuesArg := make([]C.ImU32, len(*values))
	for i, valuesV := range *values {
		valuesArg[i] = C.ImU32(valuesV)
	}

	C.wrap_ImPlot_PlotBarGroups_U32Ptr(label_idsArg, (*C.ImU32)(&valuesArg[0]), C.int(item_count), C.int(group_count))

	label_idsFin()

	for i, valuesV := range valuesArg {
		(*values)[i] = uint32(valuesV)
	}
}

func PlotPlotBarGroupsU64Ptr(label_ids []string, values []uint64, item_count int32, group_count int32) {
	label_idsArg, label_idsFin := WrapStringList(label_ids)
	C.wrap_ImPlot_PlotBarGroups_U64Ptr(label_idsArg, (*C.ulonglong)(&(values[0])), C.int(item_count), C.int(group_count))

	label_idsFin()
}

func PlotPlotBarGroupsU8Ptr(label_ids []string, values *[]byte, item_count int32, group_count int32) {
	label_idsArg, label_idsFin := WrapStringList(label_ids)
	valuesArg := make([]C.ImU8, len(*values))
	for i, valuesV := range *values {
		valuesArg[i] = C.ImU8(valuesV)
	}

	C.wrap_ImPlot_PlotBarGroups_U8Ptr(label_idsArg, (*C.ImU8)(&valuesArg[0]), C.int(item_count), C.int(group_count))

	label_idsFin()

	for i, valuesV := range valuesArg {
		(*values)[i] = byte(valuesV)
	}
}

func PlotPlotBarGroupsdoublePtr(label_ids []string, values *[]float64, item_count int32, group_count int32) {
	label_idsArg, label_idsFin := WrapStringList(label_ids)
	valuesArg := make([]C.double, len(*values))
	for i, valuesV := range *values {
		valuesArg[i] = C.double(valuesV)
	}

	C.wrap_ImPlot_PlotBarGroups_doublePtr(label_idsArg, (*C.double)(&valuesArg[0]), C.int(item_count), C.int(group_count))

	label_idsFin()

	for i, valuesV := range valuesArg {
		(*values)[i] = float64(valuesV)
	}
}

func PlotPlotBarsFloatPtrFloatPtr(label_id string, xs []float32, ys []float32, count int32, bar_size float64) {
	label_idArg, label_idFin := WrapString(label_id)
	C.wrap_ImPlot_PlotBars_FloatPtrFloatPtr(label_idArg, (*C.float)(&(xs[0])), (*C.float)(&(ys[0])), C.int(count), C.double(bar_size))

	label_idFin()
}

func PlotPlotBarsFloatPtrInt(label_id string, values []float32, count int32) {
	label_idArg, label_idFin := WrapString(label_id)
	C.wrap_ImPlot_PlotBars_FloatPtrInt(label_idArg, (*C.float)(&(values[0])), C.int(count))

	label_idFin()
}

func PlotPlotBarsS16PtrInt(label_id string, values *[]int, count int32) {
	label_idArg, label_idFin := WrapString(label_id)
	valuesArg := make([]C.ImS16, len(*values))
	for i, valuesV := range *values {
		valuesArg[i] = C.ImS16(valuesV)
	}

	C.wrap_ImPlot_PlotBars_S16PtrInt(label_idArg, (*C.ImS16)(&valuesArg[0]), C.int(count))

	label_idFin()

	for i, valuesV := range valuesArg {
		(*values)[i] = int(valuesV)
	}
}

func PlotPlotBarsS16PtrS16Ptr(label_id string, xs *[]int, ys *[]int, count int32, bar_size float64) {
	label_idArg, label_idFin := WrapString(label_id)
	xsArg := make([]C.ImS16, len(*xs))
	for i, xsV := range *xs {
		xsArg[i] = C.ImS16(xsV)
	}

	ysArg := make([]C.ImS16, len(*ys))
	for i, ysV := range *ys {
		ysArg[i] = C.ImS16(ysV)
	}

	C.wrap_ImPlot_PlotBars_S16PtrS16Ptr(label_idArg, (*C.ImS16)(&xsArg[0]), (*C.ImS16)(&ysArg[0]), C.int(count), C.double(bar_size))

	label_idFin()

	for i, xsV := range xsArg {
		(*xs)[i] = int(xsV)
	}

	for i, ysV := range ysArg {
		(*ys)[i] = int(ysV)
	}
}

func PlotPlotBarsS32PtrInt(label_id string, values *[]int32, count int32) {
	label_idArg, label_idFin := WrapString(label_id)
	valuesArg := make([]C.ImS32, len(*values))
	for i, valuesV := range *values {
		valuesArg[i] = C.ImS32(valuesV)
	}

	C.wrap_ImPlot_PlotBars_S32PtrInt(label_idArg, (*C.ImS32)(&valuesArg[0]), C.int(count))

	label_idFin()

	for i, valuesV := range valuesArg {
		(*values)[i] = int32(valuesV)
	}
}

func PlotPlotBarsS32PtrS32Ptr(label_id string, xs *[]int32, ys *[]int32, count int32, bar_size float64) {
	label_idArg, label_idFin := WrapString(label_id)
	xsArg := make([]C.ImS32, len(*xs))
	for i, xsV := range *xs {
		xsArg[i] = C.ImS32(xsV)
	}

	ysArg := make([]C.ImS32, len(*ys))
	for i, ysV := range *ys {
		ysArg[i] = C.ImS32(ysV)
	}

	C.wrap_ImPlot_PlotBars_S32PtrS32Ptr(label_idArg, (*C.ImS32)(&xsArg[0]), (*C.ImS32)(&ysArg[0]), C.int(count), C.double(bar_size))

	label_idFin()

	for i, xsV := range xsArg {
		(*xs)[i] = int32(xsV)
	}

	for i, ysV := range ysArg {
		(*ys)[i] = int32(ysV)
	}
}

func PlotPlotBarsS64PtrInt(label_id string, values []int64, count int32) {
	label_idArg, label_idFin := WrapString(label_id)
	C.wrap_ImPlot_PlotBars_S64PtrInt(label_idArg, (*C.longlong)(&(values[0])), C.int(count))

	label_idFin()
}

func PlotPlotBarsS64PtrS64Ptr(label_id string, xs []int64, ys []int64, count int32, bar_size float64) {
	label_idArg, label_idFin := WrapString(label_id)
	C.wrap_ImPlot_PlotBars_S64PtrS64Ptr(label_idArg, (*C.longlong)(&(xs[0])), (*C.longlong)(&(ys[0])), C.int(count), C.double(bar_size))

	label_idFin()
}

func PlotPlotBarsS8PtrInt(label_id string, values *[]int8, count int32) {
	label_idArg, label_idFin := WrapString(label_id)
	valuesArg := make([]C.ImS8, len(*values))
	for i, valuesV := range *values {
		valuesArg[i] = C.ImS8(valuesV)
	}

	C.wrap_ImPlot_PlotBars_S8PtrInt(label_idArg, (*C.ImS8)(&valuesArg[0]), C.int(count))

	label_idFin()

	for i, valuesV := range valuesArg {
		(*values)[i] = int8(valuesV)
	}
}

func PlotPlotBarsS8PtrS8Ptr(label_id string, xs *[]int8, ys *[]int8, count int32, bar_size float64) {
	label_idArg, label_idFin := WrapString(label_id)
	xsArg := make([]C.ImS8, len(*xs))
	for i, xsV := range *xs {
		xsArg[i] = C.ImS8(xsV)
	}

	ysArg := make([]C.ImS8, len(*ys))
	for i, ysV := range *ys {
		ysArg[i] = C.ImS8(ysV)
	}

	C.wrap_ImPlot_PlotBars_S8PtrS8Ptr(label_idArg, (*C.ImS8)(&xsArg[0]), (*C.ImS8)(&ysArg[0]), C.int(count), C.double(bar_size))

	label_idFin()

	for i, xsV := range xsArg {
		(*xs)[i] = int8(xsV)
	}

	for i, ysV := range ysArg {
		(*ys)[i] = int8(ysV)
	}
}

func PlotPlotBarsU16PtrInt(label_id string, values *[]uint16, count int32) {
	label_idArg, label_idFin := WrapString(label_id)
	valuesArg := make([]C.ImU16, len(*values))
	for i, valuesV := range *values {
		valuesArg[i] = C.ImU16(valuesV)
	}

	C.wrap_ImPlot_PlotBars_U16PtrInt(label_idArg, (*C.ImU16)(&valuesArg[0]), C.int(count))

	label_idFin()

	for i, valuesV := range valuesArg {
		(*values)[i] = uint16(valuesV)
	}
}

func PlotPlotBarsU16PtrU16Ptr(label_id string, xs *[]uint16, ys *[]uint16, count int32, bar_size float64) {
	label_idArg, label_idFin := WrapString(label_id)
	xsArg := make([]C.ImU16, len(*xs))
	for i, xsV := range *xs {
		xsArg[i] = C.ImU16(xsV)
	}

	ysArg := make([]C.ImU16, len(*ys))
	for i, ysV := range *ys {
		ysArg[i] = C.ImU16(ysV)
	}

	C.wrap_ImPlot_PlotBars_U16PtrU16Ptr(label_idArg, (*C.ImU16)(&xsArg[0]), (*C.ImU16)(&ysArg[0]), C.int(count), C.double(bar_size))

	label_idFin()

	for i, xsV := range xsArg {
		(*xs)[i] = uint16(xsV)
	}

	for i, ysV := range ysArg {
		(*ys)[i] = uint16(ysV)
	}
}

func PlotPlotBarsU32PtrInt(label_id string, values *[]uint32, count int32) {
	label_idArg, label_idFin := WrapString(label_id)
	valuesArg := make([]C.ImU32, len(*values))
	for i, valuesV := range *values {
		valuesArg[i] = C.ImU32(valuesV)
	}

	C.wrap_ImPlot_PlotBars_U32PtrInt(label_idArg, (*C.ImU32)(&valuesArg[0]), C.int(count))

	label_idFin()

	for i, valuesV := range valuesArg {
		(*values)[i] = uint32(valuesV)
	}
}

func PlotPlotBarsU32PtrU32Ptr(label_id string, xs *[]uint32, ys *[]uint32, count int32, bar_size float64) {
	label_idArg, label_idFin := WrapString(label_id)
	xsArg := make([]C.ImU32, len(*xs))
	for i, xsV := range *xs {
		xsArg[i] = C.ImU32(xsV)
	}

	ysArg := make([]C.ImU32, len(*ys))
	for i, ysV := range *ys {
		ysArg[i] = C.ImU32(ysV)
	}

	C.wrap_ImPlot_PlotBars_U32PtrU32Ptr(label_idArg, (*C.ImU32)(&xsArg[0]), (*C.ImU32)(&ysArg[0]), C.int(count), C.double(bar_size))

	label_idFin()

	for i, xsV := range xsArg {
		(*xs)[i] = uint32(xsV)
	}

	for i, ysV := range ysArg {
		(*ys)[i] = uint32(ysV)
	}
}

func PlotPlotBarsU64PtrInt(label_id string, values []uint64, count int32) {
	label_idArg, label_idFin := WrapString(label_id)
	C.wrap_ImPlot_PlotBars_U64PtrInt(label_idArg, (*C.ulonglong)(&(values[0])), C.int(count))

	label_idFin()
}

func PlotPlotBarsU64PtrU64Ptr(label_id string, xs []uint64, ys []uint64, count int32, bar_size float64) {
	label_idArg, label_idFin := WrapString(label_id)
	C.wrap_ImPlot_PlotBars_U64PtrU64Ptr(label_idArg, (*C.ulonglong)(&(xs[0])), (*C.ulonglong)(&(ys[0])), C.int(count), C.double(bar_size))

	label_idFin()
}

func PlotPlotBarsU8PtrInt(label_id string, values *[]byte, count int32) {
	label_idArg, label_idFin := WrapString(label_id)
	valuesArg := make([]C.ImU8, len(*values))
	for i, valuesV := range *values {
		valuesArg[i] = C.ImU8(valuesV)
	}

	C.wrap_ImPlot_PlotBars_U8PtrInt(label_idArg, (*C.ImU8)(&valuesArg[0]), C.int(count))

	label_idFin()

	for i, valuesV := range valuesArg {
		(*values)[i] = byte(valuesV)
	}
}

func PlotPlotBarsU8PtrU8Ptr(label_id string, xs *[]byte, ys *[]byte, count int32, bar_size float64) {
	label_idArg, label_idFin := WrapString(label_id)
	xsArg := make([]C.ImU8, len(*xs))
	for i, xsV := range *xs {
		xsArg[i] = C.ImU8(xsV)
	}

	ysArg := make([]C.ImU8, len(*ys))
	for i, ysV := range *ys {
		ysArg[i] = C.ImU8(ysV)
	}

	C.wrap_ImPlot_PlotBars_U8PtrU8Ptr(label_idArg, (*C.ImU8)(&xsArg[0]), (*C.ImU8)(&ysArg[0]), C.int(count), C.double(bar_size))

	label_idFin()

	for i, xsV := range xsArg {
		(*xs)[i] = byte(xsV)
	}

	for i, ysV := range ysArg {
		(*ys)[i] = byte(ysV)
	}
}

func PlotPlotBarsdoublePtrInt(label_id string, values *[]float64, count int32) {
	label_idArg, label_idFin := WrapString(label_id)
	valuesArg := make([]C.double, len(*values))
	for i, valuesV := range *values {
		valuesArg[i] = C.double(valuesV)
	}

	C.wrap_ImPlot_PlotBars_doublePtrInt(label_idArg, (*C.double)(&valuesArg[0]), C.int(count))

	label_idFin()

	for i, valuesV := range valuesArg {
		(*values)[i] = float64(valuesV)
	}
}

func PlotPlotBarsdoublePtrdoublePtr(label_id string, xs *[]float64, ys *[]float64, count int32, bar_size float64) {
	label_idArg, label_idFin := WrapString(label_id)
	xsArg := make([]C.double, len(*xs))
	for i, xsV := range *xs {
		xsArg[i] = C.double(xsV)
	}

	ysArg := make([]C.double, len(*ys))
	for i, ysV := range *ys {
		ysArg[i] = C.double(ysV)
	}

	C.wrap_ImPlot_PlotBars_doublePtrdoublePtr(label_idArg, (*C.double)(&xsArg[0]), (*C.double)(&ysArg[0]), C.int(count), C.double(bar_size))

	label_idFin()

	for i, xsV := range xsArg {
		(*xs)[i] = float64(xsV)
	}

	for i, ysV := range ysArg {
		(*ys)[i] = float64(ysV)
	}
}

func PlotPlotDigitalFloatPtr(label_id string, xs []float32, ys []float32, count int32) {
	label_idArg, label_idFin := WrapString(label_id)
	C.wrap_ImPlot_PlotDigital_FloatPtr(label_idArg, (*C.float)(&(xs[0])), (*C.float)(&(ys[0])), C.int(count))

	label_idFin()
}

func PlotPlotDigitalS16Ptr(label_id string, xs *[]int, ys *[]int, count int32) {
	label_idArg, label_idFin := WrapString(label_id)
	xsArg := make([]C.ImS16, len(*xs))
	for i, xsV := range *xs {
		xsArg[i] = C.ImS16(xsV)
	}

	ysArg := make([]C.ImS16, len(*ys))
	for i, ysV := range *ys {
		ysArg[i] = C.ImS16(ysV)
	}

	C.wrap_ImPlot_PlotDigital_S16Ptr(label_idArg, (*C.ImS16)(&xsArg[0]), (*C.ImS16)(&ysArg[0]), C.int(count))

	label_idFin()

	for i, xsV := range xsArg {
		(*xs)[i] = int(xsV)
	}

	for i, ysV := range ysArg {
		(*ys)[i] = int(ysV)
	}
}

func PlotPlotDigitalS32Ptr(label_id string, xs *[]int32, ys *[]int32, count int32) {
	label_idArg, label_idFin := WrapString(label_id)
	xsArg := make([]C.ImS32, len(*xs))
	for i, xsV := range *xs {
		xsArg[i] = C.ImS32(xsV)
	}

	ysArg := make([]C.ImS32, len(*ys))
	for i, ysV := range *ys {
		ysArg[i] = C.ImS32(ysV)
	}

	C.wrap_ImPlot_PlotDigital_S32Ptr(label_idArg, (*C.ImS32)(&xsArg[0]), (*C.ImS32)(&ysArg[0]), C.int(count))

	label_idFin()

	for i, xsV := range xsArg {
		(*xs)[i] = int32(xsV)
	}

	for i, ysV := range ysArg {
		(*ys)[i] = int32(ysV)
	}
}

func PlotPlotDigitalS64Ptr(label_id string, xs []int64, ys []int64, count int32) {
	label_idArg, label_idFin := WrapString(label_id)
	C.wrap_ImPlot_PlotDigital_S64Ptr(label_idArg, (*C.longlong)(&(xs[0])), (*C.longlong)(&(ys[0])), C.int(count))

	label_idFin()
}

func PlotPlotDigitalS8Ptr(label_id string, xs *[]int8, ys *[]int8, count int32) {
	label_idArg, label_idFin := WrapString(label_id)
	xsArg := make([]C.ImS8, len(*xs))
	for i, xsV := range *xs {
		xsArg[i] = C.ImS8(xsV)
	}

	ysArg := make([]C.ImS8, len(*ys))
	for i, ysV := range *ys {
		ysArg[i] = C.ImS8(ysV)
	}

	C.wrap_ImPlot_PlotDigital_S8Ptr(label_idArg, (*C.ImS8)(&xsArg[0]), (*C.ImS8)(&ysArg[0]), C.int(count))

	label_idFin()

	for i, xsV := range xsArg {
		(*xs)[i] = int8(xsV)
	}

	for i, ysV := range ysArg {
		(*ys)[i] = int8(ysV)
	}
}

func PlotPlotDigitalU16Ptr(label_id string, xs *[]uint16, ys *[]uint16, count int32) {
	label_idArg, label_idFin := WrapString(label_id)
	xsArg := make([]C.ImU16, len(*xs))
	for i, xsV := range *xs {
		xsArg[i] = C.ImU16(xsV)
	}

	ysArg := make([]C.ImU16, len(*ys))
	for i, ysV := range *ys {
		ysArg[i] = C.ImU16(ysV)
	}

	C.wrap_ImPlot_PlotDigital_U16Ptr(label_idArg, (*C.ImU16)(&xsArg[0]), (*C.ImU16)(&ysArg[0]), C.int(count))

	label_idFin()

	for i, xsV := range xsArg {
		(*xs)[i] = uint16(xsV)
	}

	for i, ysV := range ysArg {
		(*ys)[i] = uint16(ysV)
	}
}

func PlotPlotDigitalU32Ptr(label_id string, xs *[]uint32, ys *[]uint32, count int32) {
	label_idArg, label_idFin := WrapString(label_id)
	xsArg := make([]C.ImU32, len(*xs))
	for i, xsV := range *xs {
		xsArg[i] = C.ImU32(xsV)
	}

	ysArg := make([]C.ImU32, len(*ys))
	for i, ysV := range *ys {
		ysArg[i] = C.ImU32(ysV)
	}

	C.wrap_ImPlot_PlotDigital_U32Ptr(label_idArg, (*C.ImU32)(&xsArg[0]), (*C.ImU32)(&ysArg[0]), C.int(count))

	label_idFin()

	for i, xsV := range xsArg {
		(*xs)[i] = uint32(xsV)
	}

	for i, ysV := range ysArg {
		(*ys)[i] = uint32(ysV)
	}
}

func PlotPlotDigitalU64Ptr(label_id string, xs []uint64, ys []uint64, count int32) {
	label_idArg, label_idFin := WrapString(label_id)
	C.wrap_ImPlot_PlotDigital_U64Ptr(label_idArg, (*C.ulonglong)(&(xs[0])), (*C.ulonglong)(&(ys[0])), C.int(count))

	label_idFin()
}

func PlotPlotDigitalU8Ptr(label_id string, xs *[]byte, ys *[]byte, count int32) {
	label_idArg, label_idFin := WrapString(label_id)
	xsArg := make([]C.ImU8, len(*xs))
	for i, xsV := range *xs {
		xsArg[i] = C.ImU8(xsV)
	}

	ysArg := make([]C.ImU8, len(*ys))
	for i, ysV := range *ys {
		ysArg[i] = C.ImU8(ysV)
	}

	C.wrap_ImPlot_PlotDigital_U8Ptr(label_idArg, (*C.ImU8)(&xsArg[0]), (*C.ImU8)(&ysArg[0]), C.int(count))

	label_idFin()

	for i, xsV := range xsArg {
		(*xs)[i] = byte(xsV)
	}

	for i, ysV := range ysArg {
		(*ys)[i] = byte(ysV)
	}
}

func PlotPlotDigitaldoublePtr(label_id string, xs *[]float64, ys *[]float64, count int32) {
	label_idArg, label_idFin := WrapString(label_id)
	xsArg := make([]C.double, len(*xs))
	for i, xsV := range *xs {
		xsArg[i] = C.double(xsV)
	}

	ysArg := make([]C.double, len(*ys))
	for i, ysV := range *ys {
		ysArg[i] = C.double(ysV)
	}

	C.wrap_ImPlot_PlotDigital_doublePtr(label_idArg, (*C.double)(&xsArg[0]), (*C.double)(&ysArg[0]), C.int(count))

	label_idFin()

	for i, xsV := range xsArg {
		(*xs)[i] = float64(xsV)
	}

	for i, ysV := range ysArg {
		(*ys)[i] = float64(ysV)
	}
}

func PlotPlotDummy(label_id string) {
	label_idArg, label_idFin := WrapString(label_id)
	C.wrap_ImPlot_PlotDummy(label_idArg)

	label_idFin()
}

func PlotPlotErrorBarsFloatPtrFloatPtrFloatPtrFloatPtr(label_id string, xs []float32, ys []float32, neg []float32, pos []float32, count int32) {
	label_idArg, label_idFin := WrapString(label_id)
	C.wrap_ImPlot_PlotErrorBars_FloatPtrFloatPtrFloatPtrFloatPtr(label_idArg, (*C.float)(&(xs[0])), (*C.float)(&(ys[0])), (*C.float)(&(neg[0])), (*C.float)(&(pos[0])), C.int(count))

	label_idFin()
}

func PlotPlotErrorBarsFloatPtrFloatPtrFloatPtrInt(label_id string, xs []float32, ys []float32, err []float32, count int32) {
	label_idArg, label_idFin := WrapString(label_id)
	C.wrap_ImPlot_PlotErrorBars_FloatPtrFloatPtrFloatPtrInt(label_idArg, (*C.float)(&(xs[0])), (*C.float)(&(ys[0])), (*C.float)(&(err[0])), C.int(count))

	label_idFin()
}

func PlotPlotErrorBarsS16PtrS16PtrS16PtrInt(label_id string, xs *[]int, ys *[]int, err *[]int, count int32) {
	label_idArg, label_idFin := WrapString(label_id)
	xsArg := make([]C.ImS16, len(*xs))
	for i, xsV := range *xs {
		xsArg[i] = C.ImS16(xsV)
	}

	ysArg := make([]C.ImS16, len(*ys))
	for i, ysV := range *ys {
		ysArg[i] = C.ImS16(ysV)
	}

	errArg := make([]C.ImS16, len(*err))
	for i, errV := range *err {
		errArg[i] = C.ImS16(errV)
	}

	C.wrap_ImPlot_PlotErrorBars_S16PtrS16PtrS16PtrInt(label_idArg, (*C.ImS16)(&xsArg[0]), (*C.ImS16)(&ysArg[0]), (*C.ImS16)(&errArg[0]), C.int(count))

	label_idFin()

	for i, xsV := range xsArg {
		(*xs)[i] = int(xsV)
	}

	for i, ysV := range ysArg {
		(*ys)[i] = int(ysV)
	}

	for i, errV := range errArg {
		(*err)[i] = int(errV)
	}
}

func PlotPlotErrorBarsS16PtrS16PtrS16PtrS16Ptr(label_id string, xs *[]int, ys *[]int, neg *[]int, pos *[]int, count int32) {
	label_idArg, label_idFin := WrapString(label_id)
	xsArg := make([]C.ImS16, len(*xs))
	for i, xsV := range *xs {
		xsArg[i] = C.ImS16(xsV)
	}

	ysArg := make([]C.ImS16, len(*ys))
	for i, ysV := range *ys {
		ysArg[i] = C.ImS16(ysV)
	}

	negArg := make([]C.ImS16, len(*neg))
	for i, negV := range *neg {
		negArg[i] = C.ImS16(negV)
	}

	posArg := make([]C.ImS16, len(*pos))
	for i, posV := range *pos {
		posArg[i] = C.ImS16(posV)
	}

	C.wrap_ImPlot_PlotErrorBars_S16PtrS16PtrS16PtrS16Ptr(label_idArg, (*C.ImS16)(&xsArg[0]), (*C.ImS16)(&ysArg[0]), (*C.ImS16)(&negArg[0]), (*C.ImS16)(&posArg[0]), C.int(count))

	label_idFin()

	for i, xsV := range xsArg {
		(*xs)[i] = int(xsV)
	}

	for i, ysV := range ysArg {
		(*ys)[i] = int(ysV)
	}

	for i, negV := range negArg {
		(*neg)[i] = int(negV)
	}

	for i, posV := range posArg {
		(*pos)[i] = int(posV)
	}
}

func PlotPlotErrorBarsS32PtrS32PtrS32PtrInt(label_id string, xs *[]int32, ys *[]int32, err *[]int32, count int32) {
	label_idArg, label_idFin := WrapString(label_id)
	xsArg := make([]C.ImS32, len(*xs))
	for i, xsV := range *xs {
		xsArg[i] = C.ImS32(xsV)
	}

	ysArg := make([]C.ImS32, len(*ys))
	for i, ysV := range *ys {
		ysArg[i] = C.ImS32(ysV)
	}

	errArg := make([]C.ImS32, len(*err))
	for i, errV := range *err {
		errArg[i] = C.ImS32(errV)
	}

	C.wrap_ImPlot_PlotErrorBars_S32PtrS32PtrS32PtrInt(label_idArg, (*C.ImS32)(&xsArg[0]), (*C.ImS32)(&ysArg[0]), (*C.ImS32)(&errArg[0]), C.int(count))

	label_idFin()

	for i, xsV := range xsArg {
		(*xs)[i] = int32(xsV)
	}

	for i, ysV := range ysArg {
		(*ys)[i] = int32(ysV)
	}

	for i, errV := range errArg {
		(*err)[i] = int32(errV)
	}
}

func PlotPlotErrorBarsS32PtrS32PtrS32PtrS32Ptr(label_id string, xs *[]int32, ys *[]int32, neg *[]int32, pos *[]int32, count int32) {
	label_idArg, label_idFin := WrapString(label_id)
	xsArg := make([]C.ImS32, len(*xs))
	for i, xsV := range *xs {
		xsArg[i] = C.ImS32(xsV)
	}

	ysArg := make([]C.ImS32, len(*ys))
	for i, ysV := range *ys {
		ysArg[i] = C.ImS32(ysV)
	}

	negArg := make([]C.ImS32, len(*neg))
	for i, negV := range *neg {
		negArg[i] = C.ImS32(negV)
	}

	posArg := make([]C.ImS32, len(*pos))
	for i, posV := range *pos {
		posArg[i] = C.ImS32(posV)
	}

	C.wrap_ImPlot_PlotErrorBars_S32PtrS32PtrS32PtrS32Ptr(label_idArg, (*C.ImS32)(&xsArg[0]), (*C.ImS32)(&ysArg[0]), (*C.ImS32)(&negArg[0]), (*C.ImS32)(&posArg[0]), C.int(count))

	label_idFin()

	for i, xsV := range xsArg {
		(*xs)[i] = int32(xsV)
	}

	for i, ysV := range ysArg {
		(*ys)[i] = int32(ysV)
	}

	for i, negV := range negArg {
		(*neg)[i] = int32(negV)
	}

	for i, posV := range posArg {
		(*pos)[i] = int32(posV)
	}
}

func PlotPlotErrorBarsS64PtrS64PtrS64PtrInt(label_id string, xs []int64, ys []int64, err []int64, count int32) {
	label_idArg, label_idFin := WrapString(label_id)
	C.wrap_ImPlot_PlotErrorBars_S64PtrS64PtrS64PtrInt(label_idArg, (*C.longlong)(&(xs[0])), (*C.longlong)(&(ys[0])), (*C.longlong)(&(err[0])), C.int(count))

	label_idFin()
}

func PlotPlotErrorBarsS64PtrS64PtrS64PtrS64Ptr(label_id string, xs []int64, ys []int64, neg []int64, pos []int64, count int32) {
	label_idArg, label_idFin := WrapString(label_id)
	C.wrap_ImPlot_PlotErrorBars_S64PtrS64PtrS64PtrS64Ptr(label_idArg, (*C.longlong)(&(xs[0])), (*C.longlong)(&(ys[0])), (*C.longlong)(&(neg[0])), (*C.longlong)(&(pos[0])), C.int(count))

	label_idFin()
}

func PlotPlotErrorBarsS8PtrS8PtrS8PtrInt(label_id string, xs *[]int8, ys *[]int8, err *[]int8, count int32) {
	label_idArg, label_idFin := WrapString(label_id)
	xsArg := make([]C.ImS8, len(*xs))
	for i, xsV := range *xs {
		xsArg[i] = C.ImS8(xsV)
	}

	ysArg := make([]C.ImS8, len(*ys))
	for i, ysV := range *ys {
		ysArg[i] = C.ImS8(ysV)
	}

	errArg := make([]C.ImS8, len(*err))
	for i, errV := range *err {
		errArg[i] = C.ImS8(errV)
	}

	C.wrap_ImPlot_PlotErrorBars_S8PtrS8PtrS8PtrInt(label_idArg, (*C.ImS8)(&xsArg[0]), (*C.ImS8)(&ysArg[0]), (*C.ImS8)(&errArg[0]), C.int(count))

	label_idFin()

	for i, xsV := range xsArg {
		(*xs)[i] = int8(xsV)
	}

	for i, ysV := range ysArg {
		(*ys)[i] = int8(ysV)
	}

	for i, errV := range errArg {
		(*err)[i] = int8(errV)
	}
}

func PlotPlotErrorBarsS8PtrS8PtrS8PtrS8Ptr(label_id string, xs *[]int8, ys *[]int8, neg *[]int8, pos *[]int8, count int32) {
	label_idArg, label_idFin := WrapString(label_id)
	xsArg := make([]C.ImS8, len(*xs))
	for i, xsV := range *xs {
		xsArg[i] = C.ImS8(xsV)
	}

	ysArg := make([]C.ImS8, len(*ys))
	for i, ysV := range *ys {
		ysArg[i] = C.ImS8(ysV)
	}

	negArg := make([]C.ImS8, len(*neg))
	for i, negV := range *neg {
		negArg[i] = C.ImS8(negV)
	}

	posArg := make([]C.ImS8, len(*pos))
	for i, posV := range *pos {
		posArg[i] = C.ImS8(posV)
	}

	C.wrap_ImPlot_PlotErrorBars_S8PtrS8PtrS8PtrS8Ptr(label_idArg, (*C.ImS8)(&xsArg[0]), (*C.ImS8)(&ysArg[0]), (*C.ImS8)(&negArg[0]), (*C.ImS8)(&posArg[0]), C.int(count))

	label_idFin()

	for i, xsV := range xsArg {
		(*xs)[i] = int8(xsV)
	}

	for i, ysV := range ysArg {
		(*ys)[i] = int8(ysV)
	}

	for i, negV := range negArg {
		(*neg)[i] = int8(negV)
	}

	for i, posV := range posArg {
		(*pos)[i] = int8(posV)
	}
}

func PlotPlotErrorBarsU16PtrU16PtrU16PtrInt(label_id string, xs *[]uint16, ys *[]uint16, err *[]uint16, count int32) {
	label_idArg, label_idFin := WrapString(label_id)
	xsArg := make([]C.ImU16, len(*xs))
	for i, xsV := range *xs {
		xsArg[i] = C.ImU16(xsV)
	}

	ysArg := make([]C.ImU16, len(*ys))
	for i, ysV := range *ys {
		ysArg[i] = C.ImU16(ysV)
	}

	errArg := make([]C.ImU16, len(*err))
	for i, errV := range *err {
		errArg[i] = C.ImU16(errV)
	}

	C.wrap_ImPlot_PlotErrorBars_U16PtrU16PtrU16PtrInt(label_idArg, (*C.ImU16)(&xsArg[0]), (*C.ImU16)(&ysArg[0]), (*C.ImU16)(&errArg[0]), C.int(count))

	label_idFin()

	for i, xsV := range xsArg {
		(*xs)[i] = uint16(xsV)
	}

	for i, ysV := range ysArg {
		(*ys)[i] = uint16(ysV)
	}

	for i, errV := range errArg {
		(*err)[i] = uint16(errV)
	}
}

func PlotPlotErrorBarsU16PtrU16PtrU16PtrU16Ptr(label_id string, xs *[]uint16, ys *[]uint16, neg *[]uint16, pos *[]uint16, count int32) {
	label_idArg, label_idFin := WrapString(label_id)
	xsArg := make([]C.ImU16, len(*xs))
	for i, xsV := range *xs {
		xsArg[i] = C.ImU16(xsV)
	}

	ysArg := make([]C.ImU16, len(*ys))
	for i, ysV := range *ys {
		ysArg[i] = C.ImU16(ysV)
	}

	negArg := make([]C.ImU16, len(*neg))
	for i, negV := range *neg {
		negArg[i] = C.ImU16(negV)
	}

	posArg := make([]C.ImU16, len(*pos))
	for i, posV := range *pos {
		posArg[i] = C.ImU16(posV)
	}

	C.wrap_ImPlot_PlotErrorBars_U16PtrU16PtrU16PtrU16Ptr(label_idArg, (*C.ImU16)(&xsArg[0]), (*C.ImU16)(&ysArg[0]), (*C.ImU16)(&negArg[0]), (*C.ImU16)(&posArg[0]), C.int(count))

	label_idFin()

	for i, xsV := range xsArg {
		(*xs)[i] = uint16(xsV)
	}

	for i, ysV := range ysArg {
		(*ys)[i] = uint16(ysV)
	}

	for i, negV := range negArg {
		(*neg)[i] = uint16(negV)
	}

	for i, posV := range posArg {
		(*pos)[i] = uint16(posV)
	}
}

func PlotPlotErrorBarsU32PtrU32PtrU32PtrInt(label_id string, xs *[]uint32, ys *[]uint32, err *[]uint32, count int32) {
	label_idArg, label_idFin := WrapString(label_id)
	xsArg := make([]C.ImU32, len(*xs))
	for i, xsV := range *xs {
		xsArg[i] = C.ImU32(xsV)
	}

	ysArg := make([]C.ImU32, len(*ys))
	for i, ysV := range *ys {
		ysArg[i] = C.ImU32(ysV)
	}

	errArg := make([]C.ImU32, len(*err))
	for i, errV := range *err {
		errArg[i] = C.ImU32(errV)
	}

	C.wrap_ImPlot_PlotErrorBars_U32PtrU32PtrU32PtrInt(label_idArg, (*C.ImU32)(&xsArg[0]), (*C.ImU32)(&ysArg[0]), (*C.ImU32)(&errArg[0]), C.int(count))

	label_idFin()

	for i, xsV := range xsArg {
		(*xs)[i] = uint32(xsV)
	}

	for i, ysV := range ysArg {
		(*ys)[i] = uint32(ysV)
	}

	for i, errV := range errArg {
		(*err)[i] = uint32(errV)
	}
}

func PlotPlotErrorBarsU32PtrU32PtrU32PtrU32Ptr(label_id string, xs *[]uint32, ys *[]uint32, neg *[]uint32, pos *[]uint32, count int32) {
	label_idArg, label_idFin := WrapString(label_id)
	xsArg := make([]C.ImU32, len(*xs))
	for i, xsV := range *xs {
		xsArg[i] = C.ImU32(xsV)
	}

	ysArg := make([]C.ImU32, len(*ys))
	for i, ysV := range *ys {
		ysArg[i] = C.ImU32(ysV)
	}

	negArg := make([]C.ImU32, len(*neg))
	for i, negV := range *neg {
		negArg[i] = C.ImU32(negV)
	}

	posArg := make([]C.ImU32, len(*pos))
	for i, posV := range *pos {
		posArg[i] = C.ImU32(posV)
	}

	C.wrap_ImPlot_PlotErrorBars_U32PtrU32PtrU32PtrU32Ptr(label_idArg, (*C.ImU32)(&xsArg[0]), (*C.ImU32)(&ysArg[0]), (*C.ImU32)(&negArg[0]), (*C.ImU32)(&posArg[0]), C.int(count))

	label_idFin()

	for i, xsV := range xsArg {
		(*xs)[i] = uint32(xsV)
	}

	for i, ysV := range ysArg {
		(*ys)[i] = uint32(ysV)
	}

	for i, negV := range negArg {
		(*neg)[i] = uint32(negV)
	}

	for i, posV := range posArg {
		(*pos)[i] = uint32(posV)
	}
}

func PlotPlotErrorBarsU64PtrU64PtrU64PtrInt(label_id string, xs []uint64, ys []uint64, err []uint64, count int32) {
	label_idArg, label_idFin := WrapString(label_id)
	C.wrap_ImPlot_PlotErrorBars_U64PtrU64PtrU64PtrInt(label_idArg, (*C.ulonglong)(&(xs[0])), (*C.ulonglong)(&(ys[0])), (*C.ulonglong)(&(err[0])), C.int(count))

	label_idFin()
}

func PlotPlotErrorBarsU64PtrU64PtrU64PtrU64Ptr(label_id string, xs []uint64, ys []uint64, neg []uint64, pos []uint64, count int32) {
	label_idArg, label_idFin := WrapString(label_id)
	C.wrap_ImPlot_PlotErrorBars_U64PtrU64PtrU64PtrU64Ptr(label_idArg, (*C.ulonglong)(&(xs[0])), (*C.ulonglong)(&(ys[0])), (*C.ulonglong)(&(neg[0])), (*C.ulonglong)(&(pos[0])), C.int(count))

	label_idFin()
}

func PlotPlotErrorBarsU8PtrU8PtrU8PtrInt(label_id string, xs *[]byte, ys *[]byte, err *[]byte, count int32) {
	label_idArg, label_idFin := WrapString(label_id)
	xsArg := make([]C.ImU8, len(*xs))
	for i, xsV := range *xs {
		xsArg[i] = C.ImU8(xsV)
	}

	ysArg := make([]C.ImU8, len(*ys))
	for i, ysV := range *ys {
		ysArg[i] = C.ImU8(ysV)
	}

	errArg := make([]C.ImU8, len(*err))
	for i, errV := range *err {
		errArg[i] = C.ImU8(errV)
	}

	C.wrap_ImPlot_PlotErrorBars_U8PtrU8PtrU8PtrInt(label_idArg, (*C.ImU8)(&xsArg[0]), (*C.ImU8)(&ysArg[0]), (*C.ImU8)(&errArg[0]), C.int(count))

	label_idFin()

	for i, xsV := range xsArg {
		(*xs)[i] = byte(xsV)
	}

	for i, ysV := range ysArg {
		(*ys)[i] = byte(ysV)
	}

	for i, errV := range errArg {
		(*err)[i] = byte(errV)
	}
}

func PlotPlotErrorBarsU8PtrU8PtrU8PtrU8Ptr(label_id string, xs *[]byte, ys *[]byte, neg *[]byte, pos *[]byte, count int32) {
	label_idArg, label_idFin := WrapString(label_id)
	xsArg := make([]C.ImU8, len(*xs))
	for i, xsV := range *xs {
		xsArg[i] = C.ImU8(xsV)
	}

	ysArg := make([]C.ImU8, len(*ys))
	for i, ysV := range *ys {
		ysArg[i] = C.ImU8(ysV)
	}

	negArg := make([]C.ImU8, len(*neg))
	for i, negV := range *neg {
		negArg[i] = C.ImU8(negV)
	}

	posArg := make([]C.ImU8, len(*pos))
	for i, posV := range *pos {
		posArg[i] = C.ImU8(posV)
	}

	C.wrap_ImPlot_PlotErrorBars_U8PtrU8PtrU8PtrU8Ptr(label_idArg, (*C.ImU8)(&xsArg[0]), (*C.ImU8)(&ysArg[0]), (*C.ImU8)(&negArg[0]), (*C.ImU8)(&posArg[0]), C.int(count))

	label_idFin()

	for i, xsV := range xsArg {
		(*xs)[i] = byte(xsV)
	}

	for i, ysV := range ysArg {
		(*ys)[i] = byte(ysV)
	}

	for i, negV := range negArg {
		(*neg)[i] = byte(negV)
	}

	for i, posV := range posArg {
		(*pos)[i] = byte(posV)
	}
}

func PlotPlotErrorBarsdoublePtrdoublePtrdoublePtrInt(label_id string, xs *[]float64, ys *[]float64, err *[]float64, count int32) {
	label_idArg, label_idFin := WrapString(label_id)
	xsArg := make([]C.double, len(*xs))
	for i, xsV := range *xs {
		xsArg[i] = C.double(xsV)
	}

	ysArg := make([]C.double, len(*ys))
	for i, ysV := range *ys {
		ysArg[i] = C.double(ysV)
	}

	errArg := make([]C.double, len(*err))
	for i, errV := range *err {
		errArg[i] = C.double(errV)
	}

	C.wrap_ImPlot_PlotErrorBars_doublePtrdoublePtrdoublePtrInt(label_idArg, (*C.double)(&xsArg[0]), (*C.double)(&ysArg[0]), (*C.double)(&errArg[0]), C.int(count))

	label_idFin()

	for i, xsV := range xsArg {
		(*xs)[i] = float64(xsV)
	}

	for i, ysV := range ysArg {
		(*ys)[i] = float64(ysV)
	}

	for i, errV := range errArg {
		(*err)[i] = float64(errV)
	}
}

func PlotPlotErrorBarsdoublePtrdoublePtrdoublePtrdoublePtr(label_id string, xs *[]float64, ys *[]float64, neg *[]float64, pos *[]float64, count int32) {
	label_idArg, label_idFin := WrapString(label_id)
	xsArg := make([]C.double, len(*xs))
	for i, xsV := range *xs {
		xsArg[i] = C.double(xsV)
	}

	ysArg := make([]C.double, len(*ys))
	for i, ysV := range *ys {
		ysArg[i] = C.double(ysV)
	}

	negArg := make([]C.double, len(*neg))
	for i, negV := range *neg {
		negArg[i] = C.double(negV)
	}

	posArg := make([]C.double, len(*pos))
	for i, posV := range *pos {
		posArg[i] = C.double(posV)
	}

	C.wrap_ImPlot_PlotErrorBars_doublePtrdoublePtrdoublePtrdoublePtr(label_idArg, (*C.double)(&xsArg[0]), (*C.double)(&ysArg[0]), (*C.double)(&negArg[0]), (*C.double)(&posArg[0]), C.int(count))

	label_idFin()

	for i, xsV := range xsArg {
		(*xs)[i] = float64(xsV)
	}

	for i, ysV := range ysArg {
		(*ys)[i] = float64(ysV)
	}

	for i, negV := range negArg {
		(*neg)[i] = float64(negV)
	}

	for i, posV := range posArg {
		(*pos)[i] = float64(posV)
	}
}

func PlotPlotHeatmapFloatPtr(label_id string, values []float32, rows int32, cols int32) {
	label_idArg, label_idFin := WrapString(label_id)
	C.wrap_ImPlot_PlotHeatmap_FloatPtr(label_idArg, (*C.float)(&(values[0])), C.int(rows), C.int(cols))

	label_idFin()
}

func PlotPlotHeatmapS16Ptr(label_id string, values *[]int, rows int32, cols int32) {
	label_idArg, label_idFin := WrapString(label_id)
	valuesArg := make([]C.ImS16, len(*values))
	for i, valuesV := range *values {
		valuesArg[i] = C.ImS16(valuesV)
	}

	C.wrap_ImPlot_PlotHeatmap_S16Ptr(label_idArg, (*C.ImS16)(&valuesArg[0]), C.int(rows), C.int(cols))

	label_idFin()

	for i, valuesV := range valuesArg {
		(*values)[i] = int(valuesV)
	}
}

func PlotPlotHeatmapS32Ptr(label_id string, values *[]int32, rows int32, cols int32) {
	label_idArg, label_idFin := WrapString(label_id)
	valuesArg := make([]C.ImS32, len(*values))
	for i, valuesV := range *values {
		valuesArg[i] = C.ImS32(valuesV)
	}

	C.wrap_ImPlot_PlotHeatmap_S32Ptr(label_idArg, (*C.ImS32)(&valuesArg[0]), C.int(rows), C.int(cols))

	label_idFin()

	for i, valuesV := range valuesArg {
		(*values)[i] = int32(valuesV)
	}
}

func PlotPlotHeatmapS64Ptr(label_id string, values []int64, rows int32, cols int32) {
	label_idArg, label_idFin := WrapString(label_id)
	C.wrap_ImPlot_PlotHeatmap_S64Ptr(label_idArg, (*C.longlong)(&(values[0])), C.int(rows), C.int(cols))

	label_idFin()
}

func PlotPlotHeatmapS8Ptr(label_id string, values *[]int8, rows int32, cols int32) {
	label_idArg, label_idFin := WrapString(label_id)
	valuesArg := make([]C.ImS8, len(*values))
	for i, valuesV := range *values {
		valuesArg[i] = C.ImS8(valuesV)
	}

	C.wrap_ImPlot_PlotHeatmap_S8Ptr(label_idArg, (*C.ImS8)(&valuesArg[0]), C.int(rows), C.int(cols))

	label_idFin()

	for i, valuesV := range valuesArg {
		(*values)[i] = int8(valuesV)
	}
}

func PlotPlotHeatmapU16Ptr(label_id string, values *[]uint16, rows int32, cols int32) {
	label_idArg, label_idFin := WrapString(label_id)
	valuesArg := make([]C.ImU16, len(*values))
	for i, valuesV := range *values {
		valuesArg[i] = C.ImU16(valuesV)
	}

	C.wrap_ImPlot_PlotHeatmap_U16Ptr(label_idArg, (*C.ImU16)(&valuesArg[0]), C.int(rows), C.int(cols))

	label_idFin()

	for i, valuesV := range valuesArg {
		(*values)[i] = uint16(valuesV)
	}
}

func PlotPlotHeatmapU32Ptr(label_id string, values *[]uint32, rows int32, cols int32) {
	label_idArg, label_idFin := WrapString(label_id)
	valuesArg := make([]C.ImU32, len(*values))
	for i, valuesV := range *values {
		valuesArg[i] = C.ImU32(valuesV)
	}

	C.wrap_ImPlot_PlotHeatmap_U32Ptr(label_idArg, (*C.ImU32)(&valuesArg[0]), C.int(rows), C.int(cols))

	label_idFin()

	for i, valuesV := range valuesArg {
		(*values)[i] = uint32(valuesV)
	}
}

func PlotPlotHeatmapU64Ptr(label_id string, values []uint64, rows int32, cols int32) {
	label_idArg, label_idFin := WrapString(label_id)
	C.wrap_ImPlot_PlotHeatmap_U64Ptr(label_idArg, (*C.ulonglong)(&(values[0])), C.int(rows), C.int(cols))

	label_idFin()
}

func PlotPlotHeatmapU8Ptr(label_id string, values *[]byte, rows int32, cols int32) {
	label_idArg, label_idFin := WrapString(label_id)
	valuesArg := make([]C.ImU8, len(*values))
	for i, valuesV := range *values {
		valuesArg[i] = C.ImU8(valuesV)
	}

	C.wrap_ImPlot_PlotHeatmap_U8Ptr(label_idArg, (*C.ImU8)(&valuesArg[0]), C.int(rows), C.int(cols))

	label_idFin()

	for i, valuesV := range valuesArg {
		(*values)[i] = byte(valuesV)
	}
}

func PlotPlotHeatmapdoublePtr(label_id string, values *[]float64, rows int32, cols int32) {
	label_idArg, label_idFin := WrapString(label_id)
	valuesArg := make([]C.double, len(*values))
	for i, valuesV := range *values {
		valuesArg[i] = C.double(valuesV)
	}

	C.wrap_ImPlot_PlotHeatmap_doublePtr(label_idArg, (*C.double)(&valuesArg[0]), C.int(rows), C.int(cols))

	label_idFin()

	for i, valuesV := range valuesArg {
		(*values)[i] = float64(valuesV)
	}
}

func PlotPlotHistogram2DFloatPtr(label_id string, xs []float32, ys []float32, count int32) float64 {
	label_idArg, label_idFin := WrapString(label_id)

	defer func() {
		label_idFin()
	}()
	return float64(C.wrap_ImPlot_PlotHistogram2D_FloatPtr(label_idArg, (*C.float)(&(xs[0])), (*C.float)(&(ys[0])), C.int(count)))
}

func PlotPlotHistogram2DS16Ptr(label_id string, xs *[]int, ys *[]int, count int32) float64 {
	label_idArg, label_idFin := WrapString(label_id)
	xsArg := make([]C.ImS16, len(*xs))
	for i, xsV := range *xs {
		xsArg[i] = C.ImS16(xsV)
	}

	ysArg := make([]C.ImS16, len(*ys))
	for i, ysV := range *ys {
		ysArg[i] = C.ImS16(ysV)
	}

	defer func() {
		label_idFin()

		for i, xsV := range xsArg {
			(*xs)[i] = int(xsV)
		}

		for i, ysV := range ysArg {
			(*ys)[i] = int(ysV)
		}
	}()
	return float64(C.wrap_ImPlot_PlotHistogram2D_S16Ptr(label_idArg, (*C.ImS16)(&xsArg[0]), (*C.ImS16)(&ysArg[0]), C.int(count)))
}

func PlotPlotHistogram2DS32Ptr(label_id string, xs *[]int32, ys *[]int32, count int32) float64 {
	label_idArg, label_idFin := WrapString(label_id)
	xsArg := make([]C.ImS32, len(*xs))
	for i, xsV := range *xs {
		xsArg[i] = C.ImS32(xsV)
	}

	ysArg := make([]C.ImS32, len(*ys))
	for i, ysV := range *ys {
		ysArg[i] = C.ImS32(ysV)
	}

	defer func() {
		label_idFin()

		for i, xsV := range xsArg {
			(*xs)[i] = int32(xsV)
		}

		for i, ysV := range ysArg {
			(*ys)[i] = int32(ysV)
		}
	}()
	return float64(C.wrap_ImPlot_PlotHistogram2D_S32Ptr(label_idArg, (*C.ImS32)(&xsArg[0]), (*C.ImS32)(&ysArg[0]), C.int(count)))
}

func PlotPlotHistogram2DS64Ptr(label_id string, xs []int64, ys []int64, count int32) float64 {
	label_idArg, label_idFin := WrapString(label_id)

	defer func() {
		label_idFin()
	}()
	return float64(C.wrap_ImPlot_PlotHistogram2D_S64Ptr(label_idArg, (*C.longlong)(&(xs[0])), (*C.longlong)(&(ys[0])), C.int(count)))
}

func PlotPlotHistogram2DS8Ptr(label_id string, xs *[]int8, ys *[]int8, count int32) float64 {
	label_idArg, label_idFin := WrapString(label_id)
	xsArg := make([]C.ImS8, len(*xs))
	for i, xsV := range *xs {
		xsArg[i] = C.ImS8(xsV)
	}

	ysArg := make([]C.ImS8, len(*ys))
	for i, ysV := range *ys {
		ysArg[i] = C.ImS8(ysV)
	}

	defer func() {
		label_idFin()

		for i, xsV := range xsArg {
			(*xs)[i] = int8(xsV)
		}

		for i, ysV := range ysArg {
			(*ys)[i] = int8(ysV)
		}
	}()
	return float64(C.wrap_ImPlot_PlotHistogram2D_S8Ptr(label_idArg, (*C.ImS8)(&xsArg[0]), (*C.ImS8)(&ysArg[0]), C.int(count)))
}

func PlotPlotHistogram2DU16Ptr(label_id string, xs *[]uint16, ys *[]uint16, count int32) float64 {
	label_idArg, label_idFin := WrapString(label_id)
	xsArg := make([]C.ImU16, len(*xs))
	for i, xsV := range *xs {
		xsArg[i] = C.ImU16(xsV)
	}

	ysArg := make([]C.ImU16, len(*ys))
	for i, ysV := range *ys {
		ysArg[i] = C.ImU16(ysV)
	}

	defer func() {
		label_idFin()

		for i, xsV := range xsArg {
			(*xs)[i] = uint16(xsV)
		}

		for i, ysV := range ysArg {
			(*ys)[i] = uint16(ysV)
		}
	}()
	return float64(C.wrap_ImPlot_PlotHistogram2D_U16Ptr(label_idArg, (*C.ImU16)(&xsArg[0]), (*C.ImU16)(&ysArg[0]), C.int(count)))
}

func PlotPlotHistogram2DU32Ptr(label_id string, xs *[]uint32, ys *[]uint32, count int32) float64 {
	label_idArg, label_idFin := WrapString(label_id)
	xsArg := make([]C.ImU32, len(*xs))
	for i, xsV := range *xs {
		xsArg[i] = C.ImU32(xsV)
	}

	ysArg := make([]C.ImU32, len(*ys))
	for i, ysV := range *ys {
		ysArg[i] = C.ImU32(ysV)
	}

	defer func() {
		label_idFin()

		for i, xsV := range xsArg {
			(*xs)[i] = uint32(xsV)
		}

		for i, ysV := range ysArg {
			(*ys)[i] = uint32(ysV)
		}
	}()
	return float64(C.wrap_ImPlot_PlotHistogram2D_U32Ptr(label_idArg, (*C.ImU32)(&xsArg[0]), (*C.ImU32)(&ysArg[0]), C.int(count)))
}

func PlotPlotHistogram2DU64Ptr(label_id string, xs []uint64, ys []uint64, count int32) float64 {
	label_idArg, label_idFin := WrapString(label_id)

	defer func() {
		label_idFin()
	}()
	return float64(C.wrap_ImPlot_PlotHistogram2D_U64Ptr(label_idArg, (*C.ulonglong)(&(xs[0])), (*C.ulonglong)(&(ys[0])), C.int(count)))
}

func PlotPlotHistogram2DU8Ptr(label_id string, xs *[]byte, ys *[]byte, count int32) float64 {
	label_idArg, label_idFin := WrapString(label_id)
	xsArg := make([]C.ImU8, len(*xs))
	for i, xsV := range *xs {
		xsArg[i] = C.ImU8(xsV)
	}

	ysArg := make([]C.ImU8, len(*ys))
	for i, ysV := range *ys {
		ysArg[i] = C.ImU8(ysV)
	}

	defer func() {
		label_idFin()

		for i, xsV := range xsArg {
			(*xs)[i] = byte(xsV)
		}

		for i, ysV := range ysArg {
			(*ys)[i] = byte(ysV)
		}
	}()
	return float64(C.wrap_ImPlot_PlotHistogram2D_U8Ptr(label_idArg, (*C.ImU8)(&xsArg[0]), (*C.ImU8)(&ysArg[0]), C.int(count)))
}

func PlotPlotHistogram2DdoublePtr(label_id string, xs *[]float64, ys *[]float64, count int32) float64 {
	label_idArg, label_idFin := WrapString(label_id)
	xsArg := make([]C.double, len(*xs))
	for i, xsV := range *xs {
		xsArg[i] = C.double(xsV)
	}

	ysArg := make([]C.double, len(*ys))
	for i, ysV := range *ys {
		ysArg[i] = C.double(ysV)
	}

	defer func() {
		label_idFin()

		for i, xsV := range xsArg {
			(*xs)[i] = float64(xsV)
		}

		for i, ysV := range ysArg {
			(*ys)[i] = float64(ysV)
		}
	}()
	return float64(C.wrap_ImPlot_PlotHistogram2D_doublePtr(label_idArg, (*C.double)(&xsArg[0]), (*C.double)(&ysArg[0]), C.int(count)))
}

func PlotPlotHistogramFloatPtr(label_id string, values []float32, count int32) float64 {
	label_idArg, label_idFin := WrapString(label_id)

	defer func() {
		label_idFin()
	}()
	return float64(C.wrap_ImPlot_PlotHistogram_FloatPtr(label_idArg, (*C.float)(&(values[0])), C.int(count)))
}

func PlotPlotHistogramS16Ptr(label_id string, values *[]int, count int32) float64 {
	label_idArg, label_idFin := WrapString(label_id)
	valuesArg := make([]C.ImS16, len(*values))
	for i, valuesV := range *values {
		valuesArg[i] = C.ImS16(valuesV)
	}

	defer func() {
		label_idFin()

		for i, valuesV := range valuesArg {
			(*values)[i] = int(valuesV)
		}
	}()
	return float64(C.wrap_ImPlot_PlotHistogram_S16Ptr(label_idArg, (*C.ImS16)(&valuesArg[0]), C.int(count)))
}

func PlotPlotHistogramS32Ptr(label_id string, values *[]int32, count int32) float64 {
	label_idArg, label_idFin := WrapString(label_id)
	valuesArg := make([]C.ImS32, len(*values))
	for i, valuesV := range *values {
		valuesArg[i] = C.ImS32(valuesV)
	}

	defer func() {
		label_idFin()

		for i, valuesV := range valuesArg {
			(*values)[i] = int32(valuesV)
		}
	}()
	return float64(C.wrap_ImPlot_PlotHistogram_S32Ptr(label_idArg, (*C.ImS32)(&valuesArg[0]), C.int(count)))
}

func PlotPlotHistogramS64Ptr(label_id string, values []int64, count int32) float64 {
	label_idArg, label_idFin := WrapString(label_id)

	defer func() {
		label_idFin()
	}()
	return float64(C.wrap_ImPlot_PlotHistogram_S64Ptr(label_idArg, (*C.longlong)(&(values[0])), C.int(count)))
}

func PlotPlotHistogramS8Ptr(label_id string, values *[]int8, count int32) float64 {
	label_idArg, label_idFin := WrapString(label_id)
	valuesArg := make([]C.ImS8, len(*values))
	for i, valuesV := range *values {
		valuesArg[i] = C.ImS8(valuesV)
	}

	defer func() {
		label_idFin()

		for i, valuesV := range valuesArg {
			(*values)[i] = int8(valuesV)
		}
	}()
	return float64(C.wrap_ImPlot_PlotHistogram_S8Ptr(label_idArg, (*C.ImS8)(&valuesArg[0]), C.int(count)))
}

func PlotPlotHistogramU16Ptr(label_id string, values *[]uint16, count int32) float64 {
	label_idArg, label_idFin := WrapString(label_id)
	valuesArg := make([]C.ImU16, len(*values))
	for i, valuesV := range *values {
		valuesArg[i] = C.ImU16(valuesV)
	}

	defer func() {
		label_idFin()

		for i, valuesV := range valuesArg {
			(*values)[i] = uint16(valuesV)
		}
	}()
	return float64(C.wrap_ImPlot_PlotHistogram_U16Ptr(label_idArg, (*C.ImU16)(&valuesArg[0]), C.int(count)))
}

func PlotPlotHistogramU32Ptr(label_id string, values *[]uint32, count int32) float64 {
	label_idArg, label_idFin := WrapString(label_id)
	valuesArg := make([]C.ImU32, len(*values))
	for i, valuesV := range *values {
		valuesArg[i] = C.ImU32(valuesV)
	}

	defer func() {
		label_idFin()

		for i, valuesV := range valuesArg {
			(*values)[i] = uint32(valuesV)
		}
	}()
	return float64(C.wrap_ImPlot_PlotHistogram_U32Ptr(label_idArg, (*C.ImU32)(&valuesArg[0]), C.int(count)))
}

func PlotPlotHistogramU64Ptr(label_id string, values []uint64, count int32) float64 {
	label_idArg, label_idFin := WrapString(label_id)

	defer func() {
		label_idFin()
	}()
	return float64(C.wrap_ImPlot_PlotHistogram_U64Ptr(label_idArg, (*C.ulonglong)(&(values[0])), C.int(count)))
}

func PlotPlotHistogramU8Ptr(label_id string, values *[]byte, count int32) float64 {
	label_idArg, label_idFin := WrapString(label_id)
	valuesArg := make([]C.ImU8, len(*values))
	for i, valuesV := range *values {
		valuesArg[i] = C.ImU8(valuesV)
	}

	defer func() {
		label_idFin()

		for i, valuesV := range valuesArg {
			(*values)[i] = byte(valuesV)
		}
	}()
	return float64(C.wrap_ImPlot_PlotHistogram_U8Ptr(label_idArg, (*C.ImU8)(&valuesArg[0]), C.int(count)))
}

func PlotPlotHistogramdoublePtr(label_id string, values *[]float64, count int32) float64 {
	label_idArg, label_idFin := WrapString(label_id)
	valuesArg := make([]C.double, len(*values))
	for i, valuesV := range *values {
		valuesArg[i] = C.double(valuesV)
	}

	defer func() {
		label_idFin()

		for i, valuesV := range valuesArg {
			(*values)[i] = float64(valuesV)
		}
	}()
	return float64(C.wrap_ImPlot_PlotHistogram_doublePtr(label_idArg, (*C.double)(&valuesArg[0]), C.int(count)))
}

func PlotPlotInfLinesFloatPtr(label_id string, values []float32, count int32) {
	label_idArg, label_idFin := WrapString(label_id)
	C.wrap_ImPlot_PlotInfLines_FloatPtr(label_idArg, (*C.float)(&(values[0])), C.int(count))

	label_idFin()
}

func PlotPlotInfLinesS16Ptr(label_id string, values *[]int, count int32) {
	label_idArg, label_idFin := WrapString(label_id)
	valuesArg := make([]C.ImS16, len(*values))
	for i, valuesV := range *values {
		valuesArg[i] = C.ImS16(valuesV)
	}

	C.wrap_ImPlot_PlotInfLines_S16Ptr(label_idArg, (*C.ImS16)(&valuesArg[0]), C.int(count))

	label_idFin()

	for i, valuesV := range valuesArg {
		(*values)[i] = int(valuesV)
	}
}

func PlotPlotInfLinesS32Ptr(label_id string, values *[]int32, count int32) {
	label_idArg, label_idFin := WrapString(label_id)
	valuesArg := make([]C.ImS32, len(*values))
	for i, valuesV := range *values {
		valuesArg[i] = C.ImS32(valuesV)
	}

	C.wrap_ImPlot_PlotInfLines_S32Ptr(label_idArg, (*C.ImS32)(&valuesArg[0]), C.int(count))

	label_idFin()

	for i, valuesV := range valuesArg {
		(*values)[i] = int32(valuesV)
	}
}

func PlotPlotInfLinesS64Ptr(label_id string, values []int64, count int32) {
	label_idArg, label_idFin := WrapString(label_id)
	C.wrap_ImPlot_PlotInfLines_S64Ptr(label_idArg, (*C.longlong)(&(values[0])), C.int(count))

	label_idFin()
}

func PlotPlotInfLinesS8Ptr(label_id string, values *[]int8, count int32) {
	label_idArg, label_idFin := WrapString(label_id)
	valuesArg := make([]C.ImS8, len(*values))
	for i, valuesV := range *values {
		valuesArg[i] = C.ImS8(valuesV)
	}

	C.wrap_ImPlot_PlotInfLines_S8Ptr(label_idArg, (*C.ImS8)(&valuesArg[0]), C.int(count))

	label_idFin()

	for i, valuesV := range valuesArg {
		(*values)[i] = int8(valuesV)
	}
}

func PlotPlotInfLinesU16Ptr(label_id string, values *[]uint16, count int32) {
	label_idArg, label_idFin := WrapString(label_id)
	valuesArg := make([]C.ImU16, len(*values))
	for i, valuesV := range *values {
		valuesArg[i] = C.ImU16(valuesV)
	}

	C.wrap_ImPlot_PlotInfLines_U16Ptr(label_idArg, (*C.ImU16)(&valuesArg[0]), C.int(count))

	label_idFin()

	for i, valuesV := range valuesArg {
		(*values)[i] = uint16(valuesV)
	}
}

func PlotPlotInfLinesU32Ptr(label_id string, values *[]uint32, count int32) {
	label_idArg, label_idFin := WrapString(label_id)
	valuesArg := make([]C.ImU32, len(*values))
	for i, valuesV := range *values {
		valuesArg[i] = C.ImU32(valuesV)
	}

	C.wrap_ImPlot_PlotInfLines_U32Ptr(label_idArg, (*C.ImU32)(&valuesArg[0]), C.int(count))

	label_idFin()

	for i, valuesV := range valuesArg {
		(*values)[i] = uint32(valuesV)
	}
}

func PlotPlotInfLinesU64Ptr(label_id string, values []uint64, count int32) {
	label_idArg, label_idFin := WrapString(label_id)
	C.wrap_ImPlot_PlotInfLines_U64Ptr(label_idArg, (*C.ulonglong)(&(values[0])), C.int(count))

	label_idFin()
}

func PlotPlotInfLinesU8Ptr(label_id string, values *[]byte, count int32) {
	label_idArg, label_idFin := WrapString(label_id)
	valuesArg := make([]C.ImU8, len(*values))
	for i, valuesV := range *values {
		valuesArg[i] = C.ImU8(valuesV)
	}

	C.wrap_ImPlot_PlotInfLines_U8Ptr(label_idArg, (*C.ImU8)(&valuesArg[0]), C.int(count))

	label_idFin()

	for i, valuesV := range valuesArg {
		(*values)[i] = byte(valuesV)
	}
}

func PlotPlotInfLinesdoublePtr(label_id string, values *[]float64, count int32) {
	label_idArg, label_idFin := WrapString(label_id)
	valuesArg := make([]C.double, len(*values))
	for i, valuesV := range *values {
		valuesArg[i] = C.double(valuesV)
	}

	C.wrap_ImPlot_PlotInfLines_doublePtr(label_idArg, (*C.double)(&valuesArg[0]), C.int(count))

	label_idFin()

	for i, valuesV := range valuesArg {
		(*values)[i] = float64(valuesV)
	}
}

func PlotPlotLineFloatPtrFloatPtr(label_id string, xs []float32, ys []float32, count int32) {
	label_idArg, label_idFin := WrapString(label_id)
	C.wrap_ImPlot_PlotLine_FloatPtrFloatPtr(label_idArg, (*C.float)(&(xs[0])), (*C.float)(&(ys[0])), C.int(count))

	label_idFin()
}

func PlotPlotLineFloatPtrInt(label_id string, values []float32, count int32) {
	label_idArg, label_idFin := WrapString(label_id)
	C.wrap_ImPlot_PlotLine_FloatPtrInt(label_idArg, (*C.float)(&(values[0])), C.int(count))

	label_idFin()
}

func PlotPlotLineS16PtrInt(label_id string, values *[]int, count int32) {
	label_idArg, label_idFin := WrapString(label_id)
	valuesArg := make([]C.ImS16, len(*values))
	for i, valuesV := range *values {
		valuesArg[i] = C.ImS16(valuesV)
	}

	C.wrap_ImPlot_PlotLine_S16PtrInt(label_idArg, (*C.ImS16)(&valuesArg[0]), C.int(count))

	label_idFin()

	for i, valuesV := range valuesArg {
		(*values)[i] = int(valuesV)
	}
}

func PlotPlotLineS16PtrS16Ptr(label_id string, xs *[]int, ys *[]int, count int32) {
	label_idArg, label_idFin := WrapString(label_id)
	xsArg := make([]C.ImS16, len(*xs))
	for i, xsV := range *xs {
		xsArg[i] = C.ImS16(xsV)
	}

	ysArg := make([]C.ImS16, len(*ys))
	for i, ysV := range *ys {
		ysArg[i] = C.ImS16(ysV)
	}

	C.wrap_ImPlot_PlotLine_S16PtrS16Ptr(label_idArg, (*C.ImS16)(&xsArg[0]), (*C.ImS16)(&ysArg[0]), C.int(count))

	label_idFin()

	for i, xsV := range xsArg {
		(*xs)[i] = int(xsV)
	}

	for i, ysV := range ysArg {
		(*ys)[i] = int(ysV)
	}
}

func PlotPlotLineS32PtrInt(label_id string, values *[]int32, count int32) {
	label_idArg, label_idFin := WrapString(label_id)
	valuesArg := make([]C.ImS32, len(*values))
	for i, valuesV := range *values {
		valuesArg[i] = C.ImS32(valuesV)
	}

	C.wrap_ImPlot_PlotLine_S32PtrInt(label_idArg, (*C.ImS32)(&valuesArg[0]), C.int(count))

	label_idFin()

	for i, valuesV := range valuesArg {
		(*values)[i] = int32(valuesV)
	}
}

func PlotPlotLineS32PtrS32Ptr(label_id string, xs *[]int32, ys *[]int32, count int32) {
	label_idArg, label_idFin := WrapString(label_id)
	xsArg := make([]C.ImS32, len(*xs))
	for i, xsV := range *xs {
		xsArg[i] = C.ImS32(xsV)
	}

	ysArg := make([]C.ImS32, len(*ys))
	for i, ysV := range *ys {
		ysArg[i] = C.ImS32(ysV)
	}

	C.wrap_ImPlot_PlotLine_S32PtrS32Ptr(label_idArg, (*C.ImS32)(&xsArg[0]), (*C.ImS32)(&ysArg[0]), C.int(count))

	label_idFin()

	for i, xsV := range xsArg {
		(*xs)[i] = int32(xsV)
	}

	for i, ysV := range ysArg {
		(*ys)[i] = int32(ysV)
	}
}

func PlotPlotLineS64PtrInt(label_id string, values []int64, count int32) {
	label_idArg, label_idFin := WrapString(label_id)
	C.wrap_ImPlot_PlotLine_S64PtrInt(label_idArg, (*C.longlong)(&(values[0])), C.int(count))

	label_idFin()
}

func PlotPlotLineS64PtrS64Ptr(label_id string, xs []int64, ys []int64, count int32) {
	label_idArg, label_idFin := WrapString(label_id)
	C.wrap_ImPlot_PlotLine_S64PtrS64Ptr(label_idArg, (*C.longlong)(&(xs[0])), (*C.longlong)(&(ys[0])), C.int(count))

	label_idFin()
}

func PlotPlotLineS8PtrInt(label_id string, values *[]int8, count int32) {
	label_idArg, label_idFin := WrapString(label_id)
	valuesArg := make([]C.ImS8, len(*values))
	for i, valuesV := range *values {
		valuesArg[i] = C.ImS8(valuesV)
	}

	C.wrap_ImPlot_PlotLine_S8PtrInt(label_idArg, (*C.ImS8)(&valuesArg[0]), C.int(count))

	label_idFin()

	for i, valuesV := range valuesArg {
		(*values)[i] = int8(valuesV)
	}
}

func PlotPlotLineS8PtrS8Ptr(label_id string, xs *[]int8, ys *[]int8, count int32) {
	label_idArg, label_idFin := WrapString(label_id)
	xsArg := make([]C.ImS8, len(*xs))
	for i, xsV := range *xs {
		xsArg[i] = C.ImS8(xsV)
	}

	ysArg := make([]C.ImS8, len(*ys))
	for i, ysV := range *ys {
		ysArg[i] = C.ImS8(ysV)
	}

	C.wrap_ImPlot_PlotLine_S8PtrS8Ptr(label_idArg, (*C.ImS8)(&xsArg[0]), (*C.ImS8)(&ysArg[0]), C.int(count))

	label_idFin()

	for i, xsV := range xsArg {
		(*xs)[i] = int8(xsV)
	}

	for i, ysV := range ysArg {
		(*ys)[i] = int8(ysV)
	}
}

func PlotPlotLineU16PtrInt(label_id string, values *[]uint16, count int32) {
	label_idArg, label_idFin := WrapString(label_id)
	valuesArg := make([]C.ImU16, len(*values))
	for i, valuesV := range *values {
		valuesArg[i] = C.ImU16(valuesV)
	}

	C.wrap_ImPlot_PlotLine_U16PtrInt(label_idArg, (*C.ImU16)(&valuesArg[0]), C.int(count))

	label_idFin()

	for i, valuesV := range valuesArg {
		(*values)[i] = uint16(valuesV)
	}
}

func PlotPlotLineU16PtrU16Ptr(label_id string, xs *[]uint16, ys *[]uint16, count int32) {
	label_idArg, label_idFin := WrapString(label_id)
	xsArg := make([]C.ImU16, len(*xs))
	for i, xsV := range *xs {
		xsArg[i] = C.ImU16(xsV)
	}

	ysArg := make([]C.ImU16, len(*ys))
	for i, ysV := range *ys {
		ysArg[i] = C.ImU16(ysV)
	}

	C.wrap_ImPlot_PlotLine_U16PtrU16Ptr(label_idArg, (*C.ImU16)(&xsArg[0]), (*C.ImU16)(&ysArg[0]), C.int(count))

	label_idFin()

	for i, xsV := range xsArg {
		(*xs)[i] = uint16(xsV)
	}

	for i, ysV := range ysArg {
		(*ys)[i] = uint16(ysV)
	}
}

func PlotPlotLineU32PtrInt(label_id string, values *[]uint32, count int32) {
	label_idArg, label_idFin := WrapString(label_id)
	valuesArg := make([]C.ImU32, len(*values))
	for i, valuesV := range *values {
		valuesArg[i] = C.ImU32(valuesV)
	}

	C.wrap_ImPlot_PlotLine_U32PtrInt(label_idArg, (*C.ImU32)(&valuesArg[0]), C.int(count))

	label_idFin()

	for i, valuesV := range valuesArg {
		(*values)[i] = uint32(valuesV)
	}
}

func PlotPlotLineU32PtrU32Ptr(label_id string, xs *[]uint32, ys *[]uint32, count int32) {
	label_idArg, label_idFin := WrapString(label_id)
	xsArg := make([]C.ImU32, len(*xs))
	for i, xsV := range *xs {
		xsArg[i] = C.ImU32(xsV)
	}

	ysArg := make([]C.ImU32, len(*ys))
	for i, ysV := range *ys {
		ysArg[i] = C.ImU32(ysV)
	}

	C.wrap_ImPlot_PlotLine_U32PtrU32Ptr(label_idArg, (*C.ImU32)(&xsArg[0]), (*C.ImU32)(&ysArg[0]), C.int(count))

	label_idFin()

	for i, xsV := range xsArg {
		(*xs)[i] = uint32(xsV)
	}

	for i, ysV := range ysArg {
		(*ys)[i] = uint32(ysV)
	}
}

func PlotPlotLineU64PtrInt(label_id string, values []uint64, count int32) {
	label_idArg, label_idFin := WrapString(label_id)
	C.wrap_ImPlot_PlotLine_U64PtrInt(label_idArg, (*C.ulonglong)(&(values[0])), C.int(count))

	label_idFin()
}

func PlotPlotLineU64PtrU64Ptr(label_id string, xs []uint64, ys []uint64, count int32) {
	label_idArg, label_idFin := WrapString(label_id)
	C.wrap_ImPlot_PlotLine_U64PtrU64Ptr(label_idArg, (*C.ulonglong)(&(xs[0])), (*C.ulonglong)(&(ys[0])), C.int(count))

	label_idFin()
}

func PlotPlotLineU8PtrInt(label_id string, values *[]byte, count int32) {
	label_idArg, label_idFin := WrapString(label_id)
	valuesArg := make([]C.ImU8, len(*values))
	for i, valuesV := range *values {
		valuesArg[i] = C.ImU8(valuesV)
	}

	C.wrap_ImPlot_PlotLine_U8PtrInt(label_idArg, (*C.ImU8)(&valuesArg[0]), C.int(count))

	label_idFin()

	for i, valuesV := range valuesArg {
		(*values)[i] = byte(valuesV)
	}
}

func PlotPlotLineU8PtrU8Ptr(label_id string, xs *[]byte, ys *[]byte, count int32) {
	label_idArg, label_idFin := WrapString(label_id)
	xsArg := make([]C.ImU8, len(*xs))
	for i, xsV := range *xs {
		xsArg[i] = C.ImU8(xsV)
	}

	ysArg := make([]C.ImU8, len(*ys))
	for i, ysV := range *ys {
		ysArg[i] = C.ImU8(ysV)
	}

	C.wrap_ImPlot_PlotLine_U8PtrU8Ptr(label_idArg, (*C.ImU8)(&xsArg[0]), (*C.ImU8)(&ysArg[0]), C.int(count))

	label_idFin()

	for i, xsV := range xsArg {
		(*xs)[i] = byte(xsV)
	}

	for i, ysV := range ysArg {
		(*ys)[i] = byte(ysV)
	}
}

func PlotPlotLinedoublePtrInt(label_id string, values *[]float64, count int32) {
	label_idArg, label_idFin := WrapString(label_id)
	valuesArg := make([]C.double, len(*values))
	for i, valuesV := range *values {
		valuesArg[i] = C.double(valuesV)
	}

	C.wrap_ImPlot_PlotLine_doublePtrInt(label_idArg, (*C.double)(&valuesArg[0]), C.int(count))

	label_idFin()

	for i, valuesV := range valuesArg {
		(*values)[i] = float64(valuesV)
	}
}

func PlotPlotLinedoublePtrdoublePtr(label_id string, xs *[]float64, ys *[]float64, count int32) {
	label_idArg, label_idFin := WrapString(label_id)
	xsArg := make([]C.double, len(*xs))
	for i, xsV := range *xs {
		xsArg[i] = C.double(xsV)
	}

	ysArg := make([]C.double, len(*ys))
	for i, ysV := range *ys {
		ysArg[i] = C.double(ysV)
	}

	C.wrap_ImPlot_PlotLine_doublePtrdoublePtr(label_idArg, (*C.double)(&xsArg[0]), (*C.double)(&ysArg[0]), C.int(count))

	label_idFin()

	for i, xsV := range xsArg {
		(*xs)[i] = float64(xsV)
	}

	for i, ysV := range ysArg {
		(*ys)[i] = float64(ysV)
	}
}

func PlotPlotPieChartFloatPtr(label_ids []string, values []float32, count int32, x float64, y float64, radius float64) {
	label_idsArg, label_idsFin := WrapStringList(label_ids)
	C.wrap_ImPlot_PlotPieChart_FloatPtr(label_idsArg, (*C.float)(&(values[0])), C.int(count), C.double(x), C.double(y), C.double(radius))

	label_idsFin()
}

func PlotPlotPieChartS16Ptr(label_ids []string, values *[]int, count int32, x float64, y float64, radius float64) {
	label_idsArg, label_idsFin := WrapStringList(label_ids)
	valuesArg := make([]C.ImS16, len(*values))
	for i, valuesV := range *values {
		valuesArg[i] = C.ImS16(valuesV)
	}

	C.wrap_ImPlot_PlotPieChart_S16Ptr(label_idsArg, (*C.ImS16)(&valuesArg[0]), C.int(count), C.double(x), C.double(y), C.double(radius))

	label_idsFin()

	for i, valuesV := range valuesArg {
		(*values)[i] = int(valuesV)
	}
}

func PlotPlotPieChartS32Ptr(label_ids []string, values *[]int32, count int32, x float64, y float64, radius float64) {
	label_idsArg, label_idsFin := WrapStringList(label_ids)
	valuesArg := make([]C.ImS32, len(*values))
	for i, valuesV := range *values {
		valuesArg[i] = C.ImS32(valuesV)
	}

	C.wrap_ImPlot_PlotPieChart_S32Ptr(label_idsArg, (*C.ImS32)(&valuesArg[0]), C.int(count), C.double(x), C.double(y), C.double(radius))

	label_idsFin()

	for i, valuesV := range valuesArg {
		(*values)[i] = int32(valuesV)
	}
}

func PlotPlotPieChartS64Ptr(label_ids []string, values []int64, count int32, x float64, y float64, radius float64) {
	label_idsArg, label_idsFin := WrapStringList(label_ids)
	C.wrap_ImPlot_PlotPieChart_S64Ptr(label_idsArg, (*C.longlong)(&(values[0])), C.int(count), C.double(x), C.double(y), C.double(radius))

	label_idsFin()
}

func PlotPlotPieChartS8Ptr(label_ids []string, values *[]int8, count int32, x float64, y float64, radius float64) {
	label_idsArg, label_idsFin := WrapStringList(label_ids)
	valuesArg := make([]C.ImS8, len(*values))
	for i, valuesV := range *values {
		valuesArg[i] = C.ImS8(valuesV)
	}

	C.wrap_ImPlot_PlotPieChart_S8Ptr(label_idsArg, (*C.ImS8)(&valuesArg[0]), C.int(count), C.double(x), C.double(y), C.double(radius))

	label_idsFin()

	for i, valuesV := range valuesArg {
		(*values)[i] = int8(valuesV)
	}
}

func PlotPlotPieChartU16Ptr(label_ids []string, values *[]uint16, count int32, x float64, y float64, radius float64) {
	label_idsArg, label_idsFin := WrapStringList(label_ids)
	valuesArg := make([]C.ImU16, len(*values))
	for i, valuesV := range *values {
		valuesArg[i] = C.ImU16(valuesV)
	}

	C.wrap_ImPlot_PlotPieChart_U16Ptr(label_idsArg, (*C.ImU16)(&valuesArg[0]), C.int(count), C.double(x), C.double(y), C.double(radius))

	label_idsFin()

	for i, valuesV := range valuesArg {
		(*values)[i] = uint16(valuesV)
	}
}

func PlotPlotPieChartU32Ptr(label_ids []string, values *[]uint32, count int32, x float64, y float64, radius float64) {
	label_idsArg, label_idsFin := WrapStringList(label_ids)
	valuesArg := make([]C.ImU32, len(*values))
	for i, valuesV := range *values {
		valuesArg[i] = C.ImU32(valuesV)
	}

	C.wrap_ImPlot_PlotPieChart_U32Ptr(label_idsArg, (*C.ImU32)(&valuesArg[0]), C.int(count), C.double(x), C.double(y), C.double(radius))

	label_idsFin()

	for i, valuesV := range valuesArg {
		(*values)[i] = uint32(valuesV)
	}
}

func PlotPlotPieChartU64Ptr(label_ids []string, values []uint64, count int32, x float64, y float64, radius float64) {
	label_idsArg, label_idsFin := WrapStringList(label_ids)
	C.wrap_ImPlot_PlotPieChart_U64Ptr(label_idsArg, (*C.ulonglong)(&(values[0])), C.int(count), C.double(x), C.double(y), C.double(radius))

	label_idsFin()
}

func PlotPlotPieChartU8Ptr(label_ids []string, values *[]byte, count int32, x float64, y float64, radius float64) {
	label_idsArg, label_idsFin := WrapStringList(label_ids)
	valuesArg := make([]C.ImU8, len(*values))
	for i, valuesV := range *values {
		valuesArg[i] = C.ImU8(valuesV)
	}

	C.wrap_ImPlot_PlotPieChart_U8Ptr(label_idsArg, (*C.ImU8)(&valuesArg[0]), C.int(count), C.double(x), C.double(y), C.double(radius))

	label_idsFin()

	for i, valuesV := range valuesArg {
		(*values)[i] = byte(valuesV)
	}
}

func PlotPlotPieChartdoublePtr(label_ids []string, values *[]float64, count int32, x float64, y float64, radius float64) {
	label_idsArg, label_idsFin := WrapStringList(label_ids)
	valuesArg := make([]C.double, len(*values))
	for i, valuesV := range *values {
		valuesArg[i] = C.double(valuesV)
	}

	C.wrap_ImPlot_PlotPieChart_doublePtr(label_idsArg, (*C.double)(&valuesArg[0]), C.int(count), C.double(x), C.double(y), C.double(radius))

	label_idsFin()

	for i, valuesV := range valuesArg {
		(*values)[i] = float64(valuesV)
	}
}

func PlotPlotScatterFloatPtrFloatPtr(label_id string, xs []float32, ys []float32, count int32) {
	label_idArg, label_idFin := WrapString(label_id)
	C.wrap_ImPlot_PlotScatter_FloatPtrFloatPtr(label_idArg, (*C.float)(&(xs[0])), (*C.float)(&(ys[0])), C.int(count))

	label_idFin()
}

func PlotPlotScatterFloatPtrInt(label_id string, values []float32, count int32) {
	label_idArg, label_idFin := WrapString(label_id)
	C.wrap_ImPlot_PlotScatter_FloatPtrInt(label_idArg, (*C.float)(&(values[0])), C.int(count))

	label_idFin()
}

func PlotPlotScatterS16PtrInt(label_id string, values *[]int, count int32) {
	label_idArg, label_idFin := WrapString(label_id)
	valuesArg := make([]C.ImS16, len(*values))
	for i, valuesV := range *values {
		valuesArg[i] = C.ImS16(valuesV)
	}

	C.wrap_ImPlot_PlotScatter_S16PtrInt(label_idArg, (*C.ImS16)(&valuesArg[0]), C.int(count))

	label_idFin()

	for i, valuesV := range valuesArg {
		(*values)[i] = int(valuesV)
	}
}

func PlotPlotScatterS16PtrS16Ptr(label_id string, xs *[]int, ys *[]int, count int32) {
	label_idArg, label_idFin := WrapString(label_id)
	xsArg := make([]C.ImS16, len(*xs))
	for i, xsV := range *xs {
		xsArg[i] = C.ImS16(xsV)
	}

	ysArg := make([]C.ImS16, len(*ys))
	for i, ysV := range *ys {
		ysArg[i] = C.ImS16(ysV)
	}

	C.wrap_ImPlot_PlotScatter_S16PtrS16Ptr(label_idArg, (*C.ImS16)(&xsArg[0]), (*C.ImS16)(&ysArg[0]), C.int(count))

	label_idFin()

	for i, xsV := range xsArg {
		(*xs)[i] = int(xsV)
	}

	for i, ysV := range ysArg {
		(*ys)[i] = int(ysV)
	}
}

func PlotPlotScatterS32PtrInt(label_id string, values *[]int32, count int32) {
	label_idArg, label_idFin := WrapString(label_id)
	valuesArg := make([]C.ImS32, len(*values))
	for i, valuesV := range *values {
		valuesArg[i] = C.ImS32(valuesV)
	}

	C.wrap_ImPlot_PlotScatter_S32PtrInt(label_idArg, (*C.ImS32)(&valuesArg[0]), C.int(count))

	label_idFin()

	for i, valuesV := range valuesArg {
		(*values)[i] = int32(valuesV)
	}
}

func PlotPlotScatterS32PtrS32Ptr(label_id string, xs *[]int32, ys *[]int32, count int32) {
	label_idArg, label_idFin := WrapString(label_id)
	xsArg := make([]C.ImS32, len(*xs))
	for i, xsV := range *xs {
		xsArg[i] = C.ImS32(xsV)
	}

	ysArg := make([]C.ImS32, len(*ys))
	for i, ysV := range *ys {
		ysArg[i] = C.ImS32(ysV)
	}

	C.wrap_ImPlot_PlotScatter_S32PtrS32Ptr(label_idArg, (*C.ImS32)(&xsArg[0]), (*C.ImS32)(&ysArg[0]), C.int(count))

	label_idFin()

	for i, xsV := range xsArg {
		(*xs)[i] = int32(xsV)
	}

	for i, ysV := range ysArg {
		(*ys)[i] = int32(ysV)
	}
}

func PlotPlotScatterS64PtrInt(label_id string, values []int64, count int32) {
	label_idArg, label_idFin := WrapString(label_id)
	C.wrap_ImPlot_PlotScatter_S64PtrInt(label_idArg, (*C.longlong)(&(values[0])), C.int(count))

	label_idFin()
}

func PlotPlotScatterS64PtrS64Ptr(label_id string, xs []int64, ys []int64, count int32) {
	label_idArg, label_idFin := WrapString(label_id)
	C.wrap_ImPlot_PlotScatter_S64PtrS64Ptr(label_idArg, (*C.longlong)(&(xs[0])), (*C.longlong)(&(ys[0])), C.int(count))

	label_idFin()
}

func PlotPlotScatterS8PtrInt(label_id string, values *[]int8, count int32) {
	label_idArg, label_idFin := WrapString(label_id)
	valuesArg := make([]C.ImS8, len(*values))
	for i, valuesV := range *values {
		valuesArg[i] = C.ImS8(valuesV)
	}

	C.wrap_ImPlot_PlotScatter_S8PtrInt(label_idArg, (*C.ImS8)(&valuesArg[0]), C.int(count))

	label_idFin()

	for i, valuesV := range valuesArg {
		(*values)[i] = int8(valuesV)
	}
}

func PlotPlotScatterS8PtrS8Ptr(label_id string, xs *[]int8, ys *[]int8, count int32) {
	label_idArg, label_idFin := WrapString(label_id)
	xsArg := make([]C.ImS8, len(*xs))
	for i, xsV := range *xs {
		xsArg[i] = C.ImS8(xsV)
	}

	ysArg := make([]C.ImS8, len(*ys))
	for i, ysV := range *ys {
		ysArg[i] = C.ImS8(ysV)
	}

	C.wrap_ImPlot_PlotScatter_S8PtrS8Ptr(label_idArg, (*C.ImS8)(&xsArg[0]), (*C.ImS8)(&ysArg[0]), C.int(count))

	label_idFin()

	for i, xsV := range xsArg {
		(*xs)[i] = int8(xsV)
	}

	for i, ysV := range ysArg {
		(*ys)[i] = int8(ysV)
	}
}

func PlotPlotScatterU16PtrInt(label_id string, values *[]uint16, count int32) {
	label_idArg, label_idFin := WrapString(label_id)
	valuesArg := make([]C.ImU16, len(*values))
	for i, valuesV := range *values {
		valuesArg[i] = C.ImU16(valuesV)
	}

	C.wrap_ImPlot_PlotScatter_U16PtrInt(label_idArg, (*C.ImU16)(&valuesArg[0]), C.int(count))

	label_idFin()

	for i, valuesV := range valuesArg {
		(*values)[i] = uint16(valuesV)
	}
}

func PlotPlotScatterU16PtrU16Ptr(label_id string, xs *[]uint16, ys *[]uint16, count int32) {
	label_idArg, label_idFin := WrapString(label_id)
	xsArg := make([]C.ImU16, len(*xs))
	for i, xsV := range *xs {
		xsArg[i] = C.ImU16(xsV)
	}

	ysArg := make([]C.ImU16, len(*ys))
	for i, ysV := range *ys {
		ysArg[i] = C.ImU16(ysV)
	}

	C.wrap_ImPlot_PlotScatter_U16PtrU16Ptr(label_idArg, (*C.ImU16)(&xsArg[0]), (*C.ImU16)(&ysArg[0]), C.int(count))

	label_idFin()

	for i, xsV := range xsArg {
		(*xs)[i] = uint16(xsV)
	}

	for i, ysV := range ysArg {
		(*ys)[i] = uint16(ysV)
	}
}

func PlotPlotScatterU32PtrInt(label_id string, values *[]uint32, count int32) {
	label_idArg, label_idFin := WrapString(label_id)
	valuesArg := make([]C.ImU32, len(*values))
	for i, valuesV := range *values {
		valuesArg[i] = C.ImU32(valuesV)
	}

	C.wrap_ImPlot_PlotScatter_U32PtrInt(label_idArg, (*C.ImU32)(&valuesArg[0]), C.int(count))

	label_idFin()

	for i, valuesV := range valuesArg {
		(*values)[i] = uint32(valuesV)
	}
}

func PlotPlotScatterU32PtrU32Ptr(label_id string, xs *[]uint32, ys *[]uint32, count int32) {
	label_idArg, label_idFin := WrapString(label_id)
	xsArg := make([]C.ImU32, len(*xs))
	for i, xsV := range *xs {
		xsArg[i] = C.ImU32(xsV)
	}

	ysArg := make([]C.ImU32, len(*ys))
	for i, ysV := range *ys {
		ysArg[i] = C.ImU32(ysV)
	}

	C.wrap_ImPlot_PlotScatter_U32PtrU32Ptr(label_idArg, (*C.ImU32)(&xsArg[0]), (*C.ImU32)(&ysArg[0]), C.int(count))

	label_idFin()

	for i, xsV := range xsArg {
		(*xs)[i] = uint32(xsV)
	}

	for i, ysV := range ysArg {
		(*ys)[i] = uint32(ysV)
	}
}

func PlotPlotScatterU64PtrInt(label_id string, values []uint64, count int32) {
	label_idArg, label_idFin := WrapString(label_id)
	C.wrap_ImPlot_PlotScatter_U64PtrInt(label_idArg, (*C.ulonglong)(&(values[0])), C.int(count))

	label_idFin()
}

func PlotPlotScatterU64PtrU64Ptr(label_id string, xs []uint64, ys []uint64, count int32) {
	label_idArg, label_idFin := WrapString(label_id)
	C.wrap_ImPlot_PlotScatter_U64PtrU64Ptr(label_idArg, (*C.ulonglong)(&(xs[0])), (*C.ulonglong)(&(ys[0])), C.int(count))

	label_idFin()
}

func PlotPlotScatterU8PtrInt(label_id string, values *[]byte, count int32) {
	label_idArg, label_idFin := WrapString(label_id)
	valuesArg := make([]C.ImU8, len(*values))
	for i, valuesV := range *values {
		valuesArg[i] = C.ImU8(valuesV)
	}

	C.wrap_ImPlot_PlotScatter_U8PtrInt(label_idArg, (*C.ImU8)(&valuesArg[0]), C.int(count))

	label_idFin()

	for i, valuesV := range valuesArg {
		(*values)[i] = byte(valuesV)
	}
}

func PlotPlotScatterU8PtrU8Ptr(label_id string, xs *[]byte, ys *[]byte, count int32) {
	label_idArg, label_idFin := WrapString(label_id)
	xsArg := make([]C.ImU8, len(*xs))
	for i, xsV := range *xs {
		xsArg[i] = C.ImU8(xsV)
	}

	ysArg := make([]C.ImU8, len(*ys))
	for i, ysV := range *ys {
		ysArg[i] = C.ImU8(ysV)
	}

	C.wrap_ImPlot_PlotScatter_U8PtrU8Ptr(label_idArg, (*C.ImU8)(&xsArg[0]), (*C.ImU8)(&ysArg[0]), C.int(count))

	label_idFin()

	for i, xsV := range xsArg {
		(*xs)[i] = byte(xsV)
	}

	for i, ysV := range ysArg {
		(*ys)[i] = byte(ysV)
	}
}

func PlotPlotScatterdoublePtrInt(label_id string, values *[]float64, count int32) {
	label_idArg, label_idFin := WrapString(label_id)
	valuesArg := make([]C.double, len(*values))
	for i, valuesV := range *values {
		valuesArg[i] = C.double(valuesV)
	}

	C.wrap_ImPlot_PlotScatter_doublePtrInt(label_idArg, (*C.double)(&valuesArg[0]), C.int(count))

	label_idFin()

	for i, valuesV := range valuesArg {
		(*values)[i] = float64(valuesV)
	}
}

func PlotPlotScatterdoublePtrdoublePtr(label_id string, xs *[]float64, ys *[]float64, count int32) {
	label_idArg, label_idFin := WrapString(label_id)
	xsArg := make([]C.double, len(*xs))
	for i, xsV := range *xs {
		xsArg[i] = C.double(xsV)
	}

	ysArg := make([]C.double, len(*ys))
	for i, ysV := range *ys {
		ysArg[i] = C.double(ysV)
	}

	C.wrap_ImPlot_PlotScatter_doublePtrdoublePtr(label_idArg, (*C.double)(&xsArg[0]), (*C.double)(&ysArg[0]), C.int(count))

	label_idFin()

	for i, xsV := range xsArg {
		(*xs)[i] = float64(xsV)
	}

	for i, ysV := range ysArg {
		(*ys)[i] = float64(ysV)
	}
}

func PlotPlotShadedFloatPtrFloatPtrFloatPtr(label_id string, xs []float32, ys1 []float32, ys2 []float32, count int32) {
	label_idArg, label_idFin := WrapString(label_id)
	C.wrap_ImPlot_PlotShaded_FloatPtrFloatPtrFloatPtr(label_idArg, (*C.float)(&(xs[0])), (*C.float)(&(ys1[0])), (*C.float)(&(ys2[0])), C.int(count))

	label_idFin()
}

func PlotPlotShadedFloatPtrFloatPtrInt(label_id string, xs []float32, ys []float32, count int32) {
	label_idArg, label_idFin := WrapString(label_id)
	C.wrap_ImPlot_PlotShaded_FloatPtrFloatPtrInt(label_idArg, (*C.float)(&(xs[0])), (*C.float)(&(ys[0])), C.int(count))

	label_idFin()
}

func PlotPlotShadedFloatPtrInt(label_id string, values []float32, count int32) {
	label_idArg, label_idFin := WrapString(label_id)
	C.wrap_ImPlot_PlotShaded_FloatPtrInt(label_idArg, (*C.float)(&(values[0])), C.int(count))

	label_idFin()
}

func PlotPlotShadedS16PtrInt(label_id string, values *[]int, count int32) {
	label_idArg, label_idFin := WrapString(label_id)
	valuesArg := make([]C.ImS16, len(*values))
	for i, valuesV := range *values {
		valuesArg[i] = C.ImS16(valuesV)
	}

	C.wrap_ImPlot_PlotShaded_S16PtrInt(label_idArg, (*C.ImS16)(&valuesArg[0]), C.int(count))

	label_idFin()

	for i, valuesV := range valuesArg {
		(*values)[i] = int(valuesV)
	}
}

func PlotPlotShadedS16PtrS16PtrInt(label_id string, xs *[]int, ys *[]int, count int32) {
	label_idArg, label_idFin := WrapString(label_id)
	xsArg := make([]C.ImS16, len(*xs))
	for i, xsV := range *xs {
		xsArg[i] = C.ImS16(xsV)
	}

	ysArg := make([]C.ImS16, len(*ys))
	for i, ysV := range *ys {
		ysArg[i] = C.ImS16(ysV)
	}

	C.wrap_ImPlot_PlotShaded_S16PtrS16PtrInt(label_idArg, (*C.ImS16)(&xsArg[0]), (*C.ImS16)(&ysArg[0]), C.int(count))

	label_idFin()

	for i, xsV := range xsArg {
		(*xs)[i] = int(xsV)
	}

	for i, ysV := range ysArg {
		(*ys)[i] = int(ysV)
	}
}

func PlotPlotShadedS16PtrS16PtrS16Ptr(label_id string, xs *[]int, ys1 *[]int, ys2 *[]int, count int32) {
	label_idArg, label_idFin := WrapString(label_id)
	xsArg := make([]C.ImS16, len(*xs))
	for i, xsV := range *xs {
		xsArg[i] = C.ImS16(xsV)
	}

	ys1Arg := make([]C.ImS16, len(*ys1))
	for i, ys1V := range *ys1 {
		ys1Arg[i] = C.ImS16(ys1V)
	}

	ys2Arg := make([]C.ImS16, len(*ys2))
	for i, ys2V := range *ys2 {
		ys2Arg[i] = C.ImS16(ys2V)
	}

	C.wrap_ImPlot_PlotShaded_S16PtrS16PtrS16Ptr(label_idArg, (*C.ImS16)(&xsArg[0]), (*C.ImS16)(&ys1Arg[0]), (*C.ImS16)(&ys2Arg[0]), C.int(count))

	label_idFin()

	for i, xsV := range xsArg {
		(*xs)[i] = int(xsV)
	}

	for i, ys1V := range ys1Arg {
		(*ys1)[i] = int(ys1V)
	}

	for i, ys2V := range ys2Arg {
		(*ys2)[i] = int(ys2V)
	}
}

func PlotPlotShadedS32PtrInt(label_id string, values *[]int32, count int32) {
	label_idArg, label_idFin := WrapString(label_id)
	valuesArg := make([]C.ImS32, len(*values))
	for i, valuesV := range *values {
		valuesArg[i] = C.ImS32(valuesV)
	}

	C.wrap_ImPlot_PlotShaded_S32PtrInt(label_idArg, (*C.ImS32)(&valuesArg[0]), C.int(count))

	label_idFin()

	for i, valuesV := range valuesArg {
		(*values)[i] = int32(valuesV)
	}
}

func PlotPlotShadedS32PtrS32PtrInt(label_id string, xs *[]int32, ys *[]int32, count int32) {
	label_idArg, label_idFin := WrapString(label_id)
	xsArg := make([]C.ImS32, len(*xs))
	for i, xsV := range *xs {
		xsArg[i] = C.ImS32(xsV)
	}

	ysArg := make([]C.ImS32, len(*ys))
	for i, ysV := range *ys {
		ysArg[i] = C.ImS32(ysV)
	}

	C.wrap_ImPlot_PlotShaded_S32PtrS32PtrInt(label_idArg, (*C.ImS32)(&xsArg[0]), (*C.ImS32)(&ysArg[0]), C.int(count))

	label_idFin()

	for i, xsV := range xsArg {
		(*xs)[i] = int32(xsV)
	}

	for i, ysV := range ysArg {
		(*ys)[i] = int32(ysV)
	}
}

func PlotPlotShadedS32PtrS32PtrS32Ptr(label_id string, xs *[]int32, ys1 *[]int32, ys2 *[]int32, count int32) {
	label_idArg, label_idFin := WrapString(label_id)
	xsArg := make([]C.ImS32, len(*xs))
	for i, xsV := range *xs {
		xsArg[i] = C.ImS32(xsV)
	}

	ys1Arg := make([]C.ImS32, len(*ys1))
	for i, ys1V := range *ys1 {
		ys1Arg[i] = C.ImS32(ys1V)
	}

	ys2Arg := make([]C.ImS32, len(*ys2))
	for i, ys2V := range *ys2 {
		ys2Arg[i] = C.ImS32(ys2V)
	}

	C.wrap_ImPlot_PlotShaded_S32PtrS32PtrS32Ptr(label_idArg, (*C.ImS32)(&xsArg[0]), (*C.ImS32)(&ys1Arg[0]), (*C.ImS32)(&ys2Arg[0]), C.int(count))

	label_idFin()

	for i, xsV := range xsArg {
		(*xs)[i] = int32(xsV)
	}

	for i, ys1V := range ys1Arg {
		(*ys1)[i] = int32(ys1V)
	}

	for i, ys2V := range ys2Arg {
		(*ys2)[i] = int32(ys2V)
	}
}

func PlotPlotShadedS64PtrInt(label_id string, values []int64, count int32) {
	label_idArg, label_idFin := WrapString(label_id)
	C.wrap_ImPlot_PlotShaded_S64PtrInt(label_idArg, (*C.longlong)(&(values[0])), C.int(count))

	label_idFin()
}

func PlotPlotShadedS64PtrS64PtrInt(label_id string, xs []int64, ys []int64, count int32) {
	label_idArg, label_idFin := WrapString(label_id)
	C.wrap_ImPlot_PlotShaded_S64PtrS64PtrInt(label_idArg, (*C.longlong)(&(xs[0])), (*C.longlong)(&(ys[0])), C.int(count))

	label_idFin()
}

func PlotPlotShadedS64PtrS64PtrS64Ptr(label_id string, xs []int64, ys1 []int64, ys2 []int64, count int32) {
	label_idArg, label_idFin := WrapString(label_id)
	C.wrap_ImPlot_PlotShaded_S64PtrS64PtrS64Ptr(label_idArg, (*C.longlong)(&(xs[0])), (*C.longlong)(&(ys1[0])), (*C.longlong)(&(ys2[0])), C.int(count))

	label_idFin()
}

func PlotPlotShadedS8PtrInt(label_id string, values *[]int8, count int32) {
	label_idArg, label_idFin := WrapString(label_id)
	valuesArg := make([]C.ImS8, len(*values))
	for i, valuesV := range *values {
		valuesArg[i] = C.ImS8(valuesV)
	}

	C.wrap_ImPlot_PlotShaded_S8PtrInt(label_idArg, (*C.ImS8)(&valuesArg[0]), C.int(count))

	label_idFin()

	for i, valuesV := range valuesArg {
		(*values)[i] = int8(valuesV)
	}
}

func PlotPlotShadedS8PtrS8PtrInt(label_id string, xs *[]int8, ys *[]int8, count int32) {
	label_idArg, label_idFin := WrapString(label_id)
	xsArg := make([]C.ImS8, len(*xs))
	for i, xsV := range *xs {
		xsArg[i] = C.ImS8(xsV)
	}

	ysArg := make([]C.ImS8, len(*ys))
	for i, ysV := range *ys {
		ysArg[i] = C.ImS8(ysV)
	}

	C.wrap_ImPlot_PlotShaded_S8PtrS8PtrInt(label_idArg, (*C.ImS8)(&xsArg[0]), (*C.ImS8)(&ysArg[0]), C.int(count))

	label_idFin()

	for i, xsV := range xsArg {
		(*xs)[i] = int8(xsV)
	}

	for i, ysV := range ysArg {
		(*ys)[i] = int8(ysV)
	}
}

func PlotPlotShadedS8PtrS8PtrS8Ptr(label_id string, xs *[]int8, ys1 *[]int8, ys2 *[]int8, count int32) {
	label_idArg, label_idFin := WrapString(label_id)
	xsArg := make([]C.ImS8, len(*xs))
	for i, xsV := range *xs {
		xsArg[i] = C.ImS8(xsV)
	}

	ys1Arg := make([]C.ImS8, len(*ys1))
	for i, ys1V := range *ys1 {
		ys1Arg[i] = C.ImS8(ys1V)
	}

	ys2Arg := make([]C.ImS8, len(*ys2))
	for i, ys2V := range *ys2 {
		ys2Arg[i] = C.ImS8(ys2V)
	}

	C.wrap_ImPlot_PlotShaded_S8PtrS8PtrS8Ptr(label_idArg, (*C.ImS8)(&xsArg[0]), (*C.ImS8)(&ys1Arg[0]), (*C.ImS8)(&ys2Arg[0]), C.int(count))

	label_idFin()

	for i, xsV := range xsArg {
		(*xs)[i] = int8(xsV)
	}

	for i, ys1V := range ys1Arg {
		(*ys1)[i] = int8(ys1V)
	}

	for i, ys2V := range ys2Arg {
		(*ys2)[i] = int8(ys2V)
	}
}

func PlotPlotShadedU16PtrInt(label_id string, values *[]uint16, count int32) {
	label_idArg, label_idFin := WrapString(label_id)
	valuesArg := make([]C.ImU16, len(*values))
	for i, valuesV := range *values {
		valuesArg[i] = C.ImU16(valuesV)
	}

	C.wrap_ImPlot_PlotShaded_U16PtrInt(label_idArg, (*C.ImU16)(&valuesArg[0]), C.int(count))

	label_idFin()

	for i, valuesV := range valuesArg {
		(*values)[i] = uint16(valuesV)
	}
}

func PlotPlotShadedU16PtrU16PtrInt(label_id string, xs *[]uint16, ys *[]uint16, count int32) {
	label_idArg, label_idFin := WrapString(label_id)
	xsArg := make([]C.ImU16, len(*xs))
	for i, xsV := range *xs {
		xsArg[i] = C.ImU16(xsV)
	}

	ysArg := make([]C.ImU16, len(*ys))
	for i, ysV := range *ys {
		ysArg[i] = C.ImU16(ysV)
	}

	C.wrap_ImPlot_PlotShaded_U16PtrU16PtrInt(label_idArg, (*C.ImU16)(&xsArg[0]), (*C.ImU16)(&ysArg[0]), C.int(count))

	label_idFin()

	for i, xsV := range xsArg {
		(*xs)[i] = uint16(xsV)
	}

	for i, ysV := range ysArg {
		(*ys)[i] = uint16(ysV)
	}
}

func PlotPlotShadedU16PtrU16PtrU16Ptr(label_id string, xs *[]uint16, ys1 *[]uint16, ys2 *[]uint16, count int32) {
	label_idArg, label_idFin := WrapString(label_id)
	xsArg := make([]C.ImU16, len(*xs))
	for i, xsV := range *xs {
		xsArg[i] = C.ImU16(xsV)
	}

	ys1Arg := make([]C.ImU16, len(*ys1))
	for i, ys1V := range *ys1 {
		ys1Arg[i] = C.ImU16(ys1V)
	}

	ys2Arg := make([]C.ImU16, len(*ys2))
	for i, ys2V := range *ys2 {
		ys2Arg[i] = C.ImU16(ys2V)
	}

	C.wrap_ImPlot_PlotShaded_U16PtrU16PtrU16Ptr(label_idArg, (*C.ImU16)(&xsArg[0]), (*C.ImU16)(&ys1Arg[0]), (*C.ImU16)(&ys2Arg[0]), C.int(count))

	label_idFin()

	for i, xsV := range xsArg {
		(*xs)[i] = uint16(xsV)
	}

	for i, ys1V := range ys1Arg {
		(*ys1)[i] = uint16(ys1V)
	}

	for i, ys2V := range ys2Arg {
		(*ys2)[i] = uint16(ys2V)
	}
}

func PlotPlotShadedU32PtrInt(label_id string, values *[]uint32, count int32) {
	label_idArg, label_idFin := WrapString(label_id)
	valuesArg := make([]C.ImU32, len(*values))
	for i, valuesV := range *values {
		valuesArg[i] = C.ImU32(valuesV)
	}

	C.wrap_ImPlot_PlotShaded_U32PtrInt(label_idArg, (*C.ImU32)(&valuesArg[0]), C.int(count))

	label_idFin()

	for i, valuesV := range valuesArg {
		(*values)[i] = uint32(valuesV)
	}
}

func PlotPlotShadedU32PtrU32PtrInt(label_id string, xs *[]uint32, ys *[]uint32, count int32) {
	label_idArg, label_idFin := WrapString(label_id)
	xsArg := make([]C.ImU32, len(*xs))
	for i, xsV := range *xs {
		xsArg[i] = C.ImU32(xsV)
	}

	ysArg := make([]C.ImU32, len(*ys))
	for i, ysV := range *ys {
		ysArg[i] = C.ImU32(ysV)
	}

	C.wrap_ImPlot_PlotShaded_U32PtrU32PtrInt(label_idArg, (*C.ImU32)(&xsArg[0]), (*C.ImU32)(&ysArg[0]), C.int(count))

	label_idFin()

	for i, xsV := range xsArg {
		(*xs)[i] = uint32(xsV)
	}

	for i, ysV := range ysArg {
		(*ys)[i] = uint32(ysV)
	}
}

func PlotPlotShadedU32PtrU32PtrU32Ptr(label_id string, xs *[]uint32, ys1 *[]uint32, ys2 *[]uint32, count int32) {
	label_idArg, label_idFin := WrapString(label_id)
	xsArg := make([]C.ImU32, len(*xs))
	for i, xsV := range *xs {
		xsArg[i] = C.ImU32(xsV)
	}

	ys1Arg := make([]C.ImU32, len(*ys1))
	for i, ys1V := range *ys1 {
		ys1Arg[i] = C.ImU32(ys1V)
	}

	ys2Arg := make([]C.ImU32, len(*ys2))
	for i, ys2V := range *ys2 {
		ys2Arg[i] = C.ImU32(ys2V)
	}

	C.wrap_ImPlot_PlotShaded_U32PtrU32PtrU32Ptr(label_idArg, (*C.ImU32)(&xsArg[0]), (*C.ImU32)(&ys1Arg[0]), (*C.ImU32)(&ys2Arg[0]), C.int(count))

	label_idFin()

	for i, xsV := range xsArg {
		(*xs)[i] = uint32(xsV)
	}

	for i, ys1V := range ys1Arg {
		(*ys1)[i] = uint32(ys1V)
	}

	for i, ys2V := range ys2Arg {
		(*ys2)[i] = uint32(ys2V)
	}
}

func PlotPlotShadedU64PtrInt(label_id string, values []uint64, count int32) {
	label_idArg, label_idFin := WrapString(label_id)
	C.wrap_ImPlot_PlotShaded_U64PtrInt(label_idArg, (*C.ulonglong)(&(values[0])), C.int(count))

	label_idFin()
}

func PlotPlotShadedU64PtrU64PtrInt(label_id string, xs []uint64, ys []uint64, count int32) {
	label_idArg, label_idFin := WrapString(label_id)
	C.wrap_ImPlot_PlotShaded_U64PtrU64PtrInt(label_idArg, (*C.ulonglong)(&(xs[0])), (*C.ulonglong)(&(ys[0])), C.int(count))

	label_idFin()
}

func PlotPlotShadedU64PtrU64PtrU64Ptr(label_id string, xs []uint64, ys1 []uint64, ys2 []uint64, count int32) {
	label_idArg, label_idFin := WrapString(label_id)
	C.wrap_ImPlot_PlotShaded_U64PtrU64PtrU64Ptr(label_idArg, (*C.ulonglong)(&(xs[0])), (*C.ulonglong)(&(ys1[0])), (*C.ulonglong)(&(ys2[0])), C.int(count))

	label_idFin()
}

func PlotPlotShadedU8PtrInt(label_id string, values *[]byte, count int32) {
	label_idArg, label_idFin := WrapString(label_id)
	valuesArg := make([]C.ImU8, len(*values))
	for i, valuesV := range *values {
		valuesArg[i] = C.ImU8(valuesV)
	}

	C.wrap_ImPlot_PlotShaded_U8PtrInt(label_idArg, (*C.ImU8)(&valuesArg[0]), C.int(count))

	label_idFin()

	for i, valuesV := range valuesArg {
		(*values)[i] = byte(valuesV)
	}
}

func PlotPlotShadedU8PtrU8PtrInt(label_id string, xs *[]byte, ys *[]byte, count int32) {
	label_idArg, label_idFin := WrapString(label_id)
	xsArg := make([]C.ImU8, len(*xs))
	for i, xsV := range *xs {
		xsArg[i] = C.ImU8(xsV)
	}

	ysArg := make([]C.ImU8, len(*ys))
	for i, ysV := range *ys {
		ysArg[i] = C.ImU8(ysV)
	}

	C.wrap_ImPlot_PlotShaded_U8PtrU8PtrInt(label_idArg, (*C.ImU8)(&xsArg[0]), (*C.ImU8)(&ysArg[0]), C.int(count))

	label_idFin()

	for i, xsV := range xsArg {
		(*xs)[i] = byte(xsV)
	}

	for i, ysV := range ysArg {
		(*ys)[i] = byte(ysV)
	}
}

func PlotPlotShadedU8PtrU8PtrU8Ptr(label_id string, xs *[]byte, ys1 *[]byte, ys2 *[]byte, count int32) {
	label_idArg, label_idFin := WrapString(label_id)
	xsArg := make([]C.ImU8, len(*xs))
	for i, xsV := range *xs {
		xsArg[i] = C.ImU8(xsV)
	}

	ys1Arg := make([]C.ImU8, len(*ys1))
	for i, ys1V := range *ys1 {
		ys1Arg[i] = C.ImU8(ys1V)
	}

	ys2Arg := make([]C.ImU8, len(*ys2))
	for i, ys2V := range *ys2 {
		ys2Arg[i] = C.ImU8(ys2V)
	}

	C.wrap_ImPlot_PlotShaded_U8PtrU8PtrU8Ptr(label_idArg, (*C.ImU8)(&xsArg[0]), (*C.ImU8)(&ys1Arg[0]), (*C.ImU8)(&ys2Arg[0]), C.int(count))

	label_idFin()

	for i, xsV := range xsArg {
		(*xs)[i] = byte(xsV)
	}

	for i, ys1V := range ys1Arg {
		(*ys1)[i] = byte(ys1V)
	}

	for i, ys2V := range ys2Arg {
		(*ys2)[i] = byte(ys2V)
	}
}

func PlotPlotShadeddoublePtrInt(label_id string, values *[]float64, count int32) {
	label_idArg, label_idFin := WrapString(label_id)
	valuesArg := make([]C.double, len(*values))
	for i, valuesV := range *values {
		valuesArg[i] = C.double(valuesV)
	}

	C.wrap_ImPlot_PlotShaded_doublePtrInt(label_idArg, (*C.double)(&valuesArg[0]), C.int(count))

	label_idFin()

	for i, valuesV := range valuesArg {
		(*values)[i] = float64(valuesV)
	}
}

func PlotPlotShadeddoublePtrdoublePtrInt(label_id string, xs *[]float64, ys *[]float64, count int32) {
	label_idArg, label_idFin := WrapString(label_id)
	xsArg := make([]C.double, len(*xs))
	for i, xsV := range *xs {
		xsArg[i] = C.double(xsV)
	}

	ysArg := make([]C.double, len(*ys))
	for i, ysV := range *ys {
		ysArg[i] = C.double(ysV)
	}

	C.wrap_ImPlot_PlotShaded_doublePtrdoublePtrInt(label_idArg, (*C.double)(&xsArg[0]), (*C.double)(&ysArg[0]), C.int(count))

	label_idFin()

	for i, xsV := range xsArg {
		(*xs)[i] = float64(xsV)
	}

	for i, ysV := range ysArg {
		(*ys)[i] = float64(ysV)
	}
}

func PlotPlotShadeddoublePtrdoublePtrdoublePtr(label_id string, xs *[]float64, ys1 *[]float64, ys2 *[]float64, count int32) {
	label_idArg, label_idFin := WrapString(label_id)
	xsArg := make([]C.double, len(*xs))
	for i, xsV := range *xs {
		xsArg[i] = C.double(xsV)
	}

	ys1Arg := make([]C.double, len(*ys1))
	for i, ys1V := range *ys1 {
		ys1Arg[i] = C.double(ys1V)
	}

	ys2Arg := make([]C.double, len(*ys2))
	for i, ys2V := range *ys2 {
		ys2Arg[i] = C.double(ys2V)
	}

	C.wrap_ImPlot_PlotShaded_doublePtrdoublePtrdoublePtr(label_idArg, (*C.double)(&xsArg[0]), (*C.double)(&ys1Arg[0]), (*C.double)(&ys2Arg[0]), C.int(count))

	label_idFin()

	for i, xsV := range xsArg {
		(*xs)[i] = float64(xsV)
	}

	for i, ys1V := range ys1Arg {
		(*ys1)[i] = float64(ys1V)
	}

	for i, ys2V := range ys2Arg {
		(*ys2)[i] = float64(ys2V)
	}
}

func PlotPlotStairsFloatPtrFloatPtr(label_id string, xs []float32, ys []float32, count int32) {
	label_idArg, label_idFin := WrapString(label_id)
	C.wrap_ImPlot_PlotStairs_FloatPtrFloatPtr(label_idArg, (*C.float)(&(xs[0])), (*C.float)(&(ys[0])), C.int(count))

	label_idFin()
}

func PlotPlotStairsFloatPtrInt(label_id string, values []float32, count int32) {
	label_idArg, label_idFin := WrapString(label_id)
	C.wrap_ImPlot_PlotStairs_FloatPtrInt(label_idArg, (*C.float)(&(values[0])), C.int(count))

	label_idFin()
}

func PlotPlotStairsS16PtrInt(label_id string, values *[]int, count int32) {
	label_idArg, label_idFin := WrapString(label_id)
	valuesArg := make([]C.ImS16, len(*values))
	for i, valuesV := range *values {
		valuesArg[i] = C.ImS16(valuesV)
	}

	C.wrap_ImPlot_PlotStairs_S16PtrInt(label_idArg, (*C.ImS16)(&valuesArg[0]), C.int(count))

	label_idFin()

	for i, valuesV := range valuesArg {
		(*values)[i] = int(valuesV)
	}
}

func PlotPlotStairsS16PtrS16Ptr(label_id string, xs *[]int, ys *[]int, count int32) {
	label_idArg, label_idFin := WrapString(label_id)
	xsArg := make([]C.ImS16, len(*xs))
	for i, xsV := range *xs {
		xsArg[i] = C.ImS16(xsV)
	}

	ysArg := make([]C.ImS16, len(*ys))
	for i, ysV := range *ys {
		ysArg[i] = C.ImS16(ysV)
	}

	C.wrap_ImPlot_PlotStairs_S16PtrS16Ptr(label_idArg, (*C.ImS16)(&xsArg[0]), (*C.ImS16)(&ysArg[0]), C.int(count))

	label_idFin()

	for i, xsV := range xsArg {
		(*xs)[i] = int(xsV)
	}

	for i, ysV := range ysArg {
		(*ys)[i] = int(ysV)
	}
}

func PlotPlotStairsS32PtrInt(label_id string, values *[]int32, count int32) {
	label_idArg, label_idFin := WrapString(label_id)
	valuesArg := make([]C.ImS32, len(*values))
	for i, valuesV := range *values {
		valuesArg[i] = C.ImS32(valuesV)
	}

	C.wrap_ImPlot_PlotStairs_S32PtrInt(label_idArg, (*C.ImS32)(&valuesArg[0]), C.int(count))

	label_idFin()

	for i, valuesV := range valuesArg {
		(*values)[i] = int32(valuesV)
	}
}

func PlotPlotStairsS32PtrS32Ptr(label_id string, xs *[]int32, ys *[]int32, count int32) {
	label_idArg, label_idFin := WrapString(label_id)
	xsArg := make([]C.ImS32, len(*xs))
	for i, xsV := range *xs {
		xsArg[i] = C.ImS32(xsV)
	}

	ysArg := make([]C.ImS32, len(*ys))
	for i, ysV := range *ys {
		ysArg[i] = C.ImS32(ysV)
	}

	C.wrap_ImPlot_PlotStairs_S32PtrS32Ptr(label_idArg, (*C.ImS32)(&xsArg[0]), (*C.ImS32)(&ysArg[0]), C.int(count))

	label_idFin()

	for i, xsV := range xsArg {
		(*xs)[i] = int32(xsV)
	}

	for i, ysV := range ysArg {
		(*ys)[i] = int32(ysV)
	}
}

func PlotPlotStairsS64PtrInt(label_id string, values []int64, count int32) {
	label_idArg, label_idFin := WrapString(label_id)
	C.wrap_ImPlot_PlotStairs_S64PtrInt(label_idArg, (*C.longlong)(&(values[0])), C.int(count))

	label_idFin()
}

func PlotPlotStairsS64PtrS64Ptr(label_id string, xs []int64, ys []int64, count int32) {
	label_idArg, label_idFin := WrapString(label_id)
	C.wrap_ImPlot_PlotStairs_S64PtrS64Ptr(label_idArg, (*C.longlong)(&(xs[0])), (*C.longlong)(&(ys[0])), C.int(count))

	label_idFin()
}

func PlotPlotStairsS8PtrInt(label_id string, values *[]int8, count int32) {
	label_idArg, label_idFin := WrapString(label_id)
	valuesArg := make([]C.ImS8, len(*values))
	for i, valuesV := range *values {
		valuesArg[i] = C.ImS8(valuesV)
	}

	C.wrap_ImPlot_PlotStairs_S8PtrInt(label_idArg, (*C.ImS8)(&valuesArg[0]), C.int(count))

	label_idFin()

	for i, valuesV := range valuesArg {
		(*values)[i] = int8(valuesV)
	}
}

func PlotPlotStairsS8PtrS8Ptr(label_id string, xs *[]int8, ys *[]int8, count int32) {
	label_idArg, label_idFin := WrapString(label_id)
	xsArg := make([]C.ImS8, len(*xs))
	for i, xsV := range *xs {
		xsArg[i] = C.ImS8(xsV)
	}

	ysArg := make([]C.ImS8, len(*ys))
	for i, ysV := range *ys {
		ysArg[i] = C.ImS8(ysV)
	}

	C.wrap_ImPlot_PlotStairs_S8PtrS8Ptr(label_idArg, (*C.ImS8)(&xsArg[0]), (*C.ImS8)(&ysArg[0]), C.int(count))

	label_idFin()

	for i, xsV := range xsArg {
		(*xs)[i] = int8(xsV)
	}

	for i, ysV := range ysArg {
		(*ys)[i] = int8(ysV)
	}
}

func PlotPlotStairsU16PtrInt(label_id string, values *[]uint16, count int32) {
	label_idArg, label_idFin := WrapString(label_id)
	valuesArg := make([]C.ImU16, len(*values))
	for i, valuesV := range *values {
		valuesArg[i] = C.ImU16(valuesV)
	}

	C.wrap_ImPlot_PlotStairs_U16PtrInt(label_idArg, (*C.ImU16)(&valuesArg[0]), C.int(count))

	label_idFin()

	for i, valuesV := range valuesArg {
		(*values)[i] = uint16(valuesV)
	}
}

func PlotPlotStairsU16PtrU16Ptr(label_id string, xs *[]uint16, ys *[]uint16, count int32) {
	label_idArg, label_idFin := WrapString(label_id)
	xsArg := make([]C.ImU16, len(*xs))
	for i, xsV := range *xs {
		xsArg[i] = C.ImU16(xsV)
	}

	ysArg := make([]C.ImU16, len(*ys))
	for i, ysV := range *ys {
		ysArg[i] = C.ImU16(ysV)
	}

	C.wrap_ImPlot_PlotStairs_U16PtrU16Ptr(label_idArg, (*C.ImU16)(&xsArg[0]), (*C.ImU16)(&ysArg[0]), C.int(count))

	label_idFin()

	for i, xsV := range xsArg {
		(*xs)[i] = uint16(xsV)
	}

	for i, ysV := range ysArg {
		(*ys)[i] = uint16(ysV)
	}
}

func PlotPlotStairsU32PtrInt(label_id string, values *[]uint32, count int32) {
	label_idArg, label_idFin := WrapString(label_id)
	valuesArg := make([]C.ImU32, len(*values))
	for i, valuesV := range *values {
		valuesArg[i] = C.ImU32(valuesV)
	}

	C.wrap_ImPlot_PlotStairs_U32PtrInt(label_idArg, (*C.ImU32)(&valuesArg[0]), C.int(count))

	label_idFin()

	for i, valuesV := range valuesArg {
		(*values)[i] = uint32(valuesV)
	}
}

func PlotPlotStairsU32PtrU32Ptr(label_id string, xs *[]uint32, ys *[]uint32, count int32) {
	label_idArg, label_idFin := WrapString(label_id)
	xsArg := make([]C.ImU32, len(*xs))
	for i, xsV := range *xs {
		xsArg[i] = C.ImU32(xsV)
	}

	ysArg := make([]C.ImU32, len(*ys))
	for i, ysV := range *ys {
		ysArg[i] = C.ImU32(ysV)
	}

	C.wrap_ImPlot_PlotStairs_U32PtrU32Ptr(label_idArg, (*C.ImU32)(&xsArg[0]), (*C.ImU32)(&ysArg[0]), C.int(count))

	label_idFin()

	for i, xsV := range xsArg {
		(*xs)[i] = uint32(xsV)
	}

	for i, ysV := range ysArg {
		(*ys)[i] = uint32(ysV)
	}
}

func PlotPlotStairsU64PtrInt(label_id string, values []uint64, count int32) {
	label_idArg, label_idFin := WrapString(label_id)
	C.wrap_ImPlot_PlotStairs_U64PtrInt(label_idArg, (*C.ulonglong)(&(values[0])), C.int(count))

	label_idFin()
}

func PlotPlotStairsU64PtrU64Ptr(label_id string, xs []uint64, ys []uint64, count int32) {
	label_idArg, label_idFin := WrapString(label_id)
	C.wrap_ImPlot_PlotStairs_U64PtrU64Ptr(label_idArg, (*C.ulonglong)(&(xs[0])), (*C.ulonglong)(&(ys[0])), C.int(count))

	label_idFin()
}

func PlotPlotStairsU8PtrInt(label_id string, values *[]byte, count int32) {
	label_idArg, label_idFin := WrapString(label_id)
	valuesArg := make([]C.ImU8, len(*values))
	for i, valuesV := range *values {
		valuesArg[i] = C.ImU8(valuesV)
	}

	C.wrap_ImPlot_PlotStairs_U8PtrInt(label_idArg, (*C.ImU8)(&valuesArg[0]), C.int(count))

	label_idFin()

	for i, valuesV := range valuesArg {
		(*values)[i] = byte(valuesV)
	}
}

func PlotPlotStairsU8PtrU8Ptr(label_id string, xs *[]byte, ys *[]byte, count int32) {
	label_idArg, label_idFin := WrapString(label_id)
	xsArg := make([]C.ImU8, len(*xs))
	for i, xsV := range *xs {
		xsArg[i] = C.ImU8(xsV)
	}

	ysArg := make([]C.ImU8, len(*ys))
	for i, ysV := range *ys {
		ysArg[i] = C.ImU8(ysV)
	}

	C.wrap_ImPlot_PlotStairs_U8PtrU8Ptr(label_idArg, (*C.ImU8)(&xsArg[0]), (*C.ImU8)(&ysArg[0]), C.int(count))

	label_idFin()

	for i, xsV := range xsArg {
		(*xs)[i] = byte(xsV)
	}

	for i, ysV := range ysArg {
		(*ys)[i] = byte(ysV)
	}
}

func PlotPlotStairsdoublePtrInt(label_id string, values *[]float64, count int32) {
	label_idArg, label_idFin := WrapString(label_id)
	valuesArg := make([]C.double, len(*values))
	for i, valuesV := range *values {
		valuesArg[i] = C.double(valuesV)
	}

	C.wrap_ImPlot_PlotStairs_doublePtrInt(label_idArg, (*C.double)(&valuesArg[0]), C.int(count))

	label_idFin()

	for i, valuesV := range valuesArg {
		(*values)[i] = float64(valuesV)
	}
}

func PlotPlotStairsdoublePtrdoublePtr(label_id string, xs *[]float64, ys *[]float64, count int32) {
	label_idArg, label_idFin := WrapString(label_id)
	xsArg := make([]C.double, len(*xs))
	for i, xsV := range *xs {
		xsArg[i] = C.double(xsV)
	}

	ysArg := make([]C.double, len(*ys))
	for i, ysV := range *ys {
		ysArg[i] = C.double(ysV)
	}

	C.wrap_ImPlot_PlotStairs_doublePtrdoublePtr(label_idArg, (*C.double)(&xsArg[0]), (*C.double)(&ysArg[0]), C.int(count))

	label_idFin()

	for i, xsV := range xsArg {
		(*xs)[i] = float64(xsV)
	}

	for i, ysV := range ysArg {
		(*ys)[i] = float64(ysV)
	}
}

func PlotPlotStemsFloatPtrFloatPtr(label_id string, xs []float32, ys []float32, count int32) {
	label_idArg, label_idFin := WrapString(label_id)
	C.wrap_ImPlot_PlotStems_FloatPtrFloatPtr(label_idArg, (*C.float)(&(xs[0])), (*C.float)(&(ys[0])), C.int(count))

	label_idFin()
}

func PlotPlotStemsFloatPtrInt(label_id string, values []float32, count int32) {
	label_idArg, label_idFin := WrapString(label_id)
	C.wrap_ImPlot_PlotStems_FloatPtrInt(label_idArg, (*C.float)(&(values[0])), C.int(count))

	label_idFin()
}

func PlotPlotStemsS16PtrInt(label_id string, values *[]int, count int32) {
	label_idArg, label_idFin := WrapString(label_id)
	valuesArg := make([]C.ImS16, len(*values))
	for i, valuesV := range *values {
		valuesArg[i] = C.ImS16(valuesV)
	}

	C.wrap_ImPlot_PlotStems_S16PtrInt(label_idArg, (*C.ImS16)(&valuesArg[0]), C.int(count))

	label_idFin()

	for i, valuesV := range valuesArg {
		(*values)[i] = int(valuesV)
	}
}

func PlotPlotStemsS16PtrS16Ptr(label_id string, xs *[]int, ys *[]int, count int32) {
	label_idArg, label_idFin := WrapString(label_id)
	xsArg := make([]C.ImS16, len(*xs))
	for i, xsV := range *xs {
		xsArg[i] = C.ImS16(xsV)
	}

	ysArg := make([]C.ImS16, len(*ys))
	for i, ysV := range *ys {
		ysArg[i] = C.ImS16(ysV)
	}

	C.wrap_ImPlot_PlotStems_S16PtrS16Ptr(label_idArg, (*C.ImS16)(&xsArg[0]), (*C.ImS16)(&ysArg[0]), C.int(count))

	label_idFin()

	for i, xsV := range xsArg {
		(*xs)[i] = int(xsV)
	}

	for i, ysV := range ysArg {
		(*ys)[i] = int(ysV)
	}
}

func PlotPlotStemsS32PtrInt(label_id string, values *[]int32, count int32) {
	label_idArg, label_idFin := WrapString(label_id)
	valuesArg := make([]C.ImS32, len(*values))
	for i, valuesV := range *values {
		valuesArg[i] = C.ImS32(valuesV)
	}

	C.wrap_ImPlot_PlotStems_S32PtrInt(label_idArg, (*C.ImS32)(&valuesArg[0]), C.int(count))

	label_idFin()

	for i, valuesV := range valuesArg {
		(*values)[i] = int32(valuesV)
	}
}

func PlotPlotStemsS32PtrS32Ptr(label_id string, xs *[]int32, ys *[]int32, count int32) {
	label_idArg, label_idFin := WrapString(label_id)
	xsArg := make([]C.ImS32, len(*xs))
	for i, xsV := range *xs {
		xsArg[i] = C.ImS32(xsV)
	}

	ysArg := make([]C.ImS32, len(*ys))
	for i, ysV := range *ys {
		ysArg[i] = C.ImS32(ysV)
	}

	C.wrap_ImPlot_PlotStems_S32PtrS32Ptr(label_idArg, (*C.ImS32)(&xsArg[0]), (*C.ImS32)(&ysArg[0]), C.int(count))

	label_idFin()

	for i, xsV := range xsArg {
		(*xs)[i] = int32(xsV)
	}

	for i, ysV := range ysArg {
		(*ys)[i] = int32(ysV)
	}
}

func PlotPlotStemsS64PtrInt(label_id string, values []int64, count int32) {
	label_idArg, label_idFin := WrapString(label_id)
	C.wrap_ImPlot_PlotStems_S64PtrInt(label_idArg, (*C.longlong)(&(values[0])), C.int(count))

	label_idFin()
}

func PlotPlotStemsS64PtrS64Ptr(label_id string, xs []int64, ys []int64, count int32) {
	label_idArg, label_idFin := WrapString(label_id)
	C.wrap_ImPlot_PlotStems_S64PtrS64Ptr(label_idArg, (*C.longlong)(&(xs[0])), (*C.longlong)(&(ys[0])), C.int(count))

	label_idFin()
}

func PlotPlotStemsS8PtrInt(label_id string, values *[]int8, count int32) {
	label_idArg, label_idFin := WrapString(label_id)
	valuesArg := make([]C.ImS8, len(*values))
	for i, valuesV := range *values {
		valuesArg[i] = C.ImS8(valuesV)
	}

	C.wrap_ImPlot_PlotStems_S8PtrInt(label_idArg, (*C.ImS8)(&valuesArg[0]), C.int(count))

	label_idFin()

	for i, valuesV := range valuesArg {
		(*values)[i] = int8(valuesV)
	}
}

func PlotPlotStemsS8PtrS8Ptr(label_id string, xs *[]int8, ys *[]int8, count int32) {
	label_idArg, label_idFin := WrapString(label_id)
	xsArg := make([]C.ImS8, len(*xs))
	for i, xsV := range *xs {
		xsArg[i] = C.ImS8(xsV)
	}

	ysArg := make([]C.ImS8, len(*ys))
	for i, ysV := range *ys {
		ysArg[i] = C.ImS8(ysV)
	}

	C.wrap_ImPlot_PlotStems_S8PtrS8Ptr(label_idArg, (*C.ImS8)(&xsArg[0]), (*C.ImS8)(&ysArg[0]), C.int(count))

	label_idFin()

	for i, xsV := range xsArg {
		(*xs)[i] = int8(xsV)
	}

	for i, ysV := range ysArg {
		(*ys)[i] = int8(ysV)
	}
}

func PlotPlotStemsU16PtrInt(label_id string, values *[]uint16, count int32) {
	label_idArg, label_idFin := WrapString(label_id)
	valuesArg := make([]C.ImU16, len(*values))
	for i, valuesV := range *values {
		valuesArg[i] = C.ImU16(valuesV)
	}

	C.wrap_ImPlot_PlotStems_U16PtrInt(label_idArg, (*C.ImU16)(&valuesArg[0]), C.int(count))

	label_idFin()

	for i, valuesV := range valuesArg {
		(*values)[i] = uint16(valuesV)
	}
}

func PlotPlotStemsU16PtrU16Ptr(label_id string, xs *[]uint16, ys *[]uint16, count int32) {
	label_idArg, label_idFin := WrapString(label_id)
	xsArg := make([]C.ImU16, len(*xs))
	for i, xsV := range *xs {
		xsArg[i] = C.ImU16(xsV)
	}

	ysArg := make([]C.ImU16, len(*ys))
	for i, ysV := range *ys {
		ysArg[i] = C.ImU16(ysV)
	}

	C.wrap_ImPlot_PlotStems_U16PtrU16Ptr(label_idArg, (*C.ImU16)(&xsArg[0]), (*C.ImU16)(&ysArg[0]), C.int(count))

	label_idFin()

	for i, xsV := range xsArg {
		(*xs)[i] = uint16(xsV)
	}

	for i, ysV := range ysArg {
		(*ys)[i] = uint16(ysV)
	}
}

func PlotPlotStemsU32PtrInt(label_id string, values *[]uint32, count int32) {
	label_idArg, label_idFin := WrapString(label_id)
	valuesArg := make([]C.ImU32, len(*values))
	for i, valuesV := range *values {
		valuesArg[i] = C.ImU32(valuesV)
	}

	C.wrap_ImPlot_PlotStems_U32PtrInt(label_idArg, (*C.ImU32)(&valuesArg[0]), C.int(count))

	label_idFin()

	for i, valuesV := range valuesArg {
		(*values)[i] = uint32(valuesV)
	}
}

func PlotPlotStemsU32PtrU32Ptr(label_id string, xs *[]uint32, ys *[]uint32, count int32) {
	label_idArg, label_idFin := WrapString(label_id)
	xsArg := make([]C.ImU32, len(*xs))
	for i, xsV := range *xs {
		xsArg[i] = C.ImU32(xsV)
	}

	ysArg := make([]C.ImU32, len(*ys))
	for i, ysV := range *ys {
		ysArg[i] = C.ImU32(ysV)
	}

	C.wrap_ImPlot_PlotStems_U32PtrU32Ptr(label_idArg, (*C.ImU32)(&xsArg[0]), (*C.ImU32)(&ysArg[0]), C.int(count))

	label_idFin()

	for i, xsV := range xsArg {
		(*xs)[i] = uint32(xsV)
	}

	for i, ysV := range ysArg {
		(*ys)[i] = uint32(ysV)
	}
}

func PlotPlotStemsU64PtrInt(label_id string, values []uint64, count int32) {
	label_idArg, label_idFin := WrapString(label_id)
	C.wrap_ImPlot_PlotStems_U64PtrInt(label_idArg, (*C.ulonglong)(&(values[0])), C.int(count))

	label_idFin()
}

func PlotPlotStemsU64PtrU64Ptr(label_id string, xs []uint64, ys []uint64, count int32) {
	label_idArg, label_idFin := WrapString(label_id)
	C.wrap_ImPlot_PlotStems_U64PtrU64Ptr(label_idArg, (*C.ulonglong)(&(xs[0])), (*C.ulonglong)(&(ys[0])), C.int(count))

	label_idFin()
}

func PlotPlotStemsU8PtrInt(label_id string, values *[]byte, count int32) {
	label_idArg, label_idFin := WrapString(label_id)
	valuesArg := make([]C.ImU8, len(*values))
	for i, valuesV := range *values {
		valuesArg[i] = C.ImU8(valuesV)
	}

	C.wrap_ImPlot_PlotStems_U8PtrInt(label_idArg, (*C.ImU8)(&valuesArg[0]), C.int(count))

	label_idFin()

	for i, valuesV := range valuesArg {
		(*values)[i] = byte(valuesV)
	}
}

func PlotPlotStemsU8PtrU8Ptr(label_id string, xs *[]byte, ys *[]byte, count int32) {
	label_idArg, label_idFin := WrapString(label_id)
	xsArg := make([]C.ImU8, len(*xs))
	for i, xsV := range *xs {
		xsArg[i] = C.ImU8(xsV)
	}

	ysArg := make([]C.ImU8, len(*ys))
	for i, ysV := range *ys {
		ysArg[i] = C.ImU8(ysV)
	}

	C.wrap_ImPlot_PlotStems_U8PtrU8Ptr(label_idArg, (*C.ImU8)(&xsArg[0]), (*C.ImU8)(&ysArg[0]), C.int(count))

	label_idFin()

	for i, xsV := range xsArg {
		(*xs)[i] = byte(xsV)
	}

	for i, ysV := range ysArg {
		(*ys)[i] = byte(ysV)
	}
}

func PlotPlotStemsdoublePtrInt(label_id string, values *[]float64, count int32) {
	label_idArg, label_idFin := WrapString(label_id)
	valuesArg := make([]C.double, len(*values))
	for i, valuesV := range *values {
		valuesArg[i] = C.double(valuesV)
	}

	C.wrap_ImPlot_PlotStems_doublePtrInt(label_idArg, (*C.double)(&valuesArg[0]), C.int(count))

	label_idFin()

	for i, valuesV := range valuesArg {
		(*values)[i] = float64(valuesV)
	}
}

func PlotPlotStemsdoublePtrdoublePtr(label_id string, xs *[]float64, ys *[]float64, count int32) {
	label_idArg, label_idFin := WrapString(label_id)
	xsArg := make([]C.double, len(*xs))
	for i, xsV := range *xs {
		xsArg[i] = C.double(xsV)
	}

	ysArg := make([]C.double, len(*ys))
	for i, ysV := range *ys {
		ysArg[i] = C.double(ysV)
	}

	C.wrap_ImPlot_PlotStems_doublePtrdoublePtr(label_idArg, (*C.double)(&xsArg[0]), (*C.double)(&ysArg[0]), C.int(count))

	label_idFin()

	for i, xsV := range xsArg {
		(*xs)[i] = float64(xsV)
	}

	for i, ysV := range ysArg {
		(*ys)[i] = float64(ysV)
	}
}

func PlotPlotText(text string, x float64, y float64) {
	textArg, textFin := WrapString(text)
	C.wrap_ImPlot_PlotText(textArg, C.double(x), C.double(y))

	textFin()
}

func PlotPlotToPixelsPlotPoInt(plt PlotPoint) Vec2 {
	pOut := new(Vec2)
	pOutArg, pOutFin := wrap[C.ImVec2, *Vec2](pOut)

	C.wrap_ImPlot_PlotToPixels_PlotPoInt(pOutArg, plt.toC())

	pOutFin()

	return *pOut
}

func PlotPlotToPixelsdouble(x float64, y float64) Vec2 {
	pOut := new(Vec2)
	pOutArg, pOutFin := wrap[C.ImVec2, *Vec2](pOut)

	C.wrap_ImPlot_PlotToPixels_double(pOutArg, C.double(x), C.double(y))

	pOutFin()

	return *pOut
}

func PlotPopColormap() {
	C.wrap_ImPlot_PopColormap()
}

func PlotPopStyleColor() {
	C.wrap_ImPlot_PopStyleColor()
}

func PlotPopStyleVar() {
	C.wrap_ImPlot_PopStyleVar()
}

func PlotPushPlotClipRect() {
	C.wrap_ImPlot_PushPlotClipRect()
}

func PlotRegisterOrGetItem(label_id string, flags PlotItemFlags) *PlotItem {
	label_idArg, label_idFin := WrapString(label_id)

	defer func() {
		label_idFin()
	}()
	return newPlotItemFromC(C.wrap_ImPlot_RegisterOrGetItem(label_idArg, C.ImPlotItemFlags(flags)))
}

func PlotSampleColormap(t float32) Vec4 {
	pOut := new(Vec4)
	pOutArg, pOutFin := wrap[C.ImVec4, *Vec4](pOut)

	C.wrap_ImPlot_SampleColormap(pOutArg, C.float(t))

	pOutFin()

	return *pOut
}

func PlotSetNextAxesLimits(x_min float64, x_max float64, y_min float64, y_max float64) {
	C.wrap_ImPlot_SetNextAxesLimits(C.double(x_min), C.double(x_max), C.double(y_min), C.double(y_max))
}

func PlotSetNextAxisLimits(axis PlotAxisEnum, v_min float64, v_max float64) {
	C.wrap_ImPlot_SetNextAxisLimits(C.ImAxis(axis), C.double(v_min), C.double(v_max))
}

func PlotSetNextErrorBarStyle() {
	C.wrap_ImPlot_SetNextErrorBarStyle()
}

func PlotSetNextFillStyle() {
	C.wrap_ImPlot_SetNextFillStyle()
}

func PlotSetNextLineStyle() {
	C.wrap_ImPlot_SetNextLineStyle()
}

func PlotSetNextMarkerStyle() {
	C.wrap_ImPlot_SetNextMarkerStyle()
}

func PlotSetupAxes(x_label string, y_label string) {
	x_labelArg, x_labelFin := WrapString(x_label)
	y_labelArg, y_labelFin := WrapString(y_label)
	C.wrap_ImPlot_SetupAxes(x_labelArg, y_labelArg)

	x_labelFin()
	y_labelFin()
}

func PlotSetupAxesLimits(x_min float64, x_max float64, y_min float64, y_max float64) {
	C.wrap_ImPlot_SetupAxesLimits(C.double(x_min), C.double(x_max), C.double(y_min), C.double(y_max))
}

func PlotSetupAxis(axis PlotAxisEnum) {
	C.wrap_ImPlot_SetupAxis(C.ImAxis(axis))
}

func PlotSetupAxisLimits(axis PlotAxisEnum, v_min float64, v_max float64) {
	C.wrap_ImPlot_SetupAxisLimits(C.ImAxis(axis), C.double(v_min), C.double(v_max))
}

func PlotSetupAxisTicksdouble(axis PlotAxisEnum, v_min float64, v_max float64, n_ticks int32) {
	C.wrap_ImPlot_SetupAxisTicks_double(C.ImAxis(axis), C.double(v_min), C.double(v_max), C.int(n_ticks))
}

func PlotSetupAxisTicksdoublePtr(axis PlotAxisEnum, values *[]float64, n_ticks int32) {
	valuesArg := make([]C.double, len(*values))
	for i, valuesV := range *values {
		valuesArg[i] = C.double(valuesV)
	}

	C.wrap_ImPlot_SetupAxisTicks_doublePtr(C.ImAxis(axis), (*C.double)(&valuesArg[0]), C.int(n_ticks))

	for i, valuesV := range valuesArg {
		(*values)[i] = float64(valuesV)
	}
}

func PlotSetupLegend(location PlotLocation) {
	C.wrap_ImPlot_SetupLegend(C.ImPlotLocation(location))
}

func PlotSetupMouseText(location PlotLocation) {
	C.wrap_ImPlot_SetupMouseText(C.ImPlotLocation(location))
}

func PlotShowAltLegend(title_id string) {
	title_idArg, title_idFin := WrapString(title_id)
	C.wrap_ImPlot_ShowAltLegend(title_idArg)

	title_idFin()
}

func PlotShowAxisContextMenu(axis *PlotAxis, equal_axis *PlotAxis) {
	axisArg, axisFin := axis.handle()
	equal_axisArg, equal_axisFin := equal_axis.handle()
	C.wrap_ImPlot_ShowAxisContextMenu(axisArg, equal_axisArg)

	axisFin()
	equal_axisFin()
}

func PlotShowDatePicker(id string, level *int32, t *PlotTime) bool {
	idArg, idFin := WrapString(id)
	levelArg, levelFin := WrapNumberPtr[C.int, int32](level)
	tArg, tFin := wrap[C.ImPlotTime, *PlotTime](t)

	defer func() {
		idFin()
		levelFin()
		tFin()
	}()
	return C.wrap_ImPlot_ShowDatePicker(idArg, levelArg, tArg) == C.bool(true)
}

func PlotShowDemoWindow() {
	C.wrap_ImPlot_ShowDemoWindow()
}

func PlotShowMetricsWindow() {
	C.wrap_ImPlot_ShowMetricsWindow()
}

func PlotShowStyleEditor() {
	C.wrap_ImPlot_ShowStyleEditor()
}

func PlotStyleColorsAuto() {
	C.wrap_ImPlot_StyleColorsAuto()
}

func PlotStyleColorsClassic() {
	C.wrap_ImPlot_StyleColorsClassic()
}

func PlotStyleColorsDark() {
	C.wrap_ImPlot_StyleColorsDark()
}

func PlotStyleColorsLight() {
	C.wrap_ImPlot_StyleColorsLight()
}

func PlotTagXBool(x float64, col Vec4) {
	C.wrap_ImPlot_TagX_Bool(C.double(x), col.toC())
}

func PlotTagYBool(y float64, col Vec4) {
	C.wrap_ImPlot_TagY_Bool(C.double(y), col.toC())
}

func (self *FormatterTimeData) TimeDataGetTime() PlotTime {
	selfArg, selfFin := self.handle()

	defer func() {
		selfFin()
	}()
	return *(&PlotTime{}).fromC(C.wrap_Formatter_Time_Data_GetTime(selfArg))
}

func (self *FormatterTimeData) TimeDataGetSpec() PlotDateTimeSpec {
	selfArg, selfFin := self.handle()

	defer func() {
		selfFin()
	}()

	result := C.wrap_Formatter_Time_Data_GetSpec(selfArg)
	return *newPlotDateTimeSpecFromC(func() *C.ImPlotDateTimeSpec { result := result; return &result }())
}

func (self *FormatterTimeData) TimeDataGetUserFormatterData() unsafe.Pointer {
	selfArg, selfFin := self.handle()

	defer func() {
		selfFin()
	}()
	return unsafe.Pointer(C.wrap_Formatter_Time_Data_GetUserFormatterData(selfArg))
}

func (self PlotAlignmentData) SetVertical(v bool) {
	selfArg, selfFin := self.handle()
	defer selfFin()
	C.wrap_ImPlotAlignmentData_SetVertical(selfArg, C.bool(v))
}

func (self *PlotAlignmentData) Vertical() bool {
	selfArg, selfFin := self.handle()

	defer func() {
		selfFin()
	}()
	return C.wrap_ImPlotAlignmentData_GetVertical(selfArg) == C.bool(true)
}

func (self PlotAlignmentData) SetPadA(v float32) {
	selfArg, selfFin := self.handle()
	defer selfFin()
	C.wrap_ImPlotAlignmentData_SetPadA(selfArg, C.float(v))
}

func (self *PlotAlignmentData) PadA() float32 {
	selfArg, selfFin := self.handle()

	defer func() {
		selfFin()
	}()
	return float32(C.wrap_ImPlotAlignmentData_GetPadA(selfArg))
}

func (self PlotAlignmentData) SetPadB(v float32) {
	selfArg, selfFin := self.handle()
	defer selfFin()
	C.wrap_ImPlotAlignmentData_SetPadB(selfArg, C.float(v))
}

func (self *PlotAlignmentData) PadB() float32 {
	selfArg, selfFin := self.handle()

	defer func() {
		selfFin()
	}()
	return float32(C.wrap_ImPlotAlignmentData_GetPadB(selfArg))
}

func (self PlotAlignmentData) SetPadAMax(v float32) {
	selfArg, selfFin := self.handle()
	defer selfFin()
	C.wrap_ImPlotAlignmentData_SetPadAMax(selfArg, C.float(v))
}

func (self *PlotAlignmentData) PadAMax() float32 {
	selfArg, selfFin := self.handle()

	defer func() {
		selfFin()
	}()
	return float32(C.wrap_ImPlotAlignmentData_GetPadAMax(selfArg))
}

func (self PlotAlignmentData) SetPadBMax(v float32) {
	selfArg, selfFin := self.handle()
	defer selfFin()
	C.wrap_ImPlotAlignmentData_SetPadBMax(selfArg, C.float(v))
}

func (self *PlotAlignmentData) PadBMax() float32 {
	selfArg, selfFin := self.handle()

	defer func() {
		selfFin()
	}()
	return float32(C.wrap_ImPlotAlignmentData_GetPadBMax(selfArg))
}

func (self PlotAnnotation) SetPos(v Vec2) {
	selfArg, selfFin := self.handle()
	defer selfFin()
	C.wrap_ImPlotAnnotation_SetPos(selfArg, v.toC())
}

func (self *PlotAnnotation) Pos() Vec2 {
	selfArg, selfFin := self.handle()

	defer func() {
		selfFin()
	}()
	return *(&Vec2{}).fromC(C.wrap_ImPlotAnnotation_GetPos(selfArg))
}

func (self PlotAnnotation) SetOffset(v Vec2) {
	selfArg, selfFin := self.handle()
	defer selfFin()
	C.wrap_ImPlotAnnotation_SetOffset(selfArg, v.toC())
}

func (self *PlotAnnotation) Offset() Vec2 {
	selfArg, selfFin := self.handle()

	defer func() {
		selfFin()
	}()
	return *(&Vec2{}).fromC(C.wrap_ImPlotAnnotation_GetOffset(selfArg))
}

func (self PlotAnnotation) SetColorBg(v uint32) {
	selfArg, selfFin := self.handle()
	defer selfFin()
	C.wrap_ImPlotAnnotation_SetColorBg(selfArg, C.ImU32(v))
}

func (self *PlotAnnotation) ColorBg() uint32 {
	selfArg, selfFin := self.handle()

	defer func() {
		selfFin()
	}()
	return uint32(C.wrap_ImPlotAnnotation_GetColorBg(selfArg))
}

func (self PlotAnnotation) SetColorFg(v uint32) {
	selfArg, selfFin := self.handle()
	defer selfFin()
	C.wrap_ImPlotAnnotation_SetColorFg(selfArg, C.ImU32(v))
}

func (self *PlotAnnotation) ColorFg() uint32 {
	selfArg, selfFin := self.handle()

	defer func() {
		selfFin()
	}()
	return uint32(C.wrap_ImPlotAnnotation_GetColorFg(selfArg))
}

func (self PlotAnnotation) SetTextOffset(v int32) {
	selfArg, selfFin := self.handle()
	defer selfFin()
	C.wrap_ImPlotAnnotation_SetTextOffset(selfArg, C.int(v))
}

func (self *PlotAnnotation) TextOffset() int32 {
	selfArg, selfFin := self.handle()

	defer func() {
		selfFin()
	}()
	return int32(C.wrap_ImPlotAnnotation_GetTextOffset(selfArg))
}

func (self PlotAnnotation) SetClamp(v bool) {
	selfArg, selfFin := self.handle()
	defer selfFin()
	C.wrap_ImPlotAnnotation_SetClamp(selfArg, C.bool(v))
}

func (self *PlotAnnotation) Clamp() bool {
	selfArg, selfFin := self.handle()

	defer func() {
		selfFin()
	}()
	return C.wrap_ImPlotAnnotation_GetClamp(selfArg) == C.bool(true)
}

func (self PlotAnnotationCollection) SetAnnotations(v Vector[*PlotAnnotation]) {
	vData := v.Data
	vDataArg, _ := vData.handle()
	vVecArg := new(C.ImVector_ImPlotAnnotation)
	vVecArg.Size = C.int(v.Size)
	vVecArg.Capacity = C.int(v.Capacity)
	vVecArg.Data = vDataArg
	v.pinner.Pin(vVecArg.Data)

	selfArg, selfFin := self.handle()
	defer selfFin()
	C.wrap_ImPlotAnnotationCollection_SetAnnotations(selfArg, *vVecArg)
}

func (self *PlotAnnotationCollection) Annotations() Vector[*PlotAnnotation] {
	selfArg, selfFin := self.handle()

	defer func() {
		selfFin()
	}()
	return newVectorFromC(C.wrap_ImPlotAnnotationCollection_GetAnnotations(selfArg).Size, C.wrap_ImPlotAnnotationCollection_GetAnnotations(selfArg).Capacity, newPlotAnnotationFromC(C.wrap_ImPlotAnnotationCollection_GetAnnotations(selfArg).Data))
}

func (self PlotAnnotationCollection) SetTextBuffer(v TextBuffer) {
	vArg, _ := v.c()

	selfArg, selfFin := self.handle()
	defer selfFin()
	C.wrap_ImPlotAnnotationCollection_SetTextBuffer(selfArg, vArg)
}

func (self *PlotAnnotationCollection) TextBuffer() TextBuffer {
	selfArg, selfFin := self.handle()

	defer func() {
		selfFin()
	}()

	result := C.wrap_ImPlotAnnotationCollection_GetTextBuffer(selfArg)
	return *newTextBufferFromC(func() *C.ImGuiTextBuffer { result := result; return &result }())
}

func (self PlotAnnotationCollection) SetSize(v int32) {
	selfArg, selfFin := self.handle()
	defer selfFin()
	C.wrap_ImPlotAnnotationCollection_SetSize(selfArg, C.int(v))
}

func (self *PlotAnnotationCollection) Size() int32 {
	selfArg, selfFin := self.handle()

	defer func() {
		selfFin()
	}()
	return int32(C.wrap_ImPlotAnnotationCollection_GetSize(selfArg))
}

func (self PlotAxis) SetFlags(v PlotAxisFlags) {
	selfArg, selfFin := self.handle()
	defer selfFin()
	C.wrap_ImPlotAxis_SetFlags(selfArg, C.ImPlotAxisFlags(v))
}

func (self *PlotAxis) Flags() PlotAxisFlags {
	selfArg, selfFin := self.handle()

	defer func() {
		selfFin()
	}()
	return PlotAxisFlags(C.wrap_ImPlotAxis_GetFlags(selfArg))
}

func (self PlotAxis) SetPreviousFlags(v PlotAxisFlags) {
	selfArg, selfFin := self.handle()
	defer selfFin()
	C.wrap_ImPlotAxis_SetPreviousFlags(selfArg, C.ImPlotAxisFlags(v))
}

func (self *PlotAxis) PreviousFlags() PlotAxisFlags {
	selfArg, selfFin := self.handle()

	defer func() {
		selfFin()
	}()
	return PlotAxisFlags(C.wrap_ImPlotAxis_GetPreviousFlags(selfArg))
}

func (self PlotAxis) SetRange(v PlotRange) {
	vArg, _ := v.c()

	selfArg, selfFin := self.handle()
	defer selfFin()
	C.wrap_ImPlotAxis_SetRange(selfArg, vArg)
}

func (self *PlotAxis) Range() PlotRange {
	selfArg, selfFin := self.handle()

	defer func() {
		selfFin()
	}()

	result := C.wrap_ImPlotAxis_GetRange(selfArg)
	return *newPlotRangeFromC(func() *C.ImPlotRange { result := result; return &result }())
}

func (self PlotAxis) SetRangeCond(v PlotCond) {
	selfArg, selfFin := self.handle()
	defer selfFin()
	C.wrap_ImPlotAxis_SetRangeCond(selfArg, C.ImPlotCond(v))
}

func (self *PlotAxis) RangeCond() PlotCond {
	selfArg, selfFin := self.handle()

	defer func() {
		selfFin()
	}()
	return PlotCond(C.wrap_ImPlotAxis_GetRangeCond(selfArg))
}

func (self PlotAxis) SetScale(v PlotScale) {
	selfArg, selfFin := self.handle()
	defer selfFin()
	C.wrap_ImPlotAxis_SetScale(selfArg, C.ImPlotScale(v))
}

func (self *PlotAxis) Scale() PlotScale {
	selfArg, selfFin := self.handle()

	defer func() {
		selfFin()
	}()
	return PlotScale(C.wrap_ImPlotAxis_GetScale(selfArg))
}

func (self PlotAxis) SetFitExtents(v PlotRange) {
	vArg, _ := v.c()

	selfArg, selfFin := self.handle()
	defer selfFin()
	C.wrap_ImPlotAxis_SetFitExtents(selfArg, vArg)
}

func (self *PlotAxis) FitExtents() PlotRange {
	selfArg, selfFin := self.handle()

	defer func() {
		selfFin()
	}()

	result := C.wrap_ImPlotAxis_GetFitExtents(selfArg)
	return *newPlotRangeFromC(func() *C.ImPlotRange { result := result; return &result }())
}

func (self PlotAxis) SetOrthoAxis(v *PlotAxis) {
	vArg, _ := v.handle()

	selfArg, selfFin := self.handle()
	defer selfFin()
	C.wrap_ImPlotAxis_SetOrthoAxis(selfArg, vArg)
}

func (self *PlotAxis) OrthoAxis() *PlotAxis {
	selfArg, selfFin := self.handle()

	defer func() {
		selfFin()
	}()
	return newPlotAxisFromC(C.wrap_ImPlotAxis_GetOrthoAxis(selfArg))
}

func (self PlotAxis) SetConstraintRange(v PlotRange) {
	vArg, _ := v.c()

	selfArg, selfFin := self.handle()
	defer selfFin()
	C.wrap_ImPlotAxis_SetConstraintRange(selfArg, vArg)
}

func (self *PlotAxis) ConstraintRange() PlotRange {
	selfArg, selfFin := self.handle()

	defer func() {
		selfFin()
	}()

	result := C.wrap_ImPlotAxis_GetConstraintRange(selfArg)
	return *newPlotRangeFromC(func() *C.ImPlotRange { result := result; return &result }())
}

func (self PlotAxis) SetConstraintZoom(v PlotRange) {
	vArg, _ := v.c()

	selfArg, selfFin := self.handle()
	defer selfFin()
	C.wrap_ImPlotAxis_SetConstraintZoom(selfArg, vArg)
}

func (self *PlotAxis) ConstraintZoom() PlotRange {
	selfArg, selfFin := self.handle()

	defer func() {
		selfFin()
	}()

	result := C.wrap_ImPlotAxis_GetConstraintZoom(selfArg)
	return *newPlotRangeFromC(func() *C.ImPlotRange { result := result; return &result }())
}

func (self PlotAxis) SetTicker(v PlotTicker) {
	vArg, _ := v.c()

	selfArg, selfFin := self.handle()
	defer selfFin()
	C.wrap_ImPlotAxis_SetTicker(selfArg, vArg)
}

func (self *PlotAxis) Ticker() PlotTicker {
	selfArg, selfFin := self.handle()

	defer func() {
		selfFin()
	}()

	result := C.wrap_ImPlotAxis_GetTicker(selfArg)
	return *newPlotTickerFromC(func() *C.ImPlotTicker { result := result; return &result }())
}

func (self PlotAxis) SetFormatterData(v unsafe.Pointer) {
	vArg, _ := WrapVoidPtr(v)

	selfArg, selfFin := self.handle()
	defer selfFin()
	C.wrap_ImPlotAxis_SetFormatterData(selfArg, vArg)
}

func (self *PlotAxis) FormatterData() unsafe.Pointer {
	selfArg, selfFin := self.handle()

	defer func() {
		selfFin()
	}()
	return unsafe.Pointer(C.wrap_ImPlotAxis_GetFormatterData(selfArg))
}

func (self PlotAxis) SetFormatSpec(v *[16]rune) {
	vArg := make([]C.char, len(v))
	for i, vV := range v {
		vArg[i] = C.char(vV)
	}

	selfArg, selfFin := self.handle()
	defer selfFin()
	C.wrap_ImPlotAxis_SetFormatSpec(selfArg, (*C.char)(&vArg[0]))
}

func (self PlotAxis) SetLinkedMin(v *float64) {
	vArg, _ := WrapNumberPtr[C.double, float64](v)

	selfArg, selfFin := self.handle()
	defer selfFin()
	C.wrap_ImPlotAxis_SetLinkedMin(selfArg, vArg)
}

func (self *PlotAxis) LinkedMin() *float64 {
	selfArg, selfFin := self.handle()

	defer func() {
		selfFin()
	}()
	return (*float64)(C.wrap_ImPlotAxis_GetLinkedMin(selfArg))
}

func (self PlotAxis) SetLinkedMax(v *float64) {
	vArg, _ := WrapNumberPtr[C.double, float64](v)

	selfArg, selfFin := self.handle()
	defer selfFin()
	C.wrap_ImPlotAxis_SetLinkedMax(selfArg, vArg)
}

func (self *PlotAxis) LinkedMax() *float64 {
	selfArg, selfFin := self.handle()

	defer func() {
		selfFin()
	}()
	return (*float64)(C.wrap_ImPlotAxis_GetLinkedMax(selfArg))
}

func (self PlotAxis) SetPickerLevel(v int32) {
	selfArg, selfFin := self.handle()
	defer selfFin()
	C.wrap_ImPlotAxis_SetPickerLevel(selfArg, C.int(v))
}

func (self *PlotAxis) PickerLevel() int32 {
	selfArg, selfFin := self.handle()

	defer func() {
		selfFin()
	}()
	return int32(C.wrap_ImPlotAxis_GetPickerLevel(selfArg))
}

func (self PlotAxis) SetPickerTimeMin(v PlotTime) {
	selfArg, selfFin := self.handle()
	defer selfFin()
	C.wrap_ImPlotAxis_SetPickerTimeMin(selfArg, v.toC())
}

func (self *PlotAxis) PickerTimeMin() PlotTime {
	selfArg, selfFin := self.handle()

	defer func() {
		selfFin()
	}()
	return *(&PlotTime{}).fromC(C.wrap_ImPlotAxis_GetPickerTimeMin(selfArg))
}

func (self PlotAxis) SetPickerTimeMax(v PlotTime) {
	selfArg, selfFin := self.handle()
	defer selfFin()
	C.wrap_ImPlotAxis_SetPickerTimeMax(selfArg, v.toC())
}

func (self *PlotAxis) PickerTimeMax() PlotTime {
	selfArg, selfFin := self.handle()

	defer func() {
		selfFin()
	}()
	return *(&PlotTime{}).fromC(C.wrap_ImPlotAxis_GetPickerTimeMax(selfArg))
}

func (self PlotAxis) SetTransformData(v unsafe.Pointer) {
	vArg, _ := WrapVoidPtr(v)

	selfArg, selfFin := self.handle()
	defer selfFin()
	C.wrap_ImPlotAxis_SetTransformData(selfArg, vArg)
}

func (self *PlotAxis) TransformData() unsafe.Pointer {
	selfArg, selfFin := self.handle()

	defer func() {
		selfFin()
	}()
	return unsafe.Pointer(C.wrap_ImPlotAxis_GetTransformData(selfArg))
}

func (self PlotAxis) SetPixelMin(v float32) {
	selfArg, selfFin := self.handle()
	defer selfFin()
	C.wrap_ImPlotAxis_SetPixelMin(selfArg, C.float(v))
}

func (self *PlotAxis) PixelMin() float32 {
	selfArg, selfFin := self.handle()

	defer func() {
		selfFin()
	}()
	return float32(C.wrap_ImPlotAxis_GetPixelMin(selfArg))
}

func (self PlotAxis) SetPixelMax(v float32) {
	selfArg, selfFin := self.handle()
	defer selfFin()
	C.wrap_ImPlotAxis_SetPixelMax(selfArg, C.float(v))
}

func (self *PlotAxis) PixelMax() float32 {
	selfArg, selfFin := self.handle()

	defer func() {
		selfFin()
	}()
	return float32(C.wrap_ImPlotAxis_GetPixelMax(selfArg))
}

func (self PlotAxis) SetScaleMin(v float64) {
	selfArg, selfFin := self.handle()
	defer selfFin()
	C.wrap_ImPlotAxis_SetScaleMin(selfArg, C.double(v))
}

func (self *PlotAxis) ScaleMin() float64 {
	selfArg, selfFin := self.handle()

	defer func() {
		selfFin()
	}()
	return float64(C.wrap_ImPlotAxis_GetScaleMin(selfArg))
}

func (self PlotAxis) SetScaleMax(v float64) {
	selfArg, selfFin := self.handle()
	defer selfFin()
	C.wrap_ImPlotAxis_SetScaleMax(selfArg, C.double(v))
}

func (self *PlotAxis) ScaleMax() float64 {
	selfArg, selfFin := self.handle()

	defer func() {
		selfFin()
	}()
	return float64(C.wrap_ImPlotAxis_GetScaleMax(selfArg))
}

func (self PlotAxis) SetScaleToPixel(v float64) {
	selfArg, selfFin := self.handle()
	defer selfFin()
	C.wrap_ImPlotAxis_SetScaleToPixel(selfArg, C.double(v))
}

func (self *PlotAxis) ScaleToPixel() float64 {
	selfArg, selfFin := self.handle()

	defer func() {
		selfFin()
	}()
	return float64(C.wrap_ImPlotAxis_GetScaleToPixel(selfArg))
}

func (self PlotAxis) SetDatum1(v float32) {
	selfArg, selfFin := self.handle()
	defer selfFin()
	C.wrap_ImPlotAxis_SetDatum1(selfArg, C.float(v))
}

func (self *PlotAxis) Datum1() float32 {
	selfArg, selfFin := self.handle()

	defer func() {
		selfFin()
	}()
	return float32(C.wrap_ImPlotAxis_GetDatum1(selfArg))
}

func (self PlotAxis) SetDatum2(v float32) {
	selfArg, selfFin := self.handle()
	defer selfFin()
	C.wrap_ImPlotAxis_SetDatum2(selfArg, C.float(v))
}

func (self *PlotAxis) Datum2() float32 {
	selfArg, selfFin := self.handle()

	defer func() {
		selfFin()
	}()
	return float32(C.wrap_ImPlotAxis_GetDatum2(selfArg))
}

func (self PlotAxis) SetHoverRect(v Rect) {
	selfArg, selfFin := self.handle()
	defer selfFin()
	C.wrap_ImPlotAxis_SetHoverRect(selfArg, v.toC())
}

func (self *PlotAxis) HoverRect() Rect {
	selfArg, selfFin := self.handle()

	defer func() {
		selfFin()
	}()
	return *(&Rect{}).fromC(C.wrap_ImPlotAxis_GetHoverRect(selfArg))
}

func (self PlotAxis) SetLabelOffset(v int32) {
	selfArg, selfFin := self.handle()
	defer selfFin()
	C.wrap_ImPlotAxis_SetLabelOffset(selfArg, C.int(v))
}

func (self *PlotAxis) LabelOffset() int32 {
	selfArg, selfFin := self.handle()

	defer func() {
		selfFin()
	}()
	return int32(C.wrap_ImPlotAxis_GetLabelOffset(selfArg))
}

func (self PlotAxis) SetColorMaj(v uint32) {
	selfArg, selfFin := self.handle()
	defer selfFin()
	C.wrap_ImPlotAxis_SetColorMaj(selfArg, C.ImU32(v))
}

func (self *PlotAxis) ColorMaj() uint32 {
	selfArg, selfFin := self.handle()

	defer func() {
		selfFin()
	}()
	return uint32(C.wrap_ImPlotAxis_GetColorMaj(selfArg))
}

func (self PlotAxis) SetColorMin(v uint32) {
	selfArg, selfFin := self.handle()
	defer selfFin()
	C.wrap_ImPlotAxis_SetColorMin(selfArg, C.ImU32(v))
}

func (self *PlotAxis) ColorMin() uint32 {
	selfArg, selfFin := self.handle()

	defer func() {
		selfFin()
	}()
	return uint32(C.wrap_ImPlotAxis_GetColorMin(selfArg))
}

func (self PlotAxis) SetColorTick(v uint32) {
	selfArg, selfFin := self.handle()
	defer selfFin()
	C.wrap_ImPlotAxis_SetColorTick(selfArg, C.ImU32(v))
}

func (self *PlotAxis) ColorTick() uint32 {
	selfArg, selfFin := self.handle()

	defer func() {
		selfFin()
	}()
	return uint32(C.wrap_ImPlotAxis_GetColorTick(selfArg))
}

func (self PlotAxis) SetColorTxt(v uint32) {
	selfArg, selfFin := self.handle()
	defer selfFin()
	C.wrap_ImPlotAxis_SetColorTxt(selfArg, C.ImU32(v))
}

func (self *PlotAxis) ColorTxt() uint32 {
	selfArg, selfFin := self.handle()

	defer func() {
		selfFin()
	}()
	return uint32(C.wrap_ImPlotAxis_GetColorTxt(selfArg))
}

func (self PlotAxis) SetColorBg(v uint32) {
	selfArg, selfFin := self.handle()
	defer selfFin()
	C.wrap_ImPlotAxis_SetColorBg(selfArg, C.ImU32(v))
}

func (self *PlotAxis) ColorBg() uint32 {
	selfArg, selfFin := self.handle()

	defer func() {
		selfFin()
	}()
	return uint32(C.wrap_ImPlotAxis_GetColorBg(selfArg))
}

func (self PlotAxis) SetColorHov(v uint32) {
	selfArg, selfFin := self.handle()
	defer selfFin()
	C.wrap_ImPlotAxis_SetColorHov(selfArg, C.ImU32(v))
}

func (self *PlotAxis) ColorHov() uint32 {
	selfArg, selfFin := self.handle()

	defer func() {
		selfFin()
	}()
	return uint32(C.wrap_ImPlotAxis_GetColorHov(selfArg))
}

func (self PlotAxis) SetColorAct(v uint32) {
	selfArg, selfFin := self.handle()
	defer selfFin()
	C.wrap_ImPlotAxis_SetColorAct(selfArg, C.ImU32(v))
}

func (self *PlotAxis) ColorAct() uint32 {
	selfArg, selfFin := self.handle()

	defer func() {
		selfFin()
	}()
	return uint32(C.wrap_ImPlotAxis_GetColorAct(selfArg))
}

func (self PlotAxis) SetColorHiLi(v uint32) {
	selfArg, selfFin := self.handle()
	defer selfFin()
	C.wrap_ImPlotAxis_SetColorHiLi(selfArg, C.ImU32(v))
}

func (self *PlotAxis) ColorHiLi() uint32 {
	selfArg, selfFin := self.handle()

	defer func() {
		selfFin()
	}()
	return uint32(C.wrap_ImPlotAxis_GetColorHiLi(selfArg))
}

func (self PlotAxis) SetEnabled(v bool) {
	selfArg, selfFin := self.handle()
	defer selfFin()
	C.wrap_ImPlotAxis_SetEnabled(selfArg, C.bool(v))
}

func (self *PlotAxis) Enabled() bool {
	selfArg, selfFin := self.handle()

	defer func() {
		selfFin()
	}()
	return C.wrap_ImPlotAxis_GetEnabled(selfArg) == C.bool(true)
}

func (self PlotAxis) SetVertical(v bool) {
	selfArg, selfFin := self.handle()
	defer selfFin()
	C.wrap_ImPlotAxis_SetVertical(selfArg, C.bool(v))
}

func (self *PlotAxis) Vertical() bool {
	selfArg, selfFin := self.handle()

	defer func() {
		selfFin()
	}()
	return C.wrap_ImPlotAxis_GetVertical(selfArg) == C.bool(true)
}

func (self PlotAxis) SetFitThisFrame(v bool) {
	selfArg, selfFin := self.handle()
	defer selfFin()
	C.wrap_ImPlotAxis_SetFitThisFrame(selfArg, C.bool(v))
}

func (self *PlotAxis) FitThisFrame() bool {
	selfArg, selfFin := self.handle()

	defer func() {
		selfFin()
	}()
	return C.wrap_ImPlotAxis_GetFitThisFrame(selfArg) == C.bool(true)
}

func (self PlotAxis) SetHasRange(v bool) {
	selfArg, selfFin := self.handle()
	defer selfFin()
	C.wrap_ImPlotAxis_SetHasRange(selfArg, C.bool(v))
}

func (self *PlotAxis) HasRange() bool {
	selfArg, selfFin := self.handle()

	defer func() {
		selfFin()
	}()
	return C.wrap_ImPlotAxis_GetHasRange(selfArg) == C.bool(true)
}

func (self PlotAxis) SetHasFormatSpec(v bool) {
	selfArg, selfFin := self.handle()
	defer selfFin()
	C.wrap_ImPlotAxis_SetHasFormatSpec(selfArg, C.bool(v))
}

func (self *PlotAxis) HasFormatSpec() bool {
	selfArg, selfFin := self.handle()

	defer func() {
		selfFin()
	}()
	return C.wrap_ImPlotAxis_GetHasFormatSpec(selfArg) == C.bool(true)
}

func (self PlotAxis) SetShowDefaultTicks(v bool) {
	selfArg, selfFin := self.handle()
	defer selfFin()
	C.wrap_ImPlotAxis_SetShowDefaultTicks(selfArg, C.bool(v))
}

func (self *PlotAxis) ShowDefaultTicks() bool {
	selfArg, selfFin := self.handle()

	defer func() {
		selfFin()
	}()
	return C.wrap_ImPlotAxis_GetShowDefaultTicks(selfArg) == C.bool(true)
}

func (self PlotAxis) SetHovered(v bool) {
	selfArg, selfFin := self.handle()
	defer selfFin()
	C.wrap_ImPlotAxis_SetHovered(selfArg, C.bool(v))
}

func (self *PlotAxis) Hovered() bool {
	selfArg, selfFin := self.handle()

	defer func() {
		selfFin()
	}()
	return C.wrap_ImPlotAxis_GetHovered(selfArg) == C.bool(true)
}

func (self PlotAxis) SetHeld(v bool) {
	selfArg, selfFin := self.handle()
	defer selfFin()
	C.wrap_ImPlotAxis_SetHeld(selfArg, C.bool(v))
}

func (self *PlotAxis) Held() bool {
	selfArg, selfFin := self.handle()

	defer func() {
		selfFin()
	}()
	return C.wrap_ImPlotAxis_GetHeld(selfArg) == C.bool(true)
}

func (self PlotColormapData) SetKeys(v Vector[*uint32]) {
	vData := v.Data
	vDataArg, _ := WrapNumberPtr[C.ImU32, uint32](vData)
	vVecArg := new(C.ImVector_ImU32)
	vVecArg.Size = C.int(v.Size)
	vVecArg.Capacity = C.int(v.Capacity)
	vVecArg.Data = vDataArg
	v.pinner.Pin(vVecArg.Data)

	selfArg, selfFin := self.handle()
	defer selfFin()
	C.wrap_ImPlotColormapData_SetKeys(selfArg, *vVecArg)
}

func (self PlotColormapData) SetKeyCounts(v Vector[*int32]) {
	vData := v.Data
	vDataArg, _ := WrapNumberPtr[C.int, int32](vData)
	vVecArg := new(C.ImVector_int)
	vVecArg.Size = C.int(v.Size)
	vVecArg.Capacity = C.int(v.Capacity)
	vVecArg.Data = vDataArg
	v.pinner.Pin(vVecArg.Data)

	selfArg, selfFin := self.handle()
	defer selfFin()
	C.wrap_ImPlotColormapData_SetKeyCounts(selfArg, *vVecArg)
}

func (self *PlotColormapData) KeyCounts() Vector[*int32] {
	selfArg, selfFin := self.handle()

	defer func() {
		selfFin()
	}()
	return newVectorFromC(C.wrap_ImPlotColormapData_GetKeyCounts(selfArg).Size, C.wrap_ImPlotColormapData_GetKeyCounts(selfArg).Capacity, (*int32)(C.wrap_ImPlotColormapData_GetKeyCounts(selfArg).Data))
}

func (self PlotColormapData) SetKeyOffsets(v Vector[*int32]) {
	vData := v.Data
	vDataArg, _ := WrapNumberPtr[C.int, int32](vData)
	vVecArg := new(C.ImVector_int)
	vVecArg.Size = C.int(v.Size)
	vVecArg.Capacity = C.int(v.Capacity)
	vVecArg.Data = vDataArg
	v.pinner.Pin(vVecArg.Data)

	selfArg, selfFin := self.handle()
	defer selfFin()
	C.wrap_ImPlotColormapData_SetKeyOffsets(selfArg, *vVecArg)
}

func (self *PlotColormapData) KeyOffsets() Vector[*int32] {
	selfArg, selfFin := self.handle()

	defer func() {
		selfFin()
	}()
	return newVectorFromC(C.wrap_ImPlotColormapData_GetKeyOffsets(selfArg).Size, C.wrap_ImPlotColormapData_GetKeyOffsets(selfArg).Capacity, (*int32)(C.wrap_ImPlotColormapData_GetKeyOffsets(selfArg).Data))
}

func (self PlotColormapData) SetTables(v Vector[*uint32]) {
	vData := v.Data
	vDataArg, _ := WrapNumberPtr[C.ImU32, uint32](vData)
	vVecArg := new(C.ImVector_ImU32)
	vVecArg.Size = C.int(v.Size)
	vVecArg.Capacity = C.int(v.Capacity)
	vVecArg.Data = vDataArg
	v.pinner.Pin(vVecArg.Data)

	selfArg, selfFin := self.handle()
	defer selfFin()
	C.wrap_ImPlotColormapData_SetTables(selfArg, *vVecArg)
}

func (self *PlotColormapData) Tables() Vector[*uint32] {
	selfArg, selfFin := self.handle()

	defer func() {
		selfFin()
	}()
	return newVectorFromC(C.wrap_ImPlotColormapData_GetTables(selfArg).Size, C.wrap_ImPlotColormapData_GetTables(selfArg).Capacity, (*uint32)(C.wrap_ImPlotColormapData_GetTables(selfArg).Data))
}

func (self PlotColormapData) SetTableSizes(v Vector[*int32]) {
	vData := v.Data
	vDataArg, _ := WrapNumberPtr[C.int, int32](vData)
	vVecArg := new(C.ImVector_int)
	vVecArg.Size = C.int(v.Size)
	vVecArg.Capacity = C.int(v.Capacity)
	vVecArg.Data = vDataArg
	v.pinner.Pin(vVecArg.Data)

	selfArg, selfFin := self.handle()
	defer selfFin()
	C.wrap_ImPlotColormapData_SetTableSizes(selfArg, *vVecArg)
}

func (self *PlotColormapData) TableSizes() Vector[*int32] {
	selfArg, selfFin := self.handle()

	defer func() {
		selfFin()
	}()
	return newVectorFromC(C.wrap_ImPlotColormapData_GetTableSizes(selfArg).Size, C.wrap_ImPlotColormapData_GetTableSizes(selfArg).Capacity, (*int32)(C.wrap_ImPlotColormapData_GetTableSizes(selfArg).Data))
}

func (self PlotColormapData) SetTableOffsets(v Vector[*int32]) {
	vData := v.Data
	vDataArg, _ := WrapNumberPtr[C.int, int32](vData)
	vVecArg := new(C.ImVector_int)
	vVecArg.Size = C.int(v.Size)
	vVecArg.Capacity = C.int(v.Capacity)
	vVecArg.Data = vDataArg
	v.pinner.Pin(vVecArg.Data)

	selfArg, selfFin := self.handle()
	defer selfFin()
	C.wrap_ImPlotColormapData_SetTableOffsets(selfArg, *vVecArg)
}

func (self *PlotColormapData) TableOffsets() Vector[*int32] {
	selfArg, selfFin := self.handle()

	defer func() {
		selfFin()
	}()
	return newVectorFromC(C.wrap_ImPlotColormapData_GetTableOffsets(selfArg).Size, C.wrap_ImPlotColormapData_GetTableOffsets(selfArg).Capacity, (*int32)(C.wrap_ImPlotColormapData_GetTableOffsets(selfArg).Data))
}

func (self PlotColormapData) SetText(v TextBuffer) {
	vArg, _ := v.c()

	selfArg, selfFin := self.handle()
	defer selfFin()
	C.wrap_ImPlotColormapData_SetText(selfArg, vArg)
}

func (self *PlotColormapData) Text() TextBuffer {
	selfArg, selfFin := self.handle()

	defer func() {
		selfFin()
	}()

	result := C.wrap_ImPlotColormapData_GetText(selfArg)
	return *newTextBufferFromC(func() *C.ImGuiTextBuffer { result := result; return &result }())
}

func (self PlotColormapData) SetTextOffsets(v Vector[*int32]) {
	vData := v.Data
	vDataArg, _ := WrapNumberPtr[C.int, int32](vData)
	vVecArg := new(C.ImVector_int)
	vVecArg.Size = C.int(v.Size)
	vVecArg.Capacity = C.int(v.Capacity)
	vVecArg.Data = vDataArg
	v.pinner.Pin(vVecArg.Data)

	selfArg, selfFin := self.handle()
	defer selfFin()
	C.wrap_ImPlotColormapData_SetTextOffsets(selfArg, *vVecArg)
}

func (self *PlotColormapData) TextOffsets() Vector[*int32] {
	selfArg, selfFin := self.handle()

	defer func() {
		selfFin()
	}()
	return newVectorFromC(C.wrap_ImPlotColormapData_GetTextOffsets(selfArg).Size, C.wrap_ImPlotColormapData_GetTextOffsets(selfArg).Capacity, (*int32)(C.wrap_ImPlotColormapData_GetTextOffsets(selfArg).Data))
}

func (self PlotColormapData) SetQuals(v Vector[*bool]) {
	vData := v.Data
	vDataArg, _ := WrapBool(vData)
	vVecArg := new(C.ImVector_bool)
	vVecArg.Size = C.int(v.Size)
	vVecArg.Capacity = C.int(v.Capacity)
	vVecArg.Data = vDataArg
	v.pinner.Pin(vVecArg.Data)

	selfArg, selfFin := self.handle()
	defer selfFin()
	C.wrap_ImPlotColormapData_SetQuals(selfArg, *vVecArg)
}

func (self PlotColormapData) SetMap(v Storage) {
	vArg, _ := v.c()

	selfArg, selfFin := self.handle()
	defer selfFin()
	C.wrap_ImPlotColormapData_SetMap(selfArg, vArg)
}

func (self *PlotColormapData) Map() Storage {
	selfArg, selfFin := self.handle()

	defer func() {
		selfFin()
	}()

	result := C.wrap_ImPlotColormapData_GetMap(selfArg)
	return *newStorageFromC(func() *C.ImGuiStorage { result := result; return &result }())
}

func (self PlotColormapData) SetCount(v int32) {
	selfArg, selfFin := self.handle()
	defer selfFin()
	C.wrap_ImPlotColormapData_SetCount(selfArg, C.int(v))
}

func (self *PlotColormapData) Count() int32 {
	selfArg, selfFin := self.handle()

	defer func() {
		selfFin()
	}()
	return int32(C.wrap_ImPlotColormapData_GetCount(selfArg))
}

func (self PlotContext) SetCurrentPlot(v *PlotPlot) {
	vArg, _ := v.handle()

	selfArg, selfFin := self.handle()
	defer selfFin()
	C.wrap_ImPlotContext_SetCurrentPlot(selfArg, vArg)
}

func (self *PlotContext) CurrentPlot() *PlotPlot {
	selfArg, selfFin := self.handle()

	defer func() {
		selfFin()
	}()
	return newPlotPlotFromC(C.wrap_ImPlotContext_GetCurrentPlot(selfArg))
}

func (self PlotContext) SetCurrentSubplot(v *PlotSubplot) {
	vArg, _ := v.handle()

	selfArg, selfFin := self.handle()
	defer selfFin()
	C.wrap_ImPlotContext_SetCurrentSubplot(selfArg, vArg)
}

func (self *PlotContext) CurrentSubplot() *PlotSubplot {
	selfArg, selfFin := self.handle()

	defer func() {
		selfFin()
	}()
	return newPlotSubplotFromC(C.wrap_ImPlotContext_GetCurrentSubplot(selfArg))
}

func (self PlotContext) SetCurrentItems(v *PlotItemGroup) {
	vArg, _ := v.handle()

	selfArg, selfFin := self.handle()
	defer selfFin()
	C.wrap_ImPlotContext_SetCurrentItems(selfArg, vArg)
}

func (self *PlotContext) CurrentItems() *PlotItemGroup {
	selfArg, selfFin := self.handle()

	defer func() {
		selfFin()
	}()
	return newPlotItemGroupFromC(C.wrap_ImPlotContext_GetCurrentItems(selfArg))
}

func (self PlotContext) SetCurrentItem(v *PlotItem) {
	vArg, _ := v.handle()

	selfArg, selfFin := self.handle()
	defer selfFin()
	C.wrap_ImPlotContext_SetCurrentItem(selfArg, vArg)
}

func (self *PlotContext) CurrentItem() *PlotItem {
	selfArg, selfFin := self.handle()

	defer func() {
		selfFin()
	}()
	return newPlotItemFromC(C.wrap_ImPlotContext_GetCurrentItem(selfArg))
}

func (self PlotContext) SetPreviousItem(v *PlotItem) {
	vArg, _ := v.handle()

	selfArg, selfFin := self.handle()
	defer selfFin()
	C.wrap_ImPlotContext_SetPreviousItem(selfArg, vArg)
}

func (self *PlotContext) PreviousItem() *PlotItem {
	selfArg, selfFin := self.handle()

	defer func() {
		selfFin()
	}()
	return newPlotItemFromC(C.wrap_ImPlotContext_GetPreviousItem(selfArg))
}

func (self PlotContext) SetCTicker(v PlotTicker) {
	vArg, _ := v.c()

	selfArg, selfFin := self.handle()
	defer selfFin()
	C.wrap_ImPlotContext_SetCTicker(selfArg, vArg)
}

func (self *PlotContext) CTicker() PlotTicker {
	selfArg, selfFin := self.handle()

	defer func() {
		selfFin()
	}()

	result := C.wrap_ImPlotContext_GetCTicker(selfArg)
	return *newPlotTickerFromC(func() *C.ImPlotTicker { result := result; return &result }())
}

func (self PlotContext) SetAnnotations(v PlotAnnotationCollection) {
	vArg, _ := v.c()

	selfArg, selfFin := self.handle()
	defer selfFin()
	C.wrap_ImPlotContext_SetAnnotations(selfArg, vArg)
}

func (self *PlotContext) Annotations() PlotAnnotationCollection {
	selfArg, selfFin := self.handle()

	defer func() {
		selfFin()
	}()

	result := C.wrap_ImPlotContext_GetAnnotations(selfArg)
	return *newPlotAnnotationCollectionFromC(func() *C.ImPlotAnnotationCollection { result := result; return &result }())
}

func (self PlotContext) SetTags(v PlotTagCollection) {
	vArg, _ := v.c()

	selfArg, selfFin := self.handle()
	defer selfFin()
	C.wrap_ImPlotContext_SetTags(selfArg, vArg)
}

func (self *PlotContext) Tags() PlotTagCollection {
	selfArg, selfFin := self.handle()

	defer func() {
		selfFin()
	}()

	result := C.wrap_ImPlotContext_GetTags(selfArg)
	return *newPlotTagCollectionFromC(func() *C.ImPlotTagCollection { result := result; return &result }())
}

func (self PlotContext) SetStyle(v PlotStyle) {
	vArg, _ := v.c()

	selfArg, selfFin := self.handle()
	defer selfFin()
	C.wrap_ImPlotContext_SetStyle(selfArg, vArg)
}

func (self *PlotContext) Style() PlotStyle {
	selfArg, selfFin := self.handle()

	defer func() {
		selfFin()
	}()

	result := C.wrap_ImPlotContext_GetStyle(selfArg)
	return *newPlotStyleFromC(func() *C.ImPlotStyle { result := result; return &result }())
}

func (self PlotContext) SetColorModifiers(v Vector[*ColorMod]) {
	vData := v.Data
	vDataArg, _ := vData.handle()
	vVecArg := new(C.ImVector_ImGuiColorMod)
	vVecArg.Size = C.int(v.Size)
	vVecArg.Capacity = C.int(v.Capacity)
	vVecArg.Data = vDataArg
	v.pinner.Pin(vVecArg.Data)

	selfArg, selfFin := self.handle()
	defer selfFin()
	C.wrap_ImPlotContext_SetColorModifiers(selfArg, *vVecArg)
}

func (self *PlotContext) ColorModifiers() Vector[*ColorMod] {
	selfArg, selfFin := self.handle()

	defer func() {
		selfFin()
	}()
	return newVectorFromC(C.wrap_ImPlotContext_GetColorModifiers(selfArg).Size, C.wrap_ImPlotContext_GetColorModifiers(selfArg).Capacity, newColorModFromC(C.wrap_ImPlotContext_GetColorModifiers(selfArg).Data))
}

func (self PlotContext) SetStyleModifiers(v Vector[*StyleMod]) {
	vData := v.Data
	vDataArg, _ := vData.handle()
	vVecArg := new(C.ImVector_ImGuiStyleMod)
	vVecArg.Size = C.int(v.Size)
	vVecArg.Capacity = C.int(v.Capacity)
	vVecArg.Data = vDataArg
	v.pinner.Pin(vVecArg.Data)

	selfArg, selfFin := self.handle()
	defer selfFin()
	C.wrap_ImPlotContext_SetStyleModifiers(selfArg, *vVecArg)
}

func (self *PlotContext) StyleModifiers() Vector[*StyleMod] {
	selfArg, selfFin := self.handle()

	defer func() {
		selfFin()
	}()
	return newVectorFromC(C.wrap_ImPlotContext_GetStyleModifiers(selfArg).Size, C.wrap_ImPlotContext_GetStyleModifiers(selfArg).Capacity, newStyleModFromC(C.wrap_ImPlotContext_GetStyleModifiers(selfArg).Data))
}

func (self PlotContext) SetColormapData(v PlotColormapData) {
	vArg, _ := v.c()

	selfArg, selfFin := self.handle()
	defer selfFin()
	C.wrap_ImPlotContext_SetColormapData(selfArg, vArg)
}

func (self *PlotContext) ColormapData() PlotColormapData {
	selfArg, selfFin := self.handle()

	defer func() {
		selfFin()
	}()

	result := C.wrap_ImPlotContext_GetColormapData(selfArg)
	return *newPlotColormapDataFromC(func() *C.ImPlotColormapData { result := result; return &result }())
}

func (self *PlotContext) ColormapModifiers() Vector[*PlotColormap] {
	selfArg, selfFin := self.handle()

	defer func() {
		selfFin()
	}()
	return newVectorFromC(C.wrap_ImPlotContext_GetColormapModifiers(selfArg).Size, C.wrap_ImPlotContext_GetColormapModifiers(selfArg).Capacity, (*PlotColormap)(C.wrap_ImPlotContext_GetColormapModifiers(selfArg).Data))
}

func (self PlotContext) SetTempDouble1(v Vector[*float64]) {
	vData := v.Data
	vDataArg, _ := WrapNumberPtr[C.double, float64](vData)
	vVecArg := new(C.ImVector_double)
	vVecArg.Size = C.int(v.Size)
	vVecArg.Capacity = C.int(v.Capacity)
	vVecArg.Data = vDataArg
	v.pinner.Pin(vVecArg.Data)

	selfArg, selfFin := self.handle()
	defer selfFin()
	C.wrap_ImPlotContext_SetTempDouble1(selfArg, *vVecArg)
}

func (self *PlotContext) TempDouble1() Vector[*float64] {
	selfArg, selfFin := self.handle()

	defer func() {
		selfFin()
	}()
	return newVectorFromC(C.wrap_ImPlotContext_GetTempDouble1(selfArg).Size, C.wrap_ImPlotContext_GetTempDouble1(selfArg).Capacity, (*float64)(C.wrap_ImPlotContext_GetTempDouble1(selfArg).Data))
}

func (self PlotContext) SetTempDouble2(v Vector[*float64]) {
	vData := v.Data
	vDataArg, _ := WrapNumberPtr[C.double, float64](vData)
	vVecArg := new(C.ImVector_double)
	vVecArg.Size = C.int(v.Size)
	vVecArg.Capacity = C.int(v.Capacity)
	vVecArg.Data = vDataArg
	v.pinner.Pin(vVecArg.Data)

	selfArg, selfFin := self.handle()
	defer selfFin()
	C.wrap_ImPlotContext_SetTempDouble2(selfArg, *vVecArg)
}

func (self *PlotContext) TempDouble2() Vector[*float64] {
	selfArg, selfFin := self.handle()

	defer func() {
		selfFin()
	}()
	return newVectorFromC(C.wrap_ImPlotContext_GetTempDouble2(selfArg).Size, C.wrap_ImPlotContext_GetTempDouble2(selfArg).Capacity, (*float64)(C.wrap_ImPlotContext_GetTempDouble2(selfArg).Data))
}

func (self PlotContext) SetTempInt1(v Vector[*int32]) {
	vData := v.Data
	vDataArg, _ := WrapNumberPtr[C.int, int32](vData)
	vVecArg := new(C.ImVector_int)
	vVecArg.Size = C.int(v.Size)
	vVecArg.Capacity = C.int(v.Capacity)
	vVecArg.Data = vDataArg
	v.pinner.Pin(vVecArg.Data)

	selfArg, selfFin := self.handle()
	defer selfFin()
	C.wrap_ImPlotContext_SetTempInt1(selfArg, *vVecArg)
}

func (self *PlotContext) TempInt1() Vector[*int32] {
	selfArg, selfFin := self.handle()

	defer func() {
		selfFin()
	}()
	return newVectorFromC(C.wrap_ImPlotContext_GetTempInt1(selfArg).Size, C.wrap_ImPlotContext_GetTempInt1(selfArg).Capacity, (*int32)(C.wrap_ImPlotContext_GetTempInt1(selfArg).Data))
}

func (self PlotContext) SetDigitalPlotItemCnt(v int32) {
	selfArg, selfFin := self.handle()
	defer selfFin()
	C.wrap_ImPlotContext_SetDigitalPlotItemCnt(selfArg, C.int(v))
}

func (self *PlotContext) DigitalPlotItemCnt() int32 {
	selfArg, selfFin := self.handle()

	defer func() {
		selfFin()
	}()
	return int32(C.wrap_ImPlotContext_GetDigitalPlotItemCnt(selfArg))
}

func (self PlotContext) SetDigitalPlotOffset(v int32) {
	selfArg, selfFin := self.handle()
	defer selfFin()
	C.wrap_ImPlotContext_SetDigitalPlotOffset(selfArg, C.int(v))
}

func (self *PlotContext) DigitalPlotOffset() int32 {
	selfArg, selfFin := self.handle()

	defer func() {
		selfFin()
	}()
	return int32(C.wrap_ImPlotContext_GetDigitalPlotOffset(selfArg))
}

func (self PlotContext) SetNextPlotData(v PlotNextPlotData) {
	vArg, _ := v.c()

	selfArg, selfFin := self.handle()
	defer selfFin()
	C.wrap_ImPlotContext_SetNextPlotData(selfArg, vArg)
}

func (self *PlotContext) NextPlotData() PlotNextPlotData {
	selfArg, selfFin := self.handle()

	defer func() {
		selfFin()
	}()

	result := C.wrap_ImPlotContext_GetNextPlotData(selfArg)
	return *newPlotNextPlotDataFromC(func() *C.ImPlotNextPlotData { result := result; return &result }())
}

func (self PlotContext) SetNextItemData(v PlotNextItemData) {
	vArg, _ := v.c()

	selfArg, selfFin := self.handle()
	defer selfFin()
	C.wrap_ImPlotContext_SetNextItemData(selfArg, vArg)
}

func (self *PlotContext) NextItemData() PlotNextItemData {
	selfArg, selfFin := self.handle()

	defer func() {
		selfFin()
	}()

	result := C.wrap_ImPlotContext_GetNextItemData(selfArg)
	return *newPlotNextItemDataFromC(func() *C.ImPlotNextItemData { result := result; return &result }())
}

func (self PlotContext) SetInputMap(v PlotInputMap) {
	vArg, _ := v.c()

	selfArg, selfFin := self.handle()
	defer selfFin()
	C.wrap_ImPlotContext_SetInputMap(selfArg, vArg)
}

func (self *PlotContext) InputMap() PlotInputMap {
	selfArg, selfFin := self.handle()

	defer func() {
		selfFin()
	}()

	result := C.wrap_ImPlotContext_GetInputMap(selfArg)
	return *newPlotInputMapFromC(func() *C.ImPlotInputMap { result := result; return &result }())
}

func (self PlotContext) SetOpenContextThisFrame(v bool) {
	selfArg, selfFin := self.handle()
	defer selfFin()
	C.wrap_ImPlotContext_SetOpenContextThisFrame(selfArg, C.bool(v))
}

func (self *PlotContext) OpenContextThisFrame() bool {
	selfArg, selfFin := self.handle()

	defer func() {
		selfFin()
	}()
	return C.wrap_ImPlotContext_GetOpenContextThisFrame(selfArg) == C.bool(true)
}

func (self PlotContext) SetMousePosStringBuilder(v TextBuffer) {
	vArg, _ := v.c()

	selfArg, selfFin := self.handle()
	defer selfFin()
	C.wrap_ImPlotContext_SetMousePosStringBuilder(selfArg, vArg)
}

func (self *PlotContext) MousePosStringBuilder() TextBuffer {
	selfArg, selfFin := self.handle()

	defer func() {
		selfFin()
	}()

	result := C.wrap_ImPlotContext_GetMousePosStringBuilder(selfArg)
	return *newTextBufferFromC(func() *C.ImGuiTextBuffer { result := result; return &result }())
}

func (self PlotContext) SetSortItems(v *PlotItemGroup) {
	vArg, _ := v.handle()

	selfArg, selfFin := self.handle()
	defer selfFin()
	C.wrap_ImPlotContext_SetSortItems(selfArg, vArg)
}

func (self *PlotContext) SortItems() *PlotItemGroup {
	selfArg, selfFin := self.handle()

	defer func() {
		selfFin()
	}()
	return newPlotItemGroupFromC(C.wrap_ImPlotContext_GetSortItems(selfArg))
}

func (self PlotContext) SetCurrentAlignmentH(v *PlotAlignmentData) {
	vArg, _ := v.handle()

	selfArg, selfFin := self.handle()
	defer selfFin()
	C.wrap_ImPlotContext_SetCurrentAlignmentH(selfArg, vArg)
}

func (self *PlotContext) CurrentAlignmentH() *PlotAlignmentData {
	selfArg, selfFin := self.handle()

	defer func() {
		selfFin()
	}()
	return newPlotAlignmentDataFromC(C.wrap_ImPlotContext_GetCurrentAlignmentH(selfArg))
}

func (self PlotContext) SetCurrentAlignmentV(v *PlotAlignmentData) {
	vArg, _ := v.handle()

	selfArg, selfFin := self.handle()
	defer selfFin()
	C.wrap_ImPlotContext_SetCurrentAlignmentV(selfArg, vArg)
}

func (self *PlotContext) CurrentAlignmentV() *PlotAlignmentData {
	selfArg, selfFin := self.handle()

	defer func() {
		selfFin()
	}()
	return newPlotAlignmentDataFromC(C.wrap_ImPlotContext_GetCurrentAlignmentV(selfArg))
}

func (self PlotDateTimeSpec) SetDate(v PlotDateFmt) {
	selfArg, selfFin := self.handle()
	defer selfFin()
	C.wrap_ImPlotDateTimeSpec_SetDate(selfArg, C.ImPlotDateFmt(v))
}

func (self *PlotDateTimeSpec) Date() PlotDateFmt {
	selfArg, selfFin := self.handle()

	defer func() {
		selfFin()
	}()
	return PlotDateFmt(C.wrap_ImPlotDateTimeSpec_GetDate(selfArg))
}

func (self PlotDateTimeSpec) SetTime(v PlotTimeFmt) {
	selfArg, selfFin := self.handle()
	defer selfFin()
	C.wrap_ImPlotDateTimeSpec_SetTime(selfArg, C.ImPlotTimeFmt(v))
}

func (self *PlotDateTimeSpec) Time() PlotTimeFmt {
	selfArg, selfFin := self.handle()

	defer func() {
		selfFin()
	}()
	return PlotTimeFmt(C.wrap_ImPlotDateTimeSpec_GetTime(selfArg))
}

func (self PlotDateTimeSpec) SetUseISO8601(v bool) {
	selfArg, selfFin := self.handle()
	defer selfFin()
	C.wrap_ImPlotDateTimeSpec_SetUseISO8601(selfArg, C.bool(v))
}

func (self *PlotDateTimeSpec) UseISO8601() bool {
	selfArg, selfFin := self.handle()

	defer func() {
		selfFin()
	}()
	return C.wrap_ImPlotDateTimeSpec_GetUseISO8601(selfArg) == C.bool(true)
}

func (self PlotDateTimeSpec) SetUse24HourClock(v bool) {
	selfArg, selfFin := self.handle()
	defer selfFin()
	C.wrap_ImPlotDateTimeSpec_SetUse24HourClock(selfArg, C.bool(v))
}

func (self *PlotDateTimeSpec) Use24HourClock() bool {
	selfArg, selfFin := self.handle()

	defer func() {
		selfFin()
	}()
	return C.wrap_ImPlotDateTimeSpec_GetUse24HourClock(selfArg) == C.bool(true)
}

func (self PlotInputMap) SetPan(v MouseButton) {
	selfArg, selfFin := self.handle()
	defer selfFin()
	C.wrap_ImPlotInputMap_SetPan(selfArg, C.ImGuiMouseButton(v))
}

func (self *PlotInputMap) Pan() MouseButton {
	selfArg, selfFin := self.handle()

	defer func() {
		selfFin()
	}()
	return MouseButton(C.wrap_ImPlotInputMap_GetPan(selfArg))
}

func (self PlotInputMap) SetPanMod(v int32) {
	selfArg, selfFin := self.handle()
	defer selfFin()
	C.wrap_ImPlotInputMap_SetPanMod(selfArg, C.int(v))
}

func (self *PlotInputMap) PanMod() int32 {
	selfArg, selfFin := self.handle()

	defer func() {
		selfFin()
	}()
	return int32(C.wrap_ImPlotInputMap_GetPanMod(selfArg))
}

func (self PlotInputMap) SetFit(v MouseButton) {
	selfArg, selfFin := self.handle()
	defer selfFin()
	C.wrap_ImPlotInputMap_SetFit(selfArg, C.ImGuiMouseButton(v))
}

func (self *PlotInputMap) Fit() MouseButton {
	selfArg, selfFin := self.handle()

	defer func() {
		selfFin()
	}()
	return MouseButton(C.wrap_ImPlotInputMap_GetFit(selfArg))
}

func (self PlotInputMap) SetSelect(v MouseButton) {
	selfArg, selfFin := self.handle()
	defer selfFin()
	C.wrap_ImPlotInputMap_SetSelect(selfArg, C.ImGuiMouseButton(v))
}

func (self *PlotInputMap) Select() MouseButton {
	selfArg, selfFin := self.handle()

	defer func() {
		selfFin()
	}()
	return MouseButton(C.wrap_ImPlotInputMap_GetSelect(selfArg))
}

func (self PlotInputMap) SetSelectCancel(v MouseButton) {
	selfArg, selfFin := self.handle()
	defer selfFin()
	C.wrap_ImPlotInputMap_SetSelectCancel(selfArg, C.ImGuiMouseButton(v))
}

func (self *PlotInputMap) SelectCancel() MouseButton {
	selfArg, selfFin := self.handle()

	defer func() {
		selfFin()
	}()
	return MouseButton(C.wrap_ImPlotInputMap_GetSelectCancel(selfArg))
}

func (self PlotInputMap) SetSelectMod(v int32) {
	selfArg, selfFin := self.handle()
	defer selfFin()
	C.wrap_ImPlotInputMap_SetSelectMod(selfArg, C.int(v))
}

func (self *PlotInputMap) SelectMod() int32 {
	selfArg, selfFin := self.handle()

	defer func() {
		selfFin()
	}()
	return int32(C.wrap_ImPlotInputMap_GetSelectMod(selfArg))
}

func (self PlotInputMap) SetSelectHorzMod(v int32) {
	selfArg, selfFin := self.handle()
	defer selfFin()
	C.wrap_ImPlotInputMap_SetSelectHorzMod(selfArg, C.int(v))
}

func (self *PlotInputMap) SelectHorzMod() int32 {
	selfArg, selfFin := self.handle()

	defer func() {
		selfFin()
	}()
	return int32(C.wrap_ImPlotInputMap_GetSelectHorzMod(selfArg))
}

func (self PlotInputMap) SetSelectVertMod(v int32) {
	selfArg, selfFin := self.handle()
	defer selfFin()
	C.wrap_ImPlotInputMap_SetSelectVertMod(selfArg, C.int(v))
}

func (self *PlotInputMap) SelectVertMod() int32 {
	selfArg, selfFin := self.handle()

	defer func() {
		selfFin()
	}()
	return int32(C.wrap_ImPlotInputMap_GetSelectVertMod(selfArg))
}

func (self PlotInputMap) SetMenu(v MouseButton) {
	selfArg, selfFin := self.handle()
	defer selfFin()
	C.wrap_ImPlotInputMap_SetMenu(selfArg, C.ImGuiMouseButton(v))
}

func (self *PlotInputMap) Menu() MouseButton {
	selfArg, selfFin := self.handle()

	defer func() {
		selfFin()
	}()
	return MouseButton(C.wrap_ImPlotInputMap_GetMenu(selfArg))
}

func (self PlotInputMap) SetOverrideMod(v int32) {
	selfArg, selfFin := self.handle()
	defer selfFin()
	C.wrap_ImPlotInputMap_SetOverrideMod(selfArg, C.int(v))
}

func (self *PlotInputMap) OverrideMod() int32 {
	selfArg, selfFin := self.handle()

	defer func() {
		selfFin()
	}()
	return int32(C.wrap_ImPlotInputMap_GetOverrideMod(selfArg))
}

func (self PlotInputMap) SetZoomMod(v int32) {
	selfArg, selfFin := self.handle()
	defer selfFin()
	C.wrap_ImPlotInputMap_SetZoomMod(selfArg, C.int(v))
}

func (self *PlotInputMap) ZoomMod() int32 {
	selfArg, selfFin := self.handle()

	defer func() {
		selfFin()
	}()
	return int32(C.wrap_ImPlotInputMap_GetZoomMod(selfArg))
}

func (self PlotInputMap) SetZoomRate(v float32) {
	selfArg, selfFin := self.handle()
	defer selfFin()
	C.wrap_ImPlotInputMap_SetZoomRate(selfArg, C.float(v))
}

func (self *PlotInputMap) ZoomRate() float32 {
	selfArg, selfFin := self.handle()

	defer func() {
		selfFin()
	}()
	return float32(C.wrap_ImPlotInputMap_GetZoomRate(selfArg))
}

func (self PlotItem) SetColor(v uint32) {
	selfArg, selfFin := self.handle()
	defer selfFin()
	C.wrap_ImPlotItem_SetColor(selfArg, C.ImU32(v))
}

func (self *PlotItem) Color() uint32 {
	selfArg, selfFin := self.handle()

	defer func() {
		selfFin()
	}()
	return uint32(C.wrap_ImPlotItem_GetColor(selfArg))
}

func (self PlotItem) SetLegendHoverRect(v Rect) {
	selfArg, selfFin := self.handle()
	defer selfFin()
	C.wrap_ImPlotItem_SetLegendHoverRect(selfArg, v.toC())
}

func (self *PlotItem) LegendHoverRect() Rect {
	selfArg, selfFin := self.handle()

	defer func() {
		selfFin()
	}()
	return *(&Rect{}).fromC(C.wrap_ImPlotItem_GetLegendHoverRect(selfArg))
}

func (self PlotItem) SetNameOffset(v int32) {
	selfArg, selfFin := self.handle()
	defer selfFin()
	C.wrap_ImPlotItem_SetNameOffset(selfArg, C.int(v))
}

func (self *PlotItem) NameOffset() int32 {
	selfArg, selfFin := self.handle()

	defer func() {
		selfFin()
	}()
	return int32(C.wrap_ImPlotItem_GetNameOffset(selfArg))
}

func (self PlotItem) SetShow(v bool) {
	selfArg, selfFin := self.handle()
	defer selfFin()
	C.wrap_ImPlotItem_SetShow(selfArg, C.bool(v))
}

func (self *PlotItem) Show() bool {
	selfArg, selfFin := self.handle()

	defer func() {
		selfFin()
	}()
	return C.wrap_ImPlotItem_GetShow(selfArg) == C.bool(true)
}

func (self PlotItem) SetLegendHovered(v bool) {
	selfArg, selfFin := self.handle()
	defer selfFin()
	C.wrap_ImPlotItem_SetLegendHovered(selfArg, C.bool(v))
}

func (self *PlotItem) LegendHovered() bool {
	selfArg, selfFin := self.handle()

	defer func() {
		selfFin()
	}()
	return C.wrap_ImPlotItem_GetLegendHovered(selfArg) == C.bool(true)
}

func (self PlotItem) SetSeenThisFrame(v bool) {
	selfArg, selfFin := self.handle()
	defer selfFin()
	C.wrap_ImPlotItem_SetSeenThisFrame(selfArg, C.bool(v))
}

func (self *PlotItem) SeenThisFrame() bool {
	selfArg, selfFin := self.handle()

	defer func() {
		selfFin()
	}()
	return C.wrap_ImPlotItem_GetSeenThisFrame(selfArg) == C.bool(true)
}

func (self PlotItemGroup) SetLegend(v PlotLegend) {
	vArg, _ := v.c()

	selfArg, selfFin := self.handle()
	defer selfFin()
	C.wrap_ImPlotItemGroup_SetLegend(selfArg, vArg)
}

func (self *PlotItemGroup) Legend() PlotLegend {
	selfArg, selfFin := self.handle()

	defer func() {
		selfFin()
	}()

	result := C.wrap_ImPlotItemGroup_GetLegend(selfArg)
	return *newPlotLegendFromC(func() *C.ImPlotLegend { result := result; return &result }())
}

func (self PlotItemGroup) SetColormapIdx(v int32) {
	selfArg, selfFin := self.handle()
	defer selfFin()
	C.wrap_ImPlotItemGroup_SetColormapIdx(selfArg, C.int(v))
}

func (self *PlotItemGroup) ColormapIdx() int32 {
	selfArg, selfFin := self.handle()

	defer func() {
		selfFin()
	}()
	return int32(C.wrap_ImPlotItemGroup_GetColormapIdx(selfArg))
}

func (self PlotLegend) SetFlags(v PlotLegendFlags) {
	selfArg, selfFin := self.handle()
	defer selfFin()
	C.wrap_ImPlotLegend_SetFlags(selfArg, C.ImPlotLegendFlags(v))
}

func (self *PlotLegend) Flags() PlotLegendFlags {
	selfArg, selfFin := self.handle()

	defer func() {
		selfFin()
	}()
	return PlotLegendFlags(C.wrap_ImPlotLegend_GetFlags(selfArg))
}

func (self PlotLegend) SetPreviousFlags(v PlotLegendFlags) {
	selfArg, selfFin := self.handle()
	defer selfFin()
	C.wrap_ImPlotLegend_SetPreviousFlags(selfArg, C.ImPlotLegendFlags(v))
}

func (self *PlotLegend) PreviousFlags() PlotLegendFlags {
	selfArg, selfFin := self.handle()

	defer func() {
		selfFin()
	}()
	return PlotLegendFlags(C.wrap_ImPlotLegend_GetPreviousFlags(selfArg))
}

func (self PlotLegend) SetLocation(v PlotLocation) {
	selfArg, selfFin := self.handle()
	defer selfFin()
	C.wrap_ImPlotLegend_SetLocation(selfArg, C.ImPlotLocation(v))
}

func (self *PlotLegend) Location() PlotLocation {
	selfArg, selfFin := self.handle()

	defer func() {
		selfFin()
	}()
	return PlotLocation(C.wrap_ImPlotLegend_GetLocation(selfArg))
}

func (self PlotLegend) SetPreviousLocation(v PlotLocation) {
	selfArg, selfFin := self.handle()
	defer selfFin()
	C.wrap_ImPlotLegend_SetPreviousLocation(selfArg, C.ImPlotLocation(v))
}

func (self *PlotLegend) PreviousLocation() PlotLocation {
	selfArg, selfFin := self.handle()

	defer func() {
		selfFin()
	}()
	return PlotLocation(C.wrap_ImPlotLegend_GetPreviousLocation(selfArg))
}

func (self PlotLegend) SetScroll(v Vec2) {
	selfArg, selfFin := self.handle()
	defer selfFin()
	C.wrap_ImPlotLegend_SetScroll(selfArg, v.toC())
}

func (self *PlotLegend) Scroll() Vec2 {
	selfArg, selfFin := self.handle()

	defer func() {
		selfFin()
	}()
	return *(&Vec2{}).fromC(C.wrap_ImPlotLegend_GetScroll(selfArg))
}

func (self PlotLegend) SetIndices(v Vector[*int32]) {
	vData := v.Data
	vDataArg, _ := WrapNumberPtr[C.int, int32](vData)
	vVecArg := new(C.ImVector_int)
	vVecArg.Size = C.int(v.Size)
	vVecArg.Capacity = C.int(v.Capacity)
	vVecArg.Data = vDataArg
	v.pinner.Pin(vVecArg.Data)

	selfArg, selfFin := self.handle()
	defer selfFin()
	C.wrap_ImPlotLegend_SetIndices(selfArg, *vVecArg)
}

func (self *PlotLegend) Indices() Vector[*int32] {
	selfArg, selfFin := self.handle()

	defer func() {
		selfFin()
	}()
	return newVectorFromC(C.wrap_ImPlotLegend_GetIndices(selfArg).Size, C.wrap_ImPlotLegend_GetIndices(selfArg).Capacity, (*int32)(C.wrap_ImPlotLegend_GetIndices(selfArg).Data))
}

func (self PlotLegend) SetLabels(v TextBuffer) {
	vArg, _ := v.c()

	selfArg, selfFin := self.handle()
	defer selfFin()
	C.wrap_ImPlotLegend_SetLabels(selfArg, vArg)
}

func (self *PlotLegend) Labels() TextBuffer {
	selfArg, selfFin := self.handle()

	defer func() {
		selfFin()
	}()

	result := C.wrap_ImPlotLegend_GetLabels(selfArg)
	return *newTextBufferFromC(func() *C.ImGuiTextBuffer { result := result; return &result }())
}

func (self PlotLegend) SetRect(v Rect) {
	selfArg, selfFin := self.handle()
	defer selfFin()
	C.wrap_ImPlotLegend_SetRect(selfArg, v.toC())
}

func (self *PlotLegend) Rect() Rect {
	selfArg, selfFin := self.handle()

	defer func() {
		selfFin()
	}()
	return *(&Rect{}).fromC(C.wrap_ImPlotLegend_GetRect(selfArg))
}

func (self PlotLegend) SetRectClamped(v Rect) {
	selfArg, selfFin := self.handle()
	defer selfFin()
	C.wrap_ImPlotLegend_SetRectClamped(selfArg, v.toC())
}

func (self *PlotLegend) RectClamped() Rect {
	selfArg, selfFin := self.handle()

	defer func() {
		selfFin()
	}()
	return *(&Rect{}).fromC(C.wrap_ImPlotLegend_GetRectClamped(selfArg))
}

func (self PlotLegend) SetHovered(v bool) {
	selfArg, selfFin := self.handle()
	defer selfFin()
	C.wrap_ImPlotLegend_SetHovered(selfArg, C.bool(v))
}

func (self *PlotLegend) Hovered() bool {
	selfArg, selfFin := self.handle()

	defer func() {
		selfFin()
	}()
	return C.wrap_ImPlotLegend_GetHovered(selfArg) == C.bool(true)
}

func (self PlotLegend) SetHeld(v bool) {
	selfArg, selfFin := self.handle()
	defer selfFin()
	C.wrap_ImPlotLegend_SetHeld(selfArg, C.bool(v))
}

func (self *PlotLegend) Held() bool {
	selfArg, selfFin := self.handle()

	defer func() {
		selfFin()
	}()
	return C.wrap_ImPlotLegend_GetHeld(selfArg) == C.bool(true)
}

func (self PlotLegend) SetCanGoInside(v bool) {
	selfArg, selfFin := self.handle()
	defer selfFin()
	C.wrap_ImPlotLegend_SetCanGoInside(selfArg, C.bool(v))
}

func (self *PlotLegend) CanGoInside() bool {
	selfArg, selfFin := self.handle()

	defer func() {
		selfFin()
	}()
	return C.wrap_ImPlotLegend_GetCanGoInside(selfArg) == C.bool(true)
}

func (self PlotNextItemData) SetLineWeight(v float32) {
	selfArg, selfFin := self.handle()
	defer selfFin()
	C.wrap_ImPlotNextItemData_SetLineWeight(selfArg, C.float(v))
}

func (self *PlotNextItemData) LineWeight() float32 {
	selfArg, selfFin := self.handle()

	defer func() {
		selfFin()
	}()
	return float32(C.wrap_ImPlotNextItemData_GetLineWeight(selfArg))
}

func (self PlotNextItemData) SetMarker(v PlotMarker) {
	selfArg, selfFin := self.handle()
	defer selfFin()
	C.wrap_ImPlotNextItemData_SetMarker(selfArg, C.ImPlotMarker(v))
}

func (self *PlotNextItemData) Marker() PlotMarker {
	selfArg, selfFin := self.handle()

	defer func() {
		selfFin()
	}()
	return PlotMarker(C.wrap_ImPlotNextItemData_GetMarker(selfArg))
}

func (self PlotNextItemData) SetMarkerSize(v float32) {
	selfArg, selfFin := self.handle()
	defer selfFin()
	C.wrap_ImPlotNextItemData_SetMarkerSize(selfArg, C.float(v))
}

func (self *PlotNextItemData) MarkerSize() float32 {
	selfArg, selfFin := self.handle()

	defer func() {
		selfFin()
	}()
	return float32(C.wrap_ImPlotNextItemData_GetMarkerSize(selfArg))
}

func (self PlotNextItemData) SetMarkerWeight(v float32) {
	selfArg, selfFin := self.handle()
	defer selfFin()
	C.wrap_ImPlotNextItemData_SetMarkerWeight(selfArg, C.float(v))
}

func (self *PlotNextItemData) MarkerWeight() float32 {
	selfArg, selfFin := self.handle()

	defer func() {
		selfFin()
	}()
	return float32(C.wrap_ImPlotNextItemData_GetMarkerWeight(selfArg))
}

func (self PlotNextItemData) SetFillAlpha(v float32) {
	selfArg, selfFin := self.handle()
	defer selfFin()
	C.wrap_ImPlotNextItemData_SetFillAlpha(selfArg, C.float(v))
}

func (self *PlotNextItemData) FillAlpha() float32 {
	selfArg, selfFin := self.handle()

	defer func() {
		selfFin()
	}()
	return float32(C.wrap_ImPlotNextItemData_GetFillAlpha(selfArg))
}

func (self PlotNextItemData) SetErrorBarSize(v float32) {
	selfArg, selfFin := self.handle()
	defer selfFin()
	C.wrap_ImPlotNextItemData_SetErrorBarSize(selfArg, C.float(v))
}

func (self *PlotNextItemData) ErrorBarSize() float32 {
	selfArg, selfFin := self.handle()

	defer func() {
		selfFin()
	}()
	return float32(C.wrap_ImPlotNextItemData_GetErrorBarSize(selfArg))
}

func (self PlotNextItemData) SetErrorBarWeight(v float32) {
	selfArg, selfFin := self.handle()
	defer selfFin()
	C.wrap_ImPlotNextItemData_SetErrorBarWeight(selfArg, C.float(v))
}

func (self *PlotNextItemData) ErrorBarWeight() float32 {
	selfArg, selfFin := self.handle()

	defer func() {
		selfFin()
	}()
	return float32(C.wrap_ImPlotNextItemData_GetErrorBarWeight(selfArg))
}

func (self PlotNextItemData) SetDigitalBitHeight(v float32) {
	selfArg, selfFin := self.handle()
	defer selfFin()
	C.wrap_ImPlotNextItemData_SetDigitalBitHeight(selfArg, C.float(v))
}

func (self *PlotNextItemData) DigitalBitHeight() float32 {
	selfArg, selfFin := self.handle()

	defer func() {
		selfFin()
	}()
	return float32(C.wrap_ImPlotNextItemData_GetDigitalBitHeight(selfArg))
}

func (self PlotNextItemData) SetDigitalBitGap(v float32) {
	selfArg, selfFin := self.handle()
	defer selfFin()
	C.wrap_ImPlotNextItemData_SetDigitalBitGap(selfArg, C.float(v))
}

func (self *PlotNextItemData) DigitalBitGap() float32 {
	selfArg, selfFin := self.handle()

	defer func() {
		selfFin()
	}()
	return float32(C.wrap_ImPlotNextItemData_GetDigitalBitGap(selfArg))
}

func (self PlotNextItemData) SetRenderLine(v bool) {
	selfArg, selfFin := self.handle()
	defer selfFin()
	C.wrap_ImPlotNextItemData_SetRenderLine(selfArg, C.bool(v))
}

func (self *PlotNextItemData) RenderLine() bool {
	selfArg, selfFin := self.handle()

	defer func() {
		selfFin()
	}()
	return C.wrap_ImPlotNextItemData_GetRenderLine(selfArg) == C.bool(true)
}

func (self PlotNextItemData) SetRenderFill(v bool) {
	selfArg, selfFin := self.handle()
	defer selfFin()
	C.wrap_ImPlotNextItemData_SetRenderFill(selfArg, C.bool(v))
}

func (self *PlotNextItemData) RenderFill() bool {
	selfArg, selfFin := self.handle()

	defer func() {
		selfFin()
	}()
	return C.wrap_ImPlotNextItemData_GetRenderFill(selfArg) == C.bool(true)
}

func (self PlotNextItemData) SetRenderMarkerLine(v bool) {
	selfArg, selfFin := self.handle()
	defer selfFin()
	C.wrap_ImPlotNextItemData_SetRenderMarkerLine(selfArg, C.bool(v))
}

func (self *PlotNextItemData) RenderMarkerLine() bool {
	selfArg, selfFin := self.handle()

	defer func() {
		selfFin()
	}()
	return C.wrap_ImPlotNextItemData_GetRenderMarkerLine(selfArg) == C.bool(true)
}

func (self PlotNextItemData) SetRenderMarkerFill(v bool) {
	selfArg, selfFin := self.handle()
	defer selfFin()
	C.wrap_ImPlotNextItemData_SetRenderMarkerFill(selfArg, C.bool(v))
}

func (self *PlotNextItemData) RenderMarkerFill() bool {
	selfArg, selfFin := self.handle()

	defer func() {
		selfFin()
	}()
	return C.wrap_ImPlotNextItemData_GetRenderMarkerFill(selfArg) == C.bool(true)
}

func (self PlotNextItemData) SetHasHidden(v bool) {
	selfArg, selfFin := self.handle()
	defer selfFin()
	C.wrap_ImPlotNextItemData_SetHasHidden(selfArg, C.bool(v))
}

func (self *PlotNextItemData) HasHidden() bool {
	selfArg, selfFin := self.handle()

	defer func() {
		selfFin()
	}()
	return C.wrap_ImPlotNextItemData_GetHasHidden(selfArg) == C.bool(true)
}

func (self PlotNextItemData) SetHidden(v bool) {
	selfArg, selfFin := self.handle()
	defer selfFin()
	C.wrap_ImPlotNextItemData_SetHidden(selfArg, C.bool(v))
}

func (self *PlotNextItemData) Hidden() bool {
	selfArg, selfFin := self.handle()

	defer func() {
		selfFin()
	}()
	return C.wrap_ImPlotNextItemData_GetHidden(selfArg) == C.bool(true)
}

func (self PlotNextItemData) SetHiddenCond(v PlotCond) {
	selfArg, selfFin := self.handle()
	defer selfFin()
	C.wrap_ImPlotNextItemData_SetHiddenCond(selfArg, C.ImPlotCond(v))
}

func (self *PlotNextItemData) HiddenCond() PlotCond {
	selfArg, selfFin := self.handle()

	defer func() {
		selfFin()
	}()
	return PlotCond(C.wrap_ImPlotNextItemData_GetHiddenCond(selfArg))
}

func (self PlotPlot) SetFlags(v PlotFlags) {
	selfArg, selfFin := self.handle()
	defer selfFin()
	C.wrap_ImPlotPlot_SetFlags(selfArg, C.ImPlotFlags(v))
}

func (self *PlotPlot) Flags() PlotFlags {
	selfArg, selfFin := self.handle()

	defer func() {
		selfFin()
	}()
	return PlotFlags(C.wrap_ImPlotPlot_GetFlags(selfArg))
}

func (self PlotPlot) SetPreviousFlags(v PlotFlags) {
	selfArg, selfFin := self.handle()
	defer selfFin()
	C.wrap_ImPlotPlot_SetPreviousFlags(selfArg, C.ImPlotFlags(v))
}

func (self *PlotPlot) PreviousFlags() PlotFlags {
	selfArg, selfFin := self.handle()

	defer func() {
		selfFin()
	}()
	return PlotFlags(C.wrap_ImPlotPlot_GetPreviousFlags(selfArg))
}

func (self PlotPlot) SetMouseTextLocation(v PlotLocation) {
	selfArg, selfFin := self.handle()
	defer selfFin()
	C.wrap_ImPlotPlot_SetMouseTextLocation(selfArg, C.ImPlotLocation(v))
}

func (self *PlotPlot) MouseTextLocation() PlotLocation {
	selfArg, selfFin := self.handle()

	defer func() {
		selfFin()
	}()
	return PlotLocation(C.wrap_ImPlotPlot_GetMouseTextLocation(selfArg))
}

func (self PlotPlot) SetMouseTextFlags(v PlotMouseTextFlags) {
	selfArg, selfFin := self.handle()
	defer selfFin()
	C.wrap_ImPlotPlot_SetMouseTextFlags(selfArg, C.ImPlotMouseTextFlags(v))
}

func (self *PlotPlot) MouseTextFlags() PlotMouseTextFlags {
	selfArg, selfFin := self.handle()

	defer func() {
		selfFin()
	}()
	return PlotMouseTextFlags(C.wrap_ImPlotPlot_GetMouseTextFlags(selfArg))
}

func (self PlotPlot) SetTextBuffer(v TextBuffer) {
	vArg, _ := v.c()

	selfArg, selfFin := self.handle()
	defer selfFin()
	C.wrap_ImPlotPlot_SetTextBuffer(selfArg, vArg)
}

func (self *PlotPlot) TextBuffer() TextBuffer {
	selfArg, selfFin := self.handle()

	defer func() {
		selfFin()
	}()

	result := C.wrap_ImPlotPlot_GetTextBuffer(selfArg)
	return *newTextBufferFromC(func() *C.ImGuiTextBuffer { result := result; return &result }())
}

func (self PlotPlot) SetItems(v PlotItemGroup) {
	vArg, _ := v.c()

	selfArg, selfFin := self.handle()
	defer selfFin()
	C.wrap_ImPlotPlot_SetItems(selfArg, vArg)
}

func (self *PlotPlot) Items() PlotItemGroup {
	selfArg, selfFin := self.handle()

	defer func() {
		selfFin()
	}()

	result := C.wrap_ImPlotPlot_GetItems(selfArg)
	return *newPlotItemGroupFromC(func() *C.ImPlotItemGroup { result := result; return &result }())
}

func (self PlotPlot) SetCurrentX(v PlotAxisEnum) {
	selfArg, selfFin := self.handle()
	defer selfFin()
	C.wrap_ImPlotPlot_SetCurrentX(selfArg, C.ImAxis(v))
}

func (self *PlotPlot) CurrentX() PlotAxisEnum {
	selfArg, selfFin := self.handle()

	defer func() {
		selfFin()
	}()
	return PlotAxisEnum(C.wrap_ImPlotPlot_GetCurrentX(selfArg))
}

func (self PlotPlot) SetCurrentY(v PlotAxisEnum) {
	selfArg, selfFin := self.handle()
	defer selfFin()
	C.wrap_ImPlotPlot_SetCurrentY(selfArg, C.ImAxis(v))
}

func (self *PlotPlot) CurrentY() PlotAxisEnum {
	selfArg, selfFin := self.handle()

	defer func() {
		selfFin()
	}()
	return PlotAxisEnum(C.wrap_ImPlotPlot_GetCurrentY(selfArg))
}

func (self PlotPlot) SetFrameRect(v Rect) {
	selfArg, selfFin := self.handle()
	defer selfFin()
	C.wrap_ImPlotPlot_SetFrameRect(selfArg, v.toC())
}

func (self *PlotPlot) FrameRect() Rect {
	selfArg, selfFin := self.handle()

	defer func() {
		selfFin()
	}()
	return *(&Rect{}).fromC(C.wrap_ImPlotPlot_GetFrameRect(selfArg))
}

func (self PlotPlot) SetCanvasRect(v Rect) {
	selfArg, selfFin := self.handle()
	defer selfFin()
	C.wrap_ImPlotPlot_SetCanvasRect(selfArg, v.toC())
}

func (self *PlotPlot) CanvasRect() Rect {
	selfArg, selfFin := self.handle()

	defer func() {
		selfFin()
	}()
	return *(&Rect{}).fromC(C.wrap_ImPlotPlot_GetCanvasRect(selfArg))
}

func (self PlotPlot) SetPlotRect(v Rect) {
	selfArg, selfFin := self.handle()
	defer selfFin()
	C.wrap_ImPlotPlot_SetPlotRect(selfArg, v.toC())
}

func (self *PlotPlot) PlotRect() Rect {
	selfArg, selfFin := self.handle()

	defer func() {
		selfFin()
	}()
	return *(&Rect{}).fromC(C.wrap_ImPlotPlot_GetPlotRect(selfArg))
}

func (self PlotPlot) SetAxesRect(v Rect) {
	selfArg, selfFin := self.handle()
	defer selfFin()
	C.wrap_ImPlotPlot_SetAxesRect(selfArg, v.toC())
}

func (self *PlotPlot) AxesRect() Rect {
	selfArg, selfFin := self.handle()

	defer func() {
		selfFin()
	}()
	return *(&Rect{}).fromC(C.wrap_ImPlotPlot_GetAxesRect(selfArg))
}

func (self PlotPlot) SetSelectRect(v Rect) {
	selfArg, selfFin := self.handle()
	defer selfFin()
	C.wrap_ImPlotPlot_SetSelectRect(selfArg, v.toC())
}

func (self *PlotPlot) SelectRect() Rect {
	selfArg, selfFin := self.handle()

	defer func() {
		selfFin()
	}()
	return *(&Rect{}).fromC(C.wrap_ImPlotPlot_GetSelectRect(selfArg))
}

func (self PlotPlot) SetSelectStart(v Vec2) {
	selfArg, selfFin := self.handle()
	defer selfFin()
	C.wrap_ImPlotPlot_SetSelectStart(selfArg, v.toC())
}

func (self *PlotPlot) SelectStart() Vec2 {
	selfArg, selfFin := self.handle()

	defer func() {
		selfFin()
	}()
	return *(&Vec2{}).fromC(C.wrap_ImPlotPlot_GetSelectStart(selfArg))
}

func (self PlotPlot) SetTitleOffset(v int32) {
	selfArg, selfFin := self.handle()
	defer selfFin()
	C.wrap_ImPlotPlot_SetTitleOffset(selfArg, C.int(v))
}

func (self *PlotPlot) TitleOffset() int32 {
	selfArg, selfFin := self.handle()

	defer func() {
		selfFin()
	}()
	return int32(C.wrap_ImPlotPlot_GetTitleOffset(selfArg))
}

func (self PlotPlot) SetJustCreated(v bool) {
	selfArg, selfFin := self.handle()
	defer selfFin()
	C.wrap_ImPlotPlot_SetJustCreated(selfArg, C.bool(v))
}

func (self *PlotPlot) JustCreated() bool {
	selfArg, selfFin := self.handle()

	defer func() {
		selfFin()
	}()
	return C.wrap_ImPlotPlot_GetJustCreated(selfArg) == C.bool(true)
}

func (self PlotPlot) SetInitialized(v bool) {
	selfArg, selfFin := self.handle()
	defer selfFin()
	C.wrap_ImPlotPlot_SetInitialized(selfArg, C.bool(v))
}

func (self *PlotPlot) Initialized() bool {
	selfArg, selfFin := self.handle()

	defer func() {
		selfFin()
	}()
	return C.wrap_ImPlotPlot_GetInitialized(selfArg) == C.bool(true)
}

func (self PlotPlot) SetSetupLocked(v bool) {
	selfArg, selfFin := self.handle()
	defer selfFin()
	C.wrap_ImPlotPlot_SetSetupLocked(selfArg, C.bool(v))
}

func (self *PlotPlot) SetupLocked() bool {
	selfArg, selfFin := self.handle()

	defer func() {
		selfFin()
	}()
	return C.wrap_ImPlotPlot_GetSetupLocked(selfArg) == C.bool(true)
}

func (self PlotPlot) SetFitThisFrame(v bool) {
	selfArg, selfFin := self.handle()
	defer selfFin()
	C.wrap_ImPlotPlot_SetFitThisFrame(selfArg, C.bool(v))
}

func (self *PlotPlot) FitThisFrame() bool {
	selfArg, selfFin := self.handle()

	defer func() {
		selfFin()
	}()
	return C.wrap_ImPlotPlot_GetFitThisFrame(selfArg) == C.bool(true)
}

func (self PlotPlot) SetHovered(v bool) {
	selfArg, selfFin := self.handle()
	defer selfFin()
	C.wrap_ImPlotPlot_SetHovered(selfArg, C.bool(v))
}

func (self *PlotPlot) Hovered() bool {
	selfArg, selfFin := self.handle()

	defer func() {
		selfFin()
	}()
	return C.wrap_ImPlotPlot_GetHovered(selfArg) == C.bool(true)
}

func (self PlotPlot) SetHeld(v bool) {
	selfArg, selfFin := self.handle()
	defer selfFin()
	C.wrap_ImPlotPlot_SetHeld(selfArg, C.bool(v))
}

func (self *PlotPlot) Held() bool {
	selfArg, selfFin := self.handle()

	defer func() {
		selfFin()
	}()
	return C.wrap_ImPlotPlot_GetHeld(selfArg) == C.bool(true)
}

func (self PlotPlot) SetSelecting(v bool) {
	selfArg, selfFin := self.handle()
	defer selfFin()
	C.wrap_ImPlotPlot_SetSelecting(selfArg, C.bool(v))
}

func (self *PlotPlot) Selecting() bool {
	selfArg, selfFin := self.handle()

	defer func() {
		selfFin()
	}()
	return C.wrap_ImPlotPlot_GetSelecting(selfArg) == C.bool(true)
}

func (self PlotPlot) SetSelected(v bool) {
	selfArg, selfFin := self.handle()
	defer selfFin()
	C.wrap_ImPlotPlot_SetSelected(selfArg, C.bool(v))
}

func (self *PlotPlot) Selected() bool {
	selfArg, selfFin := self.handle()

	defer func() {
		selfFin()
	}()
	return C.wrap_ImPlotPlot_GetSelected(selfArg) == C.bool(true)
}

func (self PlotPlot) SetContextLocked(v bool) {
	selfArg, selfFin := self.handle()
	defer selfFin()
	C.wrap_ImPlotPlot_SetContextLocked(selfArg, C.bool(v))
}

func (self *PlotPlot) ContextLocked() bool {
	selfArg, selfFin := self.handle()

	defer func() {
		selfFin()
	}()
	return C.wrap_ImPlotPlot_GetContextLocked(selfArg) == C.bool(true)
}

func (self PlotPointError) SetX(v float64) {
	selfArg, selfFin := self.handle()
	defer selfFin()
	C.wrap_ImPlotPointError_SetX(selfArg, C.double(v))
}

func (self *PlotPointError) X() float64 {
	selfArg, selfFin := self.handle()

	defer func() {
		selfFin()
	}()
	return float64(C.wrap_ImPlotPointError_GetX(selfArg))
}

func (self PlotPointError) SetY(v float64) {
	selfArg, selfFin := self.handle()
	defer selfFin()
	C.wrap_ImPlotPointError_SetY(selfArg, C.double(v))
}

func (self *PlotPointError) Y() float64 {
	selfArg, selfFin := self.handle()

	defer func() {
		selfFin()
	}()
	return float64(C.wrap_ImPlotPointError_GetY(selfArg))
}

func (self PlotPointError) SetNeg(v float64) {
	selfArg, selfFin := self.handle()
	defer selfFin()
	C.wrap_ImPlotPointError_SetNeg(selfArg, C.double(v))
}

func (self *PlotPointError) Neg() float64 {
	selfArg, selfFin := self.handle()

	defer func() {
		selfFin()
	}()
	return float64(C.wrap_ImPlotPointError_GetNeg(selfArg))
}

func (self PlotPointError) SetPos(v float64) {
	selfArg, selfFin := self.handle()
	defer selfFin()
	C.wrap_ImPlotPointError_SetPos(selfArg, C.double(v))
}

func (self *PlotPointError) Pos() float64 {
	selfArg, selfFin := self.handle()

	defer func() {
		selfFin()
	}()
	return float64(C.wrap_ImPlotPointError_GetPos(selfArg))
}

func (self PlotRange) SetMin(v float64) {
	selfArg, selfFin := self.handle()
	defer selfFin()
	C.wrap_ImPlotRange_SetMin(selfArg, C.double(v))
}

func (self *PlotRange) Min() float64 {
	selfArg, selfFin := self.handle()

	defer func() {
		selfFin()
	}()
	return float64(C.wrap_ImPlotRange_GetMin(selfArg))
}

func (self PlotRange) SetMax(v float64) {
	selfArg, selfFin := self.handle()
	defer selfFin()
	C.wrap_ImPlotRange_SetMax(selfArg, C.double(v))
}

func (self *PlotRange) Max() float64 {
	selfArg, selfFin := self.handle()

	defer func() {
		selfFin()
	}()
	return float64(C.wrap_ImPlotRange_GetMax(selfArg))
}

func (self PlotRect) SetX(v PlotRange) {
	vArg, _ := v.c()

	selfArg, selfFin := self.handle()
	defer selfFin()
	C.wrap_ImPlotRect_SetX(selfArg, vArg)
}

func (self *PlotRect) X() PlotRange {
	selfArg, selfFin := self.handle()

	defer func() {
		selfFin()
	}()

	result := C.wrap_ImPlotRect_GetX(selfArg)
	return *newPlotRangeFromC(func() *C.ImPlotRange { result := result; return &result }())
}

func (self PlotRect) SetY(v PlotRange) {
	vArg, _ := v.c()

	selfArg, selfFin := self.handle()
	defer selfFin()
	C.wrap_ImPlotRect_SetY(selfArg, vArg)
}

func (self *PlotRect) Y() PlotRange {
	selfArg, selfFin := self.handle()

	defer func() {
		selfFin()
	}()

	result := C.wrap_ImPlotRect_GetY(selfArg)
	return *newPlotRangeFromC(func() *C.ImPlotRange { result := result; return &result }())
}

func (self PlotStyle) SetLineWeight(v float32) {
	selfArg, selfFin := self.handle()
	defer selfFin()
	C.wrap_ImPlotStyle_SetLineWeight(selfArg, C.float(v))
}

func (self *PlotStyle) LineWeight() float32 {
	selfArg, selfFin := self.handle()

	defer func() {
		selfFin()
	}()
	return float32(C.wrap_ImPlotStyle_GetLineWeight(selfArg))
}

func (self PlotStyle) SetMarker(v int32) {
	selfArg, selfFin := self.handle()
	defer selfFin()
	C.wrap_ImPlotStyle_SetMarker(selfArg, C.int(v))
}

func (self *PlotStyle) Marker() int32 {
	selfArg, selfFin := self.handle()

	defer func() {
		selfFin()
	}()
	return int32(C.wrap_ImPlotStyle_GetMarker(selfArg))
}

func (self PlotStyle) SetMarkerSize(v float32) {
	selfArg, selfFin := self.handle()
	defer selfFin()
	C.wrap_ImPlotStyle_SetMarkerSize(selfArg, C.float(v))
}

func (self *PlotStyle) MarkerSize() float32 {
	selfArg, selfFin := self.handle()

	defer func() {
		selfFin()
	}()
	return float32(C.wrap_ImPlotStyle_GetMarkerSize(selfArg))
}

func (self PlotStyle) SetMarkerWeight(v float32) {
	selfArg, selfFin := self.handle()
	defer selfFin()
	C.wrap_ImPlotStyle_SetMarkerWeight(selfArg, C.float(v))
}

func (self *PlotStyle) MarkerWeight() float32 {
	selfArg, selfFin := self.handle()

	defer func() {
		selfFin()
	}()
	return float32(C.wrap_ImPlotStyle_GetMarkerWeight(selfArg))
}

func (self PlotStyle) SetFillAlpha(v float32) {
	selfArg, selfFin := self.handle()
	defer selfFin()
	C.wrap_ImPlotStyle_SetFillAlpha(selfArg, C.float(v))
}

func (self *PlotStyle) FillAlpha() float32 {
	selfArg, selfFin := self.handle()

	defer func() {
		selfFin()
	}()
	return float32(C.wrap_ImPlotStyle_GetFillAlpha(selfArg))
}

func (self PlotStyle) SetErrorBarSize(v float32) {
	selfArg, selfFin := self.handle()
	defer selfFin()
	C.wrap_ImPlotStyle_SetErrorBarSize(selfArg, C.float(v))
}

func (self *PlotStyle) ErrorBarSize() float32 {
	selfArg, selfFin := self.handle()

	defer func() {
		selfFin()
	}()
	return float32(C.wrap_ImPlotStyle_GetErrorBarSize(selfArg))
}

func (self PlotStyle) SetErrorBarWeight(v float32) {
	selfArg, selfFin := self.handle()
	defer selfFin()
	C.wrap_ImPlotStyle_SetErrorBarWeight(selfArg, C.float(v))
}

func (self *PlotStyle) ErrorBarWeight() float32 {
	selfArg, selfFin := self.handle()

	defer func() {
		selfFin()
	}()
	return float32(C.wrap_ImPlotStyle_GetErrorBarWeight(selfArg))
}

func (self PlotStyle) SetDigitalBitHeight(v float32) {
	selfArg, selfFin := self.handle()
	defer selfFin()
	C.wrap_ImPlotStyle_SetDigitalBitHeight(selfArg, C.float(v))
}

func (self *PlotStyle) DigitalBitHeight() float32 {
	selfArg, selfFin := self.handle()

	defer func() {
		selfFin()
	}()
	return float32(C.wrap_ImPlotStyle_GetDigitalBitHeight(selfArg))
}

func (self PlotStyle) SetDigitalBitGap(v float32) {
	selfArg, selfFin := self.handle()
	defer selfFin()
	C.wrap_ImPlotStyle_SetDigitalBitGap(selfArg, C.float(v))
}

func (self *PlotStyle) DigitalBitGap() float32 {
	selfArg, selfFin := self.handle()

	defer func() {
		selfFin()
	}()
	return float32(C.wrap_ImPlotStyle_GetDigitalBitGap(selfArg))
}

func (self PlotStyle) SetPlotBorderSize(v float32) {
	selfArg, selfFin := self.handle()
	defer selfFin()
	C.wrap_ImPlotStyle_SetPlotBorderSize(selfArg, C.float(v))
}

func (self *PlotStyle) PlotBorderSize() float32 {
	selfArg, selfFin := self.handle()

	defer func() {
		selfFin()
	}()
	return float32(C.wrap_ImPlotStyle_GetPlotBorderSize(selfArg))
}

func (self PlotStyle) SetMinorAlpha(v float32) {
	selfArg, selfFin := self.handle()
	defer selfFin()
	C.wrap_ImPlotStyle_SetMinorAlpha(selfArg, C.float(v))
}

func (self *PlotStyle) MinorAlpha() float32 {
	selfArg, selfFin := self.handle()

	defer func() {
		selfFin()
	}()
	return float32(C.wrap_ImPlotStyle_GetMinorAlpha(selfArg))
}

func (self PlotStyle) SetMajorTickLen(v Vec2) {
	selfArg, selfFin := self.handle()
	defer selfFin()
	C.wrap_ImPlotStyle_SetMajorTickLen(selfArg, v.toC())
}

func (self *PlotStyle) MajorTickLen() Vec2 {
	selfArg, selfFin := self.handle()

	defer func() {
		selfFin()
	}()
	return *(&Vec2{}).fromC(C.wrap_ImPlotStyle_GetMajorTickLen(selfArg))
}

func (self PlotStyle) SetMinorTickLen(v Vec2) {
	selfArg, selfFin := self.handle()
	defer selfFin()
	C.wrap_ImPlotStyle_SetMinorTickLen(selfArg, v.toC())
}

func (self *PlotStyle) MinorTickLen() Vec2 {
	selfArg, selfFin := self.handle()

	defer func() {
		selfFin()
	}()
	return *(&Vec2{}).fromC(C.wrap_ImPlotStyle_GetMinorTickLen(selfArg))
}

func (self PlotStyle) SetMajorTickSize(v Vec2) {
	selfArg, selfFin := self.handle()
	defer selfFin()
	C.wrap_ImPlotStyle_SetMajorTickSize(selfArg, v.toC())
}

func (self *PlotStyle) MajorTickSize() Vec2 {
	selfArg, selfFin := self.handle()

	defer func() {
		selfFin()
	}()
	return *(&Vec2{}).fromC(C.wrap_ImPlotStyle_GetMajorTickSize(selfArg))
}

func (self PlotStyle) SetMinorTickSize(v Vec2) {
	selfArg, selfFin := self.handle()
	defer selfFin()
	C.wrap_ImPlotStyle_SetMinorTickSize(selfArg, v.toC())
}

func (self *PlotStyle) MinorTickSize() Vec2 {
	selfArg, selfFin := self.handle()

	defer func() {
		selfFin()
	}()
	return *(&Vec2{}).fromC(C.wrap_ImPlotStyle_GetMinorTickSize(selfArg))
}

func (self PlotStyle) SetMajorGridSize(v Vec2) {
	selfArg, selfFin := self.handle()
	defer selfFin()
	C.wrap_ImPlotStyle_SetMajorGridSize(selfArg, v.toC())
}

func (self *PlotStyle) MajorGridSize() Vec2 {
	selfArg, selfFin := self.handle()

	defer func() {
		selfFin()
	}()
	return *(&Vec2{}).fromC(C.wrap_ImPlotStyle_GetMajorGridSize(selfArg))
}

func (self PlotStyle) SetMinorGridSize(v Vec2) {
	selfArg, selfFin := self.handle()
	defer selfFin()
	C.wrap_ImPlotStyle_SetMinorGridSize(selfArg, v.toC())
}

func (self *PlotStyle) MinorGridSize() Vec2 {
	selfArg, selfFin := self.handle()

	defer func() {
		selfFin()
	}()
	return *(&Vec2{}).fromC(C.wrap_ImPlotStyle_GetMinorGridSize(selfArg))
}

func (self PlotStyle) SetPlotPadding(v Vec2) {
	selfArg, selfFin := self.handle()
	defer selfFin()
	C.wrap_ImPlotStyle_SetPlotPadding(selfArg, v.toC())
}

func (self *PlotStyle) PlotPadding() Vec2 {
	selfArg, selfFin := self.handle()

	defer func() {
		selfFin()
	}()
	return *(&Vec2{}).fromC(C.wrap_ImPlotStyle_GetPlotPadding(selfArg))
}

func (self PlotStyle) SetLabelPadding(v Vec2) {
	selfArg, selfFin := self.handle()
	defer selfFin()
	C.wrap_ImPlotStyle_SetLabelPadding(selfArg, v.toC())
}

func (self *PlotStyle) LabelPadding() Vec2 {
	selfArg, selfFin := self.handle()

	defer func() {
		selfFin()
	}()
	return *(&Vec2{}).fromC(C.wrap_ImPlotStyle_GetLabelPadding(selfArg))
}

func (self PlotStyle) SetLegendPadding(v Vec2) {
	selfArg, selfFin := self.handle()
	defer selfFin()
	C.wrap_ImPlotStyle_SetLegendPadding(selfArg, v.toC())
}

func (self *PlotStyle) LegendPadding() Vec2 {
	selfArg, selfFin := self.handle()

	defer func() {
		selfFin()
	}()
	return *(&Vec2{}).fromC(C.wrap_ImPlotStyle_GetLegendPadding(selfArg))
}

func (self PlotStyle) SetLegendInnerPadding(v Vec2) {
	selfArg, selfFin := self.handle()
	defer selfFin()
	C.wrap_ImPlotStyle_SetLegendInnerPadding(selfArg, v.toC())
}

func (self *PlotStyle) LegendInnerPadding() Vec2 {
	selfArg, selfFin := self.handle()

	defer func() {
		selfFin()
	}()
	return *(&Vec2{}).fromC(C.wrap_ImPlotStyle_GetLegendInnerPadding(selfArg))
}

func (self PlotStyle) SetLegendSpacing(v Vec2) {
	selfArg, selfFin := self.handle()
	defer selfFin()
	C.wrap_ImPlotStyle_SetLegendSpacing(selfArg, v.toC())
}

func (self *PlotStyle) LegendSpacing() Vec2 {
	selfArg, selfFin := self.handle()

	defer func() {
		selfFin()
	}()
	return *(&Vec2{}).fromC(C.wrap_ImPlotStyle_GetLegendSpacing(selfArg))
}

func (self PlotStyle) SetMousePosPadding(v Vec2) {
	selfArg, selfFin := self.handle()
	defer selfFin()
	C.wrap_ImPlotStyle_SetMousePosPadding(selfArg, v.toC())
}

func (self *PlotStyle) MousePosPadding() Vec2 {
	selfArg, selfFin := self.handle()

	defer func() {
		selfFin()
	}()
	return *(&Vec2{}).fromC(C.wrap_ImPlotStyle_GetMousePosPadding(selfArg))
}

func (self PlotStyle) SetAnnotationPadding(v Vec2) {
	selfArg, selfFin := self.handle()
	defer selfFin()
	C.wrap_ImPlotStyle_SetAnnotationPadding(selfArg, v.toC())
}

func (self *PlotStyle) AnnotationPadding() Vec2 {
	selfArg, selfFin := self.handle()

	defer func() {
		selfFin()
	}()
	return *(&Vec2{}).fromC(C.wrap_ImPlotStyle_GetAnnotationPadding(selfArg))
}

func (self PlotStyle) SetFitPadding(v Vec2) {
	selfArg, selfFin := self.handle()
	defer selfFin()
	C.wrap_ImPlotStyle_SetFitPadding(selfArg, v.toC())
}

func (self *PlotStyle) FitPadding() Vec2 {
	selfArg, selfFin := self.handle()

	defer func() {
		selfFin()
	}()
	return *(&Vec2{}).fromC(C.wrap_ImPlotStyle_GetFitPadding(selfArg))
}

func (self PlotStyle) SetPlotDefaultSize(v Vec2) {
	selfArg, selfFin := self.handle()
	defer selfFin()
	C.wrap_ImPlotStyle_SetPlotDefaultSize(selfArg, v.toC())
}

func (self *PlotStyle) PlotDefaultSize() Vec2 {
	selfArg, selfFin := self.handle()

	defer func() {
		selfFin()
	}()
	return *(&Vec2{}).fromC(C.wrap_ImPlotStyle_GetPlotDefaultSize(selfArg))
}

func (self PlotStyle) SetPlotMinSize(v Vec2) {
	selfArg, selfFin := self.handle()
	defer selfFin()
	C.wrap_ImPlotStyle_SetPlotMinSize(selfArg, v.toC())
}

func (self *PlotStyle) PlotMinSize() Vec2 {
	selfArg, selfFin := self.handle()

	defer func() {
		selfFin()
	}()
	return *(&Vec2{}).fromC(C.wrap_ImPlotStyle_GetPlotMinSize(selfArg))
}

func (self PlotStyle) SetColormap(v PlotColormap) {
	selfArg, selfFin := self.handle()
	defer selfFin()
	C.wrap_ImPlotStyle_SetColormap(selfArg, C.ImPlotColormap(v))
}

func (self *PlotStyle) Colormap() PlotColormap {
	selfArg, selfFin := self.handle()

	defer func() {
		selfFin()
	}()
	return PlotColormap(C.wrap_ImPlotStyle_GetColormap(selfArg))
}

func (self PlotStyle) SetUseLocalTime(v bool) {
	selfArg, selfFin := self.handle()
	defer selfFin()
	C.wrap_ImPlotStyle_SetUseLocalTime(selfArg, C.bool(v))
}

func (self *PlotStyle) UseLocalTime() bool {
	selfArg, selfFin := self.handle()

	defer func() {
		selfFin()
	}()
	return C.wrap_ImPlotStyle_GetUseLocalTime(selfArg) == C.bool(true)
}

func (self PlotStyle) SetUseISO8601(v bool) {
	selfArg, selfFin := self.handle()
	defer selfFin()
	C.wrap_ImPlotStyle_SetUseISO8601(selfArg, C.bool(v))
}

func (self *PlotStyle) UseISO8601() bool {
	selfArg, selfFin := self.handle()

	defer func() {
		selfFin()
	}()
	return C.wrap_ImPlotStyle_GetUseISO8601(selfArg) == C.bool(true)
}

func (self PlotStyle) SetUse24HourClock(v bool) {
	selfArg, selfFin := self.handle()
	defer selfFin()
	C.wrap_ImPlotStyle_SetUse24HourClock(selfArg, C.bool(v))
}

func (self *PlotStyle) Use24HourClock() bool {
	selfArg, selfFin := self.handle()

	defer func() {
		selfFin()
	}()
	return C.wrap_ImPlotStyle_GetUse24HourClock(selfArg) == C.bool(true)
}

func (self PlotSubplot) SetFlags(v PlotSubplotFlags) {
	selfArg, selfFin := self.handle()
	defer selfFin()
	C.wrap_ImPlotSubplot_SetFlags(selfArg, C.ImPlotSubplotFlags(v))
}

func (self *PlotSubplot) Flags() PlotSubplotFlags {
	selfArg, selfFin := self.handle()

	defer func() {
		selfFin()
	}()
	return PlotSubplotFlags(C.wrap_ImPlotSubplot_GetFlags(selfArg))
}

func (self PlotSubplot) SetPreviousFlags(v PlotSubplotFlags) {
	selfArg, selfFin := self.handle()
	defer selfFin()
	C.wrap_ImPlotSubplot_SetPreviousFlags(selfArg, C.ImPlotSubplotFlags(v))
}

func (self *PlotSubplot) PreviousFlags() PlotSubplotFlags {
	selfArg, selfFin := self.handle()

	defer func() {
		selfFin()
	}()
	return PlotSubplotFlags(C.wrap_ImPlotSubplot_GetPreviousFlags(selfArg))
}

func (self PlotSubplot) SetItems(v PlotItemGroup) {
	vArg, _ := v.c()

	selfArg, selfFin := self.handle()
	defer selfFin()
	C.wrap_ImPlotSubplot_SetItems(selfArg, vArg)
}

func (self *PlotSubplot) Items() PlotItemGroup {
	selfArg, selfFin := self.handle()

	defer func() {
		selfFin()
	}()

	result := C.wrap_ImPlotSubplot_GetItems(selfArg)
	return *newPlotItemGroupFromC(func() *C.ImPlotItemGroup { result := result; return &result }())
}

func (self PlotSubplot) SetRows(v int32) {
	selfArg, selfFin := self.handle()
	defer selfFin()
	C.wrap_ImPlotSubplot_SetRows(selfArg, C.int(v))
}

func (self *PlotSubplot) Rows() int32 {
	selfArg, selfFin := self.handle()

	defer func() {
		selfFin()
	}()
	return int32(C.wrap_ImPlotSubplot_GetRows(selfArg))
}

func (self PlotSubplot) SetCols(v int32) {
	selfArg, selfFin := self.handle()
	defer selfFin()
	C.wrap_ImPlotSubplot_SetCols(selfArg, C.int(v))
}

func (self *PlotSubplot) Cols() int32 {
	selfArg, selfFin := self.handle()

	defer func() {
		selfFin()
	}()
	return int32(C.wrap_ImPlotSubplot_GetCols(selfArg))
}

func (self PlotSubplot) SetCurrentIdx(v int32) {
	selfArg, selfFin := self.handle()
	defer selfFin()
	C.wrap_ImPlotSubplot_SetCurrentIdx(selfArg, C.int(v))
}

func (self *PlotSubplot) CurrentIdx() int32 {
	selfArg, selfFin := self.handle()

	defer func() {
		selfFin()
	}()
	return int32(C.wrap_ImPlotSubplot_GetCurrentIdx(selfArg))
}

func (self PlotSubplot) SetFrameRect(v Rect) {
	selfArg, selfFin := self.handle()
	defer selfFin()
	C.wrap_ImPlotSubplot_SetFrameRect(selfArg, v.toC())
}

func (self *PlotSubplot) FrameRect() Rect {
	selfArg, selfFin := self.handle()

	defer func() {
		selfFin()
	}()
	return *(&Rect{}).fromC(C.wrap_ImPlotSubplot_GetFrameRect(selfArg))
}

func (self PlotSubplot) SetGridRect(v Rect) {
	selfArg, selfFin := self.handle()
	defer selfFin()
	C.wrap_ImPlotSubplot_SetGridRect(selfArg, v.toC())
}

func (self *PlotSubplot) GridRect() Rect {
	selfArg, selfFin := self.handle()

	defer func() {
		selfFin()
	}()
	return *(&Rect{}).fromC(C.wrap_ImPlotSubplot_GetGridRect(selfArg))
}

func (self PlotSubplot) SetCellSize(v Vec2) {
	selfArg, selfFin := self.handle()
	defer selfFin()
	C.wrap_ImPlotSubplot_SetCellSize(selfArg, v.toC())
}

func (self *PlotSubplot) CellSize() Vec2 {
	selfArg, selfFin := self.handle()

	defer func() {
		selfFin()
	}()
	return *(&Vec2{}).fromC(C.wrap_ImPlotSubplot_GetCellSize(selfArg))
}

func (self PlotSubplot) SetRowAlignmentData(v Vector[*PlotAlignmentData]) {
	vData := v.Data
	vDataArg, _ := vData.handle()
	vVecArg := new(C.ImVector_ImPlotAlignmentData)
	vVecArg.Size = C.int(v.Size)
	vVecArg.Capacity = C.int(v.Capacity)
	vVecArg.Data = vDataArg
	v.pinner.Pin(vVecArg.Data)

	selfArg, selfFin := self.handle()
	defer selfFin()
	C.wrap_ImPlotSubplot_SetRowAlignmentData(selfArg, *vVecArg)
}

func (self *PlotSubplot) RowAlignmentData() Vector[*PlotAlignmentData] {
	selfArg, selfFin := self.handle()

	defer func() {
		selfFin()
	}()
	return newVectorFromC(C.wrap_ImPlotSubplot_GetRowAlignmentData(selfArg).Size, C.wrap_ImPlotSubplot_GetRowAlignmentData(selfArg).Capacity, newPlotAlignmentDataFromC(C.wrap_ImPlotSubplot_GetRowAlignmentData(selfArg).Data))
}

func (self PlotSubplot) SetColAlignmentData(v Vector[*PlotAlignmentData]) {
	vData := v.Data
	vDataArg, _ := vData.handle()
	vVecArg := new(C.ImVector_ImPlotAlignmentData)
	vVecArg.Size = C.int(v.Size)
	vVecArg.Capacity = C.int(v.Capacity)
	vVecArg.Data = vDataArg
	v.pinner.Pin(vVecArg.Data)

	selfArg, selfFin := self.handle()
	defer selfFin()
	C.wrap_ImPlotSubplot_SetColAlignmentData(selfArg, *vVecArg)
}

func (self *PlotSubplot) ColAlignmentData() Vector[*PlotAlignmentData] {
	selfArg, selfFin := self.handle()

	defer func() {
		selfFin()
	}()
	return newVectorFromC(C.wrap_ImPlotSubplot_GetColAlignmentData(selfArg).Size, C.wrap_ImPlotSubplot_GetColAlignmentData(selfArg).Capacity, newPlotAlignmentDataFromC(C.wrap_ImPlotSubplot_GetColAlignmentData(selfArg).Data))
}

func (self PlotSubplot) SetRowRatios(v Vector[*float32]) {
	vData := v.Data
	vDataArg, _ := WrapNumberPtr[C.float, float32](vData)
	vVecArg := new(C.ImVector_float)
	vVecArg.Size = C.int(v.Size)
	vVecArg.Capacity = C.int(v.Capacity)
	vVecArg.Data = vDataArg
	v.pinner.Pin(vVecArg.Data)

	selfArg, selfFin := self.handle()
	defer selfFin()
	C.wrap_ImPlotSubplot_SetRowRatios(selfArg, *vVecArg)
}

func (self *PlotSubplot) RowRatios() Vector[*float32] {
	selfArg, selfFin := self.handle()

	defer func() {
		selfFin()
	}()
	return newVectorFromC(C.wrap_ImPlotSubplot_GetRowRatios(selfArg).Size, C.wrap_ImPlotSubplot_GetRowRatios(selfArg).Capacity, (*float32)(C.wrap_ImPlotSubplot_GetRowRatios(selfArg).Data))
}

func (self PlotSubplot) SetColRatios(v Vector[*float32]) {
	vData := v.Data
	vDataArg, _ := WrapNumberPtr[C.float, float32](vData)
	vVecArg := new(C.ImVector_float)
	vVecArg.Size = C.int(v.Size)
	vVecArg.Capacity = C.int(v.Capacity)
	vVecArg.Data = vDataArg
	v.pinner.Pin(vVecArg.Data)

	selfArg, selfFin := self.handle()
	defer selfFin()
	C.wrap_ImPlotSubplot_SetColRatios(selfArg, *vVecArg)
}

func (self *PlotSubplot) ColRatios() Vector[*float32] {
	selfArg, selfFin := self.handle()

	defer func() {
		selfFin()
	}()
	return newVectorFromC(C.wrap_ImPlotSubplot_GetColRatios(selfArg).Size, C.wrap_ImPlotSubplot_GetColRatios(selfArg).Capacity, (*float32)(C.wrap_ImPlotSubplot_GetColRatios(selfArg).Data))
}

func (self PlotSubplot) SetRowLinkData(v Vector[*PlotRange]) {
	vData := v.Data
	vDataArg, _ := vData.handle()
	vVecArg := new(C.ImVector_ImPlotRange)
	vVecArg.Size = C.int(v.Size)
	vVecArg.Capacity = C.int(v.Capacity)
	vVecArg.Data = vDataArg
	v.pinner.Pin(vVecArg.Data)

	selfArg, selfFin := self.handle()
	defer selfFin()
	C.wrap_ImPlotSubplot_SetRowLinkData(selfArg, *vVecArg)
}

func (self *PlotSubplot) RowLinkData() Vector[*PlotRange] {
	selfArg, selfFin := self.handle()

	defer func() {
		selfFin()
	}()
	return newVectorFromC(C.wrap_ImPlotSubplot_GetRowLinkData(selfArg).Size, C.wrap_ImPlotSubplot_GetRowLinkData(selfArg).Capacity, newPlotRangeFromC(C.wrap_ImPlotSubplot_GetRowLinkData(selfArg).Data))
}

func (self PlotSubplot) SetColLinkData(v Vector[*PlotRange]) {
	vData := v.Data
	vDataArg, _ := vData.handle()
	vVecArg := new(C.ImVector_ImPlotRange)
	vVecArg.Size = C.int(v.Size)
	vVecArg.Capacity = C.int(v.Capacity)
	vVecArg.Data = vDataArg
	v.pinner.Pin(vVecArg.Data)

	selfArg, selfFin := self.handle()
	defer selfFin()
	C.wrap_ImPlotSubplot_SetColLinkData(selfArg, *vVecArg)
}

func (self *PlotSubplot) ColLinkData() Vector[*PlotRange] {
	selfArg, selfFin := self.handle()

	defer func() {
		selfFin()
	}()
	return newVectorFromC(C.wrap_ImPlotSubplot_GetColLinkData(selfArg).Size, C.wrap_ImPlotSubplot_GetColLinkData(selfArg).Capacity, newPlotRangeFromC(C.wrap_ImPlotSubplot_GetColLinkData(selfArg).Data))
}

func (self PlotSubplot) SetTempSizes(v *[2]float32) {
	vArg := make([]C.float, len(v))
	for i, vV := range v {
		vArg[i] = C.float(vV)
	}

	selfArg, selfFin := self.handle()
	defer selfFin()
	C.wrap_ImPlotSubplot_SetTempSizes(selfArg, (*C.float)(&vArg[0]))
}

func (self PlotSubplot) SetFrameHovered(v bool) {
	selfArg, selfFin := self.handle()
	defer selfFin()
	C.wrap_ImPlotSubplot_SetFrameHovered(selfArg, C.bool(v))
}

func (self *PlotSubplot) FrameHovered() bool {
	selfArg, selfFin := self.handle()

	defer func() {
		selfFin()
	}()
	return C.wrap_ImPlotSubplot_GetFrameHovered(selfArg) == C.bool(true)
}

func (self PlotSubplot) SetHasTitle(v bool) {
	selfArg, selfFin := self.handle()
	defer selfFin()
	C.wrap_ImPlotSubplot_SetHasTitle(selfArg, C.bool(v))
}

func (self *PlotSubplot) HasTitle() bool {
	selfArg, selfFin := self.handle()

	defer func() {
		selfFin()
	}()
	return C.wrap_ImPlotSubplot_GetHasTitle(selfArg) == C.bool(true)
}

func (self PlotTag) SetAxis(v PlotAxisEnum) {
	selfArg, selfFin := self.handle()
	defer selfFin()
	C.wrap_ImPlotTag_SetAxis(selfArg, C.ImAxis(v))
}

func (self *PlotTag) Axis() PlotAxisEnum {
	selfArg, selfFin := self.handle()

	defer func() {
		selfFin()
	}()
	return PlotAxisEnum(C.wrap_ImPlotTag_GetAxis(selfArg))
}

func (self PlotTag) SetValue(v float64) {
	selfArg, selfFin := self.handle()
	defer selfFin()
	C.wrap_ImPlotTag_SetValue(selfArg, C.double(v))
}

func (self *PlotTag) Value() float64 {
	selfArg, selfFin := self.handle()

	defer func() {
		selfFin()
	}()
	return float64(C.wrap_ImPlotTag_GetValue(selfArg))
}

func (self PlotTag) SetColorBg(v uint32) {
	selfArg, selfFin := self.handle()
	defer selfFin()
	C.wrap_ImPlotTag_SetColorBg(selfArg, C.ImU32(v))
}

func (self *PlotTag) ColorBg() uint32 {
	selfArg, selfFin := self.handle()

	defer func() {
		selfFin()
	}()
	return uint32(C.wrap_ImPlotTag_GetColorBg(selfArg))
}

func (self PlotTag) SetColorFg(v uint32) {
	selfArg, selfFin := self.handle()
	defer selfFin()
	C.wrap_ImPlotTag_SetColorFg(selfArg, C.ImU32(v))
}

func (self *PlotTag) ColorFg() uint32 {
	selfArg, selfFin := self.handle()

	defer func() {
		selfFin()
	}()
	return uint32(C.wrap_ImPlotTag_GetColorFg(selfArg))
}

func (self PlotTag) SetTextOffset(v int32) {
	selfArg, selfFin := self.handle()
	defer selfFin()
	C.wrap_ImPlotTag_SetTextOffset(selfArg, C.int(v))
}

func (self *PlotTag) TextOffset() int32 {
	selfArg, selfFin := self.handle()

	defer func() {
		selfFin()
	}()
	return int32(C.wrap_ImPlotTag_GetTextOffset(selfArg))
}

func (self PlotTagCollection) SetTags(v Vector[*PlotTag]) {
	vData := v.Data
	vDataArg, _ := vData.handle()
	vVecArg := new(C.ImVector_ImPlotTag)
	vVecArg.Size = C.int(v.Size)
	vVecArg.Capacity = C.int(v.Capacity)
	vVecArg.Data = vDataArg
	v.pinner.Pin(vVecArg.Data)

	selfArg, selfFin := self.handle()
	defer selfFin()
	C.wrap_ImPlotTagCollection_SetTags(selfArg, *vVecArg)
}

func (self *PlotTagCollection) Tags() Vector[*PlotTag] {
	selfArg, selfFin := self.handle()

	defer func() {
		selfFin()
	}()
	return newVectorFromC(C.wrap_ImPlotTagCollection_GetTags(selfArg).Size, C.wrap_ImPlotTagCollection_GetTags(selfArg).Capacity, newPlotTagFromC(C.wrap_ImPlotTagCollection_GetTags(selfArg).Data))
}

func (self PlotTagCollection) SetTextBuffer(v TextBuffer) {
	vArg, _ := v.c()

	selfArg, selfFin := self.handle()
	defer selfFin()
	C.wrap_ImPlotTagCollection_SetTextBuffer(selfArg, vArg)
}

func (self *PlotTagCollection) TextBuffer() TextBuffer {
	selfArg, selfFin := self.handle()

	defer func() {
		selfFin()
	}()

	result := C.wrap_ImPlotTagCollection_GetTextBuffer(selfArg)
	return *newTextBufferFromC(func() *C.ImGuiTextBuffer { result := result; return &result }())
}

func (self PlotTagCollection) SetSize(v int32) {
	selfArg, selfFin := self.handle()
	defer selfFin()
	C.wrap_ImPlotTagCollection_SetSize(selfArg, C.int(v))
}

func (self *PlotTagCollection) Size() int32 {
	selfArg, selfFin := self.handle()

	defer func() {
		selfFin()
	}()
	return int32(C.wrap_ImPlotTagCollection_GetSize(selfArg))
}

func (self PlotTick) SetPlotPos(v float64) {
	selfArg, selfFin := self.handle()
	defer selfFin()
	C.wrap_ImPlotTick_SetPlotPos(selfArg, C.double(v))
}

func (self *PlotTick) PlotPos() float64 {
	selfArg, selfFin := self.handle()

	defer func() {
		selfFin()
	}()
	return float64(C.wrap_ImPlotTick_GetPlotPos(selfArg))
}

func (self PlotTick) SetPixelPos(v float32) {
	selfArg, selfFin := self.handle()
	defer selfFin()
	C.wrap_ImPlotTick_SetPixelPos(selfArg, C.float(v))
}

func (self *PlotTick) PixelPos() float32 {
	selfArg, selfFin := self.handle()

	defer func() {
		selfFin()
	}()
	return float32(C.wrap_ImPlotTick_GetPixelPos(selfArg))
}

func (self PlotTick) SetLabelSize(v Vec2) {
	selfArg, selfFin := self.handle()
	defer selfFin()
	C.wrap_ImPlotTick_SetLabelSize(selfArg, v.toC())
}

func (self *PlotTick) LabelSize() Vec2 {
	selfArg, selfFin := self.handle()

	defer func() {
		selfFin()
	}()
	return *(&Vec2{}).fromC(C.wrap_ImPlotTick_GetLabelSize(selfArg))
}

func (self PlotTick) SetTextOffset(v int32) {
	selfArg, selfFin := self.handle()
	defer selfFin()
	C.wrap_ImPlotTick_SetTextOffset(selfArg, C.int(v))
}

func (self *PlotTick) TextOffset() int32 {
	selfArg, selfFin := self.handle()

	defer func() {
		selfFin()
	}()
	return int32(C.wrap_ImPlotTick_GetTextOffset(selfArg))
}

func (self PlotTick) SetMajor(v bool) {
	selfArg, selfFin := self.handle()
	defer selfFin()
	C.wrap_ImPlotTick_SetMajor(selfArg, C.bool(v))
}

func (self *PlotTick) Major() bool {
	selfArg, selfFin := self.handle()

	defer func() {
		selfFin()
	}()
	return C.wrap_ImPlotTick_GetMajor(selfArg) == C.bool(true)
}

func (self PlotTick) SetShowLabel(v bool) {
	selfArg, selfFin := self.handle()
	defer selfFin()
	C.wrap_ImPlotTick_SetShowLabel(selfArg, C.bool(v))
}

func (self *PlotTick) ShowLabel() bool {
	selfArg, selfFin := self.handle()

	defer func() {
		selfFin()
	}()
	return C.wrap_ImPlotTick_GetShowLabel(selfArg) == C.bool(true)
}

func (self PlotTick) SetLevel(v int32) {
	selfArg, selfFin := self.handle()
	defer selfFin()
	C.wrap_ImPlotTick_SetLevel(selfArg, C.int(v))
}

func (self *PlotTick) Level() int32 {
	selfArg, selfFin := self.handle()

	defer func() {
		selfFin()
	}()
	return int32(C.wrap_ImPlotTick_GetLevel(selfArg))
}

func (self PlotTick) SetIdx(v int32) {
	selfArg, selfFin := self.handle()
	defer selfFin()
	C.wrap_ImPlotTick_SetIdx(selfArg, C.int(v))
}

func (self *PlotTick) Idx() int32 {
	selfArg, selfFin := self.handle()

	defer func() {
		selfFin()
	}()
	return int32(C.wrap_ImPlotTick_GetIdx(selfArg))
}

func (self PlotTicker) SetTicks(v Vector[*PlotTick]) {
	vData := v.Data
	vDataArg, _ := vData.handle()
	vVecArg := new(C.ImVector_ImPlotTick)
	vVecArg.Size = C.int(v.Size)
	vVecArg.Capacity = C.int(v.Capacity)
	vVecArg.Data = vDataArg
	v.pinner.Pin(vVecArg.Data)

	selfArg, selfFin := self.handle()
	defer selfFin()
	C.wrap_ImPlotTicker_SetTicks(selfArg, *vVecArg)
}

func (self *PlotTicker) Ticks() Vector[*PlotTick] {
	selfArg, selfFin := self.handle()

	defer func() {
		selfFin()
	}()
	return newVectorFromC(C.wrap_ImPlotTicker_GetTicks(selfArg).Size, C.wrap_ImPlotTicker_GetTicks(selfArg).Capacity, newPlotTickFromC(C.wrap_ImPlotTicker_GetTicks(selfArg).Data))
}

func (self PlotTicker) SetTextBuffer(v TextBuffer) {
	vArg, _ := v.c()

	selfArg, selfFin := self.handle()
	defer selfFin()
	C.wrap_ImPlotTicker_SetTextBuffer(selfArg, vArg)
}

func (self *PlotTicker) TextBuffer() TextBuffer {
	selfArg, selfFin := self.handle()

	defer func() {
		selfFin()
	}()

	result := C.wrap_ImPlotTicker_GetTextBuffer(selfArg)
	return *newTextBufferFromC(func() *C.ImGuiTextBuffer { result := result; return &result }())
}

func (self PlotTicker) SetMaxSize(v Vec2) {
	selfArg, selfFin := self.handle()
	defer selfFin()
	C.wrap_ImPlotTicker_SetMaxSize(selfArg, v.toC())
}

func (self *PlotTicker) MaxSize() Vec2 {
	selfArg, selfFin := self.handle()

	defer func() {
		selfFin()
	}()
	return *(&Vec2{}).fromC(C.wrap_ImPlotTicker_GetMaxSize(selfArg))
}

func (self PlotTicker) SetLateSize(v Vec2) {
	selfArg, selfFin := self.handle()
	defer selfFin()
	C.wrap_ImPlotTicker_SetLateSize(selfArg, v.toC())
}

func (self *PlotTicker) LateSize() Vec2 {
	selfArg, selfFin := self.handle()

	defer func() {
		selfFin()
	}()
	return *(&Vec2{}).fromC(C.wrap_ImPlotTicker_GetLateSize(selfArg))
}

func (self PlotTicker) SetLevels(v int32) {
	selfArg, selfFin := self.handle()
	defer selfFin()
	C.wrap_ImPlotTicker_SetLevels(selfArg, C.int(v))
}

func (self *PlotTicker) Levels() int32 {
	selfArg, selfFin := self.handle()

	defer func() {
		selfFin()
	}()
	return int32(C.wrap_ImPlotTicker_GetLevels(selfArg))
}

func (self *PlotTime) Us() int32 {
	selfArg, selfFin := wrap[C.ImPlotTime, *PlotTime](self)

	defer func() {
		selfFin()
	}()
	return int32(C.wrap_ImPlotTime_GetUs(selfArg))
}
