// Code generated by cmd/codegen from https://github.com/AllenDang/cimgui-go.
// DO NOT EDIT.

package imgui

// #include <stdlib.h>
// #include <memory.h>
// #include "extra_types.h"
// #include "cimgui_wrapper.h"
import "C"
import "unsafe"

// Helper: ImBitVector
// Store 1-bit per value.
type BitVector struct {
	FieldStorage Vector[*uint32]
}

func (self BitVector) handle() (result *C.ImBitVector, releaseFn func()) {
	result = new(C.ImBitVector)
	FieldStorage := self.FieldStorage
	FieldStorageData := FieldStorage.Data
	FieldStorageDataArg, FieldStorageDataFin := WrapNumberPtr[C.ImU32, uint32](FieldStorageData)
	FieldStorageVecArg := new(C.ImVector_ImU32)
	FieldStorageVecArg.Size = C.int(FieldStorage.Size)
	FieldStorageVecArg.Capacity = C.int(FieldStorage.Capacity)
	FieldStorageVecArg.Data = FieldStorageDataArg
	FieldStorage.pinner.Pin(FieldStorageVecArg.Data)

	result.Storage = *FieldStorageVecArg
	releaseFn = func() {
		FieldStorageDataFin()
		FieldStorage.pinner.Unpin()
	}
	return result, releaseFn
}

func (self BitVector) c() (result C.ImBitVector, fin func()) {
	resultPtr, finFn := self.handle()
	return *resultPtr, finFn
}

func newBitVectorFromC(cvalue *C.ImBitVector) *BitVector {
	result := new(BitVector)
	result.FieldStorage = newVectorFromC(cvalue.Storage.Size, cvalue.Storage.Capacity, (*uint32)(cvalue.Storage.Data))
	return result
}

// [Internal] For use by ImDrawListSplitter
type DrawChannel struct {
	// TODO: contains unsupported fields
	data unsafe.Pointer
}

func (self DrawChannel) handle() (result *C.ImDrawChannel, releaseFn func()) {
	result = (*C.ImDrawChannel)(self.data)
	return result, func() {}
}

func (self DrawChannel) c() (result C.ImDrawChannel, fin func()) {
	resultPtr, finFn := self.handle()
	return *resultPtr, finFn
}

func newDrawChannelFromC(cvalue *C.ImDrawChannel) *DrawChannel {
	result := new(DrawChannel)
	result.data = unsafe.Pointer(cvalue)
	return result
}

// Typically, 1 command = 1 GPU draw call (unless command is a callback)
//   - VtxOffset: When 'io.BackendFlags & ImGuiBackendFlags_RendererHasVtxOffset' is enabled,
//     this fields allow us to render meshes larger than 64K vertices while keeping 16-bit indices.
//     Backends made for <1.71. will typically ignore the VtxOffset fields.
//   - The ClipRect/TextureId/VtxOffset fields must be contiguous as we memcmp() them together (this is asserted for).
type DrawCmd struct {
	// TODO: contains unsupported fields
	data unsafe.Pointer
}

func (self DrawCmd) handle() (result *C.ImDrawCmd, releaseFn func()) {
	result = (*C.ImDrawCmd)(self.data)
	return result, func() {}
}

func (self DrawCmd) c() (result C.ImDrawCmd, fin func()) {
	resultPtr, finFn := self.handle()
	return *resultPtr, finFn
}

func newDrawCmdFromC(cvalue *C.ImDrawCmd) *DrawCmd {
	result := new(DrawCmd)
	result.data = unsafe.Pointer(cvalue)
	return result
}

// [Internal] For use by ImDrawList
type DrawCmdHeader struct {
	// TODO: contains unsupported fields
	data unsafe.Pointer
}

func (self DrawCmdHeader) handle() (result *C.ImDrawCmdHeader, releaseFn func()) {
	result = (*C.ImDrawCmdHeader)(self.data)
	return result, func() {}
}

func (self DrawCmdHeader) c() (result C.ImDrawCmdHeader, fin func()) {
	resultPtr, finFn := self.handle()
	return *resultPtr, finFn
}

func newDrawCmdHeaderFromC(cvalue *C.ImDrawCmdHeader) *DrawCmdHeader {
	result := new(DrawCmdHeader)
	result.data = unsafe.Pointer(cvalue)
	return result
}

// All draw data to render a Dear ImGui frame
// (NB: the style and the naming convention here is a little inconsistent, we currently preserve them for backward compatibility purpose,
// as this is one of the oldest structure exposed by the library! Basically, ImDrawList == CmdList)
type DrawData struct {
	// TODO: contains unsupported fields
	data unsafe.Pointer
}

func (self DrawData) handle() (result *C.ImDrawData, releaseFn func()) {
	result = (*C.ImDrawData)(self.data)
	return result, func() {}
}

func (self DrawData) c() (result C.ImDrawData, fin func()) {
	resultPtr, finFn := self.handle()
	return *resultPtr, finFn
}

func newDrawDataFromC(cvalue *C.ImDrawData) *DrawData {
	result := new(DrawData)
	result.data = unsafe.Pointer(cvalue)
	return result
}

type DrawDataBuilder struct {
	// TODO: contains unsupported fields
	data unsafe.Pointer
}

func (self DrawDataBuilder) handle() (result *C.ImDrawDataBuilder, releaseFn func()) {
	result = (*C.ImDrawDataBuilder)(self.data)
	return result, func() {}
}

func (self DrawDataBuilder) c() (result C.ImDrawDataBuilder, fin func()) {
	resultPtr, finFn := self.handle()
	return *resultPtr, finFn
}

func newDrawDataBuilderFromC(cvalue *C.ImDrawDataBuilder) *DrawDataBuilder {
	result := new(DrawDataBuilder)
	result.data = unsafe.Pointer(cvalue)
	return result
}

// Draw command list
// This is the low-level list of polygons that ImGui:: functions are filling. At the end of the frame,
// all command lists are passed to your ImGuiIO::RenderDrawListFn function for rendering.
// Each dear imgui window contains its own ImDrawList. You can use ImGui::GetWindowDrawList() to
// access the current window draw list and draw custom primitives.
// You can interleave normal ImGui:: calls and adding primitives to the current draw list.
// In single viewport mode, top-left is == GetMainViewport()->Pos (generally 0,0), bottom-right is == GetMainViewport()->Pos+Size (generally io.DisplaySize).
// You are totally free to apply whatever transformation matrix to want to the data (depending on the use of the transformation you may want to apply it to ClipRect as well!)
// Important: Primitives are always added to the list and not culled (culling is done at higher-level by ImGui:: functions), if you use this API a lot consider coarse culling your drawn objects.
type DrawList struct {
	// TODO: contains unsupported fields
	data unsafe.Pointer
}

func (self DrawList) handle() (result *C.ImDrawList, releaseFn func()) {
	result = (*C.ImDrawList)(self.data)
	return result, func() {}
}

func (self DrawList) c() (result C.ImDrawList, fin func()) {
	resultPtr, finFn := self.handle()
	return *resultPtr, finFn
}

func newDrawListFromC(cvalue *C.ImDrawList) *DrawList {
	result := new(DrawList)
	result.data = unsafe.Pointer(cvalue)
	return result
}

// Data shared between all ImDrawList instances
// You may want to create your own instance of this if you want to use ImDrawList completely without ImGui. In that case, watch out for future changes to this structure.
type DrawListSharedData struct {
	// TODO: contains unsupported fields
	data unsafe.Pointer
}

func (self DrawListSharedData) handle() (result *C.ImDrawListSharedData, releaseFn func()) {
	result = (*C.ImDrawListSharedData)(self.data)
	return result, func() {}
}

func (self DrawListSharedData) c() (result C.ImDrawListSharedData, fin func()) {
	resultPtr, finFn := self.handle()
	return *resultPtr, finFn
}

func newDrawListSharedDataFromC(cvalue *C.ImDrawListSharedData) *DrawListSharedData {
	result := new(DrawListSharedData)
	result.data = unsafe.Pointer(cvalue)
	return result
}

// Split/Merge functions are used to split the draw list into different layers which can be drawn into out of order.
// This is used by the Columns/Tables API, so items of each column can be batched together in a same draw call.
type DrawListSplitter struct {
	FieldCurrent  int32                // Current channel number (0)
	FieldCount    int32                // Number of active channels (1+)
	FieldChannels Vector[*DrawChannel] // Draw channels (not resized down so _Count might be < Channels.Size)
}

func (self DrawListSplitter) handle() (result *C.ImDrawListSplitter, releaseFn func()) {
	result = new(C.ImDrawListSplitter)
	FieldCurrent := self.FieldCurrent

	result._Current = C.int(FieldCurrent)
	FieldCount := self.FieldCount

	result._Count = C.int(FieldCount)
	FieldChannels := self.FieldChannels
	FieldChannelsData := FieldChannels.Data
	FieldChannelsDataArg, FieldChannelsDataFin := FieldChannelsData.handle()
	FieldChannelsVecArg := new(C.ImVector_ImDrawChannel)
	FieldChannelsVecArg.Size = C.int(FieldChannels.Size)
	FieldChannelsVecArg.Capacity = C.int(FieldChannels.Capacity)
	FieldChannelsVecArg.Data = FieldChannelsDataArg
	FieldChannels.pinner.Pin(FieldChannelsVecArg.Data)

	result._Channels = *FieldChannelsVecArg
	releaseFn = func() {
		FieldChannelsDataFin()
		FieldChannels.pinner.Unpin()
	}
	return result, releaseFn
}

func (self DrawListSplitter) c() (result C.ImDrawListSplitter, fin func()) {
	resultPtr, finFn := self.handle()
	return *resultPtr, finFn
}

func newDrawListSplitterFromC(cvalue *C.ImDrawListSplitter) *DrawListSplitter {
	result := new(DrawListSplitter)
	result.FieldCurrent = int32(cvalue._Current)
	result.FieldCount = int32(cvalue._Count)
	result.FieldChannels = newVectorFromC(cvalue._Channels.Size, cvalue._Channels.Capacity, newDrawChannelFromC(cvalue._Channels.Data))
	return result
}

type DrawVert struct {
	FieldPos Vec2
	FieldUv  Vec2
	FieldCol uint32
}

func (self DrawVert) handle() (result *C.ImDrawVert, releaseFn func()) {
	result = new(C.ImDrawVert)
	FieldPos := self.FieldPos

	result.pos = FieldPos.toC()
	FieldUv := self.FieldUv

	result.uv = FieldUv.toC()
	FieldCol := self.FieldCol

	result.col = C.ImU32(FieldCol)
	releaseFn = func() {
	}
	return result, releaseFn
}

func (self DrawVert) c() (result C.ImDrawVert, fin func()) {
	resultPtr, finFn := self.handle()
	return *resultPtr, finFn
}

func newDrawVertFromC(cvalue *C.ImDrawVert) *DrawVert {
	result := new(DrawVert)
	result.FieldPos = *(&Vec2{}).fromC(cvalue.pos)
	result.FieldUv = *(&Vec2{}).fromC(cvalue.uv)
	result.FieldCol = uint32(cvalue.col)
	return result
}

// Font runtime data and rendering
// ImFontAtlas automatically loads a default embedded font for you when you call GetTexDataAsAlpha8() or GetTexDataAsRGBA32().
type Font struct {
	// TODO: contains unsupported fields
	data unsafe.Pointer
}

func (self Font) handle() (result *C.ImFont, releaseFn func()) {
	result = (*C.ImFont)(self.data)
	return result, func() {}
}

func (self Font) c() (result C.ImFont, fin func()) {
	resultPtr, finFn := self.handle()
	return *resultPtr, finFn
}

func newFontFromC(cvalue *C.ImFont) *Font {
	result := new(Font)
	result.data = unsafe.Pointer(cvalue)
	return result
}

// Load and rasterize multiple TTF/OTF fonts into a same texture. The font atlas will build a single texture holding:
//   - One or more fonts.
//   - Custom graphics data needed to render the shapes needed by Dear ImGui.
//   - Mouse cursor shapes for software cursor rendering (unless setting 'Flags |= ImFontAtlasFlags_NoMouseCursors' in the font atlas).
//
// It is the user-code responsibility to setup/build the atlas, then upload the pixel data into a texture accessible by your graphics api.
//   - Optionally, call any of the AddFont*** functions. If you don't call any, the default font embedded in the code will be loaded for you.
//   - Call GetTexDataAsAlpha8() or GetTexDataAsRGBA32() to build and retrieve pixels data.
//   - Upload the pixels data into a texture within your graphics system (see imgui_impl_xxxx.cpp examples)
//   - Call SetTexID(my_tex_id); and pass the pointer/identifier to your texture in a format natural to your graphics API.
//     This value will be passed back to you during rendering to identify the texture. Read FAQ entry about ImTextureID for more details.
//
// Common pitfalls:
//   - If you pass a 'glyph_ranges' array to AddFont*** functions, you need to make sure that your array persist up until the
//     atlas is build (when calling GetTexData*** or Build()). We only copy the pointer, not the data.
//   - Important: By default, AddFontFromMemoryTTF() takes ownership of the data. Even though we are not writing to it, we will free the pointer on destruction.
//     You can set font_cfg->FontDataOwnedByAtlas=false to keep ownership of your data and it won't be freed,
//   - Even though many functions are suffixed with "TTF", OTF data is supported just as well.
//   - This is an old API and it is currently awkward for those and various other reasons! We will address them in the future!
type FontAtlas struct {
	// TODO: contains unsupported fields
	data unsafe.Pointer
}

func (self FontAtlas) handle() (result *C.ImFontAtlas, releaseFn func()) {
	result = (*C.ImFontAtlas)(self.data)
	return result, func() {}
}

func (self FontAtlas) c() (result C.ImFontAtlas, fin func()) {
	resultPtr, finFn := self.handle()
	return *resultPtr, finFn
}

func newFontAtlasFromC(cvalue *C.ImFontAtlas) *FontAtlas {
	result := new(FontAtlas)
	result.data = unsafe.Pointer(cvalue)
	return result
}

// See ImFontAtlas::AddCustomRectXXX functions.
type FontAtlasCustomRect struct {
	FieldWidth         uint16  // Input    // Desired rectangle dimension
	FieldHeight        uint16  // Input    // Desired rectangle dimension
	FieldX             uint16  // Output   // Packed position in Atlas
	FieldY             uint16  // Output   // Packed position in Atlas
	FieldGlyphID       uint32  // Input    // For custom font glyphs only (ID < 0x110000)
	FieldGlyphAdvanceX float32 // Input    // For custom font glyphs only: glyph xadvance
	FieldGlyphOffset   Vec2    // Input    // For custom font glyphs only: glyph display offset
	FieldFont          *Font   // Input    // For custom font glyphs only: target font
}

func (self FontAtlasCustomRect) handle() (result *C.ImFontAtlasCustomRect, releaseFn func()) {
	result = new(C.ImFontAtlasCustomRect)
	FieldWidth := self.FieldWidth

	result.Width = C.ushort(FieldWidth)
	FieldHeight := self.FieldHeight

	result.Height = C.ushort(FieldHeight)
	FieldX := self.FieldX

	result.X = C.ushort(FieldX)
	FieldY := self.FieldY

	result.Y = C.ushort(FieldY)
	FieldGlyphID := self.FieldGlyphID

	result.GlyphID = C.uint(FieldGlyphID)
	FieldGlyphAdvanceX := self.FieldGlyphAdvanceX

	result.GlyphAdvanceX = C.float(FieldGlyphAdvanceX)
	FieldGlyphOffset := self.FieldGlyphOffset

	result.GlyphOffset = FieldGlyphOffset.toC()
	FieldFont := self.FieldFont
	FieldFontArg, FieldFontFin := FieldFont.handle()
	result.Font = FieldFontArg
	releaseFn = func() {
		FieldFontFin()
	}
	return result, releaseFn
}

func (self FontAtlasCustomRect) c() (result C.ImFontAtlasCustomRect, fin func()) {
	resultPtr, finFn := self.handle()
	return *resultPtr, finFn
}

func newFontAtlasCustomRectFromC(cvalue *C.ImFontAtlasCustomRect) *FontAtlasCustomRect {
	result := new(FontAtlasCustomRect)
	result.FieldWidth = uint16(cvalue.Width)
	result.FieldHeight = uint16(cvalue.Height)
	result.FieldX = uint16(cvalue.X)
	result.FieldY = uint16(cvalue.Y)
	result.FieldGlyphID = uint32(cvalue.GlyphID)
	result.FieldGlyphAdvanceX = float32(cvalue.GlyphAdvanceX)
	result.FieldGlyphOffset = *(&Vec2{}).fromC(cvalue.GlyphOffset)
	result.FieldFont = newFontFromC(cvalue.Font)
	return result
}

// This structure is likely to evolve as we add support for incremental atlas updates
type FontBuilderIO struct {
	// TODO: contains unsupported fields
	data unsafe.Pointer
}

func (self FontBuilderIO) handle() (result *C.ImFontBuilderIO, releaseFn func()) {
	result = (*C.ImFontBuilderIO)(self.data)
	return result, func() {}
}

func (self FontBuilderIO) c() (result C.ImFontBuilderIO, fin func()) {
	resultPtr, finFn := self.handle()
	return *resultPtr, finFn
}

func newFontBuilderIOFromC(cvalue *C.ImFontBuilderIO) *FontBuilderIO {
	result := new(FontBuilderIO)
	result.data = unsafe.Pointer(cvalue)
	return result
}

type FontConfig struct {
	// TODO: contains unsupported fields
	data unsafe.Pointer
}

func (self FontConfig) handle() (result *C.ImFontConfig, releaseFn func()) {
	result = (*C.ImFontConfig)(self.data)
	return result, func() {}
}

func (self FontConfig) c() (result C.ImFontConfig, fin func()) {
	resultPtr, finFn := self.handle()
	return *resultPtr, finFn
}

func newFontConfigFromC(cvalue *C.ImFontConfig) *FontConfig {
	result := new(FontConfig)
	result.data = unsafe.Pointer(cvalue)
	return result
}

// Hold rendering data for one glyph.
// (Note: some language parsers may fail to convert the 31+1 bitfield members, in this case maybe drop store a single u32 or we can rework this)
type FontGlyph struct {
	// TODO: contains unsupported fields
	data unsafe.Pointer
}

func (self FontGlyph) handle() (result *C.ImFontGlyph, releaseFn func()) {
	result = (*C.ImFontGlyph)(self.data)
	return result, func() {}
}

func (self FontGlyph) c() (result C.ImFontGlyph, fin func()) {
	resultPtr, finFn := self.handle()
	return *resultPtr, finFn
}

func newFontGlyphFromC(cvalue *C.ImFontGlyph) *FontGlyph {
	result := new(FontGlyph)
	result.data = unsafe.Pointer(cvalue)
	return result
}

// Helper to build glyph ranges from text/string data. Feed your application strings/characters to it then call BuildRanges().
// This is essentially a tightly packed of vector of 64k booleans = 8KB storage.
type FontGlyphRangesBuilder struct {
	FieldUsedChars Vector[*uint32] // Store 1-bit per Unicode code point (0=unused, 1=used)
}

func (self FontGlyphRangesBuilder) handle() (result *C.ImFontGlyphRangesBuilder, releaseFn func()) {
	result = new(C.ImFontGlyphRangesBuilder)
	FieldUsedChars := self.FieldUsedChars
	FieldUsedCharsData := FieldUsedChars.Data
	FieldUsedCharsDataArg, FieldUsedCharsDataFin := WrapNumberPtr[C.ImU32, uint32](FieldUsedCharsData)
	FieldUsedCharsVecArg := new(C.ImVector_ImU32)
	FieldUsedCharsVecArg.Size = C.int(FieldUsedChars.Size)
	FieldUsedCharsVecArg.Capacity = C.int(FieldUsedChars.Capacity)
	FieldUsedCharsVecArg.Data = FieldUsedCharsDataArg
	FieldUsedChars.pinner.Pin(FieldUsedCharsVecArg.Data)

	result.UsedChars = *FieldUsedCharsVecArg
	releaseFn = func() {
		FieldUsedCharsDataFin()
		FieldUsedChars.pinner.Unpin()
	}
	return result, releaseFn
}

func (self FontGlyphRangesBuilder) c() (result C.ImFontGlyphRangesBuilder, fin func()) {
	resultPtr, finFn := self.handle()
	return *resultPtr, finFn
}

func newFontGlyphRangesBuilderFromC(cvalue *C.ImFontGlyphRangesBuilder) *FontGlyphRangesBuilder {
	result := new(FontGlyphRangesBuilder)
	result.FieldUsedChars = newVectorFromC(cvalue.UsedChars.Size, cvalue.UsedChars.Capacity, (*uint32)(cvalue.UsedChars.Data))
	return result
}

// Stacked color modifier, backup of modified data so we can restore it
type ColorMod struct {
	FieldCol         Col
	FieldBackupValue Vec4
}

func (self ColorMod) handle() (result *C.ImGuiColorMod, releaseFn func()) {
	result = new(C.ImGuiColorMod)
	FieldCol := self.FieldCol

	result.Col = C.ImGuiCol(FieldCol)
	FieldBackupValue := self.FieldBackupValue

	result.BackupValue = FieldBackupValue.toC()
	releaseFn = func() {
	}
	return result, releaseFn
}

func (self ColorMod) c() (result C.ImGuiColorMod, fin func()) {
	resultPtr, finFn := self.handle()
	return *resultPtr, finFn
}

func newColorModFromC(cvalue *C.ImGuiColorMod) *ColorMod {
	result := new(ColorMod)
	result.FieldCol = Col(cvalue.Col)
	result.FieldBackupValue = *(&Vec4{}).fromC(cvalue.BackupValue)
	return result
}

// Storage data for BeginComboPreview()/EndComboPreview()
type ComboPreviewData struct {
	FieldPreviewRect                  Rect
	FieldBackupCursorPos              Vec2
	FieldBackupCursorMaxPos           Vec2
	FieldBackupCursorPosPrevLine      Vec2
	FieldBackupPrevLineTextBaseOffset float32
	FieldBackupLayout                 LayoutType
}

func (self ComboPreviewData) handle() (result *C.ImGuiComboPreviewData, releaseFn func()) {
	result = new(C.ImGuiComboPreviewData)
	FieldPreviewRect := self.FieldPreviewRect

	result.PreviewRect = FieldPreviewRect.toC()
	FieldBackupCursorPos := self.FieldBackupCursorPos

	result.BackupCursorPos = FieldBackupCursorPos.toC()
	FieldBackupCursorMaxPos := self.FieldBackupCursorMaxPos

	result.BackupCursorMaxPos = FieldBackupCursorMaxPos.toC()
	FieldBackupCursorPosPrevLine := self.FieldBackupCursorPosPrevLine

	result.BackupCursorPosPrevLine = FieldBackupCursorPosPrevLine.toC()
	FieldBackupPrevLineTextBaseOffset := self.FieldBackupPrevLineTextBaseOffset

	result.BackupPrevLineTextBaseOffset = C.float(FieldBackupPrevLineTextBaseOffset)
	FieldBackupLayout := self.FieldBackupLayout

	result.BackupLayout = C.ImGuiLayoutType(FieldBackupLayout)
	releaseFn = func() {
	}
	return result, releaseFn
}

func (self ComboPreviewData) c() (result C.ImGuiComboPreviewData, fin func()) {
	resultPtr, finFn := self.handle()
	return *resultPtr, finFn
}

func newComboPreviewDataFromC(cvalue *C.ImGuiComboPreviewData) *ComboPreviewData {
	result := new(ComboPreviewData)
	result.FieldPreviewRect = *(&Rect{}).fromC(cvalue.PreviewRect)
	result.FieldBackupCursorPos = *(&Vec2{}).fromC(cvalue.BackupCursorPos)
	result.FieldBackupCursorMaxPos = *(&Vec2{}).fromC(cvalue.BackupCursorMaxPos)
	result.FieldBackupCursorPosPrevLine = *(&Vec2{}).fromC(cvalue.BackupCursorPosPrevLine)
	result.FieldBackupPrevLineTextBaseOffset = float32(cvalue.BackupPrevLineTextBaseOffset)
	result.FieldBackupLayout = LayoutType(cvalue.BackupLayout)
	return result
}

type Context struct {
	// TODO: contains unsupported fields
	data unsafe.Pointer
}

func (self Context) handle() (result *C.ImGuiContext, releaseFn func()) {
	result = (*C.ImGuiContext)(self.data)
	return result, func() {}
}

func (self Context) c() (result C.ImGuiContext, fin func()) {
	resultPtr, finFn := self.handle()
	return *resultPtr, finFn
}

func newContextFromC(cvalue *C.ImGuiContext) *Context {
	result := new(Context)
	result.data = unsafe.Pointer(cvalue)
	return result
}

type ContextHook struct {
	// TODO: contains unsupported fields
	data unsafe.Pointer
}

func (self ContextHook) handle() (result *C.ImGuiContextHook, releaseFn func()) {
	result = (*C.ImGuiContextHook)(self.data)
	return result, func() {}
}

func (self ContextHook) c() (result C.ImGuiContextHook, fin func()) {
	resultPtr, finFn := self.handle()
	return *resultPtr, finFn
}

func newContextHookFromC(cvalue *C.ImGuiContextHook) *ContextHook {
	result := new(ContextHook)
	result.data = unsafe.Pointer(cvalue)
	return result
}

// Type information associated to one ImGuiDataType. Retrieve with DataTypeGetInfo().
type DataTypeInfo struct {
	FieldSize     uint64 // Size in bytes
	FieldName     string // Short descriptive name for the type, for debugging
	FieldPrintFmt string // Default printf format for the type
	FieldScanFmt  string // Default scanf format for the type
}

func (self DataTypeInfo) handle() (result *C.ImGuiDataTypeInfo, releaseFn func()) {
	result = new(C.ImGuiDataTypeInfo)
	FieldSize := self.FieldSize

	result.Size = C.xulong(FieldSize)
	FieldName := self.FieldName
	FieldNameArg, FieldNameFin := WrapString(FieldName)
	result.Name = FieldNameArg
	FieldPrintFmt := self.FieldPrintFmt
	FieldPrintFmtArg, FieldPrintFmtFin := WrapString(FieldPrintFmt)
	result.PrintFmt = FieldPrintFmtArg
	FieldScanFmt := self.FieldScanFmt
	FieldScanFmtArg, FieldScanFmtFin := WrapString(FieldScanFmt)
	result.ScanFmt = FieldScanFmtArg
	releaseFn = func() {
		FieldNameFin()
		FieldPrintFmtFin()
		FieldScanFmtFin()
	}
	return result, releaseFn
}

func (self DataTypeInfo) c() (result C.ImGuiDataTypeInfo, fin func()) {
	resultPtr, finFn := self.handle()
	return *resultPtr, finFn
}

func newDataTypeInfoFromC(cvalue *C.ImGuiDataTypeInfo) *DataTypeInfo {
	result := new(DataTypeInfo)
	result.FieldSize = uint64(cvalue.Size)
	result.FieldName = C.GoString(cvalue.Name)
	result.FieldPrintFmt = C.GoString(cvalue.PrintFmt)
	result.FieldScanFmt = C.GoString(cvalue.ScanFmt)
	return result
}

type DataTypeTempStorage struct {
	// TODO: contains unsupported fields
	data unsafe.Pointer
}

func (self DataTypeTempStorage) handle() (result *C.ImGuiDataTypeTempStorage, releaseFn func()) {
	result = (*C.ImGuiDataTypeTempStorage)(self.data)
	return result, func() {}
}

func (self DataTypeTempStorage) c() (result C.ImGuiDataTypeTempStorage, fin func()) {
	resultPtr, finFn := self.handle()
	return *resultPtr, finFn
}

func newDataTypeTempStorageFromC(cvalue *C.ImGuiDataTypeTempStorage) *DataTypeTempStorage {
	result := new(DataTypeTempStorage)
	result.data = unsafe.Pointer(cvalue)
	return result
}

type DataVarInfo struct {
	FieldType   DataType
	FieldCount  uint32 // 1+
	FieldOffset uint32 // Offset in parent structure
}

func (self DataVarInfo) handle() (result *C.ImGuiDataVarInfo, releaseFn func()) {
	result = new(C.ImGuiDataVarInfo)
	FieldType := self.FieldType

	result.Type = C.ImGuiDataType(FieldType)
	FieldCount := self.FieldCount

	result.Count = C.ImU32(FieldCount)
	FieldOffset := self.FieldOffset

	result.Offset = C.ImU32(FieldOffset)
	releaseFn = func() {
	}
	return result, releaseFn
}

func (self DataVarInfo) c() (result C.ImGuiDataVarInfo, fin func()) {
	resultPtr, finFn := self.handle()
	return *resultPtr, finFn
}

func newDataVarInfoFromC(cvalue *C.ImGuiDataVarInfo) *DataVarInfo {
	result := new(DataVarInfo)
	result.FieldType = DataType(cvalue.Type)
	result.FieldCount = uint32(cvalue.Count)
	result.FieldOffset = uint32(cvalue.Offset)
	return result
}

type DockContext struct {
	// TODO: contains unsupported fields
	data unsafe.Pointer
}

func (self DockContext) handle() (result *C.ImGuiDockContext, releaseFn func()) {
	result = (*C.ImGuiDockContext)(self.data)
	return result, func() {}
}

func (self DockContext) c() (result C.ImGuiDockContext, fin func()) {
	resultPtr, finFn := self.handle()
	return *resultPtr, finFn
}

func newDockContextFromC(cvalue *C.ImGuiDockContext) *DockContext {
	result := new(DockContext)
	result.data = unsafe.Pointer(cvalue)
	return result
}

// sizeof() 156~192
type DockNode struct {
	// TODO: contains unsupported fields
	data unsafe.Pointer
}

func (self DockNode) handle() (result *C.ImGuiDockNode, releaseFn func()) {
	result = (*C.ImGuiDockNode)(self.data)
	return result, func() {}
}

func (self DockNode) c() (result C.ImGuiDockNode, fin func()) {
	resultPtr, finFn := self.handle()
	return *resultPtr, finFn
}

func newDockNodeFromC(cvalue *C.ImGuiDockNode) *DockNode {
	result := new(DockNode)
	result.data = unsafe.Pointer(cvalue)
	return result
}

// Stacked storage data for BeginGroup()/EndGroup()
type GroupData struct {
	// TODO: contains unsupported fields
	data unsafe.Pointer
}

func (self GroupData) handle() (result *C.ImGuiGroupData, releaseFn func()) {
	result = (*C.ImGuiGroupData)(self.data)
	return result, func() {}
}

func (self GroupData) c() (result C.ImGuiGroupData, fin func()) {
	resultPtr, finFn := self.handle()
	return *resultPtr, finFn
}

func newGroupDataFromC(cvalue *C.ImGuiGroupData) *GroupData {
	result := new(GroupData)
	result.data = unsafe.Pointer(cvalue)
	return result
}

type IO struct {
	// TODO: contains unsupported fields
	data unsafe.Pointer
}

func (self IO) handle() (result *C.ImGuiIO, releaseFn func()) {
	result = (*C.ImGuiIO)(self.data)
	return result, func() {}
}

func (self IO) c() (result C.ImGuiIO, fin func()) {
	resultPtr, finFn := self.handle()
	return *resultPtr, finFn
}

func newIOFromC(cvalue *C.ImGuiIO) *IO {
	result := new(IO)
	result.data = unsafe.Pointer(cvalue)
	return result
}

type InputEvent struct {
	// TODO: contains unsupported fields
	data unsafe.Pointer
}

func (self InputEvent) handle() (result *C.ImGuiInputEvent, releaseFn func()) {
	result = (*C.ImGuiInputEvent)(self.data)
	return result, func() {}
}

func (self InputEvent) c() (result C.ImGuiInputEvent, fin func()) {
	resultPtr, finFn := self.handle()
	return *resultPtr, finFn
}

func newInputEventFromC(cvalue *C.ImGuiInputEvent) *InputEvent {
	result := new(InputEvent)
	result.data = unsafe.Pointer(cvalue)
	return result
}

type InputEventAppFocused struct {
	FieldFocused bool
}

func (self InputEventAppFocused) handle() (result *C.ImGuiInputEventAppFocused, releaseFn func()) {
	result = new(C.ImGuiInputEventAppFocused)
	FieldFocused := self.FieldFocused

	result.Focused = C.bool(FieldFocused)
	releaseFn = func() {
	}
	return result, releaseFn
}

func (self InputEventAppFocused) c() (result C.ImGuiInputEventAppFocused, fin func()) {
	resultPtr, finFn := self.handle()
	return *resultPtr, finFn
}

func newInputEventAppFocusedFromC(cvalue *C.ImGuiInputEventAppFocused) *InputEventAppFocused {
	result := new(InputEventAppFocused)
	result.FieldFocused = cvalue.Focused == C.bool(true)
	return result
}

type InputEventKey struct {
	FieldKey         Key
	FieldDown        bool
	FieldAnalogValue float32
}

func (self InputEventKey) handle() (result *C.ImGuiInputEventKey, releaseFn func()) {
	result = new(C.ImGuiInputEventKey)
	FieldKey := self.FieldKey

	result.Key = C.ImGuiKey(FieldKey)
	FieldDown := self.FieldDown

	result.Down = C.bool(FieldDown)
	FieldAnalogValue := self.FieldAnalogValue

	result.AnalogValue = C.float(FieldAnalogValue)
	releaseFn = func() {
	}
	return result, releaseFn
}

func (self InputEventKey) c() (result C.ImGuiInputEventKey, fin func()) {
	resultPtr, finFn := self.handle()
	return *resultPtr, finFn
}

func newInputEventKeyFromC(cvalue *C.ImGuiInputEventKey) *InputEventKey {
	result := new(InputEventKey)
	result.FieldKey = Key(cvalue.Key)
	result.FieldDown = cvalue.Down == C.bool(true)
	result.FieldAnalogValue = float32(cvalue.AnalogValue)
	return result
}

type InputEventMouseButton struct {
	FieldButton      int32
	FieldDown        bool
	FieldMouseSource MouseSource
}

func (self InputEventMouseButton) handle() (result *C.ImGuiInputEventMouseButton, releaseFn func()) {
	result = new(C.ImGuiInputEventMouseButton)
	FieldButton := self.FieldButton

	result.Button = C.int(FieldButton)
	FieldDown := self.FieldDown

	result.Down = C.bool(FieldDown)
	FieldMouseSource := self.FieldMouseSource

	result.MouseSource = C.ImGuiMouseSource(FieldMouseSource)
	releaseFn = func() {
	}
	return result, releaseFn
}

func (self InputEventMouseButton) c() (result C.ImGuiInputEventMouseButton, fin func()) {
	resultPtr, finFn := self.handle()
	return *resultPtr, finFn
}

func newInputEventMouseButtonFromC(cvalue *C.ImGuiInputEventMouseButton) *InputEventMouseButton {
	result := new(InputEventMouseButton)
	result.FieldButton = int32(cvalue.Button)
	result.FieldDown = cvalue.Down == C.bool(true)
	result.FieldMouseSource = MouseSource(cvalue.MouseSource)
	return result
}

// FIXME: Structures in the union below need to be declared as anonymous unions appears to be an extension?
// Using ImVec2() would fail on Clang 'union member 'MousePos' has a non-trivial default constructor'
type InputEventMousePos struct {
	FieldPosX        float32
	FieldPosY        float32
	FieldMouseSource MouseSource
}

func (self InputEventMousePos) handle() (result *C.ImGuiInputEventMousePos, releaseFn func()) {
	result = new(C.ImGuiInputEventMousePos)
	FieldPosX := self.FieldPosX

	result.PosX = C.float(FieldPosX)
	FieldPosY := self.FieldPosY

	result.PosY = C.float(FieldPosY)
	FieldMouseSource := self.FieldMouseSource

	result.MouseSource = C.ImGuiMouseSource(FieldMouseSource)
	releaseFn = func() {
	}
	return result, releaseFn
}

func (self InputEventMousePos) c() (result C.ImGuiInputEventMousePos, fin func()) {
	resultPtr, finFn := self.handle()
	return *resultPtr, finFn
}

func newInputEventMousePosFromC(cvalue *C.ImGuiInputEventMousePos) *InputEventMousePos {
	result := new(InputEventMousePos)
	result.FieldPosX = float32(cvalue.PosX)
	result.FieldPosY = float32(cvalue.PosY)
	result.FieldMouseSource = MouseSource(cvalue.MouseSource)
	return result
}

type InputEventMouseViewport struct {
	// TODO: contains unsupported fields
	data unsafe.Pointer
}

func (self InputEventMouseViewport) handle() (result *C.ImGuiInputEventMouseViewport, releaseFn func()) {
	result = (*C.ImGuiInputEventMouseViewport)(self.data)
	return result, func() {}
}

func (self InputEventMouseViewport) c() (result C.ImGuiInputEventMouseViewport, fin func()) {
	resultPtr, finFn := self.handle()
	return *resultPtr, finFn
}

func newInputEventMouseViewportFromC(cvalue *C.ImGuiInputEventMouseViewport) *InputEventMouseViewport {
	result := new(InputEventMouseViewport)
	result.data = unsafe.Pointer(cvalue)
	return result
}

type InputEventMouseWheel struct {
	FieldWheelX      float32
	FieldWheelY      float32
	FieldMouseSource MouseSource
}

func (self InputEventMouseWheel) handle() (result *C.ImGuiInputEventMouseWheel, releaseFn func()) {
	result = new(C.ImGuiInputEventMouseWheel)
	FieldWheelX := self.FieldWheelX

	result.WheelX = C.float(FieldWheelX)
	FieldWheelY := self.FieldWheelY

	result.WheelY = C.float(FieldWheelY)
	FieldMouseSource := self.FieldMouseSource

	result.MouseSource = C.ImGuiMouseSource(FieldMouseSource)
	releaseFn = func() {
	}
	return result, releaseFn
}

func (self InputEventMouseWheel) c() (result C.ImGuiInputEventMouseWheel, fin func()) {
	resultPtr, finFn := self.handle()
	return *resultPtr, finFn
}

func newInputEventMouseWheelFromC(cvalue *C.ImGuiInputEventMouseWheel) *InputEventMouseWheel {
	result := new(InputEventMouseWheel)
	result.FieldWheelX = float32(cvalue.WheelX)
	result.FieldWheelY = float32(cvalue.WheelY)
	result.FieldMouseSource = MouseSource(cvalue.MouseSource)
	return result
}

type InputEventText struct {
	FieldChar uint32
}

func (self InputEventText) handle() (result *C.ImGuiInputEventText, releaseFn func()) {
	result = new(C.ImGuiInputEventText)
	FieldChar := self.FieldChar

	result.Char = C.uint(FieldChar)
	releaseFn = func() {
	}
	return result, releaseFn
}

func (self InputEventText) c() (result C.ImGuiInputEventText, fin func()) {
	resultPtr, finFn := self.handle()
	return *resultPtr, finFn
}

func newInputEventTextFromC(cvalue *C.ImGuiInputEventText) *InputEventText {
	result := new(InputEventText)
	result.FieldChar = uint32(cvalue.Char)
	return result
}

// Shared state of InputText(), passed as an argument to your callback when a ImGuiInputTextFlags_Callback* flag is used.
// The callback function should return 0 by default.
// Callbacks (follow a flag name and see comments in ImGuiInputTextFlags_ declarations for more details)
// - ImGuiInputTextFlags_CallbackEdit:        Callback on buffer edit (note that InputText() already returns true on edit, the callback is useful mainly to manipulate the underlying buffer while focus is active)
// - ImGuiInputTextFlags_CallbackAlways:      Callback on each iteration
// - ImGuiInputTextFlags_CallbackCompletion:  Callback on pressing TAB
// - ImGuiInputTextFlags_CallbackHistory:     Callback on pressing Up/Down arrows
// - ImGuiInputTextFlags_CallbackCharFilter:  Callback on character inputs to replace or discard them. Modify 'EventChar' to replace or discard, or return 1 in callback to discard.
// - ImGuiInputTextFlags_CallbackResize:      Callback on buffer capacity changes request (beyond 'buf_size' parameter value), allowing the string to grow.
type InputTextCallbackData struct {
	FieldCtx       *Context       // Parent UI context
	FieldEventFlag InputTextFlags // One ImGuiInputTextFlags_Callback*    // Read-only
	FieldFlags     InputTextFlags // What user passed to InputText()      // Read-only
	FieldUserData  unsafe.Pointer // What user passed to InputText()      // Read-only
	// Arguments for the different callback events
	// - To modify the text buffer in a callback, prefer using the InsertChars() / DeleteChars() function. InsertChars() will take care of calling the resize callback if necessary.
	// - If you know your edits are not going to resize the underlying buffer allocation, you may modify the contents of 'Buf[]' directly. You need to update 'BufTextLen' accordingly (0 <= BufTextLen < BufSize) and set 'BufDirty'' to true so InputText can update its internal state.
	FieldEventChar      Wchar  // Character input                      // Read-write   // [CharFilter] Replace character with another one, or set to zero to drop. return 1 is equivalent to setting EventChar=0;
	FieldEventKey       Key    // Key pressed (Up/Down/TAB)            // Read-only    // [Completion,History]
	FieldBuf            string // Text buffer                          // Read-write   // [Resize] Can replace pointer / [Completion,History,Always] Only write to pointed data, don't replace the actual pointer!
	FieldBufTextLen     int32  // Text length (in bytes)               // Read-write   // [Resize,Completion,History,Always] Exclude zero-terminator storage. In C land: == strlen(some_text), in C++ land: string.length()
	FieldBufSize        int32  // Buffer size (in bytes) = capacity+1  // Read-only    // [Resize,Completion,History,Always] Include zero-terminator storage. In C land == ARRAYSIZE(my_char_array), in C++ land: string.capacity()+1
	FieldBufDirty       bool   // Set if you modify Buf/BufTextLen!    // Write        // [Completion,History,Always]
	FieldCursorPos      int32  //                                      // Read-write   // [Completion,History,Always]
	FieldSelectionStart int32  //                                      // Read-write   // [Completion,History,Always] == to SelectionEnd when no selection)
	FieldSelectionEnd   int32  //                                      // Read-write   // [Completion,History,Always]
}

func (self InputTextCallbackData) handle() (result *C.ImGuiInputTextCallbackData, releaseFn func()) {
	result = new(C.ImGuiInputTextCallbackData)
	FieldCtx := self.FieldCtx
	FieldCtxArg, FieldCtxFin := FieldCtx.handle()
	result.Ctx = FieldCtxArg
	FieldEventFlag := self.FieldEventFlag

	result.EventFlag = C.ImGuiInputTextFlags(FieldEventFlag)
	FieldFlags := self.FieldFlags

	result.Flags = C.ImGuiInputTextFlags(FieldFlags)
	FieldUserData := self.FieldUserData
	FieldUserDataArg, FieldUserDataFin := WrapVoidPtr(FieldUserData)
	result.UserData = FieldUserDataArg
	FieldEventChar := self.FieldEventChar

	result.EventChar = C.ImWchar(FieldEventChar)
	FieldEventKey := self.FieldEventKey

	result.EventKey = C.ImGuiKey(FieldEventKey)
	FieldBuf := self.FieldBuf
	FieldBufArg, FieldBufFin := WrapString(FieldBuf)
	result.Buf = FieldBufArg
	FieldBufTextLen := self.FieldBufTextLen

	result.BufTextLen = C.int(FieldBufTextLen)
	FieldBufSize := self.FieldBufSize

	result.BufSize = C.int(FieldBufSize)
	FieldBufDirty := self.FieldBufDirty

	result.BufDirty = C.bool(FieldBufDirty)
	FieldCursorPos := self.FieldCursorPos

	result.CursorPos = C.int(FieldCursorPos)
	FieldSelectionStart := self.FieldSelectionStart

	result.SelectionStart = C.int(FieldSelectionStart)
	FieldSelectionEnd := self.FieldSelectionEnd

	result.SelectionEnd = C.int(FieldSelectionEnd)
	releaseFn = func() {
		FieldCtxFin()

		FieldUserDataFin()

		FieldBufFin()
	}
	return result, releaseFn
}

func (self InputTextCallbackData) c() (result C.ImGuiInputTextCallbackData, fin func()) {
	resultPtr, finFn := self.handle()
	return *resultPtr, finFn
}

func newInputTextCallbackDataFromC(cvalue *C.ImGuiInputTextCallbackData) *InputTextCallbackData {
	result := new(InputTextCallbackData)
	result.FieldCtx = newContextFromC(cvalue.Ctx)
	result.FieldEventFlag = InputTextFlags(cvalue.EventFlag)
	result.FieldFlags = InputTextFlags(cvalue.Flags)
	result.FieldUserData = unsafe.Pointer(cvalue.UserData)
	result.FieldEventChar = Wchar(cvalue.EventChar)
	result.FieldEventKey = Key(cvalue.EventKey)
	result.FieldBuf = C.GoString(cvalue.Buf)
	result.FieldBufTextLen = int32(cvalue.BufTextLen)
	result.FieldBufSize = int32(cvalue.BufSize)
	result.FieldBufDirty = cvalue.BufDirty == C.bool(true)
	result.FieldCursorPos = int32(cvalue.CursorPos)
	result.FieldSelectionStart = int32(cvalue.SelectionStart)
	result.FieldSelectionEnd = int32(cvalue.SelectionEnd)
	return result
}

// Internal temporary state for deactivating InputText() instances.
type InputTextDeactivatedState struct {
	// TODO: contains unsupported fields
	data unsafe.Pointer
}

func (self InputTextDeactivatedState) handle() (result *C.ImGuiInputTextDeactivatedState, releaseFn func()) {
	result = (*C.ImGuiInputTextDeactivatedState)(self.data)
	return result, func() {}
}

func (self InputTextDeactivatedState) c() (result C.ImGuiInputTextDeactivatedState, fin func()) {
	resultPtr, finFn := self.handle()
	return *resultPtr, finFn
}

func newInputTextDeactivatedStateFromC(cvalue *C.ImGuiInputTextDeactivatedState) *InputTextDeactivatedState {
	result := new(InputTextDeactivatedState)
	result.data = unsafe.Pointer(cvalue)
	return result
}

// Internal state of the currently focused/edited text input box
// For a given item ID, access with ImGui::GetInputTextState()
type InputTextState struct {
	// TODO: contains unsupported fields
	data unsafe.Pointer
}

func (self InputTextState) handle() (result *C.ImGuiInputTextState, releaseFn func()) {
	result = (*C.ImGuiInputTextState)(self.data)
	return result, func() {}
}

func (self InputTextState) c() (result C.ImGuiInputTextState, fin func()) {
	resultPtr, finFn := self.handle()
	return *resultPtr, finFn
}

func newInputTextStateFromC(cvalue *C.ImGuiInputTextState) *InputTextState {
	result := new(InputTextState)
	result.data = unsafe.Pointer(cvalue)
	return result
}

// [Internal] Storage used by IsKeyDown(), IsKeyPressed() etc functions.
// If prior to 1.87 you used io.KeysDownDuration[] (which was marked as internal), you should use GetKeyData(key)->DownDuration and *NOT* io.KeysData[key]->DownDuration.
type KeyData struct {
	FieldDown             bool    // True for if key is down
	FieldDownDuration     float32 // Duration the key has been down (<0.0f: not pressed, 0.0f: just pressed, >0.0f: time held)
	FieldDownDurationPrev float32 // Last frame duration the key has been down
	FieldAnalogValue      float32 // 0.0f..1.0f for gamepad values
}

func (self KeyData) handle() (result *C.ImGuiKeyData, releaseFn func()) {
	result = new(C.ImGuiKeyData)
	FieldDown := self.FieldDown

	result.Down = C.bool(FieldDown)
	FieldDownDuration := self.FieldDownDuration

	result.DownDuration = C.float(FieldDownDuration)
	FieldDownDurationPrev := self.FieldDownDurationPrev

	result.DownDurationPrev = C.float(FieldDownDurationPrev)
	FieldAnalogValue := self.FieldAnalogValue

	result.AnalogValue = C.float(FieldAnalogValue)
	releaseFn = func() {
	}
	return result, releaseFn
}

func (self KeyData) c() (result C.ImGuiKeyData, fin func()) {
	resultPtr, finFn := self.handle()
	return *resultPtr, finFn
}

func newKeyDataFromC(cvalue *C.ImGuiKeyData) *KeyData {
	result := new(KeyData)
	result.FieldDown = cvalue.Down == C.bool(true)
	result.FieldDownDuration = float32(cvalue.DownDuration)
	result.FieldDownDurationPrev = float32(cvalue.DownDurationPrev)
	result.FieldAnalogValue = float32(cvalue.AnalogValue)
	return result
}

// This extends ImGuiKeyData but only for named keys (legacy keys don't support the new features)
// Stored in main context (1 per named key). In the future it might be merged into ImGuiKeyData.
type KeyOwnerData struct {
	// TODO: contains unsupported fields
	data unsafe.Pointer
}

func (self KeyOwnerData) handle() (result *C.ImGuiKeyOwnerData, releaseFn func()) {
	result = (*C.ImGuiKeyOwnerData)(self.data)
	return result, func() {}
}

func (self KeyOwnerData) c() (result C.ImGuiKeyOwnerData, fin func()) {
	resultPtr, finFn := self.handle()
	return *resultPtr, finFn
}

func newKeyOwnerDataFromC(cvalue *C.ImGuiKeyOwnerData) *KeyOwnerData {
	result := new(KeyOwnerData)
	result.data = unsafe.Pointer(cvalue)
	return result
}

// Routing table entry (sizeof() == 16 bytes)
type KeyRoutingData struct {
	// TODO: contains unsupported fields
	data unsafe.Pointer
}

func (self KeyRoutingData) handle() (result *C.ImGuiKeyRoutingData, releaseFn func()) {
	result = (*C.ImGuiKeyRoutingData)(self.data)
	return result, func() {}
}

func (self KeyRoutingData) c() (result C.ImGuiKeyRoutingData, fin func()) {
	resultPtr, finFn := self.handle()
	return *resultPtr, finFn
}

func newKeyRoutingDataFromC(cvalue *C.ImGuiKeyRoutingData) *KeyRoutingData {
	result := new(KeyRoutingData)
	result.data = unsafe.Pointer(cvalue)
	return result
}

// Routing table: maintain a desired owner for each possible key-chord (key + mods), and setup owner in NewFrame() when mods are matching.
// Stored in main context (1 instance)
type KeyRoutingTable struct {
	// TODO: contains unsupported fields
	data unsafe.Pointer
}

func (self KeyRoutingTable) handle() (result *C.ImGuiKeyRoutingTable, releaseFn func()) {
	result = (*C.ImGuiKeyRoutingTable)(self.data)
	return result, func() {}
}

func (self KeyRoutingTable) c() (result C.ImGuiKeyRoutingTable, fin func()) {
	resultPtr, finFn := self.handle()
	return *resultPtr, finFn
}

func newKeyRoutingTableFromC(cvalue *C.ImGuiKeyRoutingTable) *KeyRoutingTable {
	result := new(KeyRoutingTable)
	result.data = unsafe.Pointer(cvalue)
	return result
}

// Status storage for the last submitted item
type LastItemData struct {
	// TODO: contains unsupported fields
	data unsafe.Pointer
}

func (self LastItemData) handle() (result *C.ImGuiLastItemData, releaseFn func()) {
	result = (*C.ImGuiLastItemData)(self.data)
	return result, func() {}
}

func (self LastItemData) c() (result C.ImGuiLastItemData, fin func()) {
	resultPtr, finFn := self.handle()
	return *resultPtr, finFn
}

func newLastItemDataFromC(cvalue *C.ImGuiLastItemData) *LastItemData {
	result := new(LastItemData)
	result.data = unsafe.Pointer(cvalue)
	return result
}

// Helper: Manually clip large list of items.
// If you have lots evenly spaced items and you have random access to the list, you can perform coarse
// clipping based on visibility to only submit items that are in view.
// The clipper calculates the range of visible items and advance the cursor to compensate for the non-visible items we have skipped.
// (Dear ImGui already clip items based on their bounds but: it needs to first layout the item to do so, and generally
//
//	fetching/submitting your own data incurs additional cost. Coarse clipping using ImGuiListClipper allows you to easily
//	scale using lists with tens of thousands of items without a problem)
//
// Usage:
//
//	ImGuiListClipper clipper;
//	clipper.Begin(1000);         // We have 1000 elements, evenly spaced.
//	while (clipper.Step())
//	    for (int i = clipper.DisplayStart; i < clipper.DisplayEnd; i++)
//	        ImGui::Text("line number %d", i);
//
// Generally what happens is:
// - Clipper lets you process the first element (DisplayStart = 0, DisplayEnd = 1) regardless of it being visible or not.
// - User code submit that one element.
// - Clipper can measure the height of the first element
// - Clipper calculate the actual range of elements to display based on the current clipping rectangle, position the cursor before the first visible element.
// - User code submit visible elements.
// - The clipper also handles various subtleties related to keyboard/gamepad navigation, wrapping etc.
type ListClipper struct {
	FieldCtx          *Context       // Parent UI context
	FieldDisplayStart int32          // First item to display, updated by each call to Step()
	FieldDisplayEnd   int32          // End of items to display (exclusive)
	FieldItemsCount   int32          // [Internal] Number of items
	FieldItemsHeight  float32        // [Internal] Height of item after a first step and item submission can calculate it
	FieldStartPosY    float32        // [Internal] Cursor position at the time of Begin() or after table frozen rows are all processed
	FieldTempData     unsafe.Pointer // [Internal] Internal data
}

func (self ListClipper) handle() (result *C.ImGuiListClipper, releaseFn func()) {
	result = new(C.ImGuiListClipper)
	FieldCtx := self.FieldCtx
	FieldCtxArg, FieldCtxFin := FieldCtx.handle()
	result.Ctx = FieldCtxArg
	FieldDisplayStart := self.FieldDisplayStart

	result.DisplayStart = C.int(FieldDisplayStart)
	FieldDisplayEnd := self.FieldDisplayEnd

	result.DisplayEnd = C.int(FieldDisplayEnd)
	FieldItemsCount := self.FieldItemsCount

	result.ItemsCount = C.int(FieldItemsCount)
	FieldItemsHeight := self.FieldItemsHeight

	result.ItemsHeight = C.float(FieldItemsHeight)
	FieldStartPosY := self.FieldStartPosY

	result.StartPosY = C.float(FieldStartPosY)
	FieldTempData := self.FieldTempData
	FieldTempDataArg, FieldTempDataFin := WrapVoidPtr(FieldTempData)
	result.TempData = FieldTempDataArg
	releaseFn = func() {
		FieldCtxFin()

		FieldTempDataFin()
	}
	return result, releaseFn
}

func (self ListClipper) c() (result C.ImGuiListClipper, fin func()) {
	resultPtr, finFn := self.handle()
	return *resultPtr, finFn
}

func newListClipperFromC(cvalue *C.ImGuiListClipper) *ListClipper {
	result := new(ListClipper)
	result.FieldCtx = newContextFromC(cvalue.Ctx)
	result.FieldDisplayStart = int32(cvalue.DisplayStart)
	result.FieldDisplayEnd = int32(cvalue.DisplayEnd)
	result.FieldItemsCount = int32(cvalue.ItemsCount)
	result.FieldItemsHeight = float32(cvalue.ItemsHeight)
	result.FieldStartPosY = float32(cvalue.StartPosY)
	result.FieldTempData = unsafe.Pointer(cvalue.TempData)
	return result
}

// Temporary clipper data, buffers shared/reused between instances
type ListClipperData struct {
	FieldListClipper     *ListClipper
	FieldLossynessOffset float32
	FieldStepNo          int32
	FieldItemsFrozen     int32
	FieldRanges          Vector[*ListClipperRange]
}

func (self ListClipperData) handle() (result *C.ImGuiListClipperData, releaseFn func()) {
	result = new(C.ImGuiListClipperData)
	FieldListClipper := self.FieldListClipper
	FieldListClipperArg, FieldListClipperFin := FieldListClipper.handle()
	result.ListClipper = FieldListClipperArg
	FieldLossynessOffset := self.FieldLossynessOffset

	result.LossynessOffset = C.float(FieldLossynessOffset)
	FieldStepNo := self.FieldStepNo

	result.StepNo = C.int(FieldStepNo)
	FieldItemsFrozen := self.FieldItemsFrozen

	result.ItemsFrozen = C.int(FieldItemsFrozen)
	FieldRanges := self.FieldRanges
	FieldRangesData := FieldRanges.Data
	FieldRangesDataArg, FieldRangesDataFin := FieldRangesData.handle()
	FieldRangesVecArg := new(C.ImVector_ImGuiListClipperRange)
	FieldRangesVecArg.Size = C.int(FieldRanges.Size)
	FieldRangesVecArg.Capacity = C.int(FieldRanges.Capacity)
	FieldRangesVecArg.Data = FieldRangesDataArg
	FieldRanges.pinner.Pin(FieldRangesVecArg.Data)

	result.Ranges = *FieldRangesVecArg
	releaseFn = func() {
		FieldListClipperFin()

		FieldRangesDataFin()
		FieldRanges.pinner.Unpin()
	}
	return result, releaseFn
}

func (self ListClipperData) c() (result C.ImGuiListClipperData, fin func()) {
	resultPtr, finFn := self.handle()
	return *resultPtr, finFn
}

func newListClipperDataFromC(cvalue *C.ImGuiListClipperData) *ListClipperData {
	result := new(ListClipperData)
	result.FieldListClipper = newListClipperFromC(cvalue.ListClipper)
	result.FieldLossynessOffset = float32(cvalue.LossynessOffset)
	result.FieldStepNo = int32(cvalue.StepNo)
	result.FieldItemsFrozen = int32(cvalue.ItemsFrozen)
	result.FieldRanges = newVectorFromC(cvalue.Ranges.Size, cvalue.Ranges.Capacity, newListClipperRangeFromC(cvalue.Ranges.Data))
	return result
}

// Note that Max is exclusive, so perhaps should be using a Begin/End convention.
type ListClipperRange struct {
	FieldMin                 int32
	FieldMax                 int32
	FieldPosToIndexConvert   bool // Begin/End are absolute position (will be converted to indices later)
	FieldPosToIndexOffsetMin int  // Add to Min after converting to indices
	FieldPosToIndexOffsetMax int  // Add to Min after converting to indices
}

func (self ListClipperRange) handle() (result *C.ImGuiListClipperRange, releaseFn func()) {
	result = new(C.ImGuiListClipperRange)
	FieldMin := self.FieldMin

	result.Min = C.int(FieldMin)
	FieldMax := self.FieldMax

	result.Max = C.int(FieldMax)
	FieldPosToIndexConvert := self.FieldPosToIndexConvert

	result.PosToIndexConvert = C.bool(FieldPosToIndexConvert)
	FieldPosToIndexOffsetMin := self.FieldPosToIndexOffsetMin

	result.PosToIndexOffsetMin = C.ImS8(FieldPosToIndexOffsetMin)
	FieldPosToIndexOffsetMax := self.FieldPosToIndexOffsetMax

	result.PosToIndexOffsetMax = C.ImS8(FieldPosToIndexOffsetMax)
	releaseFn = func() {
	}
	return result, releaseFn
}

func (self ListClipperRange) c() (result C.ImGuiListClipperRange, fin func()) {
	resultPtr, finFn := self.handle()
	return *resultPtr, finFn
}

func newListClipperRangeFromC(cvalue *C.ImGuiListClipperRange) *ListClipperRange {
	result := new(ListClipperRange)
	result.FieldMin = int32(cvalue.Min)
	result.FieldMax = int32(cvalue.Max)
	result.FieldPosToIndexConvert = cvalue.PosToIndexConvert == C.bool(true)
	result.FieldPosToIndexOffsetMin = int(cvalue.PosToIndexOffsetMin)
	result.FieldPosToIndexOffsetMax = int(cvalue.PosToIndexOffsetMax)
	return result
}

type LocEntry struct {
	FieldKey  LocKey
	FieldText string
}

func (self LocEntry) handle() (result *C.ImGuiLocEntry, releaseFn func()) {
	result = new(C.ImGuiLocEntry)
	FieldKey := self.FieldKey

	result.Key = C.ImGuiLocKey(FieldKey)
	FieldText := self.FieldText
	FieldTextArg, FieldTextFin := WrapString(FieldText)
	result.Text = FieldTextArg
	releaseFn = func() {
		FieldTextFin()
	}
	return result, releaseFn
}

func (self LocEntry) c() (result C.ImGuiLocEntry, fin func()) {
	resultPtr, finFn := self.handle()
	return *resultPtr, finFn
}

func newLocEntryFromC(cvalue *C.ImGuiLocEntry) *LocEntry {
	result := new(LocEntry)
	result.FieldKey = LocKey(cvalue.Key)
	result.FieldText = C.GoString(cvalue.Text)
	return result
}

// Simple column measurement, currently used for MenuItem() only.. This is very short-sighted/throw-away code and NOT a generic helper.
type MenuColumns struct {
	// TODO: contains unsupported fields
	data unsafe.Pointer
}

func (self MenuColumns) handle() (result *C.ImGuiMenuColumns, releaseFn func()) {
	result = (*C.ImGuiMenuColumns)(self.data)
	return result, func() {}
}

func (self MenuColumns) c() (result C.ImGuiMenuColumns, fin func()) {
	resultPtr, finFn := self.handle()
	return *resultPtr, finFn
}

func newMenuColumnsFromC(cvalue *C.ImGuiMenuColumns) *MenuColumns {
	result := new(MenuColumns)
	result.data = unsafe.Pointer(cvalue)
	return result
}

type MetricsConfig struct {
	FieldShowDebugLog                 bool
	FieldShowStackTool                bool
	FieldShowWindowsRects             bool
	FieldShowWindowsBeginOrder        bool
	FieldShowTablesRects              bool
	FieldShowDrawCmdMesh              bool
	FieldShowDrawCmdBoundingBoxes     bool
	FieldShowAtlasTintedWithTextColor bool
	FieldShowDockingNodes             bool
	FieldShowWindowsRectsType         int32
	FieldShowTablesRectsType          int32
}

func (self MetricsConfig) handle() (result *C.ImGuiMetricsConfig, releaseFn func()) {
	result = new(C.ImGuiMetricsConfig)
	FieldShowDebugLog := self.FieldShowDebugLog

	result.ShowDebugLog = C.bool(FieldShowDebugLog)
	FieldShowStackTool := self.FieldShowStackTool

	result.ShowStackTool = C.bool(FieldShowStackTool)
	FieldShowWindowsRects := self.FieldShowWindowsRects

	result.ShowWindowsRects = C.bool(FieldShowWindowsRects)
	FieldShowWindowsBeginOrder := self.FieldShowWindowsBeginOrder

	result.ShowWindowsBeginOrder = C.bool(FieldShowWindowsBeginOrder)
	FieldShowTablesRects := self.FieldShowTablesRects

	result.ShowTablesRects = C.bool(FieldShowTablesRects)
	FieldShowDrawCmdMesh := self.FieldShowDrawCmdMesh

	result.ShowDrawCmdMesh = C.bool(FieldShowDrawCmdMesh)
	FieldShowDrawCmdBoundingBoxes := self.FieldShowDrawCmdBoundingBoxes

	result.ShowDrawCmdBoundingBoxes = C.bool(FieldShowDrawCmdBoundingBoxes)
	FieldShowAtlasTintedWithTextColor := self.FieldShowAtlasTintedWithTextColor

	result.ShowAtlasTintedWithTextColor = C.bool(FieldShowAtlasTintedWithTextColor)
	FieldShowDockingNodes := self.FieldShowDockingNodes

	result.ShowDockingNodes = C.bool(FieldShowDockingNodes)
	FieldShowWindowsRectsType := self.FieldShowWindowsRectsType

	result.ShowWindowsRectsType = C.int(FieldShowWindowsRectsType)
	FieldShowTablesRectsType := self.FieldShowTablesRectsType

	result.ShowTablesRectsType = C.int(FieldShowTablesRectsType)
	releaseFn = func() {
	}
	return result, releaseFn
}

func (self MetricsConfig) c() (result C.ImGuiMetricsConfig, fin func()) {
	resultPtr, finFn := self.handle()
	return *resultPtr, finFn
}

func newMetricsConfigFromC(cvalue *C.ImGuiMetricsConfig) *MetricsConfig {
	result := new(MetricsConfig)
	result.FieldShowDebugLog = cvalue.ShowDebugLog == C.bool(true)
	result.FieldShowStackTool = cvalue.ShowStackTool == C.bool(true)
	result.FieldShowWindowsRects = cvalue.ShowWindowsRects == C.bool(true)
	result.FieldShowWindowsBeginOrder = cvalue.ShowWindowsBeginOrder == C.bool(true)
	result.FieldShowTablesRects = cvalue.ShowTablesRects == C.bool(true)
	result.FieldShowDrawCmdMesh = cvalue.ShowDrawCmdMesh == C.bool(true)
	result.FieldShowDrawCmdBoundingBoxes = cvalue.ShowDrawCmdBoundingBoxes == C.bool(true)
	result.FieldShowAtlasTintedWithTextColor = cvalue.ShowAtlasTintedWithTextColor == C.bool(true)
	result.FieldShowDockingNodes = cvalue.ShowDockingNodes == C.bool(true)
	result.FieldShowWindowsRectsType = int32(cvalue.ShowWindowsRectsType)
	result.FieldShowTablesRectsType = int32(cvalue.ShowTablesRectsType)
	return result
}

type NavItemData struct {
	// TODO: contains unsupported fields
	data unsafe.Pointer
}

func (self NavItemData) handle() (result *C.ImGuiNavItemData, releaseFn func()) {
	result = (*C.ImGuiNavItemData)(self.data)
	return result, func() {}
}

func (self NavItemData) c() (result C.ImGuiNavItemData, fin func()) {
	resultPtr, finFn := self.handle()
	return *resultPtr, finFn
}

func newNavItemDataFromC(cvalue *C.ImGuiNavItemData) *NavItemData {
	result := new(NavItemData)
	result.data = unsafe.Pointer(cvalue)
	return result
}

// Store data emitted by TreeNode() for usage by TreePop() to implement ImGuiTreeNodeFlags_NavLeftJumpsBackHere.
// This is the minimum amount of data that we need to perform the equivalent of NavApplyItemToResult() and which we can't infer in TreePop()
// Only stored when the node is a potential candidate for landing on a Left arrow jump.
type NavTreeNodeData struct {
	// TODO: contains unsupported fields
	data unsafe.Pointer
}

func (self NavTreeNodeData) handle() (result *C.ImGuiNavTreeNodeData, releaseFn func()) {
	result = (*C.ImGuiNavTreeNodeData)(self.data)
	return result, func() {}
}

func (self NavTreeNodeData) c() (result C.ImGuiNavTreeNodeData, fin func()) {
	resultPtr, finFn := self.handle()
	return *resultPtr, finFn
}

func newNavTreeNodeDataFromC(cvalue *C.ImGuiNavTreeNodeData) *NavTreeNodeData {
	result := new(NavTreeNodeData)
	result.data = unsafe.Pointer(cvalue)
	return result
}

type NextItemData struct {
	// TODO: contains unsupported fields
	data unsafe.Pointer
}

func (self NextItemData) handle() (result *C.ImGuiNextItemData, releaseFn func()) {
	result = (*C.ImGuiNextItemData)(self.data)
	return result, func() {}
}

func (self NextItemData) c() (result C.ImGuiNextItemData, fin func()) {
	resultPtr, finFn := self.handle()
	return *resultPtr, finFn
}

func newNextItemDataFromC(cvalue *C.ImGuiNextItemData) *NextItemData {
	result := new(NextItemData)
	result.data = unsafe.Pointer(cvalue)
	return result
}

// Storage for SetNexWindow** functions
type NextWindowData struct {
	// TODO: contains unsupported fields
	data unsafe.Pointer
}

func (self NextWindowData) handle() (result *C.ImGuiNextWindowData, releaseFn func()) {
	result = (*C.ImGuiNextWindowData)(self.data)
	return result, func() {}
}

func (self NextWindowData) c() (result C.ImGuiNextWindowData, fin func()) {
	resultPtr, finFn := self.handle()
	return *resultPtr, finFn
}

func newNextWindowDataFromC(cvalue *C.ImGuiNextWindowData) *NextWindowData {
	result := new(NextWindowData)
	result.data = unsafe.Pointer(cvalue)
	return result
}

type OldColumnData struct {
	FieldOffsetNorm             float32 // Column start offset, normalized 0.0 (far left) -> 1.0 (far right)
	FieldOffsetNormBeforeResize float32
	FieldFlags                  OldColumnFlags // Not exposed
	FieldClipRect               Rect
}

func (self OldColumnData) handle() (result *C.ImGuiOldColumnData, releaseFn func()) {
	result = new(C.ImGuiOldColumnData)
	FieldOffsetNorm := self.FieldOffsetNorm

	result.OffsetNorm = C.float(FieldOffsetNorm)
	FieldOffsetNormBeforeResize := self.FieldOffsetNormBeforeResize

	result.OffsetNormBeforeResize = C.float(FieldOffsetNormBeforeResize)
	FieldFlags := self.FieldFlags

	result.Flags = C.ImGuiOldColumnFlags(FieldFlags)
	FieldClipRect := self.FieldClipRect

	result.ClipRect = FieldClipRect.toC()
	releaseFn = func() {
	}
	return result, releaseFn
}

func (self OldColumnData) c() (result C.ImGuiOldColumnData, fin func()) {
	resultPtr, finFn := self.handle()
	return *resultPtr, finFn
}

func newOldColumnDataFromC(cvalue *C.ImGuiOldColumnData) *OldColumnData {
	result := new(OldColumnData)
	result.FieldOffsetNorm = float32(cvalue.OffsetNorm)
	result.FieldOffsetNormBeforeResize = float32(cvalue.OffsetNormBeforeResize)
	result.FieldFlags = OldColumnFlags(cvalue.Flags)
	result.FieldClipRect = *(&Rect{}).fromC(cvalue.ClipRect)
	return result
}

type OldColumns struct {
	// TODO: contains unsupported fields
	data unsafe.Pointer
}

func (self OldColumns) handle() (result *C.ImGuiOldColumns, releaseFn func()) {
	result = (*C.ImGuiOldColumns)(self.data)
	return result, func() {}
}

func (self OldColumns) c() (result C.ImGuiOldColumns, fin func()) {
	resultPtr, finFn := self.handle()
	return *resultPtr, finFn
}

func newOldColumnsFromC(cvalue *C.ImGuiOldColumns) *OldColumns {
	result := new(OldColumns)
	result.data = unsafe.Pointer(cvalue)
	return result
}

// Helper: Execute a block of code at maximum once a frame. Convenient if you want to quickly create a UI within deep-nested code that runs multiple times every frame.
// Usage: static ImGuiOnceUponAFrame oaf; if (oaf) ImGui::Text("This will be called only once per frame");
type OnceUponAFrame struct {
	FieldRefFrame int32
}

func (self OnceUponAFrame) handle() (result *C.ImGuiOnceUponAFrame, releaseFn func()) {
	result = new(C.ImGuiOnceUponAFrame)
	FieldRefFrame := self.FieldRefFrame

	result.RefFrame = C.int(FieldRefFrame)
	releaseFn = func() {
	}
	return result, releaseFn
}

func (self OnceUponAFrame) c() (result C.ImGuiOnceUponAFrame, fin func()) {
	resultPtr, finFn := self.handle()
	return *resultPtr, finFn
}

func newOnceUponAFrameFromC(cvalue *C.ImGuiOnceUponAFrame) *OnceUponAFrame {
	result := new(OnceUponAFrame)
	result.FieldRefFrame = int32(cvalue.RefFrame)
	return result
}

// Data payload for Drag and Drop operations: AcceptDragDropPayload(), GetDragDropPayload()
type Payload struct {
	// TODO: contains unsupported fields
	data unsafe.Pointer
}

func (self Payload) handle() (result *C.ImGuiPayload, releaseFn func()) {
	result = (*C.ImGuiPayload)(self.data)
	return result, func() {}
}

func (self Payload) c() (result C.ImGuiPayload, fin func()) {
	resultPtr, finFn := self.handle()
	return *resultPtr, finFn
}

func newPayloadFromC(cvalue *C.ImGuiPayload) *Payload {
	result := new(Payload)
	result.data = unsafe.Pointer(cvalue)
	return result
}

// (Optional) Access via ImGui::GetPlatformIO()
type PlatformIO struct {
	// TODO: contains unsupported fields
	data unsafe.Pointer
}

func (self PlatformIO) handle() (result *C.ImGuiPlatformIO, releaseFn func()) {
	result = (*C.ImGuiPlatformIO)(self.data)
	return result, func() {}
}

func (self PlatformIO) c() (result C.ImGuiPlatformIO, fin func()) {
	resultPtr, finFn := self.handle()
	return *resultPtr, finFn
}

func newPlatformIOFromC(cvalue *C.ImGuiPlatformIO) *PlatformIO {
	result := new(PlatformIO)
	result.data = unsafe.Pointer(cvalue)
	return result
}

// (Optional) Support for IME (Input Method Editor) via the io.SetPlatformImeDataFn() function.
type PlatformImeData struct {
	FieldWantVisible     bool    // A widget wants the IME to be visible
	FieldInputPos        Vec2    // Position of the input cursor
	FieldInputLineHeight float32 // Line height
}

func (self PlatformImeData) handle() (result *C.ImGuiPlatformImeData, releaseFn func()) {
	result = new(C.ImGuiPlatformImeData)
	FieldWantVisible := self.FieldWantVisible

	result.WantVisible = C.bool(FieldWantVisible)
	FieldInputPos := self.FieldInputPos

	result.InputPos = FieldInputPos.toC()
	FieldInputLineHeight := self.FieldInputLineHeight

	result.InputLineHeight = C.float(FieldInputLineHeight)
	releaseFn = func() {
	}
	return result, releaseFn
}

func (self PlatformImeData) c() (result C.ImGuiPlatformImeData, fin func()) {
	resultPtr, finFn := self.handle()
	return *resultPtr, finFn
}

func newPlatformImeDataFromC(cvalue *C.ImGuiPlatformImeData) *PlatformImeData {
	result := new(PlatformImeData)
	result.FieldWantVisible = cvalue.WantVisible == C.bool(true)
	result.FieldInputPos = *(&Vec2{}).fromC(cvalue.InputPos)
	result.FieldInputLineHeight = float32(cvalue.InputLineHeight)
	return result
}

// (Optional) This is required when enabling multi-viewport. Represent the bounds of each connected monitor/display and their DPI.
// We use this information for multiple DPI support + clamping the position of popups and tooltips so they don't straddle multiple monitors.
type PlatformMonitor struct {
	FieldMainPos        Vec2           // Coordinates of the area displayed on this monitor (Min = upper left, Max = bottom right)
	FieldMainSize       Vec2           // Coordinates of the area displayed on this monitor (Min = upper left, Max = bottom right)
	FieldWorkPos        Vec2           // Coordinates without task bars / side bars / menu bars. Used to avoid positioning popups/tooltips inside this region. If you don't have this info, please copy the value for MainPos/MainSize.
	FieldWorkSize       Vec2           // Coordinates without task bars / side bars / menu bars. Used to avoid positioning popups/tooltips inside this region. If you don't have this info, please copy the value for MainPos/MainSize.
	FieldDpiScale       float32        // 1.0f = 96 DPI
	FieldPlatformHandle unsafe.Pointer // Backend dependant data (e.g. HMONITOR, GLFWmonitor*, SDL Display Index, NSScreen*)
}

func (self PlatformMonitor) handle() (result *C.ImGuiPlatformMonitor, releaseFn func()) {
	result = new(C.ImGuiPlatformMonitor)
	FieldMainPos := self.FieldMainPos

	result.MainPos = FieldMainPos.toC()
	FieldMainSize := self.FieldMainSize

	result.MainSize = FieldMainSize.toC()
	FieldWorkPos := self.FieldWorkPos

	result.WorkPos = FieldWorkPos.toC()
	FieldWorkSize := self.FieldWorkSize

	result.WorkSize = FieldWorkSize.toC()
	FieldDpiScale := self.FieldDpiScale

	result.DpiScale = C.float(FieldDpiScale)
	FieldPlatformHandle := self.FieldPlatformHandle
	FieldPlatformHandleArg, FieldPlatformHandleFin := WrapVoidPtr(FieldPlatformHandle)
	result.PlatformHandle = FieldPlatformHandleArg
	releaseFn = func() {
		FieldPlatformHandleFin()
	}
	return result, releaseFn
}

func (self PlatformMonitor) c() (result C.ImGuiPlatformMonitor, fin func()) {
	resultPtr, finFn := self.handle()
	return *resultPtr, finFn
}

func newPlatformMonitorFromC(cvalue *C.ImGuiPlatformMonitor) *PlatformMonitor {
	result := new(PlatformMonitor)
	result.FieldMainPos = *(&Vec2{}).fromC(cvalue.MainPos)
	result.FieldMainSize = *(&Vec2{}).fromC(cvalue.MainSize)
	result.FieldWorkPos = *(&Vec2{}).fromC(cvalue.WorkPos)
	result.FieldWorkSize = *(&Vec2{}).fromC(cvalue.WorkSize)
	result.FieldDpiScale = float32(cvalue.DpiScale)
	result.FieldPlatformHandle = unsafe.Pointer(cvalue.PlatformHandle)
	return result
}

// Storage for current popup stack
type PopupData struct {
	// TODO: contains unsupported fields
	data unsafe.Pointer
}

func (self PopupData) handle() (result *C.ImGuiPopupData, releaseFn func()) {
	result = (*C.ImGuiPopupData)(self.data)
	return result, func() {}
}

func (self PopupData) c() (result C.ImGuiPopupData, fin func()) {
	resultPtr, finFn := self.handle()
	return *resultPtr, finFn
}

func newPopupDataFromC(cvalue *C.ImGuiPopupData) *PopupData {
	result := new(PopupData)
	result.data = unsafe.Pointer(cvalue)
	return result
}

type PtrOrIndex struct {
	FieldPtr   unsafe.Pointer // Either field can be set, not both. e.g. Dock node tab bars are loose while BeginTabBar() ones are in a pool.
	FieldIndex int32          // Usually index in a main pool.
}

func (self PtrOrIndex) handle() (result *C.ImGuiPtrOrIndex, releaseFn func()) {
	result = new(C.ImGuiPtrOrIndex)
	FieldPtr := self.FieldPtr
	FieldPtrArg, FieldPtrFin := WrapVoidPtr(FieldPtr)
	result.Ptr = FieldPtrArg
	FieldIndex := self.FieldIndex

	result.Index = C.int(FieldIndex)
	releaseFn = func() {
		FieldPtrFin()
	}
	return result, releaseFn
}

func (self PtrOrIndex) c() (result C.ImGuiPtrOrIndex, fin func()) {
	resultPtr, finFn := self.handle()
	return *resultPtr, finFn
}

func newPtrOrIndexFromC(cvalue *C.ImGuiPtrOrIndex) *PtrOrIndex {
	result := new(PtrOrIndex)
	result.FieldPtr = unsafe.Pointer(cvalue.Ptr)
	result.FieldIndex = int32(cvalue.Index)
	return result
}

type SettingsHandler struct {
	// TODO: contains unsupported fields
	data unsafe.Pointer
}

func (self SettingsHandler) handle() (result *C.ImGuiSettingsHandler, releaseFn func()) {
	result = (*C.ImGuiSettingsHandler)(self.data)
	return result, func() {}
}

func (self SettingsHandler) c() (result C.ImGuiSettingsHandler, fin func()) {
	resultPtr, finFn := self.handle()
	return *resultPtr, finFn
}

func newSettingsHandlerFromC(cvalue *C.ImGuiSettingsHandler) *SettingsHandler {
	result := new(SettingsHandler)
	result.data = unsafe.Pointer(cvalue)
	return result
}

type ShrinkWidthItem struct {
	FieldIndex        int32
	FieldWidth        float32
	FieldInitialWidth float32
}

func (self ShrinkWidthItem) handle() (result *C.ImGuiShrinkWidthItem, releaseFn func()) {
	result = new(C.ImGuiShrinkWidthItem)
	FieldIndex := self.FieldIndex

	result.Index = C.int(FieldIndex)
	FieldWidth := self.FieldWidth

	result.Width = C.float(FieldWidth)
	FieldInitialWidth := self.FieldInitialWidth

	result.InitialWidth = C.float(FieldInitialWidth)
	releaseFn = func() {
	}
	return result, releaseFn
}

func (self ShrinkWidthItem) c() (result C.ImGuiShrinkWidthItem, fin func()) {
	resultPtr, finFn := self.handle()
	return *resultPtr, finFn
}

func newShrinkWidthItemFromC(cvalue *C.ImGuiShrinkWidthItem) *ShrinkWidthItem {
	result := new(ShrinkWidthItem)
	result.FieldIndex = int32(cvalue.Index)
	result.FieldWidth = float32(cvalue.Width)
	result.FieldInitialWidth = float32(cvalue.InitialWidth)
	return result
}

// Resizing callback data to apply custom constraint. As enabled by SetNextWindowSizeConstraints(). Callback is called during the next Begin().
// NB: For basic min/max size constraint on each axis you don't need to use the callback! The SetNextWindowSizeConstraints() parameters are enough.
type SizeCallbackData struct {
	FieldUserData    unsafe.Pointer // Read-only.   What user passed to SetNextWindowSizeConstraints(). Generally store an integer or float in here (need reinterpret_cast<>).
	FieldPos         Vec2           // Read-only.   Window position, for reference.
	FieldCurrentSize Vec2           // Read-only.   Current window size.
	FieldDesiredSize Vec2           // Read-write.  Desired size, based on user's mouse position. Write to this field to restrain resizing.
}

func (self SizeCallbackData) handle() (result *C.ImGuiSizeCallbackData, releaseFn func()) {
	result = new(C.ImGuiSizeCallbackData)
	FieldUserData := self.FieldUserData
	FieldUserDataArg, FieldUserDataFin := WrapVoidPtr(FieldUserData)
	result.UserData = FieldUserDataArg
	FieldPos := self.FieldPos

	result.Pos = FieldPos.toC()
	FieldCurrentSize := self.FieldCurrentSize

	result.CurrentSize = FieldCurrentSize.toC()
	FieldDesiredSize := self.FieldDesiredSize

	result.DesiredSize = FieldDesiredSize.toC()
	releaseFn = func() {
		FieldUserDataFin()
	}
	return result, releaseFn
}

func (self SizeCallbackData) c() (result C.ImGuiSizeCallbackData, fin func()) {
	resultPtr, finFn := self.handle()
	return *resultPtr, finFn
}

func newSizeCallbackDataFromC(cvalue *C.ImGuiSizeCallbackData) *SizeCallbackData {
	result := new(SizeCallbackData)
	result.FieldUserData = unsafe.Pointer(cvalue.UserData)
	result.FieldPos = *(&Vec2{}).fromC(cvalue.Pos)
	result.FieldCurrentSize = *(&Vec2{}).fromC(cvalue.CurrentSize)
	result.FieldDesiredSize = *(&Vec2{}).fromC(cvalue.DesiredSize)
	return result
}

type StackLevelInfo struct {
	// TODO: contains unsupported fields
	data unsafe.Pointer
}

func (self StackLevelInfo) handle() (result *C.ImGuiStackLevelInfo, releaseFn func()) {
	result = (*C.ImGuiStackLevelInfo)(self.data)
	return result, func() {}
}

func (self StackLevelInfo) c() (result C.ImGuiStackLevelInfo, fin func()) {
	resultPtr, finFn := self.handle()
	return *resultPtr, finFn
}

func newStackLevelInfoFromC(cvalue *C.ImGuiStackLevelInfo) *StackLevelInfo {
	result := new(StackLevelInfo)
	result.data = unsafe.Pointer(cvalue)
	return result
}

type StackSizes struct {
	FieldSizeOfIDStack         int16
	FieldSizeOfColorStack      int16
	FieldSizeOfStyleVarStack   int16
	FieldSizeOfFontStack       int16
	FieldSizeOfFocusScopeStack int16
	FieldSizeOfGroupStack      int16
	FieldSizeOfItemFlagsStack  int16
	FieldSizeOfBeginPopupStack int16
	FieldSizeOfDisabledStack   int16
}

func (self StackSizes) handle() (result *C.ImGuiStackSizes, releaseFn func()) {
	result = new(C.ImGuiStackSizes)
	FieldSizeOfIDStack := self.FieldSizeOfIDStack

	result.SizeOfIDStack = C.short(FieldSizeOfIDStack)
	FieldSizeOfColorStack := self.FieldSizeOfColorStack

	result.SizeOfColorStack = C.short(FieldSizeOfColorStack)
	FieldSizeOfStyleVarStack := self.FieldSizeOfStyleVarStack

	result.SizeOfStyleVarStack = C.short(FieldSizeOfStyleVarStack)
	FieldSizeOfFontStack := self.FieldSizeOfFontStack

	result.SizeOfFontStack = C.short(FieldSizeOfFontStack)
	FieldSizeOfFocusScopeStack := self.FieldSizeOfFocusScopeStack

	result.SizeOfFocusScopeStack = C.short(FieldSizeOfFocusScopeStack)
	FieldSizeOfGroupStack := self.FieldSizeOfGroupStack

	result.SizeOfGroupStack = C.short(FieldSizeOfGroupStack)
	FieldSizeOfItemFlagsStack := self.FieldSizeOfItemFlagsStack

	result.SizeOfItemFlagsStack = C.short(FieldSizeOfItemFlagsStack)
	FieldSizeOfBeginPopupStack := self.FieldSizeOfBeginPopupStack

	result.SizeOfBeginPopupStack = C.short(FieldSizeOfBeginPopupStack)
	FieldSizeOfDisabledStack := self.FieldSizeOfDisabledStack

	result.SizeOfDisabledStack = C.short(FieldSizeOfDisabledStack)
	releaseFn = func() {
	}
	return result, releaseFn
}

func (self StackSizes) c() (result C.ImGuiStackSizes, fin func()) {
	resultPtr, finFn := self.handle()
	return *resultPtr, finFn
}

func newStackSizesFromC(cvalue *C.ImGuiStackSizes) *StackSizes {
	result := new(StackSizes)
	result.FieldSizeOfIDStack = int16(cvalue.SizeOfIDStack)
	result.FieldSizeOfColorStack = int16(cvalue.SizeOfColorStack)
	result.FieldSizeOfStyleVarStack = int16(cvalue.SizeOfStyleVarStack)
	result.FieldSizeOfFontStack = int16(cvalue.SizeOfFontStack)
	result.FieldSizeOfFocusScopeStack = int16(cvalue.SizeOfFocusScopeStack)
	result.FieldSizeOfGroupStack = int16(cvalue.SizeOfGroupStack)
	result.FieldSizeOfItemFlagsStack = int16(cvalue.SizeOfItemFlagsStack)
	result.FieldSizeOfBeginPopupStack = int16(cvalue.SizeOfBeginPopupStack)
	result.FieldSizeOfDisabledStack = int16(cvalue.SizeOfDisabledStack)
	return result
}

// State for Stack tool queries
type StackTool struct {
	// TODO: contains unsupported fields
	data unsafe.Pointer
}

func (self StackTool) handle() (result *C.ImGuiStackTool, releaseFn func()) {
	result = (*C.ImGuiStackTool)(self.data)
	return result, func() {}
}

func (self StackTool) c() (result C.ImGuiStackTool, fin func()) {
	resultPtr, finFn := self.handle()
	return *resultPtr, finFn
}

func newStackToolFromC(cvalue *C.ImGuiStackTool) *StackTool {
	result := new(StackTool)
	result.data = unsafe.Pointer(cvalue)
	return result
}

// Helper: Key->Value storage
// Typically you don't have to worry about this since a storage is held within each Window.
// We use it to e.g. store collapse state for a tree (Int 0/1)
// This is optimized for efficient lookup (dichotomy into a contiguous buffer) and rare insertion (typically tied to user interactions aka max once a frame)
// You can use it as custom user storage for temporary values. Declare your own storage if, for example:
// - You want to manipulate the open/close state of a particular sub-tree in your interface (tree node uses Int 0/1 to store their state).
// - You want to store custom debug data easily without adding or editing structures in your code (probably not efficient, but convenient)
// Types are NOT stored, so it is up to you to make sure your Key don't collide with different types.
type Storage struct {
	FieldData Vector[*StoragePair]
}

func (self Storage) handle() (result *C.ImGuiStorage, releaseFn func()) {
	result = new(C.ImGuiStorage)
	FieldData := self.FieldData
	FieldDataData := FieldData.Data
	FieldDataDataArg, FieldDataDataFin := FieldDataData.handle()
	FieldDataVecArg := new(C.ImVector_ImGuiStoragePair)
	FieldDataVecArg.Size = C.int(FieldData.Size)
	FieldDataVecArg.Capacity = C.int(FieldData.Capacity)
	FieldDataVecArg.Data = FieldDataDataArg
	FieldData.pinner.Pin(FieldDataVecArg.Data)

	result.Data = *FieldDataVecArg
	releaseFn = func() {
		FieldDataDataFin()
		FieldData.pinner.Unpin()
	}
	return result, releaseFn
}

func (self Storage) c() (result C.ImGuiStorage, fin func()) {
	resultPtr, finFn := self.handle()
	return *resultPtr, finFn
}

func newStorageFromC(cvalue *C.ImGuiStorage) *Storage {
	result := new(Storage)
	result.FieldData = newVectorFromC(cvalue.Data.Size, cvalue.Data.Capacity, newStoragePairFromC(cvalue.Data.Data))
	return result
}

// [Internal]
type StoragePair struct {
	// TODO: contains unsupported fields
	data unsafe.Pointer
}

func (self StoragePair) handle() (result *C.ImGuiStoragePair, releaseFn func()) {
	result = (*C.ImGuiStoragePair)(self.data)
	return result, func() {}
}

func (self StoragePair) c() (result C.ImGuiStoragePair, fin func()) {
	resultPtr, finFn := self.handle()
	return *resultPtr, finFn
}

func newStoragePairFromC(cvalue *C.ImGuiStoragePair) *StoragePair {
	result := new(StoragePair)
	result.data = unsafe.Pointer(cvalue)
	return result
}

type Style struct {
	// TODO: contains unsupported fields
	data unsafe.Pointer
}

func (self Style) handle() (result *C.ImGuiStyle, releaseFn func()) {
	result = (*C.ImGuiStyle)(self.data)
	return result, func() {}
}

func (self Style) c() (result C.ImGuiStyle, fin func()) {
	resultPtr, finFn := self.handle()
	return *resultPtr, finFn
}

func newStyleFromC(cvalue *C.ImGuiStyle) *Style {
	result := new(Style)
	result.data = unsafe.Pointer(cvalue)
	return result
}

// Stacked style modifier, backup of modified data so we can restore it. Data type inferred from the variable.
type StyleMod struct {
	// TODO: contains unsupported fields
	data unsafe.Pointer
}

func (self StyleMod) handle() (result *C.ImGuiStyleMod, releaseFn func()) {
	result = (*C.ImGuiStyleMod)(self.data)
	return result, func() {}
}

func (self StyleMod) c() (result C.ImGuiStyleMod, fin func()) {
	resultPtr, finFn := self.handle()
	return *resultPtr, finFn
}

func newStyleModFromC(cvalue *C.ImGuiStyleMod) *StyleMod {
	result := new(StyleMod)
	result.data = unsafe.Pointer(cvalue)
	return result
}

// Storage for a tab bar (sizeof() 152 bytes)
type TabBar struct {
	// TODO: contains unsupported fields
	data unsafe.Pointer
}

func (self TabBar) handle() (result *C.ImGuiTabBar, releaseFn func()) {
	result = (*C.ImGuiTabBar)(self.data)
	return result, func() {}
}

func (self TabBar) c() (result C.ImGuiTabBar, fin func()) {
	resultPtr, finFn := self.handle()
	return *resultPtr, finFn
}

func newTabBarFromC(cvalue *C.ImGuiTabBar) *TabBar {
	result := new(TabBar)
	result.data = unsafe.Pointer(cvalue)
	return result
}

// Storage for one active tab item (sizeof() 48 bytes)
type TabItem struct {
	// TODO: contains unsupported fields
	data unsafe.Pointer
}

func (self TabItem) handle() (result *C.ImGuiTabItem, releaseFn func()) {
	result = (*C.ImGuiTabItem)(self.data)
	return result, func() {}
}

func (self TabItem) c() (result C.ImGuiTabItem, fin func()) {
	resultPtr, finFn := self.handle()
	return *resultPtr, finFn
}

func newTabItemFromC(cvalue *C.ImGuiTabItem) *TabItem {
	result := new(TabItem)
	result.data = unsafe.Pointer(cvalue)
	return result
}

// FIXME-TABLE: more transient data could be stored in a stacked ImGuiTableTempData: e.g. SortSpecs, incoming RowData
// sizeof() ~ 580 bytes + heap allocs described in TableBeginInitMemory()
type Table struct {
	// TODO: contains unsupported fields
	data unsafe.Pointer
}

func (self Table) handle() (result *C.ImGuiTable, releaseFn func()) {
	result = (*C.ImGuiTable)(self.data)
	return result, func() {}
}

func (self Table) c() (result C.ImGuiTable, fin func()) {
	resultPtr, finFn := self.handle()
	return *resultPtr, finFn
}

func newTableFromC(cvalue *C.ImGuiTable) *Table {
	result := new(Table)
	result.data = unsafe.Pointer(cvalue)
	return result
}

// Transient cell data stored per row.
// sizeof() ~ 6
type TableCellData struct {
	// TODO: contains unsupported fields
	data unsafe.Pointer
}

func (self TableCellData) handle() (result *C.ImGuiTableCellData, releaseFn func()) {
	result = (*C.ImGuiTableCellData)(self.data)
	return result, func() {}
}

func (self TableCellData) c() (result C.ImGuiTableCellData, fin func()) {
	resultPtr, finFn := self.handle()
	return *resultPtr, finFn
}

func newTableCellDataFromC(cvalue *C.ImGuiTableCellData) *TableCellData {
	result := new(TableCellData)
	result.data = unsafe.Pointer(cvalue)
	return result
}

// [Internal] sizeof() ~ 112
// We use the terminology "Enabled" to refer to a column that is not Hidden by user/api.
// We use the terminology "Clipped" to refer to a column that is out of sight because of scrolling/clipping.
// This is in contrast with some user-facing api such as IsItemVisible() / IsRectVisible() which use "Visible" to mean "not clipped".
type TableColumn struct {
	// TODO: contains unsupported fields
	data unsafe.Pointer
}

func (self TableColumn) handle() (result *C.ImGuiTableColumn, releaseFn func()) {
	result = (*C.ImGuiTableColumn)(self.data)
	return result, func() {}
}

func (self TableColumn) c() (result C.ImGuiTableColumn, fin func()) {
	resultPtr, finFn := self.handle()
	return *resultPtr, finFn
}

func newTableColumnFromC(cvalue *C.ImGuiTableColumn) *TableColumn {
	result := new(TableColumn)
	result.data = unsafe.Pointer(cvalue)
	return result
}

// sizeof() ~ 12
type TableColumnSettings struct {
	// TODO: contains unsupported fields
	data unsafe.Pointer
}

func (self TableColumnSettings) handle() (result *C.ImGuiTableColumnSettings, releaseFn func()) {
	result = (*C.ImGuiTableColumnSettings)(self.data)
	return result, func() {}
}

func (self TableColumnSettings) c() (result C.ImGuiTableColumnSettings, fin func()) {
	resultPtr, finFn := self.handle()
	return *resultPtr, finFn
}

func newTableColumnSettingsFromC(cvalue *C.ImGuiTableColumnSettings) *TableColumnSettings {
	result := new(TableColumnSettings)
	result.data = unsafe.Pointer(cvalue)
	return result
}

// Sorting specification for one column of a table (sizeof == 12 bytes)
type TableColumnSortSpecs struct {
	// TODO: contains unsupported fields
	data unsafe.Pointer
}

func (self TableColumnSortSpecs) handle() (result *C.ImGuiTableColumnSortSpecs, releaseFn func()) {
	result = (*C.ImGuiTableColumnSortSpecs)(self.data)
	return result, func() {}
}

func (self TableColumnSortSpecs) c() (result C.ImGuiTableColumnSortSpecs, fin func()) {
	resultPtr, finFn := self.handle()
	return *resultPtr, finFn
}

func newTableColumnSortSpecsFromC(cvalue *C.ImGuiTableColumnSortSpecs) *TableColumnSortSpecs {
	result := new(TableColumnSortSpecs)
	result.data = unsafe.Pointer(cvalue)
	return result
}

// Per-instance data that needs preserving across frames (seemingly most others do not need to be preserved aside from debug needs. Does that means they could be moved to ImGuiTableTempData?)
type TableInstanceData struct {
	// TODO: contains unsupported fields
	data unsafe.Pointer
}

func (self TableInstanceData) handle() (result *C.ImGuiTableInstanceData, releaseFn func()) {
	result = (*C.ImGuiTableInstanceData)(self.data)
	return result, func() {}
}

func (self TableInstanceData) c() (result C.ImGuiTableInstanceData, fin func()) {
	resultPtr, finFn := self.handle()
	return *resultPtr, finFn
}

func newTableInstanceDataFromC(cvalue *C.ImGuiTableInstanceData) *TableInstanceData {
	result := new(TableInstanceData)
	result.data = unsafe.Pointer(cvalue)
	return result
}

// This is designed to be stored in a single ImChunkStream (1 header followed by N ImGuiTableColumnSettings, etc.)
type TableSettings struct {
	// TODO: contains unsupported fields
	data unsafe.Pointer
}

func (self TableSettings) handle() (result *C.ImGuiTableSettings, releaseFn func()) {
	result = (*C.ImGuiTableSettings)(self.data)
	return result, func() {}
}

func (self TableSettings) c() (result C.ImGuiTableSettings, fin func()) {
	resultPtr, finFn := self.handle()
	return *resultPtr, finFn
}

func newTableSettingsFromC(cvalue *C.ImGuiTableSettings) *TableSettings {
	result := new(TableSettings)
	result.data = unsafe.Pointer(cvalue)
	return result
}

// Sorting specifications for a table (often handling sort specs for a single column, occasionally more)
// Obtained by calling TableGetSortSpecs().
// When 'SpecsDirty == true' you can sort your data. It will be true with sorting specs have changed since last call, or the first time.
// Make sure to set 'SpecsDirty = false' after sorting, else you may wastefully sort your data every frame!
type TableSortSpecs struct {
	FieldSpecs      *TableColumnSortSpecs // Pointer to sort spec array.
	FieldSpecsCount int32                 // Sort spec count. Most often 1. May be > 1 when ImGuiTableFlags_SortMulti is enabled. May be == 0 when ImGuiTableFlags_SortTristate is enabled.
	FieldSpecsDirty bool                  // Set to true when specs have changed since last time! Use this to sort again, then clear the flag.
}

func (self TableSortSpecs) handle() (result *C.ImGuiTableSortSpecs, releaseFn func()) {
	result = new(C.ImGuiTableSortSpecs)
	FieldSpecs := self.FieldSpecs
	FieldSpecsArg, FieldSpecsFin := FieldSpecs.handle()
	result.Specs = FieldSpecsArg
	FieldSpecsCount := self.FieldSpecsCount

	result.SpecsCount = C.int(FieldSpecsCount)
	FieldSpecsDirty := self.FieldSpecsDirty

	result.SpecsDirty = C.bool(FieldSpecsDirty)
	releaseFn = func() {
		FieldSpecsFin()
	}
	return result, releaseFn
}

func (self TableSortSpecs) c() (result C.ImGuiTableSortSpecs, fin func()) {
	resultPtr, finFn := self.handle()
	return *resultPtr, finFn
}

func newTableSortSpecsFromC(cvalue *C.ImGuiTableSortSpecs) *TableSortSpecs {
	result := new(TableSortSpecs)
	result.FieldSpecs = newTableColumnSortSpecsFromC(cvalue.Specs)
	result.FieldSpecsCount = int32(cvalue.SpecsCount)
	result.FieldSpecsDirty = cvalue.SpecsDirty == C.bool(true)
	return result
}

// Transient data that are only needed between BeginTable() and EndTable(), those buffers are shared (1 per level of stacked table).
// - Accessing those requires chasing an extra pointer so for very frequently used data we leave them in the main table structure.
// - We also leave out of this structure data that tend to be particularly useful for debugging/metrics.
// sizeof() ~ 112 bytes.
type TableTempData struct {
	FieldTableIndex                   int32   // Index in g.Tables.Buf[] pool
	FieldLastTimeActive               float32 // Last timestamp this structure was used
	FieldUserOuterSize                Vec2    // outer_size.x passed to BeginTable()
	FieldDrawSplitter                 DrawListSplitter
	FieldHostBackupWorkRect           Rect    // Backup of InnerWindow->WorkRect at the end of BeginTable()
	FieldHostBackupParentWorkRect     Rect    // Backup of InnerWindow->ParentWorkRect at the end of BeginTable()
	FieldHostBackupPrevLineSize       Vec2    // Backup of InnerWindow->DC.PrevLineSize at the end of BeginTable()
	FieldHostBackupCurrLineSize       Vec2    // Backup of InnerWindow->DC.CurrLineSize at the end of BeginTable()
	FieldHostBackupCursorMaxPos       Vec2    // Backup of InnerWindow->DC.CursorMaxPos at the end of BeginTable()
	FieldHostBackupColumnsOffset      Vec1    // Backup of OuterWindow->DC.ColumnsOffset at the end of BeginTable()
	FieldHostBackupItemWidth          float32 // Backup of OuterWindow->DC.ItemWidth at the end of BeginTable()
	FieldHostBackupItemWidthStackSize int32   // Backup of OuterWindow->DC.ItemWidthStack.Size at the end of BeginTable()

}

func (self TableTempData) handle() (result *C.ImGuiTableTempData, releaseFn func()) {
	result = new(C.ImGuiTableTempData)
	FieldTableIndex := self.FieldTableIndex

	result.TableIndex = C.int(FieldTableIndex)
	FieldLastTimeActive := self.FieldLastTimeActive

	result.LastTimeActive = C.float(FieldLastTimeActive)
	FieldUserOuterSize := self.FieldUserOuterSize

	result.UserOuterSize = FieldUserOuterSize.toC()
	FieldDrawSplitter := self.FieldDrawSplitter
	FieldDrawSplitterArg, FieldDrawSplitterFin := FieldDrawSplitter.c()
	result.DrawSplitter = FieldDrawSplitterArg
	FieldHostBackupWorkRect := self.FieldHostBackupWorkRect

	result.HostBackupWorkRect = FieldHostBackupWorkRect.toC()
	FieldHostBackupParentWorkRect := self.FieldHostBackupParentWorkRect

	result.HostBackupParentWorkRect = FieldHostBackupParentWorkRect.toC()
	FieldHostBackupPrevLineSize := self.FieldHostBackupPrevLineSize

	result.HostBackupPrevLineSize = FieldHostBackupPrevLineSize.toC()
	FieldHostBackupCurrLineSize := self.FieldHostBackupCurrLineSize

	result.HostBackupCurrLineSize = FieldHostBackupCurrLineSize.toC()
	FieldHostBackupCursorMaxPos := self.FieldHostBackupCursorMaxPos

	result.HostBackupCursorMaxPos = FieldHostBackupCursorMaxPos.toC()
	FieldHostBackupColumnsOffset := self.FieldHostBackupColumnsOffset
	FieldHostBackupColumnsOffsetArg, FieldHostBackupColumnsOffsetFin := FieldHostBackupColumnsOffset.c()
	result.HostBackupColumnsOffset = FieldHostBackupColumnsOffsetArg
	FieldHostBackupItemWidth := self.FieldHostBackupItemWidth

	result.HostBackupItemWidth = C.float(FieldHostBackupItemWidth)
	FieldHostBackupItemWidthStackSize := self.FieldHostBackupItemWidthStackSize

	result.HostBackupItemWidthStackSize = C.int(FieldHostBackupItemWidthStackSize)
	releaseFn = func() {
		FieldDrawSplitterFin()

		FieldHostBackupColumnsOffsetFin()
	}
	return result, releaseFn
}

func (self TableTempData) c() (result C.ImGuiTableTempData, fin func()) {
	resultPtr, finFn := self.handle()
	return *resultPtr, finFn
}

func newTableTempDataFromC(cvalue *C.ImGuiTableTempData) *TableTempData {
	result := new(TableTempData)
	result.FieldTableIndex = int32(cvalue.TableIndex)
	result.FieldLastTimeActive = float32(cvalue.LastTimeActive)
	result.FieldUserOuterSize = *(&Vec2{}).fromC(cvalue.UserOuterSize)
	result.FieldDrawSplitter = *newDrawListSplitterFromC(func() *C.ImDrawListSplitter { result := cvalue.DrawSplitter; return &result }())

	result.FieldHostBackupWorkRect = *(&Rect{}).fromC(cvalue.HostBackupWorkRect)
	result.FieldHostBackupParentWorkRect = *(&Rect{}).fromC(cvalue.HostBackupParentWorkRect)
	result.FieldHostBackupPrevLineSize = *(&Vec2{}).fromC(cvalue.HostBackupPrevLineSize)
	result.FieldHostBackupCurrLineSize = *(&Vec2{}).fromC(cvalue.HostBackupCurrLineSize)
	result.FieldHostBackupCursorMaxPos = *(&Vec2{}).fromC(cvalue.HostBackupCursorMaxPos)
	result.FieldHostBackupColumnsOffset = *newVec1FromC(func() *C.ImVec1 { result := cvalue.HostBackupColumnsOffset; return &result }())

	result.FieldHostBackupItemWidth = float32(cvalue.HostBackupItemWidth)
	result.FieldHostBackupItemWidthStackSize = int32(cvalue.HostBackupItemWidthStackSize)
	return result
}

// Helper: Growable text buffer for logging/accumulating text
// (this could be called 'ImGuiTextBuilder' / 'ImGuiStringBuilder')
type TextBuffer struct {
	FieldBuf Vector[string]
}

func (self TextBuffer) handle() (result *C.ImGuiTextBuffer, releaseFn func()) {
	result = new(C.ImGuiTextBuffer)
	FieldBuf := self.FieldBuf
	FieldBufData := FieldBuf.Data
	FieldBufDataArg, FieldBufDataFin := WrapString(FieldBufData)
	FieldBufVecArg := new(C.ImVector_char)
	FieldBufVecArg.Size = C.int(FieldBuf.Size)
	FieldBufVecArg.Capacity = C.int(FieldBuf.Capacity)
	FieldBufVecArg.Data = FieldBufDataArg
	FieldBuf.pinner.Pin(FieldBufVecArg.Data)

	result.Buf = *FieldBufVecArg
	releaseFn = func() {
		FieldBufDataFin()
		FieldBuf.pinner.Unpin()
	}
	return result, releaseFn
}

func (self TextBuffer) c() (result C.ImGuiTextBuffer, fin func()) {
	resultPtr, finFn := self.handle()
	return *resultPtr, finFn
}

func newTextBufferFromC(cvalue *C.ImGuiTextBuffer) *TextBuffer {
	result := new(TextBuffer)
	result.FieldBuf = newVectorFromC(cvalue.Buf.Size, cvalue.Buf.Capacity, C.GoString(cvalue.Buf.Data))
	return result
}

// Helper: Parse and apply text filters. In format "aaaaa[,bbbb][,ccccc]"
type TextFilter struct {
	// TODO: contains unsupported fields
	data unsafe.Pointer
}

func (self TextFilter) handle() (result *C.ImGuiTextFilter, releaseFn func()) {
	result = (*C.ImGuiTextFilter)(self.data)
	return result, func() {}
}

func (self TextFilter) c() (result C.ImGuiTextFilter, fin func()) {
	resultPtr, finFn := self.handle()
	return *resultPtr, finFn
}

func newTextFilterFromC(cvalue *C.ImGuiTextFilter) *TextFilter {
	result := new(TextFilter)
	result.data = unsafe.Pointer(cvalue)
	return result
}

// Helper: ImGuiTextIndex<>
// Maintain a line index for a text buffer. This is a strong candidate to be moved into the public API.
type TextIndex struct {
	FieldLineOffsets Vector[*int32]
	FieldEndOffset   int32 // Because we don't own text buffer we need to maintain EndOffset (may bake in LineOffsets?)
}

func (self TextIndex) handle() (result *C.ImGuiTextIndex, releaseFn func()) {
	result = new(C.ImGuiTextIndex)
	FieldLineOffsets := self.FieldLineOffsets
	FieldLineOffsetsData := FieldLineOffsets.Data
	FieldLineOffsetsDataArg, FieldLineOffsetsDataFin := WrapNumberPtr[C.int, int32](FieldLineOffsetsData)
	FieldLineOffsetsVecArg := new(C.ImVector_int)
	FieldLineOffsetsVecArg.Size = C.int(FieldLineOffsets.Size)
	FieldLineOffsetsVecArg.Capacity = C.int(FieldLineOffsets.Capacity)
	FieldLineOffsetsVecArg.Data = FieldLineOffsetsDataArg
	FieldLineOffsets.pinner.Pin(FieldLineOffsetsVecArg.Data)

	result.LineOffsets = *FieldLineOffsetsVecArg
	FieldEndOffset := self.FieldEndOffset

	result.EndOffset = C.int(FieldEndOffset)
	releaseFn = func() {
		FieldLineOffsetsDataFin()
		FieldLineOffsets.pinner.Unpin()
	}
	return result, releaseFn
}

func (self TextIndex) c() (result C.ImGuiTextIndex, fin func()) {
	resultPtr, finFn := self.handle()
	return *resultPtr, finFn
}

func newTextIndexFromC(cvalue *C.ImGuiTextIndex) *TextIndex {
	result := new(TextIndex)
	result.FieldLineOffsets = newVectorFromC(cvalue.LineOffsets.Size, cvalue.LineOffsets.Capacity, (*int32)(cvalue.LineOffsets.Data))
	result.FieldEndOffset = int32(cvalue.EndOffset)
	return result
}

// [Internal]
type TextRange struct {
	FieldB string
	FieldE string
}

func (self TextRange) handle() (result *C.ImGuiTextRange, releaseFn func()) {
	result = new(C.ImGuiTextRange)
	FieldB := self.FieldB
	FieldBArg, FieldBFin := WrapString(FieldB)
	result.b = FieldBArg
	FieldE := self.FieldE
	FieldEArg, FieldEFin := WrapString(FieldE)
	result.e = FieldEArg
	releaseFn = func() {
		FieldBFin()
		FieldEFin()
	}
	return result, releaseFn
}

func (self TextRange) c() (result C.ImGuiTextRange, fin func()) {
	resultPtr, finFn := self.handle()
	return *resultPtr, finFn
}

func newTextRangeFromC(cvalue *C.ImGuiTextRange) *TextRange {
	result := new(TextRange)
	result.FieldB = C.GoString(cvalue.b)
	result.FieldE = C.GoString(cvalue.e)
	return result
}

// Returned by GetTypingSelectRequest(), designed to eventually be public.
type TypingSelectRequest struct {
	FieldFlags           TypingSelectFlags // Flags passed to GetTypingSelectRequest()
	FieldSearchBufferLen int32
	FieldSearchBuffer    string // Search buffer contents (use full string. unless SingleCharMode is set, in which case use SingleCharSize).
	FieldSelectRequest   bool   // Set when buffer was modified this frame, requesting a selection.
	FieldSingleCharMode  bool   // Notify when buffer contains same character repeated, to implement special mode. In this situation it preferred to not display any on-screen search indication.
	FieldSingleCharSize  int    // Length in bytes of first letter codepoint (1 for ascii, 2-4 for UTF-8). If (SearchBufferLen==RepeatCharSize) only 1 letter has been input.
}

func (self TypingSelectRequest) handle() (result *C.ImGuiTypingSelectRequest, releaseFn func()) {
	result = new(C.ImGuiTypingSelectRequest)
	FieldFlags := self.FieldFlags

	result.Flags = C.ImGuiTypingSelectFlags(FieldFlags)
	FieldSearchBufferLen := self.FieldSearchBufferLen

	result.SearchBufferLen = C.int(FieldSearchBufferLen)
	FieldSearchBuffer := self.FieldSearchBuffer
	FieldSearchBufferArg, FieldSearchBufferFin := WrapString(FieldSearchBuffer)
	result.SearchBuffer = FieldSearchBufferArg
	FieldSelectRequest := self.FieldSelectRequest

	result.SelectRequest = C.bool(FieldSelectRequest)
	FieldSingleCharMode := self.FieldSingleCharMode

	result.SingleCharMode = C.bool(FieldSingleCharMode)
	FieldSingleCharSize := self.FieldSingleCharSize

	result.SingleCharSize = C.ImS8(FieldSingleCharSize)
	releaseFn = func() {
		FieldSearchBufferFin()
	}
	return result, releaseFn
}

func (self TypingSelectRequest) c() (result C.ImGuiTypingSelectRequest, fin func()) {
	resultPtr, finFn := self.handle()
	return *resultPtr, finFn
}

func newTypingSelectRequestFromC(cvalue *C.ImGuiTypingSelectRequest) *TypingSelectRequest {
	result := new(TypingSelectRequest)
	result.FieldFlags = TypingSelectFlags(cvalue.Flags)
	result.FieldSearchBufferLen = int32(cvalue.SearchBufferLen)
	result.FieldSearchBuffer = C.GoString(cvalue.SearchBuffer)
	result.FieldSelectRequest = cvalue.SelectRequest == C.bool(true)
	result.FieldSingleCharMode = cvalue.SingleCharMode == C.bool(true)
	result.FieldSingleCharSize = int(cvalue.SingleCharSize)
	return result
}

// Storage for GetTypingSelectRequest()
type TypingSelectState struct {
	// TODO: contains unsupported fields
	data unsafe.Pointer
}

func (self TypingSelectState) handle() (result *C.ImGuiTypingSelectState, releaseFn func()) {
	result = (*C.ImGuiTypingSelectState)(self.data)
	return result, func() {}
}

func (self TypingSelectState) c() (result C.ImGuiTypingSelectState, fin func()) {
	resultPtr, finFn := self.handle()
	return *resultPtr, finFn
}

func newTypingSelectStateFromC(cvalue *C.ImGuiTypingSelectState) *TypingSelectState {
	result := new(TypingSelectState)
	result.data = unsafe.Pointer(cvalue)
	return result
}

// - Currently represents the Platform Window created by the application which is hosting our Dear ImGui windows.
// - With multi-viewport enabled, we extend this concept to have multiple active viewports.
// - In the future we will extend this concept further to also represent Platform Monitor and support a "no main platform window" operation mode.
// - About Main Area vs Work Area:
//   - Main Area = entire viewport.
//   - Work Area = entire viewport minus sections used by main menu bars (for platform windows), or by task bar (for platform monitor).
//   - Windows are generally trying to stay within the Work Area of their host viewport.
type Viewport struct {
	// TODO: contains unsupported fields
	data unsafe.Pointer
}

func (self Viewport) handle() (result *C.ImGuiViewport, releaseFn func()) {
	result = (*C.ImGuiViewport)(self.data)
	return result, func() {}
}

func (self Viewport) c() (result C.ImGuiViewport, fin func()) {
	resultPtr, finFn := self.handle()
	return *resultPtr, finFn
}

func newViewportFromC(cvalue *C.ImGuiViewport) *Viewport {
	result := new(Viewport)
	result.data = unsafe.Pointer(cvalue)
	return result
}

// ImGuiViewport Private/Internals fields (cardinal sin: we are using inheritance!)
// Every instance of ImGuiViewport is in fact a ImGuiViewportP.
type ViewportP struct {
	// TODO: contains unsupported fields
	data unsafe.Pointer
}

func (self ViewportP) handle() (result *C.ImGuiViewportP, releaseFn func()) {
	result = (*C.ImGuiViewportP)(self.data)
	return result, func() {}
}

func (self ViewportP) c() (result C.ImGuiViewportP, fin func()) {
	resultPtr, finFn := self.handle()
	return *resultPtr, finFn
}

func newViewportPFromC(cvalue *C.ImGuiViewportP) *ViewportP {
	result := new(ViewportP)
	result.data = unsafe.Pointer(cvalue)
	return result
}

// Storage for one window
type Window struct {
	// TODO: contains unsupported fields
	data unsafe.Pointer
}

func (self Window) handle() (result *C.ImGuiWindow, releaseFn func()) {
	result = (*C.ImGuiWindow)(self.data)
	return result, func() {}
}

func (self Window) c() (result C.ImGuiWindow, fin func()) {
	resultPtr, finFn := self.handle()
	return *resultPtr, finFn
}

func newWindowFromC(cvalue *C.ImGuiWindow) *Window {
	result := new(Window)
	result.data = unsafe.Pointer(cvalue)
	return result
}

// [ALPHA] Rarely used / very advanced uses only. Use with SetNextWindowClass() and DockSpace() functions.
// Important: the content of this class is still highly WIP and likely to change and be refactored
// before we stabilize Docking features. Please be mindful if using this.
// Provide hints:
// - To the platform backend via altered viewport flags (enable/disable OS decoration, OS task bar icons, etc.)
// - To the platform backend for OS level parent/child relationships of viewport.
// - To the docking system for various options and filtering.
type WindowClass struct {
	// TODO: contains unsupported fields
	data unsafe.Pointer
}

func (self WindowClass) handle() (result *C.ImGuiWindowClass, releaseFn func()) {
	result = (*C.ImGuiWindowClass)(self.data)
	return result, func() {}
}

func (self WindowClass) c() (result C.ImGuiWindowClass, fin func()) {
	resultPtr, finFn := self.handle()
	return *resultPtr, finFn
}

func newWindowClassFromC(cvalue *C.ImGuiWindowClass) *WindowClass {
	result := new(WindowClass)
	result.data = unsafe.Pointer(cvalue)
	return result
}

type WindowDockStyle struct {
	// TODO: contains unsupported fields
	data unsafe.Pointer
}

func (self WindowDockStyle) handle() (result *C.ImGuiWindowDockStyle, releaseFn func()) {
	result = (*C.ImGuiWindowDockStyle)(self.data)
	return result, func() {}
}

func (self WindowDockStyle) c() (result C.ImGuiWindowDockStyle, fin func()) {
	resultPtr, finFn := self.handle()
	return *resultPtr, finFn
}

func newWindowDockStyleFromC(cvalue *C.ImGuiWindowDockStyle) *WindowDockStyle {
	result := new(WindowDockStyle)
	result.data = unsafe.Pointer(cvalue)
	return result
}

// Windows data saved in imgui.ini file
// Because we never destroy or rename ImGuiWindowSettings, we can store the names in a separate buffer easily.
// (this is designed to be stored in a ImChunkStream buffer, with the variable-length Name following our structure)
type WindowSettings struct {
	// TODO: contains unsupported fields
	data unsafe.Pointer
}

func (self WindowSettings) handle() (result *C.ImGuiWindowSettings, releaseFn func()) {
	result = (*C.ImGuiWindowSettings)(self.data)
	return result, func() {}
}

func (self WindowSettings) c() (result C.ImGuiWindowSettings, fin func()) {
	resultPtr, finFn := self.handle()
	return *resultPtr, finFn
}

func newWindowSettingsFromC(cvalue *C.ImGuiWindowSettings) *WindowSettings {
	result := new(WindowSettings)
	result.data = unsafe.Pointer(cvalue)
	return result
}

// Data saved for each window pushed into the stack
type WindowStackData struct {
	FieldWindow                   *Window
	FieldParentLastItemDataBackup LastItemData
	FieldStackSizesOnBegin        StackSizes // Store size of various stacks for asserting
}

func (self WindowStackData) handle() (result *C.ImGuiWindowStackData, releaseFn func()) {
	result = new(C.ImGuiWindowStackData)
	FieldWindow := self.FieldWindow
	FieldWindowArg, FieldWindowFin := FieldWindow.handle()
	result.Window = FieldWindowArg
	FieldParentLastItemDataBackup := self.FieldParentLastItemDataBackup
	FieldParentLastItemDataBackupArg, FieldParentLastItemDataBackupFin := FieldParentLastItemDataBackup.c()
	result.ParentLastItemDataBackup = FieldParentLastItemDataBackupArg
	FieldStackSizesOnBegin := self.FieldStackSizesOnBegin
	FieldStackSizesOnBeginArg, FieldStackSizesOnBeginFin := FieldStackSizesOnBegin.c()
	result.StackSizesOnBegin = FieldStackSizesOnBeginArg
	releaseFn = func() {
		FieldWindowFin()
		FieldParentLastItemDataBackupFin()
		FieldStackSizesOnBeginFin()
	}
	return result, releaseFn
}

func (self WindowStackData) c() (result C.ImGuiWindowStackData, fin func()) {
	resultPtr, finFn := self.handle()
	return *resultPtr, finFn
}

func newWindowStackDataFromC(cvalue *C.ImGuiWindowStackData) *WindowStackData {
	result := new(WindowStackData)
	result.FieldWindow = newWindowFromC(cvalue.Window)
	result.FieldParentLastItemDataBackup = *newLastItemDataFromC(func() *C.ImGuiLastItemData { result := cvalue.ParentLastItemDataBackup; return &result }())

	result.FieldStackSizesOnBegin = *newStackSizesFromC(func() *C.ImGuiStackSizes { result := cvalue.StackSizesOnBegin; return &result }())

	return result
}

// Transient per-window data, reset at the beginning of the frame. This used to be called ImGuiDrawContext, hence the DC variable name in ImGuiWindow.
// (That's theory, in practice the delimitation between ImGuiWindow and ImGuiWindowTempData is quite tenuous and could be reconsidered..)
// (This doesn't need a constructor because we zero-clear it as part of ImGuiWindow and all frame-temporary data are setup on Begin)
type WindowTempData struct {
	// TODO: contains unsupported fields
	data unsafe.Pointer
}

func (self WindowTempData) handle() (result *C.ImGuiWindowTempData, releaseFn func()) {
	result = (*C.ImGuiWindowTempData)(self.data)
	return result, func() {}
}

func (self WindowTempData) c() (result C.ImGuiWindowTempData, fin func()) {
	resultPtr, finFn := self.handle()
	return *resultPtr, finFn
}

func newWindowTempDataFromC(cvalue *C.ImGuiWindowTempData) *WindowTempData {
	result := new(WindowTempData)
	result.data = unsafe.Pointer(cvalue)
	return result
}

type Vec1 struct {
	FieldX float32
}

func (self Vec1) handle() (result *C.ImVec1, releaseFn func()) {
	result = new(C.ImVec1)
	FieldX := self.FieldX

	result.x = C.float(FieldX)
	releaseFn = func() {
	}
	return result, releaseFn
}

func (self Vec1) c() (result C.ImVec1, fin func()) {
	resultPtr, finFn := self.handle()
	return *resultPtr, finFn
}

func newVec1FromC(cvalue *C.ImVec1) *Vec1 {
	result := new(Vec1)
	result.FieldX = float32(cvalue.x)
	return result
}

type STBTexteditState struct {
	FieldCursor             int32
	FieldSelect_start       int32 // selection start point
	FieldSelect_end         int32
	FieldInsert_mode        uint
	FieldRow_count_per_page int32
	/////////////////////
	//
	// private data
	//
	FieldCursor_at_end_of_line uint // not implemented yet
	FieldInitialized           uint
	FieldHas_preferred_x       uint
	FieldSingle_line           uint
	FieldPadding1              uint
	FieldPadding2              uint
	FieldPadding3              uint
	FieldPreferred_x           float32 // this determines where the cursor up/down tries to seek to along x
	FieldUndostate             StbUndoState
}

func (self STBTexteditState) handle() (result *C.STB_TexteditState, releaseFn func()) {
	result = new(C.STB_TexteditState)
	FieldCursor := self.FieldCursor

	result.cursor = C.int(FieldCursor)
	FieldSelect_start := self.FieldSelect_start

	result.select_start = C.int(FieldSelect_start)
	FieldSelect_end := self.FieldSelect_end

	result.select_end = C.int(FieldSelect_end)
	FieldInsert_mode := self.FieldInsert_mode

	result.insert_mode = C.uchar(FieldInsert_mode)
	FieldRow_count_per_page := self.FieldRow_count_per_page

	result.row_count_per_page = C.int(FieldRow_count_per_page)
	FieldCursor_at_end_of_line := self.FieldCursor_at_end_of_line

	result.cursor_at_end_of_line = C.uchar(FieldCursor_at_end_of_line)
	FieldInitialized := self.FieldInitialized

	result.initialized = C.uchar(FieldInitialized)
	FieldHas_preferred_x := self.FieldHas_preferred_x

	result.has_preferred_x = C.uchar(FieldHas_preferred_x)
	FieldSingle_line := self.FieldSingle_line

	result.single_line = C.uchar(FieldSingle_line)
	FieldPadding1 := self.FieldPadding1

	result.padding1 = C.uchar(FieldPadding1)
	FieldPadding2 := self.FieldPadding2

	result.padding2 = C.uchar(FieldPadding2)
	FieldPadding3 := self.FieldPadding3

	result.padding3 = C.uchar(FieldPadding3)
	FieldPreferred_x := self.FieldPreferred_x

	result.preferred_x = C.float(FieldPreferred_x)
	FieldUndostate := self.FieldUndostate
	FieldUndostateArg, FieldUndostateFin := FieldUndostate.c()
	result.undostate = FieldUndostateArg
	releaseFn = func() {
		FieldUndostateFin()
	}
	return result, releaseFn
}

func (self STBTexteditState) c() (result C.STB_TexteditState, fin func()) {
	resultPtr, finFn := self.handle()
	return *resultPtr, finFn
}

func newSTBTexteditStateFromC(cvalue *C.STB_TexteditState) *STBTexteditState {
	result := new(STBTexteditState)
	result.FieldCursor = int32(cvalue.cursor)
	result.FieldSelect_start = int32(cvalue.select_start)
	result.FieldSelect_end = int32(cvalue.select_end)
	result.FieldInsert_mode = uint(cvalue.insert_mode)
	result.FieldRow_count_per_page = int32(cvalue.row_count_per_page)
	result.FieldCursor_at_end_of_line = uint(cvalue.cursor_at_end_of_line)
	result.FieldInitialized = uint(cvalue.initialized)
	result.FieldHas_preferred_x = uint(cvalue.has_preferred_x)
	result.FieldSingle_line = uint(cvalue.single_line)
	result.FieldPadding1 = uint(cvalue.padding1)
	result.FieldPadding2 = uint(cvalue.padding2)
	result.FieldPadding3 = uint(cvalue.padding3)
	result.FieldPreferred_x = float32(cvalue.preferred_x)
	result.FieldUndostate = *newStbUndoStateFromC(func() *C.StbUndoState { result := cvalue.undostate; return &result }())

	return result
}

// result of layout query
type StbTexteditRow struct {
	FieldX0               float32 // starting x location, end x location (allows for align=right, etc)
	FieldX1               float32 // starting x location, end x location (allows for align=right, etc)
	FieldBaseline_y_delta float32 // position of baseline relative to previous row's baseline
	FieldYmin             float32 // height of row above and below baseline
	FieldYmax             float32 // height of row above and below baseline
	FieldNum_chars        int32
}

func (self StbTexteditRow) handle() (result *C.StbTexteditRow, releaseFn func()) {
	result = new(C.StbTexteditRow)
	FieldX0 := self.FieldX0

	result.x0 = C.float(FieldX0)
	FieldX1 := self.FieldX1

	result.x1 = C.float(FieldX1)
	FieldBaseline_y_delta := self.FieldBaseline_y_delta

	result.baseline_y_delta = C.float(FieldBaseline_y_delta)
	FieldYmin := self.FieldYmin

	result.ymin = C.float(FieldYmin)
	FieldYmax := self.FieldYmax

	result.ymax = C.float(FieldYmax)
	FieldNum_chars := self.FieldNum_chars

	result.num_chars = C.int(FieldNum_chars)
	releaseFn = func() {
	}
	return result, releaseFn
}

func (self StbTexteditRow) c() (result C.StbTexteditRow, fin func()) {
	resultPtr, finFn := self.handle()
	return *resultPtr, finFn
}

func newStbTexteditRowFromC(cvalue *C.StbTexteditRow) *StbTexteditRow {
	result := new(StbTexteditRow)
	result.FieldX0 = float32(cvalue.x0)
	result.FieldX1 = float32(cvalue.x1)
	result.FieldBaseline_y_delta = float32(cvalue.baseline_y_delta)
	result.FieldYmin = float32(cvalue.ymin)
	result.FieldYmax = float32(cvalue.ymax)
	result.FieldNum_chars = int32(cvalue.num_chars)
	return result
}

// //////////////////////////////////////////////////////////////////////
//
//	STB_TexteditState
//
// Definition of STB_TexteditState which you should store
// per-textfield; it includes cursor position, selection state,
// and undo state.
type StbUndoRecord struct {
	// private data
	FieldWhere         int32
	FieldInsert_length int32
	FieldDelete_length int32
	FieldChar_storage  int32
}

func (self StbUndoRecord) handle() (result *C.StbUndoRecord, releaseFn func()) {
	result = new(C.StbUndoRecord)
	FieldWhere := self.FieldWhere

	result.where = C.int(FieldWhere)
	FieldInsert_length := self.FieldInsert_length

	result.insert_length = C.int(FieldInsert_length)
	FieldDelete_length := self.FieldDelete_length

	result.delete_length = C.int(FieldDelete_length)
	FieldChar_storage := self.FieldChar_storage

	result.char_storage = C.int(FieldChar_storage)
	releaseFn = func() {
	}
	return result, releaseFn
}

func (self StbUndoRecord) c() (result C.StbUndoRecord, fin func()) {
	resultPtr, finFn := self.handle()
	return *resultPtr, finFn
}

func newStbUndoRecordFromC(cvalue *C.StbUndoRecord) *StbUndoRecord {
	result := new(StbUndoRecord)
	result.FieldWhere = int32(cvalue.where)
	result.FieldInsert_length = int32(cvalue.insert_length)
	result.FieldDelete_length = int32(cvalue.delete_length)
	result.FieldChar_storage = int32(cvalue.char_storage)
	return result
}

type StbUndoState struct {
	// TODO: contains unsupported fields
	data unsafe.Pointer
}

func (self StbUndoState) handle() (result *C.StbUndoState, releaseFn func()) {
	result = (*C.StbUndoState)(self.data)
	return result, func() {}
}

func (self StbUndoState) c() (result C.StbUndoState, fin func()) {
	resultPtr, finFn := self.handle()
	return *resultPtr, finFn
}

func newStbUndoStateFromC(cvalue *C.StbUndoState) *StbUndoState {
	result := new(StbUndoState)
	result.data = unsafe.Pointer(cvalue)
	return result
}
