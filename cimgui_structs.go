// Code generated by cmd/codegen from https://github.com/AllenDang/cimgui-go.
// DO NOT EDIT.

package imgui

// #include <stdlib.h>
// #include <memory.h>
// #include "extra_types.h"
// #include "cimgui_wrapper.h"
import "C"
import "unsafe"

// Helper: ImBitVector
// Store 1-bit per value.
type BitVector struct {
	FieldStorage Vector[*uint32]
}

func (self BitVector) handle() (result *C.ImBitVector, releaseFn func()) {
	result = new(C.ImBitVector)
	FieldStorage := self.FieldStorage
	FieldStorageData := FieldStorage.Data
	FieldStorageDataArg, FieldStorageDataFin := WrapNumberPtr[C.ImU32, uint32](FieldStorageData)
	FieldStorageVecArg := new(C.ImVector_ImU32)
	FieldStorageVecArg.Size = C.int(FieldStorage.Size)
	FieldStorageVecArg.Capacity = C.int(FieldStorage.Capacity)
	FieldStorageVecArg.Data = FieldStorageDataArg
	FieldStorage.pinner.Pin(FieldStorageVecArg.Data)

	result.Storage = *FieldStorageVecArg
	releaseFn = func() {
		FieldStorageDataFin()
		FieldStorage.pinner.Unpin()
	}
	return result, releaseFn
}

func (self BitVector) c() (result C.ImBitVector, fin func()) {
	resultPtr, finFn := self.handle()
	return *resultPtr, finFn
}

func newBitVectorFromC(cvalue *C.ImBitVector) *BitVector {
	result := new(BitVector)
	result.FieldStorage = newVectorFromC(cvalue.Storage.Size, cvalue.Storage.Capacity, (*uint32)(cvalue.Storage.Data))
	return result
}

// [Internal] For use by ImDrawListSplitter
type DrawChannel struct {
	FieldCmdBuffer Vector[*DrawCmd]
	FieldIdxBuffer Vector[*DrawIdx]
}

func (self DrawChannel) handle() (result *C.ImDrawChannel, releaseFn func()) {
	result = new(C.ImDrawChannel)
	FieldCmdBuffer := self.FieldCmdBuffer
	FieldCmdBufferData := FieldCmdBuffer.Data
	FieldCmdBufferDataArg, FieldCmdBufferDataFin := FieldCmdBufferData.handle()
	FieldCmdBufferVecArg := new(C.ImVector_ImDrawCmd)
	FieldCmdBufferVecArg.Size = C.int(FieldCmdBuffer.Size)
	FieldCmdBufferVecArg.Capacity = C.int(FieldCmdBuffer.Capacity)
	FieldCmdBufferVecArg.Data = FieldCmdBufferDataArg
	FieldCmdBuffer.pinner.Pin(FieldCmdBufferVecArg.Data)

	result._CmdBuffer = *FieldCmdBufferVecArg
	FieldIdxBuffer := self.FieldIdxBuffer
	FieldIdxBufferData := FieldIdxBuffer.Data
	FieldIdxBufferDataArg, FieldIdxBufferDataFin := WrapNumberPtr[C.ImDrawIdx, DrawIdx](FieldIdxBufferData)
	FieldIdxBufferVecArg := new(C.ImVector_ImDrawIdx)
	FieldIdxBufferVecArg.Size = C.int(FieldIdxBuffer.Size)
	FieldIdxBufferVecArg.Capacity = C.int(FieldIdxBuffer.Capacity)
	FieldIdxBufferVecArg.Data = FieldIdxBufferDataArg
	FieldIdxBuffer.pinner.Pin(FieldIdxBufferVecArg.Data)

	result._IdxBuffer = *FieldIdxBufferVecArg
	releaseFn = func() {
		FieldCmdBufferDataFin()
		FieldCmdBuffer.pinner.Unpin()
		FieldIdxBufferDataFin()
		FieldIdxBuffer.pinner.Unpin()
	}
	return result, releaseFn
}

func (self DrawChannel) c() (result C.ImDrawChannel, fin func()) {
	resultPtr, finFn := self.handle()
	return *resultPtr, finFn
}

func newDrawChannelFromC(cvalue *C.ImDrawChannel) *DrawChannel {
	result := new(DrawChannel)
	result.FieldCmdBuffer = newVectorFromC(cvalue._CmdBuffer.Size, cvalue._CmdBuffer.Capacity, newDrawCmdFromC(cvalue._CmdBuffer.Data))
	result.FieldIdxBuffer = newVectorFromC(cvalue._IdxBuffer.Size, cvalue._IdxBuffer.Capacity, (*DrawIdx)(cvalue._IdxBuffer.Data))
	return result
}

// Typically, 1 command = 1 GPU draw call (unless command is a callback)
//   - VtxOffset: When 'io.BackendFlags & ImGuiBackendFlags_RendererHasVtxOffset' is enabled,
//     this fields allow us to render meshes larger than 64K vertices while keeping 16-bit indices.
//     Backends made for <1.71. will typically ignore the VtxOffset fields.
//   - The ClipRect/TextureId/VtxOffset fields must be contiguous as we memcmp() them together (this is asserted for).
type DrawCmd struct {
	// TODO: contains unsupported fields
	data unsafe.Pointer
}

func (self DrawCmd) handle() (result *C.ImDrawCmd, releaseFn func()) {
	result = (*C.ImDrawCmd)(self.data)
	return result, func() {}
}

func (self DrawCmd) c() (result C.ImDrawCmd, fin func()) {
	resultPtr, finFn := self.handle()
	return *resultPtr, finFn
}

func newDrawCmdFromC(cvalue *C.ImDrawCmd) *DrawCmd {
	result := new(DrawCmd)
	result.data = unsafe.Pointer(cvalue)
	return result
}

// [Internal] For use by ImDrawList
type DrawCmdHeader struct {
	FieldClipRect  Vec4
	FieldTextureId TextureID
	FieldVtxOffset uint32
}

func (self DrawCmdHeader) handle() (result *C.ImDrawCmdHeader, releaseFn func()) {
	result = new(C.ImDrawCmdHeader)
	FieldClipRect := self.FieldClipRect

	result.ClipRect = FieldClipRect.toC()
	FieldTextureId := self.FieldTextureId

	result.TextureId = C.ImTextureID(FieldTextureId)
	FieldVtxOffset := self.FieldVtxOffset

	result.VtxOffset = C.uint(FieldVtxOffset)
	releaseFn = func() {
	}
	return result, releaseFn
}

func (self DrawCmdHeader) c() (result C.ImDrawCmdHeader, fin func()) {
	resultPtr, finFn := self.handle()
	return *resultPtr, finFn
}

func newDrawCmdHeaderFromC(cvalue *C.ImDrawCmdHeader) *DrawCmdHeader {
	result := new(DrawCmdHeader)
	result.FieldClipRect = *(&Vec4{}).fromC(cvalue.ClipRect)
	result.FieldTextureId = TextureID(cvalue.TextureId)
	result.FieldVtxOffset = uint32(cvalue.VtxOffset)
	return result
}

// All draw data to render a Dear ImGui frame
// (NB: the style and the naming convention here is a little inconsistent, we currently preserve them for backward compatibility purpose,
// as this is one of the oldest structure exposed by the library! Basically, ImDrawList == CmdList)
type DrawData struct {
	// TODO: contains unsupported fields
	data unsafe.Pointer
}

func (self DrawData) handle() (result *C.ImDrawData, releaseFn func()) {
	result = (*C.ImDrawData)(self.data)
	return result, func() {}
}

func (self DrawData) c() (result C.ImDrawData, fin func()) {
	resultPtr, finFn := self.handle()
	return *resultPtr, finFn
}

func newDrawDataFromC(cvalue *C.ImDrawData) *DrawData {
	result := new(DrawData)
	result.data = unsafe.Pointer(cvalue)
	return result
}

type DrawDataBuilder struct {
	// TODO: contains unsupported fields
	data unsafe.Pointer
}

func (self DrawDataBuilder) handle() (result *C.ImDrawDataBuilder, releaseFn func()) {
	result = (*C.ImDrawDataBuilder)(self.data)
	return result, func() {}
}

func (self DrawDataBuilder) c() (result C.ImDrawDataBuilder, fin func()) {
	resultPtr, finFn := self.handle()
	return *resultPtr, finFn
}

func newDrawDataBuilderFromC(cvalue *C.ImDrawDataBuilder) *DrawDataBuilder {
	result := new(DrawDataBuilder)
	result.data = unsafe.Pointer(cvalue)
	return result
}

// Draw command list
// This is the low-level list of polygons that ImGui:: functions are filling. At the end of the frame,
// all command lists are passed to your ImGuiIO::RenderDrawListFn function for rendering.
// Each dear imgui window contains its own ImDrawList. You can use ImGui::GetWindowDrawList() to
// access the current window draw list and draw custom primitives.
// You can interleave normal ImGui:: calls and adding primitives to the current draw list.
// In single viewport mode, top-left is == GetMainViewport()->Pos (generally 0,0), bottom-right is == GetMainViewport()->Pos+Size (generally io.DisplaySize).
// You are totally free to apply whatever transformation matrix to want to the data (depending on the use of the transformation you may want to apply it to ClipRect as well!)
// Important: Primitives are always added to the list and not culled (culling is done at higher-level by ImGui:: functions), if you use this API a lot consider coarse culling your drawn objects.
type DrawList struct {
	// TODO: contains unsupported fields
	data unsafe.Pointer
}

func (self DrawList) handle() (result *C.ImDrawList, releaseFn func()) {
	result = (*C.ImDrawList)(self.data)
	return result, func() {}
}

func (self DrawList) c() (result C.ImDrawList, fin func()) {
	resultPtr, finFn := self.handle()
	return *resultPtr, finFn
}

func newDrawListFromC(cvalue *C.ImDrawList) *DrawList {
	result := new(DrawList)
	result.data = unsafe.Pointer(cvalue)
	return result
}

// Data shared between all ImDrawList instances
// You may want to create your own instance of this if you want to use ImDrawList completely without ImGui. In that case, watch out for future changes to this structure.
type DrawListSharedData struct {
	// TODO: contains unsupported fields
	data unsafe.Pointer
}

func (self DrawListSharedData) handle() (result *C.ImDrawListSharedData, releaseFn func()) {
	result = (*C.ImDrawListSharedData)(self.data)
	return result, func() {}
}

func (self DrawListSharedData) c() (result C.ImDrawListSharedData, fin func()) {
	resultPtr, finFn := self.handle()
	return *resultPtr, finFn
}

func newDrawListSharedDataFromC(cvalue *C.ImDrawListSharedData) *DrawListSharedData {
	result := new(DrawListSharedData)
	result.data = unsafe.Pointer(cvalue)
	return result
}

// Split/Merge functions are used to split the draw list into different layers which can be drawn into out of order.
// This is used by the Columns/Tables API, so items of each column can be batched together in a same draw call.
type DrawListSplitter struct {
	FieldCurrent  int32                // Current channel number (0)
	FieldCount    int32                // Number of active channels (1+)
	FieldChannels Vector[*DrawChannel] // Draw channels (not resized down so _Count might be < Channels.Size)
}

func (self DrawListSplitter) handle() (result *C.ImDrawListSplitter, releaseFn func()) {
	result = new(C.ImDrawListSplitter)
	FieldCurrent := self.FieldCurrent

	result._Current = C.int(FieldCurrent)
	FieldCount := self.FieldCount

	result._Count = C.int(FieldCount)
	FieldChannels := self.FieldChannels
	FieldChannelsData := FieldChannels.Data
	FieldChannelsDataArg, FieldChannelsDataFin := FieldChannelsData.handle()
	FieldChannelsVecArg := new(C.ImVector_ImDrawChannel)
	FieldChannelsVecArg.Size = C.int(FieldChannels.Size)
	FieldChannelsVecArg.Capacity = C.int(FieldChannels.Capacity)
	FieldChannelsVecArg.Data = FieldChannelsDataArg
	FieldChannels.pinner.Pin(FieldChannelsVecArg.Data)

	result._Channels = *FieldChannelsVecArg
	releaseFn = func() {
		FieldChannelsDataFin()
		FieldChannels.pinner.Unpin()
	}
	return result, releaseFn
}

func (self DrawListSplitter) c() (result C.ImDrawListSplitter, fin func()) {
	resultPtr, finFn := self.handle()
	return *resultPtr, finFn
}

func newDrawListSplitterFromC(cvalue *C.ImDrawListSplitter) *DrawListSplitter {
	result := new(DrawListSplitter)
	result.FieldCurrent = int32(cvalue._Current)
	result.FieldCount = int32(cvalue._Count)
	result.FieldChannels = newVectorFromC(cvalue._Channels.Size, cvalue._Channels.Capacity, newDrawChannelFromC(cvalue._Channels.Data))
	return result
}

type DrawVert struct {
	FieldPos Vec2
	FieldUv  Vec2
	FieldCol uint32
}

func (self DrawVert) handle() (result *C.ImDrawVert, releaseFn func()) {
	result = new(C.ImDrawVert)
	FieldPos := self.FieldPos

	result.pos = FieldPos.toC()
	FieldUv := self.FieldUv

	result.uv = FieldUv.toC()
	FieldCol := self.FieldCol

	result.col = C.ImU32(FieldCol)
	releaseFn = func() {
	}
	return result, releaseFn
}

func (self DrawVert) c() (result C.ImDrawVert, fin func()) {
	resultPtr, finFn := self.handle()
	return *resultPtr, finFn
}

func newDrawVertFromC(cvalue *C.ImDrawVert) *DrawVert {
	result := new(DrawVert)
	result.FieldPos = *(&Vec2{}).fromC(cvalue.pos)
	result.FieldUv = *(&Vec2{}).fromC(cvalue.uv)
	result.FieldCol = uint32(cvalue.col)
	return result
}

// Font runtime data and rendering
// ImFontAtlas automatically loads a default embedded font for you when you call GetTexDataAsAlpha8() or GetTexDataAsRGBA32().
type Font struct {
	// TODO: contains unsupported fields
	data unsafe.Pointer
}

func (self Font) handle() (result *C.ImFont, releaseFn func()) {
	result = (*C.ImFont)(self.data)
	return result, func() {}
}

func (self Font) c() (result C.ImFont, fin func()) {
	resultPtr, finFn := self.handle()
	return *resultPtr, finFn
}

func newFontFromC(cvalue *C.ImFont) *Font {
	result := new(Font)
	result.data = unsafe.Pointer(cvalue)
	return result
}

// Load and rasterize multiple TTF/OTF fonts into a same texture. The font atlas will build a single texture holding:
//   - One or more fonts.
//   - Custom graphics data needed to render the shapes needed by Dear ImGui.
//   - Mouse cursor shapes for software cursor rendering (unless setting 'Flags |= ImFontAtlasFlags_NoMouseCursors' in the font atlas).
//
// It is the user-code responsibility to setup/build the atlas, then upload the pixel data into a texture accessible by your graphics api.
//   - Optionally, call any of the AddFont*** functions. If you don't call any, the default font embedded in the code will be loaded for you.
//   - Call GetTexDataAsAlpha8() or GetTexDataAsRGBA32() to build and retrieve pixels data.
//   - Upload the pixels data into a texture within your graphics system (see imgui_impl_xxxx.cpp examples)
//   - Call SetTexID(my_tex_id); and pass the pointer/identifier to your texture in a format natural to your graphics API.
//     This value will be passed back to you during rendering to identify the texture. Read FAQ entry about ImTextureID for more details.
//
// Common pitfalls:
//   - If you pass a 'glyph_ranges' array to AddFont*** functions, you need to make sure that your array persist up until the
//     atlas is build (when calling GetTexData*** or Build()). We only copy the pointer, not the data.
//   - Important: By default, AddFontFromMemoryTTF() takes ownership of the data. Even though we are not writing to it, we will free the pointer on destruction.
//     You can set font_cfg->FontDataOwnedByAtlas=false to keep ownership of your data and it won't be freed,
//   - Even though many functions are suffixed with "TTF", OTF data is supported just as well.
//   - This is an old API and it is currently awkward for those and various other reasons! We will address them in the future!
type FontAtlas struct {
	// TODO: contains unsupported fields
	data unsafe.Pointer
}

func (self FontAtlas) handle() (result *C.ImFontAtlas, releaseFn func()) {
	result = (*C.ImFontAtlas)(self.data)
	return result, func() {}
}

func (self FontAtlas) c() (result C.ImFontAtlas, fin func()) {
	resultPtr, finFn := self.handle()
	return *resultPtr, finFn
}

func newFontAtlasFromC(cvalue *C.ImFontAtlas) *FontAtlas {
	result := new(FontAtlas)
	result.data = unsafe.Pointer(cvalue)
	return result
}

// See ImFontAtlas::AddCustomRectXXX functions.
type FontAtlasCustomRect struct {
	FieldWidth         uint16  // Input    // Desired rectangle dimension
	FieldHeight        uint16  // Input    // Desired rectangle dimension
	FieldX             uint16  // Output   // Packed position in Atlas
	FieldY             uint16  // Output   // Packed position in Atlas
	FieldGlyphID       uint32  // Input    // For custom font glyphs only (ID < 0x110000)
	FieldGlyphAdvanceX float32 // Input    // For custom font glyphs only: glyph xadvance
	FieldGlyphOffset   Vec2    // Input    // For custom font glyphs only: glyph display offset
	FieldFont          *Font   // Input    // For custom font glyphs only: target font
}

func (self FontAtlasCustomRect) handle() (result *C.ImFontAtlasCustomRect, releaseFn func()) {
	result = new(C.ImFontAtlasCustomRect)
	FieldWidth := self.FieldWidth

	result.Width = C.ushort(FieldWidth)
	FieldHeight := self.FieldHeight

	result.Height = C.ushort(FieldHeight)
	FieldX := self.FieldX

	result.X = C.ushort(FieldX)
	FieldY := self.FieldY

	result.Y = C.ushort(FieldY)
	FieldGlyphID := self.FieldGlyphID

	result.GlyphID = C.uint(FieldGlyphID)
	FieldGlyphAdvanceX := self.FieldGlyphAdvanceX

	result.GlyphAdvanceX = C.float(FieldGlyphAdvanceX)
	FieldGlyphOffset := self.FieldGlyphOffset

	result.GlyphOffset = FieldGlyphOffset.toC()
	FieldFont := self.FieldFont
	FieldFontArg, FieldFontFin := FieldFont.handle()
	result.Font = FieldFontArg
	releaseFn = func() {
		FieldFontFin()
	}
	return result, releaseFn
}

func (self FontAtlasCustomRect) c() (result C.ImFontAtlasCustomRect, fin func()) {
	resultPtr, finFn := self.handle()
	return *resultPtr, finFn
}

func newFontAtlasCustomRectFromC(cvalue *C.ImFontAtlasCustomRect) *FontAtlasCustomRect {
	result := new(FontAtlasCustomRect)
	result.FieldWidth = uint16(cvalue.Width)
	result.FieldHeight = uint16(cvalue.Height)
	result.FieldX = uint16(cvalue.X)
	result.FieldY = uint16(cvalue.Y)
	result.FieldGlyphID = uint32(cvalue.GlyphID)
	result.FieldGlyphAdvanceX = float32(cvalue.GlyphAdvanceX)
	result.FieldGlyphOffset = *(&Vec2{}).fromC(cvalue.GlyphOffset)
	result.FieldFont = newFontFromC(cvalue.Font)
	return result
}

// This structure is likely to evolve as we add support for incremental atlas updates
type FontBuilderIO struct {
	// TODO: contains unsupported fields
	data unsafe.Pointer
}

func (self FontBuilderIO) handle() (result *C.ImFontBuilderIO, releaseFn func()) {
	result = (*C.ImFontBuilderIO)(self.data)
	return result, func() {}
}

func (self FontBuilderIO) c() (result C.ImFontBuilderIO, fin func()) {
	resultPtr, finFn := self.handle()
	return *resultPtr, finFn
}

func newFontBuilderIOFromC(cvalue *C.ImFontBuilderIO) *FontBuilderIO {
	result := new(FontBuilderIO)
	result.data = unsafe.Pointer(cvalue)
	return result
}

type FontConfig struct {
	// TODO: contains unsupported fields
	data unsafe.Pointer
}

func (self FontConfig) handle() (result *C.ImFontConfig, releaseFn func()) {
	result = (*C.ImFontConfig)(self.data)
	return result, func() {}
}

func (self FontConfig) c() (result C.ImFontConfig, fin func()) {
	resultPtr, finFn := self.handle()
	return *resultPtr, finFn
}

func newFontConfigFromC(cvalue *C.ImFontConfig) *FontConfig {
	result := new(FontConfig)
	result.data = unsafe.Pointer(cvalue)
	return result
}

// Hold rendering data for one glyph.
// (Note: some language parsers may fail to convert the 31+1 bitfield members, in this case maybe drop store a single u32 or we can rework this)
type FontGlyph struct {
	// TODO: contains unsupported fields
	data unsafe.Pointer
}

func (self FontGlyph) handle() (result *C.ImFontGlyph, releaseFn func()) {
	result = (*C.ImFontGlyph)(self.data)
	return result, func() {}
}

func (self FontGlyph) c() (result C.ImFontGlyph, fin func()) {
	resultPtr, finFn := self.handle()
	return *resultPtr, finFn
}

func newFontGlyphFromC(cvalue *C.ImFontGlyph) *FontGlyph {
	result := new(FontGlyph)
	result.data = unsafe.Pointer(cvalue)
	return result
}

// Helper to build glyph ranges from text/string data. Feed your application strings/characters to it then call BuildRanges().
// This is essentially a tightly packed of vector of 64k booleans = 8KB storage.
type FontGlyphRangesBuilder struct {
	FieldUsedChars Vector[*uint32] // Store 1-bit per Unicode code point (0=unused, 1=used)
}

func (self FontGlyphRangesBuilder) handle() (result *C.ImFontGlyphRangesBuilder, releaseFn func()) {
	result = new(C.ImFontGlyphRangesBuilder)
	FieldUsedChars := self.FieldUsedChars
	FieldUsedCharsData := FieldUsedChars.Data
	FieldUsedCharsDataArg, FieldUsedCharsDataFin := WrapNumberPtr[C.ImU32, uint32](FieldUsedCharsData)
	FieldUsedCharsVecArg := new(C.ImVector_ImU32)
	FieldUsedCharsVecArg.Size = C.int(FieldUsedChars.Size)
	FieldUsedCharsVecArg.Capacity = C.int(FieldUsedChars.Capacity)
	FieldUsedCharsVecArg.Data = FieldUsedCharsDataArg
	FieldUsedChars.pinner.Pin(FieldUsedCharsVecArg.Data)

	result.UsedChars = *FieldUsedCharsVecArg
	releaseFn = func() {
		FieldUsedCharsDataFin()
		FieldUsedChars.pinner.Unpin()
	}
	return result, releaseFn
}

func (self FontGlyphRangesBuilder) c() (result C.ImFontGlyphRangesBuilder, fin func()) {
	resultPtr, finFn := self.handle()
	return *resultPtr, finFn
}

func newFontGlyphRangesBuilderFromC(cvalue *C.ImFontGlyphRangesBuilder) *FontGlyphRangesBuilder {
	result := new(FontGlyphRangesBuilder)
	result.FieldUsedChars = newVectorFromC(cvalue.UsedChars.Size, cvalue.UsedChars.Capacity, (*uint32)(cvalue.UsedChars.Data))
	return result
}

// Stacked color modifier, backup of modified data so we can restore it
type ColorMod struct {
	FieldCol         Col
	FieldBackupValue Vec4
}

func (self ColorMod) handle() (result *C.ImGuiColorMod, releaseFn func()) {
	result = new(C.ImGuiColorMod)
	FieldCol := self.FieldCol

	result.Col = C.ImGuiCol(FieldCol)
	FieldBackupValue := self.FieldBackupValue

	result.BackupValue = FieldBackupValue.toC()
	releaseFn = func() {
	}
	return result, releaseFn
}

func (self ColorMod) c() (result C.ImGuiColorMod, fin func()) {
	resultPtr, finFn := self.handle()
	return *resultPtr, finFn
}

func newColorModFromC(cvalue *C.ImGuiColorMod) *ColorMod {
	result := new(ColorMod)
	result.FieldCol = Col(cvalue.Col)
	result.FieldBackupValue = *(&Vec4{}).fromC(cvalue.BackupValue)
	return result
}

// Storage data for BeginComboPreview()/EndComboPreview()
type ComboPreviewData struct {
	FieldPreviewRect                  Rect
	FieldBackupCursorPos              Vec2
	FieldBackupCursorMaxPos           Vec2
	FieldBackupCursorPosPrevLine      Vec2
	FieldBackupPrevLineTextBaseOffset float32
	FieldBackupLayout                 LayoutType
}

func (self ComboPreviewData) handle() (result *C.ImGuiComboPreviewData, releaseFn func()) {
	result = new(C.ImGuiComboPreviewData)
	FieldPreviewRect := self.FieldPreviewRect

	result.PreviewRect = FieldPreviewRect.toC()
	FieldBackupCursorPos := self.FieldBackupCursorPos

	result.BackupCursorPos = FieldBackupCursorPos.toC()
	FieldBackupCursorMaxPos := self.FieldBackupCursorMaxPos

	result.BackupCursorMaxPos = FieldBackupCursorMaxPos.toC()
	FieldBackupCursorPosPrevLine := self.FieldBackupCursorPosPrevLine

	result.BackupCursorPosPrevLine = FieldBackupCursorPosPrevLine.toC()
	FieldBackupPrevLineTextBaseOffset := self.FieldBackupPrevLineTextBaseOffset

	result.BackupPrevLineTextBaseOffset = C.float(FieldBackupPrevLineTextBaseOffset)
	FieldBackupLayout := self.FieldBackupLayout

	result.BackupLayout = C.ImGuiLayoutType(FieldBackupLayout)
	releaseFn = func() {
	}
	return result, releaseFn
}

func (self ComboPreviewData) c() (result C.ImGuiComboPreviewData, fin func()) {
	resultPtr, finFn := self.handle()
	return *resultPtr, finFn
}

func newComboPreviewDataFromC(cvalue *C.ImGuiComboPreviewData) *ComboPreviewData {
	result := new(ComboPreviewData)
	result.FieldPreviewRect = *(&Rect{}).fromC(cvalue.PreviewRect)
	result.FieldBackupCursorPos = *(&Vec2{}).fromC(cvalue.BackupCursorPos)
	result.FieldBackupCursorMaxPos = *(&Vec2{}).fromC(cvalue.BackupCursorMaxPos)
	result.FieldBackupCursorPosPrevLine = *(&Vec2{}).fromC(cvalue.BackupCursorPosPrevLine)
	result.FieldBackupPrevLineTextBaseOffset = float32(cvalue.BackupPrevLineTextBaseOffset)
	result.FieldBackupLayout = LayoutType(cvalue.BackupLayout)
	return result
}

type Context struct {
	// TODO: contains unsupported fields
	data unsafe.Pointer
}

func (self Context) handle() (result *C.ImGuiContext, releaseFn func()) {
	result = (*C.ImGuiContext)(self.data)
	return result, func() {}
}

func (self Context) c() (result C.ImGuiContext, fin func()) {
	resultPtr, finFn := self.handle()
	return *resultPtr, finFn
}

func newContextFromC(cvalue *C.ImGuiContext) *Context {
	result := new(Context)
	result.data = unsafe.Pointer(cvalue)
	return result
}

type ContextHook struct {
	// TODO: contains unsupported fields
	data unsafe.Pointer
}

func (self ContextHook) handle() (result *C.ImGuiContextHook, releaseFn func()) {
	result = (*C.ImGuiContextHook)(self.data)
	return result, func() {}
}

func (self ContextHook) c() (result C.ImGuiContextHook, fin func()) {
	resultPtr, finFn := self.handle()
	return *resultPtr, finFn
}

func newContextHookFromC(cvalue *C.ImGuiContextHook) *ContextHook {
	result := new(ContextHook)
	result.data = unsafe.Pointer(cvalue)
	return result
}

// Type information associated to one ImGuiDataType. Retrieve with DataTypeGetInfo().
type DataTypeInfo struct {
	FieldSize     uint64 // Size in bytes
	FieldName     string // Short descriptive name for the type, for debugging
	FieldPrintFmt string // Default printf format for the type
	FieldScanFmt  string // Default scanf format for the type
}

func (self DataTypeInfo) handle() (result *C.ImGuiDataTypeInfo, releaseFn func()) {
	result = new(C.ImGuiDataTypeInfo)
	FieldSize := self.FieldSize

	result.Size = C.xulong(FieldSize)
	FieldName := self.FieldName
	FieldNameArg, FieldNameFin := WrapString(FieldName)
	result.Name = FieldNameArg
	FieldPrintFmt := self.FieldPrintFmt
	FieldPrintFmtArg, FieldPrintFmtFin := WrapString(FieldPrintFmt)
	result.PrintFmt = FieldPrintFmtArg
	FieldScanFmt := self.FieldScanFmt
	FieldScanFmtArg, FieldScanFmtFin := WrapString(FieldScanFmt)
	result.ScanFmt = FieldScanFmtArg
	releaseFn = func() {
		FieldNameFin()
		FieldPrintFmtFin()
		FieldScanFmtFin()
	}
	return result, releaseFn
}

func (self DataTypeInfo) c() (result C.ImGuiDataTypeInfo, fin func()) {
	resultPtr, finFn := self.handle()
	return *resultPtr, finFn
}

func newDataTypeInfoFromC(cvalue *C.ImGuiDataTypeInfo) *DataTypeInfo {
	result := new(DataTypeInfo)
	result.FieldSize = uint64(cvalue.Size)
	result.FieldName = C.GoString(cvalue.Name)
	result.FieldPrintFmt = C.GoString(cvalue.PrintFmt)
	result.FieldScanFmt = C.GoString(cvalue.ScanFmt)
	return result
}

type DataTypeTempStorage struct {
	// TODO: contains unsupported fields
	data unsafe.Pointer
}

func (self DataTypeTempStorage) handle() (result *C.ImGuiDataTypeTempStorage, releaseFn func()) {
	result = (*C.ImGuiDataTypeTempStorage)(self.data)
	return result, func() {}
}

func (self DataTypeTempStorage) c() (result C.ImGuiDataTypeTempStorage, fin func()) {
	resultPtr, finFn := self.handle()
	return *resultPtr, finFn
}

func newDataTypeTempStorageFromC(cvalue *C.ImGuiDataTypeTempStorage) *DataTypeTempStorage {
	result := new(DataTypeTempStorage)
	result.data = unsafe.Pointer(cvalue)
	return result
}

type DataVarInfo struct {
	FieldType   DataType
	FieldCount  uint32 // 1+
	FieldOffset uint32 // Offset in parent structure
}

func (self DataVarInfo) handle() (result *C.ImGuiDataVarInfo, releaseFn func()) {
	result = new(C.ImGuiDataVarInfo)
	FieldType := self.FieldType

	result.Type = C.ImGuiDataType(FieldType)
	FieldCount := self.FieldCount

	result.Count = C.ImU32(FieldCount)
	FieldOffset := self.FieldOffset

	result.Offset = C.ImU32(FieldOffset)
	releaseFn = func() {
	}
	return result, releaseFn
}

func (self DataVarInfo) c() (result C.ImGuiDataVarInfo, fin func()) {
	resultPtr, finFn := self.handle()
	return *resultPtr, finFn
}

func newDataVarInfoFromC(cvalue *C.ImGuiDataVarInfo) *DataVarInfo {
	result := new(DataVarInfo)
	result.FieldType = DataType(cvalue.Type)
	result.FieldCount = uint32(cvalue.Count)
	result.FieldOffset = uint32(cvalue.Offset)
	return result
}

type DockContext struct {
	// TODO: contains unsupported fields
	data unsafe.Pointer
}

func (self DockContext) handle() (result *C.ImGuiDockContext, releaseFn func()) {
	result = (*C.ImGuiDockContext)(self.data)
	return result, func() {}
}

func (self DockContext) c() (result C.ImGuiDockContext, fin func()) {
	resultPtr, finFn := self.handle()
	return *resultPtr, finFn
}

func newDockContextFromC(cvalue *C.ImGuiDockContext) *DockContext {
	result := new(DockContext)
	result.data = unsafe.Pointer(cvalue)
	return result
}

// sizeof() 156~192
type DockNode struct {
	// TODO: contains unsupported fields
	data unsafe.Pointer
}

func (self DockNode) handle() (result *C.ImGuiDockNode, releaseFn func()) {
	result = (*C.ImGuiDockNode)(self.data)
	return result, func() {}
}

func (self DockNode) c() (result C.ImGuiDockNode, fin func()) {
	resultPtr, finFn := self.handle()
	return *resultPtr, finFn
}

func newDockNodeFromC(cvalue *C.ImGuiDockNode) *DockNode {
	result := new(DockNode)
	result.data = unsafe.Pointer(cvalue)
	return result
}

// Stacked storage data for BeginGroup()/EndGroup()
type GroupData struct {
	FieldWindowID                           ID
	FieldBackupCursorPos                    Vec2
	FieldBackupCursorMaxPos                 Vec2
	FieldBackupIndent                       Vec1
	FieldBackupGroupOffset                  Vec1
	FieldBackupCurrLineSize                 Vec2
	FieldBackupCurrLineTextBaseOffset       float32
	FieldBackupActiveIdIsAlive              ID
	FieldBackupActiveIdPreviousFrameIsAlive bool
	FieldBackupHoveredIdIsAlive             bool
	FieldEmitItem                           bool
}

func (self GroupData) handle() (result *C.ImGuiGroupData, releaseFn func()) {
	result = new(C.ImGuiGroupData)
	FieldWindowID := self.FieldWindowID

	result.WindowID = C.ImGuiID(FieldWindowID)
	FieldBackupCursorPos := self.FieldBackupCursorPos

	result.BackupCursorPos = FieldBackupCursorPos.toC()
	FieldBackupCursorMaxPos := self.FieldBackupCursorMaxPos

	result.BackupCursorMaxPos = FieldBackupCursorMaxPos.toC()
	FieldBackupIndent := self.FieldBackupIndent
	FieldBackupIndentArg, FieldBackupIndentFin := FieldBackupIndent.c()
	result.BackupIndent = FieldBackupIndentArg
	FieldBackupGroupOffset := self.FieldBackupGroupOffset
	FieldBackupGroupOffsetArg, FieldBackupGroupOffsetFin := FieldBackupGroupOffset.c()
	result.BackupGroupOffset = FieldBackupGroupOffsetArg
	FieldBackupCurrLineSize := self.FieldBackupCurrLineSize

	result.BackupCurrLineSize = FieldBackupCurrLineSize.toC()
	FieldBackupCurrLineTextBaseOffset := self.FieldBackupCurrLineTextBaseOffset

	result.BackupCurrLineTextBaseOffset = C.float(FieldBackupCurrLineTextBaseOffset)
	FieldBackupActiveIdIsAlive := self.FieldBackupActiveIdIsAlive

	result.BackupActiveIdIsAlive = C.ImGuiID(FieldBackupActiveIdIsAlive)
	FieldBackupActiveIdPreviousFrameIsAlive := self.FieldBackupActiveIdPreviousFrameIsAlive

	result.BackupActiveIdPreviousFrameIsAlive = C.bool(FieldBackupActiveIdPreviousFrameIsAlive)
	FieldBackupHoveredIdIsAlive := self.FieldBackupHoveredIdIsAlive

	result.BackupHoveredIdIsAlive = C.bool(FieldBackupHoveredIdIsAlive)
	FieldEmitItem := self.FieldEmitItem

	result.EmitItem = C.bool(FieldEmitItem)
	releaseFn = func() {
		FieldBackupIndentFin()
		FieldBackupGroupOffsetFin()
	}
	return result, releaseFn
}

func (self GroupData) c() (result C.ImGuiGroupData, fin func()) {
	resultPtr, finFn := self.handle()
	return *resultPtr, finFn
}

func newGroupDataFromC(cvalue *C.ImGuiGroupData) *GroupData {
	result := new(GroupData)
	result.FieldWindowID = ID(cvalue.WindowID)
	result.FieldBackupCursorPos = *(&Vec2{}).fromC(cvalue.BackupCursorPos)
	result.FieldBackupCursorMaxPos = *(&Vec2{}).fromC(cvalue.BackupCursorMaxPos)
	result.FieldBackupIndent = *newVec1FromC(func() *C.ImVec1 { result := cvalue.BackupIndent; return &result }())

	result.FieldBackupGroupOffset = *newVec1FromC(func() *C.ImVec1 { result := cvalue.BackupGroupOffset; return &result }())

	result.FieldBackupCurrLineSize = *(&Vec2{}).fromC(cvalue.BackupCurrLineSize)
	result.FieldBackupCurrLineTextBaseOffset = float32(cvalue.BackupCurrLineTextBaseOffset)
	result.FieldBackupActiveIdIsAlive = ID(cvalue.BackupActiveIdIsAlive)
	result.FieldBackupActiveIdPreviousFrameIsAlive = cvalue.BackupActiveIdPreviousFrameIsAlive == C.bool(true)
	result.FieldBackupHoveredIdIsAlive = cvalue.BackupHoveredIdIsAlive == C.bool(true)
	result.FieldEmitItem = cvalue.EmitItem == C.bool(true)
	return result
}

type IO struct {
	// TODO: contains unsupported fields
	data unsafe.Pointer
}

func (self IO) handle() (result *C.ImGuiIO, releaseFn func()) {
	result = (*C.ImGuiIO)(self.data)
	return result, func() {}
}

func (self IO) c() (result C.ImGuiIO, fin func()) {
	resultPtr, finFn := self.handle()
	return *resultPtr, finFn
}

func newIOFromC(cvalue *C.ImGuiIO) *IO {
	result := new(IO)
	result.data = unsafe.Pointer(cvalue)
	return result
}

type InputEvent struct {
	// TODO: contains unsupported fields
	data unsafe.Pointer
}

func (self InputEvent) handle() (result *C.ImGuiInputEvent, releaseFn func()) {
	result = (*C.ImGuiInputEvent)(self.data)
	return result, func() {}
}

func (self InputEvent) c() (result C.ImGuiInputEvent, fin func()) {
	resultPtr, finFn := self.handle()
	return *resultPtr, finFn
}

func newInputEventFromC(cvalue *C.ImGuiInputEvent) *InputEvent {
	result := new(InputEvent)
	result.data = unsafe.Pointer(cvalue)
	return result
}

type InputEventAppFocused struct {
	FieldFocused bool
}

func (self InputEventAppFocused) handle() (result *C.ImGuiInputEventAppFocused, releaseFn func()) {
	result = new(C.ImGuiInputEventAppFocused)
	FieldFocused := self.FieldFocused

	result.Focused = C.bool(FieldFocused)
	releaseFn = func() {
	}
	return result, releaseFn
}

func (self InputEventAppFocused) c() (result C.ImGuiInputEventAppFocused, fin func()) {
	resultPtr, finFn := self.handle()
	return *resultPtr, finFn
}

func newInputEventAppFocusedFromC(cvalue *C.ImGuiInputEventAppFocused) *InputEventAppFocused {
	result := new(InputEventAppFocused)
	result.FieldFocused = cvalue.Focused == C.bool(true)
	return result
}

type InputEventKey struct {
	FieldKey         Key
	FieldDown        bool
	FieldAnalogValue float32
}

func (self InputEventKey) handle() (result *C.ImGuiInputEventKey, releaseFn func()) {
	result = new(C.ImGuiInputEventKey)
	FieldKey := self.FieldKey

	result.Key = C.ImGuiKey(FieldKey)
	FieldDown := self.FieldDown

	result.Down = C.bool(FieldDown)
	FieldAnalogValue := self.FieldAnalogValue

	result.AnalogValue = C.float(FieldAnalogValue)
	releaseFn = func() {
	}
	return result, releaseFn
}

func (self InputEventKey) c() (result C.ImGuiInputEventKey, fin func()) {
	resultPtr, finFn := self.handle()
	return *resultPtr, finFn
}

func newInputEventKeyFromC(cvalue *C.ImGuiInputEventKey) *InputEventKey {
	result := new(InputEventKey)
	result.FieldKey = Key(cvalue.Key)
	result.FieldDown = cvalue.Down == C.bool(true)
	result.FieldAnalogValue = float32(cvalue.AnalogValue)
	return result
}

type InputEventMouseButton struct {
	FieldButton      int32
	FieldDown        bool
	FieldMouseSource MouseSource
}

func (self InputEventMouseButton) handle() (result *C.ImGuiInputEventMouseButton, releaseFn func()) {
	result = new(C.ImGuiInputEventMouseButton)
	FieldButton := self.FieldButton

	result.Button = C.int(FieldButton)
	FieldDown := self.FieldDown

	result.Down = C.bool(FieldDown)
	FieldMouseSource := self.FieldMouseSource

	result.MouseSource = C.ImGuiMouseSource(FieldMouseSource)
	releaseFn = func() {
	}
	return result, releaseFn
}

func (self InputEventMouseButton) c() (result C.ImGuiInputEventMouseButton, fin func()) {
	resultPtr, finFn := self.handle()
	return *resultPtr, finFn
}

func newInputEventMouseButtonFromC(cvalue *C.ImGuiInputEventMouseButton) *InputEventMouseButton {
	result := new(InputEventMouseButton)
	result.FieldButton = int32(cvalue.Button)
	result.FieldDown = cvalue.Down == C.bool(true)
	result.FieldMouseSource = MouseSource(cvalue.MouseSource)
	return result
}

// FIXME: Structures in the union below need to be declared as anonymous unions appears to be an extension?
// Using ImVec2() would fail on Clang 'union member 'MousePos' has a non-trivial default constructor'
type InputEventMousePos struct {
	FieldPosX        float32
	FieldPosY        float32
	FieldMouseSource MouseSource
}

func (self InputEventMousePos) handle() (result *C.ImGuiInputEventMousePos, releaseFn func()) {
	result = new(C.ImGuiInputEventMousePos)
	FieldPosX := self.FieldPosX

	result.PosX = C.float(FieldPosX)
	FieldPosY := self.FieldPosY

	result.PosY = C.float(FieldPosY)
	FieldMouseSource := self.FieldMouseSource

	result.MouseSource = C.ImGuiMouseSource(FieldMouseSource)
	releaseFn = func() {
	}
	return result, releaseFn
}

func (self InputEventMousePos) c() (result C.ImGuiInputEventMousePos, fin func()) {
	resultPtr, finFn := self.handle()
	return *resultPtr, finFn
}

func newInputEventMousePosFromC(cvalue *C.ImGuiInputEventMousePos) *InputEventMousePos {
	result := new(InputEventMousePos)
	result.FieldPosX = float32(cvalue.PosX)
	result.FieldPosY = float32(cvalue.PosY)
	result.FieldMouseSource = MouseSource(cvalue.MouseSource)
	return result
}

type InputEventMouseViewport struct {
	FieldHoveredViewportID ID
}

func (self InputEventMouseViewport) handle() (result *C.ImGuiInputEventMouseViewport, releaseFn func()) {
	result = new(C.ImGuiInputEventMouseViewport)
	FieldHoveredViewportID := self.FieldHoveredViewportID

	result.HoveredViewportID = C.ImGuiID(FieldHoveredViewportID)
	releaseFn = func() {
	}
	return result, releaseFn
}

func (self InputEventMouseViewport) c() (result C.ImGuiInputEventMouseViewport, fin func()) {
	resultPtr, finFn := self.handle()
	return *resultPtr, finFn
}

func newInputEventMouseViewportFromC(cvalue *C.ImGuiInputEventMouseViewport) *InputEventMouseViewport {
	result := new(InputEventMouseViewport)
	result.FieldHoveredViewportID = ID(cvalue.HoveredViewportID)
	return result
}

type InputEventMouseWheel struct {
	FieldWheelX      float32
	FieldWheelY      float32
	FieldMouseSource MouseSource
}

func (self InputEventMouseWheel) handle() (result *C.ImGuiInputEventMouseWheel, releaseFn func()) {
	result = new(C.ImGuiInputEventMouseWheel)
	FieldWheelX := self.FieldWheelX

	result.WheelX = C.float(FieldWheelX)
	FieldWheelY := self.FieldWheelY

	result.WheelY = C.float(FieldWheelY)
	FieldMouseSource := self.FieldMouseSource

	result.MouseSource = C.ImGuiMouseSource(FieldMouseSource)
	releaseFn = func() {
	}
	return result, releaseFn
}

func (self InputEventMouseWheel) c() (result C.ImGuiInputEventMouseWheel, fin func()) {
	resultPtr, finFn := self.handle()
	return *resultPtr, finFn
}

func newInputEventMouseWheelFromC(cvalue *C.ImGuiInputEventMouseWheel) *InputEventMouseWheel {
	result := new(InputEventMouseWheel)
	result.FieldWheelX = float32(cvalue.WheelX)
	result.FieldWheelY = float32(cvalue.WheelY)
	result.FieldMouseSource = MouseSource(cvalue.MouseSource)
	return result
}

type InputEventText struct {
	FieldChar uint32
}

func (self InputEventText) handle() (result *C.ImGuiInputEventText, releaseFn func()) {
	result = new(C.ImGuiInputEventText)
	FieldChar := self.FieldChar

	result.Char = C.uint(FieldChar)
	releaseFn = func() {
	}
	return result, releaseFn
}

func (self InputEventText) c() (result C.ImGuiInputEventText, fin func()) {
	resultPtr, finFn := self.handle()
	return *resultPtr, finFn
}

func newInputEventTextFromC(cvalue *C.ImGuiInputEventText) *InputEventText {
	result := new(InputEventText)
	result.FieldChar = uint32(cvalue.Char)
	return result
}

// Shared state of InputText(), passed as an argument to your callback when a ImGuiInputTextFlags_Callback* flag is used.
// The callback function should return 0 by default.
// Callbacks (follow a flag name and see comments in ImGuiInputTextFlags_ declarations for more details)
// - ImGuiInputTextFlags_CallbackEdit:        Callback on buffer edit (note that InputText() already returns true on edit, the callback is useful mainly to manipulate the underlying buffer while focus is active)
// - ImGuiInputTextFlags_CallbackAlways:      Callback on each iteration
// - ImGuiInputTextFlags_CallbackCompletion:  Callback on pressing TAB
// - ImGuiInputTextFlags_CallbackHistory:     Callback on pressing Up/Down arrows
// - ImGuiInputTextFlags_CallbackCharFilter:  Callback on character inputs to replace or discard them. Modify 'EventChar' to replace or discard, or return 1 in callback to discard.
// - ImGuiInputTextFlags_CallbackResize:      Callback on buffer capacity changes request (beyond 'buf_size' parameter value), allowing the string to grow.
type InputTextCallbackData struct {
	FieldCtx       *Context       // Parent UI context
	FieldEventFlag InputTextFlags // One ImGuiInputTextFlags_Callback*    // Read-only
	FieldFlags     InputTextFlags // What user passed to InputText()      // Read-only
	FieldUserData  unsafe.Pointer // What user passed to InputText()      // Read-only
	// Arguments for the different callback events
	// - To modify the text buffer in a callback, prefer using the InsertChars() / DeleteChars() function. InsertChars() will take care of calling the resize callback if necessary.
	// - If you know your edits are not going to resize the underlying buffer allocation, you may modify the contents of 'Buf[]' directly. You need to update 'BufTextLen' accordingly (0 <= BufTextLen < BufSize) and set 'BufDirty'' to true so InputText can update its internal state.
	FieldEventChar      Wchar  // Character input                      // Read-write   // [CharFilter] Replace character with another one, or set to zero to drop. return 1 is equivalent to setting EventChar=0;
	FieldEventKey       Key    // Key pressed (Up/Down/TAB)            // Read-only    // [Completion,History]
	FieldBuf            string // Text buffer                          // Read-write   // [Resize] Can replace pointer / [Completion,History,Always] Only write to pointed data, don't replace the actual pointer!
	FieldBufTextLen     int32  // Text length (in bytes)               // Read-write   // [Resize,Completion,History,Always] Exclude zero-terminator storage. In C land: == strlen(some_text), in C++ land: string.length()
	FieldBufSize        int32  // Buffer size (in bytes) = capacity+1  // Read-only    // [Resize,Completion,History,Always] Include zero-terminator storage. In C land == ARRAYSIZE(my_char_array), in C++ land: string.capacity()+1
	FieldBufDirty       bool   // Set if you modify Buf/BufTextLen!    // Write        // [Completion,History,Always]
	FieldCursorPos      int32  //                                      // Read-write   // [Completion,History,Always]
	FieldSelectionStart int32  //                                      // Read-write   // [Completion,History,Always] == to SelectionEnd when no selection)
	FieldSelectionEnd   int32  //                                      // Read-write   // [Completion,History,Always]
}

func (self InputTextCallbackData) handle() (result *C.ImGuiInputTextCallbackData, releaseFn func()) {
	result = new(C.ImGuiInputTextCallbackData)
	FieldCtx := self.FieldCtx
	FieldCtxArg, FieldCtxFin := FieldCtx.handle()
	result.Ctx = FieldCtxArg
	FieldEventFlag := self.FieldEventFlag

	result.EventFlag = C.ImGuiInputTextFlags(FieldEventFlag)
	FieldFlags := self.FieldFlags

	result.Flags = C.ImGuiInputTextFlags(FieldFlags)
	FieldUserData := self.FieldUserData
	FieldUserDataArg, FieldUserDataFin := WrapVoidPtr(FieldUserData)
	result.UserData = FieldUserDataArg
	FieldEventChar := self.FieldEventChar

	result.EventChar = C.ImWchar(FieldEventChar)
	FieldEventKey := self.FieldEventKey

	result.EventKey = C.ImGuiKey(FieldEventKey)
	FieldBuf := self.FieldBuf
	FieldBufArg, FieldBufFin := WrapString(FieldBuf)
	result.Buf = FieldBufArg
	FieldBufTextLen := self.FieldBufTextLen

	result.BufTextLen = C.int(FieldBufTextLen)
	FieldBufSize := self.FieldBufSize

	result.BufSize = C.int(FieldBufSize)
	FieldBufDirty := self.FieldBufDirty

	result.BufDirty = C.bool(FieldBufDirty)
	FieldCursorPos := self.FieldCursorPos

	result.CursorPos = C.int(FieldCursorPos)
	FieldSelectionStart := self.FieldSelectionStart

	result.SelectionStart = C.int(FieldSelectionStart)
	FieldSelectionEnd := self.FieldSelectionEnd

	result.SelectionEnd = C.int(FieldSelectionEnd)
	releaseFn = func() {
		FieldCtxFin()

		FieldUserDataFin()

		FieldBufFin()
	}
	return result, releaseFn
}

func (self InputTextCallbackData) c() (result C.ImGuiInputTextCallbackData, fin func()) {
	resultPtr, finFn := self.handle()
	return *resultPtr, finFn
}

func newInputTextCallbackDataFromC(cvalue *C.ImGuiInputTextCallbackData) *InputTextCallbackData {
	result := new(InputTextCallbackData)
	result.FieldCtx = newContextFromC(cvalue.Ctx)
	result.FieldEventFlag = InputTextFlags(cvalue.EventFlag)
	result.FieldFlags = InputTextFlags(cvalue.Flags)
	result.FieldUserData = unsafe.Pointer(cvalue.UserData)
	result.FieldEventChar = Wchar(cvalue.EventChar)
	result.FieldEventKey = Key(cvalue.EventKey)
	result.FieldBuf = C.GoString(cvalue.Buf)
	result.FieldBufTextLen = int32(cvalue.BufTextLen)
	result.FieldBufSize = int32(cvalue.BufSize)
	result.FieldBufDirty = cvalue.BufDirty == C.bool(true)
	result.FieldCursorPos = int32(cvalue.CursorPos)
	result.FieldSelectionStart = int32(cvalue.SelectionStart)
	result.FieldSelectionEnd = int32(cvalue.SelectionEnd)
	return result
}

// Internal temporary state for deactivating InputText() instances.
type InputTextDeactivatedState struct {
	FieldID    ID             // widget id owning the text state (which just got deactivated)
	FieldTextA Vector[string] // text buffer
}

func (self InputTextDeactivatedState) handle() (result *C.ImGuiInputTextDeactivatedState, releaseFn func()) {
	result = new(C.ImGuiInputTextDeactivatedState)
	FieldID := self.FieldID

	result.ID = C.ImGuiID(FieldID)
	FieldTextA := self.FieldTextA
	FieldTextAData := FieldTextA.Data
	FieldTextADataArg, FieldTextADataFin := WrapString(FieldTextAData)
	FieldTextAVecArg := new(C.ImVector_char)
	FieldTextAVecArg.Size = C.int(FieldTextA.Size)
	FieldTextAVecArg.Capacity = C.int(FieldTextA.Capacity)
	FieldTextAVecArg.Data = FieldTextADataArg
	FieldTextA.pinner.Pin(FieldTextAVecArg.Data)

	result.TextA = *FieldTextAVecArg
	releaseFn = func() {
		FieldTextADataFin()
		FieldTextA.pinner.Unpin()
	}
	return result, releaseFn
}

func (self InputTextDeactivatedState) c() (result C.ImGuiInputTextDeactivatedState, fin func()) {
	resultPtr, finFn := self.handle()
	return *resultPtr, finFn
}

func newInputTextDeactivatedStateFromC(cvalue *C.ImGuiInputTextDeactivatedState) *InputTextDeactivatedState {
	result := new(InputTextDeactivatedState)
	result.FieldID = ID(cvalue.ID)
	result.FieldTextA = newVectorFromC(cvalue.TextA.Size, cvalue.TextA.Capacity, C.GoString(cvalue.TextA.Data))
	return result
}

// Internal state of the currently focused/edited text input box
// For a given item ID, access with ImGui::GetInputTextState()
type InputTextState struct {
	FieldCtx                  *Context         // parent UI context (needs to be set explicitly by parent).
	FieldID                   ID               // widget id owning the text state
	FieldCurLenW              int32            // we need to maintain our buffer length in both UTF-8 and wchar format. UTF-8 length is valid even if TextA is not.
	FieldCurLenA              int32            // we need to maintain our buffer length in both UTF-8 and wchar format. UTF-8 length is valid even if TextA is not.
	FieldTextW                Vector[(*Wchar)] // edit buffer, we need to persist but can't guarantee the persistence of the user-provided buffer. so we copy into own buffer.
	FieldTextA                Vector[string]   // temporary UTF8 buffer for callbacks and other operations. this is not updated in every code-path! size=capacity.
	FieldInitialTextA         Vector[string]   // backup of end-user buffer at the time of focus (in UTF-8, unaltered)
	FieldTextAIsValid         bool             // temporary UTF8 buffer is not initially valid before we make the widget active (until then we pull the data from user argument)
	FieldBufCapacityA         int32            // end-user buffer capacity
	FieldScrollX              float32          // horizontal scrolling/offset
	FieldStb                  STBTexteditState // state for stb_textedit.h
	FieldCursorAnim           float32          // timer for cursor blink, reset on every user action so the cursor reappears immediately
	FieldCursorFollow         bool             // set when we want scrolling to follow the current cursor position (not always!)
	FieldSelectedAllMouseLock bool             // after a double-click to select all, we ignore further mouse drags to update selection
	FieldEdited               bool             // edited this frame
	FieldFlags                InputTextFlags   // copy of InputText() flags. may be used to check if e.g. ImGuiInputTextFlags_Password is set.
}

func (self InputTextState) handle() (result *C.ImGuiInputTextState, releaseFn func()) {
	result = new(C.ImGuiInputTextState)
	FieldCtx := self.FieldCtx
	FieldCtxArg, FieldCtxFin := FieldCtx.handle()
	result.Ctx = FieldCtxArg
	FieldID := self.FieldID

	result.ID = C.ImGuiID(FieldID)
	FieldCurLenW := self.FieldCurLenW

	result.CurLenW = C.int(FieldCurLenW)
	FieldCurLenA := self.FieldCurLenA

	result.CurLenA = C.int(FieldCurLenA)
	FieldTextW := self.FieldTextW
	FieldTextWData := FieldTextW.Data

	FieldTextWVecArg := new(C.ImVector_ImWchar)
	FieldTextWVecArg.Size = C.int(FieldTextW.Size)
	FieldTextWVecArg.Capacity = C.int(FieldTextW.Capacity)
	FieldTextWVecArg.Data = (*C.ImWchar)(FieldTextWData)
	FieldTextW.pinner.Pin(FieldTextWVecArg.Data)

	result.TextW = *FieldTextWVecArg
	FieldTextA := self.FieldTextA
	FieldTextAData := FieldTextA.Data
	FieldTextADataArg, FieldTextADataFin := WrapString(FieldTextAData)
	FieldTextAVecArg := new(C.ImVector_char)
	FieldTextAVecArg.Size = C.int(FieldTextA.Size)
	FieldTextAVecArg.Capacity = C.int(FieldTextA.Capacity)
	FieldTextAVecArg.Data = FieldTextADataArg
	FieldTextA.pinner.Pin(FieldTextAVecArg.Data)

	result.TextA = *FieldTextAVecArg
	FieldInitialTextA := self.FieldInitialTextA
	FieldInitialTextAData := FieldInitialTextA.Data
	FieldInitialTextADataArg, FieldInitialTextADataFin := WrapString(FieldInitialTextAData)
	FieldInitialTextAVecArg := new(C.ImVector_char)
	FieldInitialTextAVecArg.Size = C.int(FieldInitialTextA.Size)
	FieldInitialTextAVecArg.Capacity = C.int(FieldInitialTextA.Capacity)
	FieldInitialTextAVecArg.Data = FieldInitialTextADataArg
	FieldInitialTextA.pinner.Pin(FieldInitialTextAVecArg.Data)

	result.InitialTextA = *FieldInitialTextAVecArg
	FieldTextAIsValid := self.FieldTextAIsValid

	result.TextAIsValid = C.bool(FieldTextAIsValid)
	FieldBufCapacityA := self.FieldBufCapacityA

	result.BufCapacityA = C.int(FieldBufCapacityA)
	FieldScrollX := self.FieldScrollX

	result.ScrollX = C.float(FieldScrollX)
	FieldStb := self.FieldStb
	FieldStbArg, FieldStbFin := FieldStb.c()
	result.Stb = FieldStbArg
	FieldCursorAnim := self.FieldCursorAnim

	result.CursorAnim = C.float(FieldCursorAnim)
	FieldCursorFollow := self.FieldCursorFollow

	result.CursorFollow = C.bool(FieldCursorFollow)
	FieldSelectedAllMouseLock := self.FieldSelectedAllMouseLock

	result.SelectedAllMouseLock = C.bool(FieldSelectedAllMouseLock)
	FieldEdited := self.FieldEdited

	result.Edited = C.bool(FieldEdited)
	FieldFlags := self.FieldFlags

	result.Flags = C.ImGuiInputTextFlags(FieldFlags)
	releaseFn = func() {
		FieldCtxFin()

		FieldTextW.pinner.Unpin()
		FieldTextADataFin()
		FieldTextA.pinner.Unpin()
		FieldInitialTextADataFin()
		FieldInitialTextA.pinner.Unpin()

		FieldStbFin()
	}
	return result, releaseFn
}

func (self InputTextState) c() (result C.ImGuiInputTextState, fin func()) {
	resultPtr, finFn := self.handle()
	return *resultPtr, finFn
}

func newInputTextStateFromC(cvalue *C.ImGuiInputTextState) *InputTextState {
	result := new(InputTextState)
	result.FieldCtx = newContextFromC(cvalue.Ctx)
	result.FieldID = ID(cvalue.ID)
	result.FieldCurLenW = int32(cvalue.CurLenW)
	result.FieldCurLenA = int32(cvalue.CurLenA)
	result.FieldTextW = newVectorFromC(cvalue.TextW.Size, cvalue.TextW.Capacity, (*Wchar)(cvalue.TextW.Data))
	result.FieldTextA = newVectorFromC(cvalue.TextA.Size, cvalue.TextA.Capacity, C.GoString(cvalue.TextA.Data))
	result.FieldInitialTextA = newVectorFromC(cvalue.InitialTextA.Size, cvalue.InitialTextA.Capacity, C.GoString(cvalue.InitialTextA.Data))
	result.FieldTextAIsValid = cvalue.TextAIsValid == C.bool(true)
	result.FieldBufCapacityA = int32(cvalue.BufCapacityA)
	result.FieldScrollX = float32(cvalue.ScrollX)
	result.FieldStb = *newSTBTexteditStateFromC(func() *C.STB_TexteditState { result := cvalue.Stb; return &result }())

	result.FieldCursorAnim = float32(cvalue.CursorAnim)
	result.FieldCursorFollow = cvalue.CursorFollow == C.bool(true)
	result.FieldSelectedAllMouseLock = cvalue.SelectedAllMouseLock == C.bool(true)
	result.FieldEdited = cvalue.Edited == C.bool(true)
	result.FieldFlags = InputTextFlags(cvalue.Flags)
	return result
}

// [Internal] Storage used by IsKeyDown(), IsKeyPressed() etc functions.
// If prior to 1.87 you used io.KeysDownDuration[] (which was marked as internal), you should use GetKeyData(key)->DownDuration and *NOT* io.KeysData[key]->DownDuration.
type KeyData struct {
	FieldDown             bool    // True for if key is down
	FieldDownDuration     float32 // Duration the key has been down (<0.0f: not pressed, 0.0f: just pressed, >0.0f: time held)
	FieldDownDurationPrev float32 // Last frame duration the key has been down
	FieldAnalogValue      float32 // 0.0f..1.0f for gamepad values
}

func (self KeyData) handle() (result *C.ImGuiKeyData, releaseFn func()) {
	result = new(C.ImGuiKeyData)
	FieldDown := self.FieldDown

	result.Down = C.bool(FieldDown)
	FieldDownDuration := self.FieldDownDuration

	result.DownDuration = C.float(FieldDownDuration)
	FieldDownDurationPrev := self.FieldDownDurationPrev

	result.DownDurationPrev = C.float(FieldDownDurationPrev)
	FieldAnalogValue := self.FieldAnalogValue

	result.AnalogValue = C.float(FieldAnalogValue)
	releaseFn = func() {
	}
	return result, releaseFn
}

func (self KeyData) c() (result C.ImGuiKeyData, fin func()) {
	resultPtr, finFn := self.handle()
	return *resultPtr, finFn
}

func newKeyDataFromC(cvalue *C.ImGuiKeyData) *KeyData {
	result := new(KeyData)
	result.FieldDown = cvalue.Down == C.bool(true)
	result.FieldDownDuration = float32(cvalue.DownDuration)
	result.FieldDownDurationPrev = float32(cvalue.DownDurationPrev)
	result.FieldAnalogValue = float32(cvalue.AnalogValue)
	return result
}

// This extends ImGuiKeyData but only for named keys (legacy keys don't support the new features)
// Stored in main context (1 per named key). In the future it might be merged into ImGuiKeyData.
type KeyOwnerData struct {
	FieldOwnerCurr        ID
	FieldOwnerNext        ID
	FieldLockThisFrame    bool // Reading this key requires explicit owner id (until end of frame). Set by ImGuiInputFlags_LockThisFrame.
	FieldLockUntilRelease bool // Reading this key requires explicit owner id (until key is released). Set by ImGuiInputFlags_LockUntilRelease. When this is true LockThisFrame is always true as well.
}

func (self KeyOwnerData) handle() (result *C.ImGuiKeyOwnerData, releaseFn func()) {
	result = new(C.ImGuiKeyOwnerData)
	FieldOwnerCurr := self.FieldOwnerCurr

	result.OwnerCurr = C.ImGuiID(FieldOwnerCurr)
	FieldOwnerNext := self.FieldOwnerNext

	result.OwnerNext = C.ImGuiID(FieldOwnerNext)
	FieldLockThisFrame := self.FieldLockThisFrame

	result.LockThisFrame = C.bool(FieldLockThisFrame)
	FieldLockUntilRelease := self.FieldLockUntilRelease

	result.LockUntilRelease = C.bool(FieldLockUntilRelease)
	releaseFn = func() {
	}
	return result, releaseFn
}

func (self KeyOwnerData) c() (result C.ImGuiKeyOwnerData, fin func()) {
	resultPtr, finFn := self.handle()
	return *resultPtr, finFn
}

func newKeyOwnerDataFromC(cvalue *C.ImGuiKeyOwnerData) *KeyOwnerData {
	result := new(KeyOwnerData)
	result.FieldOwnerCurr = ID(cvalue.OwnerCurr)
	result.FieldOwnerNext = ID(cvalue.OwnerNext)
	result.FieldLockThisFrame = cvalue.LockThisFrame == C.bool(true)
	result.FieldLockUntilRelease = cvalue.LockUntilRelease == C.bool(true)
	return result
}

// Routing table entry (sizeof() == 16 bytes)
type KeyRoutingData struct {
	// TODO: contains unsupported fields
	data unsafe.Pointer
}

func (self KeyRoutingData) handle() (result *C.ImGuiKeyRoutingData, releaseFn func()) {
	result = (*C.ImGuiKeyRoutingData)(self.data)
	return result, func() {}
}

func (self KeyRoutingData) c() (result C.ImGuiKeyRoutingData, fin func()) {
	resultPtr, finFn := self.handle()
	return *resultPtr, finFn
}

func newKeyRoutingDataFromC(cvalue *C.ImGuiKeyRoutingData) *KeyRoutingData {
	result := new(KeyRoutingData)
	result.data = unsafe.Pointer(cvalue)
	return result
}

// Routing table: maintain a desired owner for each possible key-chord (key + mods), and setup owner in NewFrame() when mods are matching.
// Stored in main context (1 instance)
type KeyRoutingTable struct {
	// TODO: contains unsupported fields
	data unsafe.Pointer
}

func (self KeyRoutingTable) handle() (result *C.ImGuiKeyRoutingTable, releaseFn func()) {
	result = (*C.ImGuiKeyRoutingTable)(self.data)
	return result, func() {}
}

func (self KeyRoutingTable) c() (result C.ImGuiKeyRoutingTable, fin func()) {
	resultPtr, finFn := self.handle()
	return *resultPtr, finFn
}

func newKeyRoutingTableFromC(cvalue *C.ImGuiKeyRoutingTable) *KeyRoutingTable {
	result := new(KeyRoutingTable)
	result.data = unsafe.Pointer(cvalue)
	return result
}

// Status storage for the last submitted item
type LastItemData struct {
	FieldID          ID
	FieldInFlags     ItemFlags       // See ImGuiItemFlags_
	FieldStatusFlags ItemStatusFlags // See ImGuiItemStatusFlags_
	FieldRect        Rect            // Full rectangle
	FieldNavRect     Rect            // Navigation scoring rectangle (not displayed)
	FieldDisplayRect Rect            // Display rectangle (only if ImGuiItemStatusFlags_HasDisplayRect is set)
}

func (self LastItemData) handle() (result *C.ImGuiLastItemData, releaseFn func()) {
	result = new(C.ImGuiLastItemData)
	FieldID := self.FieldID

	result.ID = C.ImGuiID(FieldID)
	FieldInFlags := self.FieldInFlags

	result.InFlags = C.ImGuiItemFlags(FieldInFlags)
	FieldStatusFlags := self.FieldStatusFlags

	result.StatusFlags = C.ImGuiItemStatusFlags(FieldStatusFlags)
	FieldRect := self.FieldRect

	result.Rect = FieldRect.toC()
	FieldNavRect := self.FieldNavRect

	result.NavRect = FieldNavRect.toC()
	FieldDisplayRect := self.FieldDisplayRect

	result.DisplayRect = FieldDisplayRect.toC()
	releaseFn = func() {
	}
	return result, releaseFn
}

func (self LastItemData) c() (result C.ImGuiLastItemData, fin func()) {
	resultPtr, finFn := self.handle()
	return *resultPtr, finFn
}

func newLastItemDataFromC(cvalue *C.ImGuiLastItemData) *LastItemData {
	result := new(LastItemData)
	result.FieldID = ID(cvalue.ID)
	result.FieldInFlags = ItemFlags(cvalue.InFlags)
	result.FieldStatusFlags = ItemStatusFlags(cvalue.StatusFlags)
	result.FieldRect = *(&Rect{}).fromC(cvalue.Rect)
	result.FieldNavRect = *(&Rect{}).fromC(cvalue.NavRect)
	result.FieldDisplayRect = *(&Rect{}).fromC(cvalue.DisplayRect)
	return result
}

// Helper: Manually clip large list of items.
// If you have lots evenly spaced items and you have random access to the list, you can perform coarse
// clipping based on visibility to only submit items that are in view.
// The clipper calculates the range of visible items and advance the cursor to compensate for the non-visible items we have skipped.
// (Dear ImGui already clip items based on their bounds but: it needs to first layout the item to do so, and generally
//
//	fetching/submitting your own data incurs additional cost. Coarse clipping using ImGuiListClipper allows you to easily
//	scale using lists with tens of thousands of items without a problem)
//
// Usage:
//
//	ImGuiListClipper clipper;
//	clipper.Begin(1000);         // We have 1000 elements, evenly spaced.
//	while (clipper.Step())
//	    for (int i = clipper.DisplayStart; i < clipper.DisplayEnd; i++)
//	        ImGui::Text("line number %d", i);
//
// Generally what happens is:
// - Clipper lets you process the first element (DisplayStart = 0, DisplayEnd = 1) regardless of it being visible or not.
// - User code submit that one element.
// - Clipper can measure the height of the first element
// - Clipper calculate the actual range of elements to display based on the current clipping rectangle, position the cursor before the first visible element.
// - User code submit visible elements.
// - The clipper also handles various subtleties related to keyboard/gamepad navigation, wrapping etc.
type ListClipper struct {
	FieldCtx          *Context       // Parent UI context
	FieldDisplayStart int32          // First item to display, updated by each call to Step()
	FieldDisplayEnd   int32          // End of items to display (exclusive)
	FieldItemsCount   int32          // [Internal] Number of items
	FieldItemsHeight  float32        // [Internal] Height of item after a first step and item submission can calculate it
	FieldStartPosY    float32        // [Internal] Cursor position at the time of Begin() or after table frozen rows are all processed
	FieldTempData     unsafe.Pointer // [Internal] Internal data
}

func (self ListClipper) handle() (result *C.ImGuiListClipper, releaseFn func()) {
	result = new(C.ImGuiListClipper)
	FieldCtx := self.FieldCtx
	FieldCtxArg, FieldCtxFin := FieldCtx.handle()
	result.Ctx = FieldCtxArg
	FieldDisplayStart := self.FieldDisplayStart

	result.DisplayStart = C.int(FieldDisplayStart)
	FieldDisplayEnd := self.FieldDisplayEnd

	result.DisplayEnd = C.int(FieldDisplayEnd)
	FieldItemsCount := self.FieldItemsCount

	result.ItemsCount = C.int(FieldItemsCount)
	FieldItemsHeight := self.FieldItemsHeight

	result.ItemsHeight = C.float(FieldItemsHeight)
	FieldStartPosY := self.FieldStartPosY

	result.StartPosY = C.float(FieldStartPosY)
	FieldTempData := self.FieldTempData
	FieldTempDataArg, FieldTempDataFin := WrapVoidPtr(FieldTempData)
	result.TempData = FieldTempDataArg
	releaseFn = func() {
		FieldCtxFin()

		FieldTempDataFin()
	}
	return result, releaseFn
}

func (self ListClipper) c() (result C.ImGuiListClipper, fin func()) {
	resultPtr, finFn := self.handle()
	return *resultPtr, finFn
}

func newListClipperFromC(cvalue *C.ImGuiListClipper) *ListClipper {
	result := new(ListClipper)
	result.FieldCtx = newContextFromC(cvalue.Ctx)
	result.FieldDisplayStart = int32(cvalue.DisplayStart)
	result.FieldDisplayEnd = int32(cvalue.DisplayEnd)
	result.FieldItemsCount = int32(cvalue.ItemsCount)
	result.FieldItemsHeight = float32(cvalue.ItemsHeight)
	result.FieldStartPosY = float32(cvalue.StartPosY)
	result.FieldTempData = unsafe.Pointer(cvalue.TempData)
	return result
}

// Temporary clipper data, buffers shared/reused between instances
type ListClipperData struct {
	FieldListClipper     *ListClipper
	FieldLossynessOffset float32
	FieldStepNo          int32
	FieldItemsFrozen     int32
	FieldRanges          Vector[*ListClipperRange]
}

func (self ListClipperData) handle() (result *C.ImGuiListClipperData, releaseFn func()) {
	result = new(C.ImGuiListClipperData)
	FieldListClipper := self.FieldListClipper
	FieldListClipperArg, FieldListClipperFin := FieldListClipper.handle()
	result.ListClipper = FieldListClipperArg
	FieldLossynessOffset := self.FieldLossynessOffset

	result.LossynessOffset = C.float(FieldLossynessOffset)
	FieldStepNo := self.FieldStepNo

	result.StepNo = C.int(FieldStepNo)
	FieldItemsFrozen := self.FieldItemsFrozen

	result.ItemsFrozen = C.int(FieldItemsFrozen)
	FieldRanges := self.FieldRanges
	FieldRangesData := FieldRanges.Data
	FieldRangesDataArg, FieldRangesDataFin := FieldRangesData.handle()
	FieldRangesVecArg := new(C.ImVector_ImGuiListClipperRange)
	FieldRangesVecArg.Size = C.int(FieldRanges.Size)
	FieldRangesVecArg.Capacity = C.int(FieldRanges.Capacity)
	FieldRangesVecArg.Data = FieldRangesDataArg
	FieldRanges.pinner.Pin(FieldRangesVecArg.Data)

	result.Ranges = *FieldRangesVecArg
	releaseFn = func() {
		FieldListClipperFin()

		FieldRangesDataFin()
		FieldRanges.pinner.Unpin()
	}
	return result, releaseFn
}

func (self ListClipperData) c() (result C.ImGuiListClipperData, fin func()) {
	resultPtr, finFn := self.handle()
	return *resultPtr, finFn
}

func newListClipperDataFromC(cvalue *C.ImGuiListClipperData) *ListClipperData {
	result := new(ListClipperData)
	result.FieldListClipper = newListClipperFromC(cvalue.ListClipper)
	result.FieldLossynessOffset = float32(cvalue.LossynessOffset)
	result.FieldStepNo = int32(cvalue.StepNo)
	result.FieldItemsFrozen = int32(cvalue.ItemsFrozen)
	result.FieldRanges = newVectorFromC(cvalue.Ranges.Size, cvalue.Ranges.Capacity, newListClipperRangeFromC(cvalue.Ranges.Data))
	return result
}

// Note that Max is exclusive, so perhaps should be using a Begin/End convention.
type ListClipperRange struct {
	FieldMin                 int32
	FieldMax                 int32
	FieldPosToIndexConvert   bool // Begin/End are absolute position (will be converted to indices later)
	FieldPosToIndexOffsetMin int  // Add to Min after converting to indices
	FieldPosToIndexOffsetMax int  // Add to Min after converting to indices
}

func (self ListClipperRange) handle() (result *C.ImGuiListClipperRange, releaseFn func()) {
	result = new(C.ImGuiListClipperRange)
	FieldMin := self.FieldMin

	result.Min = C.int(FieldMin)
	FieldMax := self.FieldMax

	result.Max = C.int(FieldMax)
	FieldPosToIndexConvert := self.FieldPosToIndexConvert

	result.PosToIndexConvert = C.bool(FieldPosToIndexConvert)
	FieldPosToIndexOffsetMin := self.FieldPosToIndexOffsetMin

	result.PosToIndexOffsetMin = C.ImS8(FieldPosToIndexOffsetMin)
	FieldPosToIndexOffsetMax := self.FieldPosToIndexOffsetMax

	result.PosToIndexOffsetMax = C.ImS8(FieldPosToIndexOffsetMax)
	releaseFn = func() {
	}
	return result, releaseFn
}

func (self ListClipperRange) c() (result C.ImGuiListClipperRange, fin func()) {
	resultPtr, finFn := self.handle()
	return *resultPtr, finFn
}

func newListClipperRangeFromC(cvalue *C.ImGuiListClipperRange) *ListClipperRange {
	result := new(ListClipperRange)
	result.FieldMin = int32(cvalue.Min)
	result.FieldMax = int32(cvalue.Max)
	result.FieldPosToIndexConvert = cvalue.PosToIndexConvert == C.bool(true)
	result.FieldPosToIndexOffsetMin = int(cvalue.PosToIndexOffsetMin)
	result.FieldPosToIndexOffsetMax = int(cvalue.PosToIndexOffsetMax)
	return result
}

type LocEntry struct {
	FieldKey  LocKey
	FieldText string
}

func (self LocEntry) handle() (result *C.ImGuiLocEntry, releaseFn func()) {
	result = new(C.ImGuiLocEntry)
	FieldKey := self.FieldKey

	result.Key = C.ImGuiLocKey(FieldKey)
	FieldText := self.FieldText
	FieldTextArg, FieldTextFin := WrapString(FieldText)
	result.Text = FieldTextArg
	releaseFn = func() {
		FieldTextFin()
	}
	return result, releaseFn
}

func (self LocEntry) c() (result C.ImGuiLocEntry, fin func()) {
	resultPtr, finFn := self.handle()
	return *resultPtr, finFn
}

func newLocEntryFromC(cvalue *C.ImGuiLocEntry) *LocEntry {
	result := new(LocEntry)
	result.FieldKey = LocKey(cvalue.Key)
	result.FieldText = C.GoString(cvalue.Text)
	return result
}

// Simple column measurement, currently used for MenuItem() only.. This is very short-sighted/throw-away code and NOT a generic helper.
type MenuColumns struct {
	// TODO: contains unsupported fields
	data unsafe.Pointer
}

func (self MenuColumns) handle() (result *C.ImGuiMenuColumns, releaseFn func()) {
	result = (*C.ImGuiMenuColumns)(self.data)
	return result, func() {}
}

func (self MenuColumns) c() (result C.ImGuiMenuColumns, fin func()) {
	resultPtr, finFn := self.handle()
	return *resultPtr, finFn
}

func newMenuColumnsFromC(cvalue *C.ImGuiMenuColumns) *MenuColumns {
	result := new(MenuColumns)
	result.data = unsafe.Pointer(cvalue)
	return result
}

type MetricsConfig struct {
	FieldShowDebugLog                 bool
	FieldShowStackTool                bool
	FieldShowWindowsRects             bool
	FieldShowWindowsBeginOrder        bool
	FieldShowTablesRects              bool
	FieldShowDrawCmdMesh              bool
	FieldShowDrawCmdBoundingBoxes     bool
	FieldShowAtlasTintedWithTextColor bool
	FieldShowDockingNodes             bool
	FieldShowWindowsRectsType         int32
	FieldShowTablesRectsType          int32
}

func (self MetricsConfig) handle() (result *C.ImGuiMetricsConfig, releaseFn func()) {
	result = new(C.ImGuiMetricsConfig)
	FieldShowDebugLog := self.FieldShowDebugLog

	result.ShowDebugLog = C.bool(FieldShowDebugLog)
	FieldShowStackTool := self.FieldShowStackTool

	result.ShowStackTool = C.bool(FieldShowStackTool)
	FieldShowWindowsRects := self.FieldShowWindowsRects

	result.ShowWindowsRects = C.bool(FieldShowWindowsRects)
	FieldShowWindowsBeginOrder := self.FieldShowWindowsBeginOrder

	result.ShowWindowsBeginOrder = C.bool(FieldShowWindowsBeginOrder)
	FieldShowTablesRects := self.FieldShowTablesRects

	result.ShowTablesRects = C.bool(FieldShowTablesRects)
	FieldShowDrawCmdMesh := self.FieldShowDrawCmdMesh

	result.ShowDrawCmdMesh = C.bool(FieldShowDrawCmdMesh)
	FieldShowDrawCmdBoundingBoxes := self.FieldShowDrawCmdBoundingBoxes

	result.ShowDrawCmdBoundingBoxes = C.bool(FieldShowDrawCmdBoundingBoxes)
	FieldShowAtlasTintedWithTextColor := self.FieldShowAtlasTintedWithTextColor

	result.ShowAtlasTintedWithTextColor = C.bool(FieldShowAtlasTintedWithTextColor)
	FieldShowDockingNodes := self.FieldShowDockingNodes

	result.ShowDockingNodes = C.bool(FieldShowDockingNodes)
	FieldShowWindowsRectsType := self.FieldShowWindowsRectsType

	result.ShowWindowsRectsType = C.int(FieldShowWindowsRectsType)
	FieldShowTablesRectsType := self.FieldShowTablesRectsType

	result.ShowTablesRectsType = C.int(FieldShowTablesRectsType)
	releaseFn = func() {
	}
	return result, releaseFn
}

func (self MetricsConfig) c() (result C.ImGuiMetricsConfig, fin func()) {
	resultPtr, finFn := self.handle()
	return *resultPtr, finFn
}

func newMetricsConfigFromC(cvalue *C.ImGuiMetricsConfig) *MetricsConfig {
	result := new(MetricsConfig)
	result.FieldShowDebugLog = cvalue.ShowDebugLog == C.bool(true)
	result.FieldShowStackTool = cvalue.ShowStackTool == C.bool(true)
	result.FieldShowWindowsRects = cvalue.ShowWindowsRects == C.bool(true)
	result.FieldShowWindowsBeginOrder = cvalue.ShowWindowsBeginOrder == C.bool(true)
	result.FieldShowTablesRects = cvalue.ShowTablesRects == C.bool(true)
	result.FieldShowDrawCmdMesh = cvalue.ShowDrawCmdMesh == C.bool(true)
	result.FieldShowDrawCmdBoundingBoxes = cvalue.ShowDrawCmdBoundingBoxes == C.bool(true)
	result.FieldShowAtlasTintedWithTextColor = cvalue.ShowAtlasTintedWithTextColor == C.bool(true)
	result.FieldShowDockingNodes = cvalue.ShowDockingNodes == C.bool(true)
	result.FieldShowWindowsRectsType = int32(cvalue.ShowWindowsRectsType)
	result.FieldShowTablesRectsType = int32(cvalue.ShowTablesRectsType)
	return result
}

type NavItemData struct {
	// TODO: contains unsupported fields
	data unsafe.Pointer
}

func (self NavItemData) handle() (result *C.ImGuiNavItemData, releaseFn func()) {
	result = (*C.ImGuiNavItemData)(self.data)
	return result, func() {}
}

func (self NavItemData) c() (result C.ImGuiNavItemData, fin func()) {
	resultPtr, finFn := self.handle()
	return *resultPtr, finFn
}

func newNavItemDataFromC(cvalue *C.ImGuiNavItemData) *NavItemData {
	result := new(NavItemData)
	result.data = unsafe.Pointer(cvalue)
	return result
}

// Store data emitted by TreeNode() for usage by TreePop() to implement ImGuiTreeNodeFlags_NavLeftJumpsBackHere.
// This is the minimum amount of data that we need to perform the equivalent of NavApplyItemToResult() and which we can't infer in TreePop()
// Only stored when the node is a potential candidate for landing on a Left arrow jump.
type NavTreeNodeData struct {
	FieldID      ID
	FieldInFlags ItemFlags
	FieldNavRect Rect
}

func (self NavTreeNodeData) handle() (result *C.ImGuiNavTreeNodeData, releaseFn func()) {
	result = new(C.ImGuiNavTreeNodeData)
	FieldID := self.FieldID

	result.ID = C.ImGuiID(FieldID)
	FieldInFlags := self.FieldInFlags

	result.InFlags = C.ImGuiItemFlags(FieldInFlags)
	FieldNavRect := self.FieldNavRect

	result.NavRect = FieldNavRect.toC()
	releaseFn = func() {
	}
	return result, releaseFn
}

func (self NavTreeNodeData) c() (result C.ImGuiNavTreeNodeData, fin func()) {
	resultPtr, finFn := self.handle()
	return *resultPtr, finFn
}

func newNavTreeNodeDataFromC(cvalue *C.ImGuiNavTreeNodeData) *NavTreeNodeData {
	result := new(NavTreeNodeData)
	result.FieldID = ID(cvalue.ID)
	result.FieldInFlags = ItemFlags(cvalue.InFlags)
	result.FieldNavRect = *(&Rect{}).fromC(cvalue.NavRect)
	return result
}

type NextItemData struct {
	// TODO: contains unsupported fields
	data unsafe.Pointer
}

func (self NextItemData) handle() (result *C.ImGuiNextItemData, releaseFn func()) {
	result = (*C.ImGuiNextItemData)(self.data)
	return result, func() {}
}

func (self NextItemData) c() (result C.ImGuiNextItemData, fin func()) {
	resultPtr, finFn := self.handle()
	return *resultPtr, finFn
}

func newNextItemDataFromC(cvalue *C.ImGuiNextItemData) *NextItemData {
	result := new(NextItemData)
	result.data = unsafe.Pointer(cvalue)
	return result
}

// Storage for SetNexWindow** functions
type NextWindowData struct {
	// TODO: contains unsupported fields
	data unsafe.Pointer
}

func (self NextWindowData) handle() (result *C.ImGuiNextWindowData, releaseFn func()) {
	result = (*C.ImGuiNextWindowData)(self.data)
	return result, func() {}
}

func (self NextWindowData) c() (result C.ImGuiNextWindowData, fin func()) {
	resultPtr, finFn := self.handle()
	return *resultPtr, finFn
}

func newNextWindowDataFromC(cvalue *C.ImGuiNextWindowData) *NextWindowData {
	result := new(NextWindowData)
	result.data = unsafe.Pointer(cvalue)
	return result
}

type OldColumnData struct {
	FieldOffsetNorm             float32 // Column start offset, normalized 0.0 (far left) -> 1.0 (far right)
	FieldOffsetNormBeforeResize float32
	FieldFlags                  OldColumnFlags // Not exposed
	FieldClipRect               Rect
}

func (self OldColumnData) handle() (result *C.ImGuiOldColumnData, releaseFn func()) {
	result = new(C.ImGuiOldColumnData)
	FieldOffsetNorm := self.FieldOffsetNorm

	result.OffsetNorm = C.float(FieldOffsetNorm)
	FieldOffsetNormBeforeResize := self.FieldOffsetNormBeforeResize

	result.OffsetNormBeforeResize = C.float(FieldOffsetNormBeforeResize)
	FieldFlags := self.FieldFlags

	result.Flags = C.ImGuiOldColumnFlags(FieldFlags)
	FieldClipRect := self.FieldClipRect

	result.ClipRect = FieldClipRect.toC()
	releaseFn = func() {
	}
	return result, releaseFn
}

func (self OldColumnData) c() (result C.ImGuiOldColumnData, fin func()) {
	resultPtr, finFn := self.handle()
	return *resultPtr, finFn
}

func newOldColumnDataFromC(cvalue *C.ImGuiOldColumnData) *OldColumnData {
	result := new(OldColumnData)
	result.FieldOffsetNorm = float32(cvalue.OffsetNorm)
	result.FieldOffsetNormBeforeResize = float32(cvalue.OffsetNormBeforeResize)
	result.FieldFlags = OldColumnFlags(cvalue.Flags)
	result.FieldClipRect = *(&Rect{}).fromC(cvalue.ClipRect)
	return result
}

type OldColumns struct {
	FieldID                       ID
	FieldFlags                    OldColumnFlags
	FieldIsFirstFrame             bool
	FieldIsBeingResized           bool
	FieldCurrent                  int32
	FieldCount                    int32
	FieldOffMinX                  float32 // Offsets from HostWorkRect.Min.x
	FieldOffMaxX                  float32 // Offsets from HostWorkRect.Min.x
	FieldLineMinY                 float32
	FieldLineMaxY                 float32
	FieldHostCursorPosY           float32 // Backup of CursorPos at the time of BeginColumns()
	FieldHostCursorMaxPosX        float32 // Backup of CursorMaxPos at the time of BeginColumns()
	FieldHostInitialClipRect      Rect    // Backup of ClipRect at the time of BeginColumns()
	FieldHostBackupClipRect       Rect    // Backup of ClipRect during PushColumnsBackground()/PopColumnsBackground()
	FieldHostBackupParentWorkRect Rect    // Backup of WorkRect at the time of BeginColumns()
	FieldColumns                  Vector[*OldColumnData]
	FieldSplitter                 DrawListSplitter
}

func (self OldColumns) handle() (result *C.ImGuiOldColumns, releaseFn func()) {
	result = new(C.ImGuiOldColumns)
	FieldID := self.FieldID

	result.ID = C.ImGuiID(FieldID)
	FieldFlags := self.FieldFlags

	result.Flags = C.ImGuiOldColumnFlags(FieldFlags)
	FieldIsFirstFrame := self.FieldIsFirstFrame

	result.IsFirstFrame = C.bool(FieldIsFirstFrame)
	FieldIsBeingResized := self.FieldIsBeingResized

	result.IsBeingResized = C.bool(FieldIsBeingResized)
	FieldCurrent := self.FieldCurrent

	result.Current = C.int(FieldCurrent)
	FieldCount := self.FieldCount

	result.Count = C.int(FieldCount)
	FieldOffMinX := self.FieldOffMinX

	result.OffMinX = C.float(FieldOffMinX)
	FieldOffMaxX := self.FieldOffMaxX

	result.OffMaxX = C.float(FieldOffMaxX)
	FieldLineMinY := self.FieldLineMinY

	result.LineMinY = C.float(FieldLineMinY)
	FieldLineMaxY := self.FieldLineMaxY

	result.LineMaxY = C.float(FieldLineMaxY)
	FieldHostCursorPosY := self.FieldHostCursorPosY

	result.HostCursorPosY = C.float(FieldHostCursorPosY)
	FieldHostCursorMaxPosX := self.FieldHostCursorMaxPosX

	result.HostCursorMaxPosX = C.float(FieldHostCursorMaxPosX)
	FieldHostInitialClipRect := self.FieldHostInitialClipRect

	result.HostInitialClipRect = FieldHostInitialClipRect.toC()
	FieldHostBackupClipRect := self.FieldHostBackupClipRect

	result.HostBackupClipRect = FieldHostBackupClipRect.toC()
	FieldHostBackupParentWorkRect := self.FieldHostBackupParentWorkRect

	result.HostBackupParentWorkRect = FieldHostBackupParentWorkRect.toC()
	FieldColumns := self.FieldColumns
	FieldColumnsData := FieldColumns.Data
	FieldColumnsDataArg, FieldColumnsDataFin := FieldColumnsData.handle()
	FieldColumnsVecArg := new(C.ImVector_ImGuiOldColumnData)
	FieldColumnsVecArg.Size = C.int(FieldColumns.Size)
	FieldColumnsVecArg.Capacity = C.int(FieldColumns.Capacity)
	FieldColumnsVecArg.Data = FieldColumnsDataArg
	FieldColumns.pinner.Pin(FieldColumnsVecArg.Data)

	result.Columns = *FieldColumnsVecArg
	FieldSplitter := self.FieldSplitter
	FieldSplitterArg, FieldSplitterFin := FieldSplitter.c()
	result.Splitter = FieldSplitterArg
	releaseFn = func() {
		FieldColumnsDataFin()
		FieldColumns.pinner.Unpin()
		FieldSplitterFin()
	}
	return result, releaseFn
}

func (self OldColumns) c() (result C.ImGuiOldColumns, fin func()) {
	resultPtr, finFn := self.handle()
	return *resultPtr, finFn
}

func newOldColumnsFromC(cvalue *C.ImGuiOldColumns) *OldColumns {
	result := new(OldColumns)
	result.FieldID = ID(cvalue.ID)
	result.FieldFlags = OldColumnFlags(cvalue.Flags)
	result.FieldIsFirstFrame = cvalue.IsFirstFrame == C.bool(true)
	result.FieldIsBeingResized = cvalue.IsBeingResized == C.bool(true)
	result.FieldCurrent = int32(cvalue.Current)
	result.FieldCount = int32(cvalue.Count)
	result.FieldOffMinX = float32(cvalue.OffMinX)
	result.FieldOffMaxX = float32(cvalue.OffMaxX)
	result.FieldLineMinY = float32(cvalue.LineMinY)
	result.FieldLineMaxY = float32(cvalue.LineMaxY)
	result.FieldHostCursorPosY = float32(cvalue.HostCursorPosY)
	result.FieldHostCursorMaxPosX = float32(cvalue.HostCursorMaxPosX)
	result.FieldHostInitialClipRect = *(&Rect{}).fromC(cvalue.HostInitialClipRect)
	result.FieldHostBackupClipRect = *(&Rect{}).fromC(cvalue.HostBackupClipRect)
	result.FieldHostBackupParentWorkRect = *(&Rect{}).fromC(cvalue.HostBackupParentWorkRect)
	result.FieldColumns = newVectorFromC(cvalue.Columns.Size, cvalue.Columns.Capacity, newOldColumnDataFromC(cvalue.Columns.Data))
	result.FieldSplitter = *newDrawListSplitterFromC(func() *C.ImDrawListSplitter { result := cvalue.Splitter; return &result }())

	return result
}

// Helper: Execute a block of code at maximum once a frame. Convenient if you want to quickly create a UI within deep-nested code that runs multiple times every frame.
// Usage: static ImGuiOnceUponAFrame oaf; if (oaf) ImGui::Text("This will be called only once per frame");
type OnceUponAFrame struct {
	FieldRefFrame int32
}

func (self OnceUponAFrame) handle() (result *C.ImGuiOnceUponAFrame, releaseFn func()) {
	result = new(C.ImGuiOnceUponAFrame)
	FieldRefFrame := self.FieldRefFrame

	result.RefFrame = C.int(FieldRefFrame)
	releaseFn = func() {
	}
	return result, releaseFn
}

func (self OnceUponAFrame) c() (result C.ImGuiOnceUponAFrame, fin func()) {
	resultPtr, finFn := self.handle()
	return *resultPtr, finFn
}

func newOnceUponAFrameFromC(cvalue *C.ImGuiOnceUponAFrame) *OnceUponAFrame {
	result := new(OnceUponAFrame)
	result.FieldRefFrame = int32(cvalue.RefFrame)
	return result
}

// Data payload for Drag and Drop operations: AcceptDragDropPayload(), GetDragDropPayload()
type Payload struct {
	// TODO: contains unsupported fields
	data unsafe.Pointer
}

func (self Payload) handle() (result *C.ImGuiPayload, releaseFn func()) {
	result = (*C.ImGuiPayload)(self.data)
	return result, func() {}
}

func (self Payload) c() (result C.ImGuiPayload, fin func()) {
	resultPtr, finFn := self.handle()
	return *resultPtr, finFn
}

func newPayloadFromC(cvalue *C.ImGuiPayload) *Payload {
	result := new(Payload)
	result.data = unsafe.Pointer(cvalue)
	return result
}

// (Optional) Access via ImGui::GetPlatformIO()
type PlatformIO struct {
	// TODO: contains unsupported fields
	data unsafe.Pointer
}

func (self PlatformIO) handle() (result *C.ImGuiPlatformIO, releaseFn func()) {
	result = (*C.ImGuiPlatformIO)(self.data)
	return result, func() {}
}

func (self PlatformIO) c() (result C.ImGuiPlatformIO, fin func()) {
	resultPtr, finFn := self.handle()
	return *resultPtr, finFn
}

func newPlatformIOFromC(cvalue *C.ImGuiPlatformIO) *PlatformIO {
	result := new(PlatformIO)
	result.data = unsafe.Pointer(cvalue)
	return result
}

// (Optional) Support for IME (Input Method Editor) via the io.SetPlatformImeDataFn() function.
type PlatformImeData struct {
	FieldWantVisible     bool    // A widget wants the IME to be visible
	FieldInputPos        Vec2    // Position of the input cursor
	FieldInputLineHeight float32 // Line height
}

func (self PlatformImeData) handle() (result *C.ImGuiPlatformImeData, releaseFn func()) {
	result = new(C.ImGuiPlatformImeData)
	FieldWantVisible := self.FieldWantVisible

	result.WantVisible = C.bool(FieldWantVisible)
	FieldInputPos := self.FieldInputPos

	result.InputPos = FieldInputPos.toC()
	FieldInputLineHeight := self.FieldInputLineHeight

	result.InputLineHeight = C.float(FieldInputLineHeight)
	releaseFn = func() {
	}
	return result, releaseFn
}

func (self PlatformImeData) c() (result C.ImGuiPlatformImeData, fin func()) {
	resultPtr, finFn := self.handle()
	return *resultPtr, finFn
}

func newPlatformImeDataFromC(cvalue *C.ImGuiPlatformImeData) *PlatformImeData {
	result := new(PlatformImeData)
	result.FieldWantVisible = cvalue.WantVisible == C.bool(true)
	result.FieldInputPos = *(&Vec2{}).fromC(cvalue.InputPos)
	result.FieldInputLineHeight = float32(cvalue.InputLineHeight)
	return result
}

// (Optional) This is required when enabling multi-viewport. Represent the bounds of each connected monitor/display and their DPI.
// We use this information for multiple DPI support + clamping the position of popups and tooltips so they don't straddle multiple monitors.
type PlatformMonitor struct {
	FieldMainPos        Vec2           // Coordinates of the area displayed on this monitor (Min = upper left, Max = bottom right)
	FieldMainSize       Vec2           // Coordinates of the area displayed on this monitor (Min = upper left, Max = bottom right)
	FieldWorkPos        Vec2           // Coordinates without task bars / side bars / menu bars. Used to avoid positioning popups/tooltips inside this region. If you don't have this info, please copy the value for MainPos/MainSize.
	FieldWorkSize       Vec2           // Coordinates without task bars / side bars / menu bars. Used to avoid positioning popups/tooltips inside this region. If you don't have this info, please copy the value for MainPos/MainSize.
	FieldDpiScale       float32        // 1.0f = 96 DPI
	FieldPlatformHandle unsafe.Pointer // Backend dependant data (e.g. HMONITOR, GLFWmonitor*, SDL Display Index, NSScreen*)
}

func (self PlatformMonitor) handle() (result *C.ImGuiPlatformMonitor, releaseFn func()) {
	result = new(C.ImGuiPlatformMonitor)
	FieldMainPos := self.FieldMainPos

	result.MainPos = FieldMainPos.toC()
	FieldMainSize := self.FieldMainSize

	result.MainSize = FieldMainSize.toC()
	FieldWorkPos := self.FieldWorkPos

	result.WorkPos = FieldWorkPos.toC()
	FieldWorkSize := self.FieldWorkSize

	result.WorkSize = FieldWorkSize.toC()
	FieldDpiScale := self.FieldDpiScale

	result.DpiScale = C.float(FieldDpiScale)
	FieldPlatformHandle := self.FieldPlatformHandle
	FieldPlatformHandleArg, FieldPlatformHandleFin := WrapVoidPtr(FieldPlatformHandle)
	result.PlatformHandle = FieldPlatformHandleArg
	releaseFn = func() {
		FieldPlatformHandleFin()
	}
	return result, releaseFn
}

func (self PlatformMonitor) c() (result C.ImGuiPlatformMonitor, fin func()) {
	resultPtr, finFn := self.handle()
	return *resultPtr, finFn
}

func newPlatformMonitorFromC(cvalue *C.ImGuiPlatformMonitor) *PlatformMonitor {
	result := new(PlatformMonitor)
	result.FieldMainPos = *(&Vec2{}).fromC(cvalue.MainPos)
	result.FieldMainSize = *(&Vec2{}).fromC(cvalue.MainSize)
	result.FieldWorkPos = *(&Vec2{}).fromC(cvalue.WorkPos)
	result.FieldWorkSize = *(&Vec2{}).fromC(cvalue.WorkSize)
	result.FieldDpiScale = float32(cvalue.DpiScale)
	result.FieldPlatformHandle = unsafe.Pointer(cvalue.PlatformHandle)
	return result
}

// Storage for current popup stack
type PopupData struct {
	FieldPopupId         ID      // Set on OpenPopup()
	FieldWindow          *Window // Resolved on BeginPopup() - may stay unresolved if user never calls OpenPopup()
	FieldBackupNavWindow *Window // Set on OpenPopup(), a NavWindow that will be restored on popup close
	FieldParentNavLayer  int32   // Resolved on BeginPopup(). Actually a ImGuiNavLayer type (declared down below), initialized to -1 which is not part of an enum, but serves well-enough as "not any of layers" value
	FieldOpenFrameCount  int32   // Set on OpenPopup()
	FieldOpenParentId    ID      // Set on OpenPopup(), we need this to differentiate multiple menu sets from each others (e.g. inside menu bar vs loose menu items)
	FieldOpenPopupPos    Vec2    // Set on OpenPopup(), preferred popup position (typically == OpenMousePos when using mouse)
	FieldOpenMousePos    Vec2    // Set on OpenPopup(), copy of mouse position at the time of opening popup
}

func (self PopupData) handle() (result *C.ImGuiPopupData, releaseFn func()) {
	result = new(C.ImGuiPopupData)
	FieldPopupId := self.FieldPopupId

	result.PopupId = C.ImGuiID(FieldPopupId)
	FieldWindow := self.FieldWindow
	FieldWindowArg, FieldWindowFin := FieldWindow.handle()
	result.Window = FieldWindowArg
	FieldBackupNavWindow := self.FieldBackupNavWindow
	FieldBackupNavWindowArg, FieldBackupNavWindowFin := FieldBackupNavWindow.handle()
	result.BackupNavWindow = FieldBackupNavWindowArg
	FieldParentNavLayer := self.FieldParentNavLayer

	result.ParentNavLayer = C.int(FieldParentNavLayer)
	FieldOpenFrameCount := self.FieldOpenFrameCount

	result.OpenFrameCount = C.int(FieldOpenFrameCount)
	FieldOpenParentId := self.FieldOpenParentId

	result.OpenParentId = C.ImGuiID(FieldOpenParentId)
	FieldOpenPopupPos := self.FieldOpenPopupPos

	result.OpenPopupPos = FieldOpenPopupPos.toC()
	FieldOpenMousePos := self.FieldOpenMousePos

	result.OpenMousePos = FieldOpenMousePos.toC()
	releaseFn = func() {
		FieldWindowFin()
		FieldBackupNavWindowFin()
	}
	return result, releaseFn
}

func (self PopupData) c() (result C.ImGuiPopupData, fin func()) {
	resultPtr, finFn := self.handle()
	return *resultPtr, finFn
}

func newPopupDataFromC(cvalue *C.ImGuiPopupData) *PopupData {
	result := new(PopupData)
	result.FieldPopupId = ID(cvalue.PopupId)
	result.FieldWindow = newWindowFromC(cvalue.Window)
	result.FieldBackupNavWindow = newWindowFromC(cvalue.BackupNavWindow)
	result.FieldParentNavLayer = int32(cvalue.ParentNavLayer)
	result.FieldOpenFrameCount = int32(cvalue.OpenFrameCount)
	result.FieldOpenParentId = ID(cvalue.OpenParentId)
	result.FieldOpenPopupPos = *(&Vec2{}).fromC(cvalue.OpenPopupPos)
	result.FieldOpenMousePos = *(&Vec2{}).fromC(cvalue.OpenMousePos)
	return result
}

type PtrOrIndex struct {
	FieldPtr   unsafe.Pointer // Either field can be set, not both. e.g. Dock node tab bars are loose while BeginTabBar() ones are in a pool.
	FieldIndex int32          // Usually index in a main pool.
}

func (self PtrOrIndex) handle() (result *C.ImGuiPtrOrIndex, releaseFn func()) {
	result = new(C.ImGuiPtrOrIndex)
	FieldPtr := self.FieldPtr
	FieldPtrArg, FieldPtrFin := WrapVoidPtr(FieldPtr)
	result.Ptr = FieldPtrArg
	FieldIndex := self.FieldIndex

	result.Index = C.int(FieldIndex)
	releaseFn = func() {
		FieldPtrFin()
	}
	return result, releaseFn
}

func (self PtrOrIndex) c() (result C.ImGuiPtrOrIndex, fin func()) {
	resultPtr, finFn := self.handle()
	return *resultPtr, finFn
}

func newPtrOrIndexFromC(cvalue *C.ImGuiPtrOrIndex) *PtrOrIndex {
	result := new(PtrOrIndex)
	result.FieldPtr = unsafe.Pointer(cvalue.Ptr)
	result.FieldIndex = int32(cvalue.Index)
	return result
}

type SettingsHandler struct {
	// TODO: contains unsupported fields
	data unsafe.Pointer
}

func (self SettingsHandler) handle() (result *C.ImGuiSettingsHandler, releaseFn func()) {
	result = (*C.ImGuiSettingsHandler)(self.data)
	return result, func() {}
}

func (self SettingsHandler) c() (result C.ImGuiSettingsHandler, fin func()) {
	resultPtr, finFn := self.handle()
	return *resultPtr, finFn
}

func newSettingsHandlerFromC(cvalue *C.ImGuiSettingsHandler) *SettingsHandler {
	result := new(SettingsHandler)
	result.data = unsafe.Pointer(cvalue)
	return result
}

type ShrinkWidthItem struct {
	FieldIndex        int32
	FieldWidth        float32
	FieldInitialWidth float32
}

func (self ShrinkWidthItem) handle() (result *C.ImGuiShrinkWidthItem, releaseFn func()) {
	result = new(C.ImGuiShrinkWidthItem)
	FieldIndex := self.FieldIndex

	result.Index = C.int(FieldIndex)
	FieldWidth := self.FieldWidth

	result.Width = C.float(FieldWidth)
	FieldInitialWidth := self.FieldInitialWidth

	result.InitialWidth = C.float(FieldInitialWidth)
	releaseFn = func() {
	}
	return result, releaseFn
}

func (self ShrinkWidthItem) c() (result C.ImGuiShrinkWidthItem, fin func()) {
	resultPtr, finFn := self.handle()
	return *resultPtr, finFn
}

func newShrinkWidthItemFromC(cvalue *C.ImGuiShrinkWidthItem) *ShrinkWidthItem {
	result := new(ShrinkWidthItem)
	result.FieldIndex = int32(cvalue.Index)
	result.FieldWidth = float32(cvalue.Width)
	result.FieldInitialWidth = float32(cvalue.InitialWidth)
	return result
}

// Resizing callback data to apply custom constraint. As enabled by SetNextWindowSizeConstraints(). Callback is called during the next Begin().
// NB: For basic min/max size constraint on each axis you don't need to use the callback! The SetNextWindowSizeConstraints() parameters are enough.
type SizeCallbackData struct {
	FieldUserData    unsafe.Pointer // Read-only.   What user passed to SetNextWindowSizeConstraints(). Generally store an integer or float in here (need reinterpret_cast<>).
	FieldPos         Vec2           // Read-only.   Window position, for reference.
	FieldCurrentSize Vec2           // Read-only.   Current window size.
	FieldDesiredSize Vec2           // Read-write.  Desired size, based on user's mouse position. Write to this field to restrain resizing.
}

func (self SizeCallbackData) handle() (result *C.ImGuiSizeCallbackData, releaseFn func()) {
	result = new(C.ImGuiSizeCallbackData)
	FieldUserData := self.FieldUserData
	FieldUserDataArg, FieldUserDataFin := WrapVoidPtr(FieldUserData)
	result.UserData = FieldUserDataArg
	FieldPos := self.FieldPos

	result.Pos = FieldPos.toC()
	FieldCurrentSize := self.FieldCurrentSize

	result.CurrentSize = FieldCurrentSize.toC()
	FieldDesiredSize := self.FieldDesiredSize

	result.DesiredSize = FieldDesiredSize.toC()
	releaseFn = func() {
		FieldUserDataFin()
	}
	return result, releaseFn
}

func (self SizeCallbackData) c() (result C.ImGuiSizeCallbackData, fin func()) {
	resultPtr, finFn := self.handle()
	return *resultPtr, finFn
}

func newSizeCallbackDataFromC(cvalue *C.ImGuiSizeCallbackData) *SizeCallbackData {
	result := new(SizeCallbackData)
	result.FieldUserData = unsafe.Pointer(cvalue.UserData)
	result.FieldPos = *(&Vec2{}).fromC(cvalue.Pos)
	result.FieldCurrentSize = *(&Vec2{}).fromC(cvalue.CurrentSize)
	result.FieldDesiredSize = *(&Vec2{}).fromC(cvalue.DesiredSize)
	return result
}

type StackLevelInfo struct {
	// TODO: contains unsupported fields
	data unsafe.Pointer
}

func (self StackLevelInfo) handle() (result *C.ImGuiStackLevelInfo, releaseFn func()) {
	result = (*C.ImGuiStackLevelInfo)(self.data)
	return result, func() {}
}

func (self StackLevelInfo) c() (result C.ImGuiStackLevelInfo, fin func()) {
	resultPtr, finFn := self.handle()
	return *resultPtr, finFn
}

func newStackLevelInfoFromC(cvalue *C.ImGuiStackLevelInfo) *StackLevelInfo {
	result := new(StackLevelInfo)
	result.data = unsafe.Pointer(cvalue)
	return result
}

type StackSizes struct {
	FieldSizeOfIDStack         int16
	FieldSizeOfColorStack      int16
	FieldSizeOfStyleVarStack   int16
	FieldSizeOfFontStack       int16
	FieldSizeOfFocusScopeStack int16
	FieldSizeOfGroupStack      int16
	FieldSizeOfItemFlagsStack  int16
	FieldSizeOfBeginPopupStack int16
	FieldSizeOfDisabledStack   int16
}

func (self StackSizes) handle() (result *C.ImGuiStackSizes, releaseFn func()) {
	result = new(C.ImGuiStackSizes)
	FieldSizeOfIDStack := self.FieldSizeOfIDStack

	result.SizeOfIDStack = C.short(FieldSizeOfIDStack)
	FieldSizeOfColorStack := self.FieldSizeOfColorStack

	result.SizeOfColorStack = C.short(FieldSizeOfColorStack)
	FieldSizeOfStyleVarStack := self.FieldSizeOfStyleVarStack

	result.SizeOfStyleVarStack = C.short(FieldSizeOfStyleVarStack)
	FieldSizeOfFontStack := self.FieldSizeOfFontStack

	result.SizeOfFontStack = C.short(FieldSizeOfFontStack)
	FieldSizeOfFocusScopeStack := self.FieldSizeOfFocusScopeStack

	result.SizeOfFocusScopeStack = C.short(FieldSizeOfFocusScopeStack)
	FieldSizeOfGroupStack := self.FieldSizeOfGroupStack

	result.SizeOfGroupStack = C.short(FieldSizeOfGroupStack)
	FieldSizeOfItemFlagsStack := self.FieldSizeOfItemFlagsStack

	result.SizeOfItemFlagsStack = C.short(FieldSizeOfItemFlagsStack)
	FieldSizeOfBeginPopupStack := self.FieldSizeOfBeginPopupStack

	result.SizeOfBeginPopupStack = C.short(FieldSizeOfBeginPopupStack)
	FieldSizeOfDisabledStack := self.FieldSizeOfDisabledStack

	result.SizeOfDisabledStack = C.short(FieldSizeOfDisabledStack)
	releaseFn = func() {
	}
	return result, releaseFn
}

func (self StackSizes) c() (result C.ImGuiStackSizes, fin func()) {
	resultPtr, finFn := self.handle()
	return *resultPtr, finFn
}

func newStackSizesFromC(cvalue *C.ImGuiStackSizes) *StackSizes {
	result := new(StackSizes)
	result.FieldSizeOfIDStack = int16(cvalue.SizeOfIDStack)
	result.FieldSizeOfColorStack = int16(cvalue.SizeOfColorStack)
	result.FieldSizeOfStyleVarStack = int16(cvalue.SizeOfStyleVarStack)
	result.FieldSizeOfFontStack = int16(cvalue.SizeOfFontStack)
	result.FieldSizeOfFocusScopeStack = int16(cvalue.SizeOfFocusScopeStack)
	result.FieldSizeOfGroupStack = int16(cvalue.SizeOfGroupStack)
	result.FieldSizeOfItemFlagsStack = int16(cvalue.SizeOfItemFlagsStack)
	result.FieldSizeOfBeginPopupStack = int16(cvalue.SizeOfBeginPopupStack)
	result.FieldSizeOfDisabledStack = int16(cvalue.SizeOfDisabledStack)
	return result
}

// State for Stack tool queries
type StackTool struct {
	FieldLastActiveFrame         int32
	FieldStackLevel              int32 // -1: query stack and resize Results, >= 0: individual stack level
	FieldQueryId                 ID    // ID to query details for
	FieldResults                 Vector[*StackLevelInfo]
	FieldCopyToClipboardOnCtrlC  bool
	FieldCopyToClipboardLastTime float32
}

func (self StackTool) handle() (result *C.ImGuiStackTool, releaseFn func()) {
	result = new(C.ImGuiStackTool)
	FieldLastActiveFrame := self.FieldLastActiveFrame

	result.LastActiveFrame = C.int(FieldLastActiveFrame)
	FieldStackLevel := self.FieldStackLevel

	result.StackLevel = C.int(FieldStackLevel)
	FieldQueryId := self.FieldQueryId

	result.QueryId = C.ImGuiID(FieldQueryId)
	FieldResults := self.FieldResults
	FieldResultsData := FieldResults.Data
	FieldResultsDataArg, FieldResultsDataFin := FieldResultsData.handle()
	FieldResultsVecArg := new(C.ImVector_ImGuiStackLevelInfo)
	FieldResultsVecArg.Size = C.int(FieldResults.Size)
	FieldResultsVecArg.Capacity = C.int(FieldResults.Capacity)
	FieldResultsVecArg.Data = FieldResultsDataArg
	FieldResults.pinner.Pin(FieldResultsVecArg.Data)

	result.Results = *FieldResultsVecArg
	FieldCopyToClipboardOnCtrlC := self.FieldCopyToClipboardOnCtrlC

	result.CopyToClipboardOnCtrlC = C.bool(FieldCopyToClipboardOnCtrlC)
	FieldCopyToClipboardLastTime := self.FieldCopyToClipboardLastTime

	result.CopyToClipboardLastTime = C.float(FieldCopyToClipboardLastTime)
	releaseFn = func() {
		FieldResultsDataFin()
		FieldResults.pinner.Unpin()
	}
	return result, releaseFn
}

func (self StackTool) c() (result C.ImGuiStackTool, fin func()) {
	resultPtr, finFn := self.handle()
	return *resultPtr, finFn
}

func newStackToolFromC(cvalue *C.ImGuiStackTool) *StackTool {
	result := new(StackTool)
	result.FieldLastActiveFrame = int32(cvalue.LastActiveFrame)
	result.FieldStackLevel = int32(cvalue.StackLevel)
	result.FieldQueryId = ID(cvalue.QueryId)
	result.FieldResults = newVectorFromC(cvalue.Results.Size, cvalue.Results.Capacity, newStackLevelInfoFromC(cvalue.Results.Data))
	result.FieldCopyToClipboardOnCtrlC = cvalue.CopyToClipboardOnCtrlC == C.bool(true)
	result.FieldCopyToClipboardLastTime = float32(cvalue.CopyToClipboardLastTime)
	return result
}

// Helper: Key->Value storage
// Typically you don't have to worry about this since a storage is held within each Window.
// We use it to e.g. store collapse state for a tree (Int 0/1)
// This is optimized for efficient lookup (dichotomy into a contiguous buffer) and rare insertion (typically tied to user interactions aka max once a frame)
// You can use it as custom user storage for temporary values. Declare your own storage if, for example:
// - You want to manipulate the open/close state of a particular sub-tree in your interface (tree node uses Int 0/1 to store their state).
// - You want to store custom debug data easily without adding or editing structures in your code (probably not efficient, but convenient)
// Types are NOT stored, so it is up to you to make sure your Key don't collide with different types.
type Storage struct {
	FieldData Vector[*StoragePair]
}

func (self Storage) handle() (result *C.ImGuiStorage, releaseFn func()) {
	result = new(C.ImGuiStorage)
	FieldData := self.FieldData
	FieldDataData := FieldData.Data
	FieldDataDataArg, FieldDataDataFin := FieldDataData.handle()
	FieldDataVecArg := new(C.ImVector_ImGuiStoragePair)
	FieldDataVecArg.Size = C.int(FieldData.Size)
	FieldDataVecArg.Capacity = C.int(FieldData.Capacity)
	FieldDataVecArg.Data = FieldDataDataArg
	FieldData.pinner.Pin(FieldDataVecArg.Data)

	result.Data = *FieldDataVecArg
	releaseFn = func() {
		FieldDataDataFin()
		FieldData.pinner.Unpin()
	}
	return result, releaseFn
}

func (self Storage) c() (result C.ImGuiStorage, fin func()) {
	resultPtr, finFn := self.handle()
	return *resultPtr, finFn
}

func newStorageFromC(cvalue *C.ImGuiStorage) *Storage {
	result := new(Storage)
	result.FieldData = newVectorFromC(cvalue.Data.Size, cvalue.Data.Capacity, newStoragePairFromC(cvalue.Data.Data))
	return result
}

// [Internal]
type StoragePair struct {
	// TODO: contains unsupported fields
	data unsafe.Pointer
}

func (self StoragePair) handle() (result *C.ImGuiStoragePair, releaseFn func()) {
	result = (*C.ImGuiStoragePair)(self.data)
	return result, func() {}
}

func (self StoragePair) c() (result C.ImGuiStoragePair, fin func()) {
	resultPtr, finFn := self.handle()
	return *resultPtr, finFn
}

func newStoragePairFromC(cvalue *C.ImGuiStoragePair) *StoragePair {
	result := new(StoragePair)
	result.data = unsafe.Pointer(cvalue)
	return result
}

type Style struct {
	// TODO: contains unsupported fields
	data unsafe.Pointer
}

func (self Style) handle() (result *C.ImGuiStyle, releaseFn func()) {
	result = (*C.ImGuiStyle)(self.data)
	return result, func() {}
}

func (self Style) c() (result C.ImGuiStyle, fin func()) {
	resultPtr, finFn := self.handle()
	return *resultPtr, finFn
}

func newStyleFromC(cvalue *C.ImGuiStyle) *Style {
	result := new(Style)
	result.data = unsafe.Pointer(cvalue)
	return result
}

// Stacked style modifier, backup of modified data so we can restore it. Data type inferred from the variable.
type StyleMod struct {
	// TODO: contains unsupported fields
	data unsafe.Pointer
}

func (self StyleMod) handle() (result *C.ImGuiStyleMod, releaseFn func()) {
	result = (*C.ImGuiStyleMod)(self.data)
	return result, func() {}
}

func (self StyleMod) c() (result C.ImGuiStyleMod, fin func()) {
	resultPtr, finFn := self.handle()
	return *resultPtr, finFn
}

func newStyleModFromC(cvalue *C.ImGuiStyleMod) *StyleMod {
	result := new(StyleMod)
	result.data = unsafe.Pointer(cvalue)
	return result
}

// Storage for a tab bar (sizeof() 152 bytes)
type TabBar struct {
	FieldTabs                            Vector[*TabItem]
	FieldFlags                           TabBarFlags
	FieldID                              ID // Zero for tab-bars used by docking
	FieldSelectedTabId                   ID // Selected tab/window
	FieldNextSelectedTabId               ID // Next selected tab/window. Will also trigger a scrolling animation
	FieldVisibleTabId                    ID // Can occasionally be != SelectedTabId (e.g. when previewing contents for CTRL+TAB preview)
	FieldCurrFrameVisible                int32
	FieldPrevFrameVisible                int32
	FieldBarRect                         Rect
	FieldCurrTabsContentsHeight          float32
	FieldPrevTabsContentsHeight          float32 // Record the height of contents submitted below the tab bar
	FieldWidthAllTabs                    float32 // Actual width of all tabs (locked during layout)
	FieldWidthAllTabsIdeal               float32 // Ideal width if all tabs were visible and not clipped
	FieldScrollingAnim                   float32
	FieldScrollingTarget                 float32
	FieldScrollingTargetDistToVisibility float32
	FieldScrollingSpeed                  float32
	FieldScrollingRectMinX               float32
	FieldScrollingRectMaxX               float32
	FieldSeparatorMinX                   float32
	FieldSeparatorMaxX                   float32
	FieldReorderRequestTabId             ID
	FieldReorderRequestOffset            int
	FieldBeginCount                      int
	FieldWantLayout                      bool
	FieldVisibleTabWasSubmitted          bool
	FieldTabsAddedNew                    bool // Set to true when a new tab item or button has been added to the tab bar during last frame
	FieldTabsActiveCount                 int  // Number of tabs submitted this frame.
	FieldLastTabItemIdx                  int  // Index of last BeginTabItem() tab for use by EndTabItem()
	FieldItemSpacingY                    float32
	FieldFramePadding                    Vec2 // style.FramePadding locked at the time of BeginTabBar()
	FieldBackupCursorPos                 Vec2
	FieldTabsNames                       TextBuffer // For non-docking tab bar we re-append names in a contiguous buffer.
}

func (self TabBar) handle() (result *C.ImGuiTabBar, releaseFn func()) {
	result = new(C.ImGuiTabBar)
	FieldTabs := self.FieldTabs
	FieldTabsData := FieldTabs.Data
	FieldTabsDataArg, FieldTabsDataFin := FieldTabsData.handle()
	FieldTabsVecArg := new(C.ImVector_ImGuiTabItem)
	FieldTabsVecArg.Size = C.int(FieldTabs.Size)
	FieldTabsVecArg.Capacity = C.int(FieldTabs.Capacity)
	FieldTabsVecArg.Data = FieldTabsDataArg
	FieldTabs.pinner.Pin(FieldTabsVecArg.Data)

	result.Tabs = *FieldTabsVecArg
	FieldFlags := self.FieldFlags

	result.Flags = C.ImGuiTabBarFlags(FieldFlags)
	FieldID := self.FieldID

	result.ID = C.ImGuiID(FieldID)
	FieldSelectedTabId := self.FieldSelectedTabId

	result.SelectedTabId = C.ImGuiID(FieldSelectedTabId)
	FieldNextSelectedTabId := self.FieldNextSelectedTabId

	result.NextSelectedTabId = C.ImGuiID(FieldNextSelectedTabId)
	FieldVisibleTabId := self.FieldVisibleTabId

	result.VisibleTabId = C.ImGuiID(FieldVisibleTabId)
	FieldCurrFrameVisible := self.FieldCurrFrameVisible

	result.CurrFrameVisible = C.int(FieldCurrFrameVisible)
	FieldPrevFrameVisible := self.FieldPrevFrameVisible

	result.PrevFrameVisible = C.int(FieldPrevFrameVisible)
	FieldBarRect := self.FieldBarRect

	result.BarRect = FieldBarRect.toC()
	FieldCurrTabsContentsHeight := self.FieldCurrTabsContentsHeight

	result.CurrTabsContentsHeight = C.float(FieldCurrTabsContentsHeight)
	FieldPrevTabsContentsHeight := self.FieldPrevTabsContentsHeight

	result.PrevTabsContentsHeight = C.float(FieldPrevTabsContentsHeight)
	FieldWidthAllTabs := self.FieldWidthAllTabs

	result.WidthAllTabs = C.float(FieldWidthAllTabs)
	FieldWidthAllTabsIdeal := self.FieldWidthAllTabsIdeal

	result.WidthAllTabsIdeal = C.float(FieldWidthAllTabsIdeal)
	FieldScrollingAnim := self.FieldScrollingAnim

	result.ScrollingAnim = C.float(FieldScrollingAnim)
	FieldScrollingTarget := self.FieldScrollingTarget

	result.ScrollingTarget = C.float(FieldScrollingTarget)
	FieldScrollingTargetDistToVisibility := self.FieldScrollingTargetDistToVisibility

	result.ScrollingTargetDistToVisibility = C.float(FieldScrollingTargetDistToVisibility)
	FieldScrollingSpeed := self.FieldScrollingSpeed

	result.ScrollingSpeed = C.float(FieldScrollingSpeed)
	FieldScrollingRectMinX := self.FieldScrollingRectMinX

	result.ScrollingRectMinX = C.float(FieldScrollingRectMinX)
	FieldScrollingRectMaxX := self.FieldScrollingRectMaxX

	result.ScrollingRectMaxX = C.float(FieldScrollingRectMaxX)
	FieldSeparatorMinX := self.FieldSeparatorMinX

	result.SeparatorMinX = C.float(FieldSeparatorMinX)
	FieldSeparatorMaxX := self.FieldSeparatorMaxX

	result.SeparatorMaxX = C.float(FieldSeparatorMaxX)
	FieldReorderRequestTabId := self.FieldReorderRequestTabId

	result.ReorderRequestTabId = C.ImGuiID(FieldReorderRequestTabId)
	FieldReorderRequestOffset := self.FieldReorderRequestOffset

	result.ReorderRequestOffset = C.ImS16(FieldReorderRequestOffset)
	FieldBeginCount := self.FieldBeginCount

	result.BeginCount = C.ImS8(FieldBeginCount)
	FieldWantLayout := self.FieldWantLayout

	result.WantLayout = C.bool(FieldWantLayout)
	FieldVisibleTabWasSubmitted := self.FieldVisibleTabWasSubmitted

	result.VisibleTabWasSubmitted = C.bool(FieldVisibleTabWasSubmitted)
	FieldTabsAddedNew := self.FieldTabsAddedNew

	result.TabsAddedNew = C.bool(FieldTabsAddedNew)
	FieldTabsActiveCount := self.FieldTabsActiveCount

	result.TabsActiveCount = C.ImS16(FieldTabsActiveCount)
	FieldLastTabItemIdx := self.FieldLastTabItemIdx

	result.LastTabItemIdx = C.ImS16(FieldLastTabItemIdx)
	FieldItemSpacingY := self.FieldItemSpacingY

	result.ItemSpacingY = C.float(FieldItemSpacingY)
	FieldFramePadding := self.FieldFramePadding

	result.FramePadding = FieldFramePadding.toC()
	FieldBackupCursorPos := self.FieldBackupCursorPos

	result.BackupCursorPos = FieldBackupCursorPos.toC()
	FieldTabsNames := self.FieldTabsNames
	FieldTabsNamesArg, FieldTabsNamesFin := FieldTabsNames.c()
	result.TabsNames = FieldTabsNamesArg
	releaseFn = func() {
		FieldTabsDataFin()
		FieldTabs.pinner.Unpin()

		FieldTabsNamesFin()
	}
	return result, releaseFn
}

func (self TabBar) c() (result C.ImGuiTabBar, fin func()) {
	resultPtr, finFn := self.handle()
	return *resultPtr, finFn
}

func newTabBarFromC(cvalue *C.ImGuiTabBar) *TabBar {
	result := new(TabBar)
	result.FieldTabs = newVectorFromC(cvalue.Tabs.Size, cvalue.Tabs.Capacity, newTabItemFromC(cvalue.Tabs.Data))
	result.FieldFlags = TabBarFlags(cvalue.Flags)
	result.FieldID = ID(cvalue.ID)
	result.FieldSelectedTabId = ID(cvalue.SelectedTabId)
	result.FieldNextSelectedTabId = ID(cvalue.NextSelectedTabId)
	result.FieldVisibleTabId = ID(cvalue.VisibleTabId)
	result.FieldCurrFrameVisible = int32(cvalue.CurrFrameVisible)
	result.FieldPrevFrameVisible = int32(cvalue.PrevFrameVisible)
	result.FieldBarRect = *(&Rect{}).fromC(cvalue.BarRect)
	result.FieldCurrTabsContentsHeight = float32(cvalue.CurrTabsContentsHeight)
	result.FieldPrevTabsContentsHeight = float32(cvalue.PrevTabsContentsHeight)
	result.FieldWidthAllTabs = float32(cvalue.WidthAllTabs)
	result.FieldWidthAllTabsIdeal = float32(cvalue.WidthAllTabsIdeal)
	result.FieldScrollingAnim = float32(cvalue.ScrollingAnim)
	result.FieldScrollingTarget = float32(cvalue.ScrollingTarget)
	result.FieldScrollingTargetDistToVisibility = float32(cvalue.ScrollingTargetDistToVisibility)
	result.FieldScrollingSpeed = float32(cvalue.ScrollingSpeed)
	result.FieldScrollingRectMinX = float32(cvalue.ScrollingRectMinX)
	result.FieldScrollingRectMaxX = float32(cvalue.ScrollingRectMaxX)
	result.FieldSeparatorMinX = float32(cvalue.SeparatorMinX)
	result.FieldSeparatorMaxX = float32(cvalue.SeparatorMaxX)
	result.FieldReorderRequestTabId = ID(cvalue.ReorderRequestTabId)
	result.FieldReorderRequestOffset = int(cvalue.ReorderRequestOffset)
	result.FieldBeginCount = int(cvalue.BeginCount)
	result.FieldWantLayout = cvalue.WantLayout == C.bool(true)
	result.FieldVisibleTabWasSubmitted = cvalue.VisibleTabWasSubmitted == C.bool(true)
	result.FieldTabsAddedNew = cvalue.TabsAddedNew == C.bool(true)
	result.FieldTabsActiveCount = int(cvalue.TabsActiveCount)
	result.FieldLastTabItemIdx = int(cvalue.LastTabItemIdx)
	result.FieldItemSpacingY = float32(cvalue.ItemSpacingY)
	result.FieldFramePadding = *(&Vec2{}).fromC(cvalue.FramePadding)
	result.FieldBackupCursorPos = *(&Vec2{}).fromC(cvalue.BackupCursorPos)
	result.FieldTabsNames = *newTextBufferFromC(func() *C.ImGuiTextBuffer { result := cvalue.TabsNames; return &result }())

	return result
}

// Storage for one active tab item (sizeof() 48 bytes)
type TabItem struct {
	FieldID                ID
	FieldFlags             TabItemFlags
	FieldWindow            *Window // When TabItem is part of a DockNode's TabBar, we hold on to a window.
	FieldLastFrameVisible  int32
	FieldLastFrameSelected int32   // This allows us to infer an ordered list of the last activated tabs with little maintenance
	FieldOffset            float32 // Position relative to beginning of tab
	FieldWidth             float32 // Width currently displayed
	FieldContentWidth      float32 // Width of label, stored during BeginTabItem() call
	FieldRequestedWidth    float32 // Width optionally requested by caller, -1.0f is unused
	FieldNameOffset        int     // When Window==NULL, offset to name within parent ImGuiTabBar::TabsNames
	FieldBeginOrder        int     // BeginTabItem() order, used to re-order tabs after toggling ImGuiTabBarFlags_Reorderable
	FieldIndexDuringLayout int     // Index only used during TabBarLayout(). Tabs gets reordered so 'Tabs[n].IndexDuringLayout == n' but may mismatch during additions.
	FieldWantClose         bool    // Marked as closed by SetTabItemClosed()
}

func (self TabItem) handle() (result *C.ImGuiTabItem, releaseFn func()) {
	result = new(C.ImGuiTabItem)
	FieldID := self.FieldID

	result.ID = C.ImGuiID(FieldID)
	FieldFlags := self.FieldFlags

	result.Flags = C.ImGuiTabItemFlags(FieldFlags)
	FieldWindow := self.FieldWindow
	FieldWindowArg, FieldWindowFin := FieldWindow.handle()
	result.Window = FieldWindowArg
	FieldLastFrameVisible := self.FieldLastFrameVisible

	result.LastFrameVisible = C.int(FieldLastFrameVisible)
	FieldLastFrameSelected := self.FieldLastFrameSelected

	result.LastFrameSelected = C.int(FieldLastFrameSelected)
	FieldOffset := self.FieldOffset

	result.Offset = C.float(FieldOffset)
	FieldWidth := self.FieldWidth

	result.Width = C.float(FieldWidth)
	FieldContentWidth := self.FieldContentWidth

	result.ContentWidth = C.float(FieldContentWidth)
	FieldRequestedWidth := self.FieldRequestedWidth

	result.RequestedWidth = C.float(FieldRequestedWidth)
	FieldNameOffset := self.FieldNameOffset

	result.NameOffset = C.ImS32(FieldNameOffset)
	FieldBeginOrder := self.FieldBeginOrder

	result.BeginOrder = C.ImS16(FieldBeginOrder)
	FieldIndexDuringLayout := self.FieldIndexDuringLayout

	result.IndexDuringLayout = C.ImS16(FieldIndexDuringLayout)
	FieldWantClose := self.FieldWantClose

	result.WantClose = C.bool(FieldWantClose)
	releaseFn = func() {
		FieldWindowFin()
	}
	return result, releaseFn
}

func (self TabItem) c() (result C.ImGuiTabItem, fin func()) {
	resultPtr, finFn := self.handle()
	return *resultPtr, finFn
}

func newTabItemFromC(cvalue *C.ImGuiTabItem) *TabItem {
	result := new(TabItem)
	result.FieldID = ID(cvalue.ID)
	result.FieldFlags = TabItemFlags(cvalue.Flags)
	result.FieldWindow = newWindowFromC(cvalue.Window)
	result.FieldLastFrameVisible = int32(cvalue.LastFrameVisible)
	result.FieldLastFrameSelected = int32(cvalue.LastFrameSelected)
	result.FieldOffset = float32(cvalue.Offset)
	result.FieldWidth = float32(cvalue.Width)
	result.FieldContentWidth = float32(cvalue.ContentWidth)
	result.FieldRequestedWidth = float32(cvalue.RequestedWidth)
	result.FieldNameOffset = int(cvalue.NameOffset)
	result.FieldBeginOrder = int(cvalue.BeginOrder)
	result.FieldIndexDuringLayout = int(cvalue.IndexDuringLayout)
	result.FieldWantClose = cvalue.WantClose == C.bool(true)
	return result
}

// FIXME-TABLE: more transient data could be stored in a stacked ImGuiTableTempData: e.g. SortSpecs, incoming RowData
// sizeof() ~ 580 bytes + heap allocs described in TableBeginInitMemory()
type Table struct {
	// TODO: contains unsupported fields
	data unsafe.Pointer
}

func (self Table) handle() (result *C.ImGuiTable, releaseFn func()) {
	result = (*C.ImGuiTable)(self.data)
	return result, func() {}
}

func (self Table) c() (result C.ImGuiTable, fin func()) {
	resultPtr, finFn := self.handle()
	return *resultPtr, finFn
}

func newTableFromC(cvalue *C.ImGuiTable) *Table {
	result := new(Table)
	result.data = unsafe.Pointer(cvalue)
	return result
}

// Transient cell data stored per row.
// sizeof() ~ 6
type TableCellData struct {
	FieldBgColor uint32         // Actual color
	FieldColumn  TableColumnIdx // Column number
}

func (self TableCellData) handle() (result *C.ImGuiTableCellData, releaseFn func()) {
	result = new(C.ImGuiTableCellData)
	FieldBgColor := self.FieldBgColor

	result.BgColor = C.ImU32(FieldBgColor)
	FieldColumn := self.FieldColumn

	result.Column = C.ImGuiTableColumnIdx(FieldColumn)
	releaseFn = func() {
	}
	return result, releaseFn
}

func (self TableCellData) c() (result C.ImGuiTableCellData, fin func()) {
	resultPtr, finFn := self.handle()
	return *resultPtr, finFn
}

func newTableCellDataFromC(cvalue *C.ImGuiTableCellData) *TableCellData {
	result := new(TableCellData)
	result.FieldBgColor = uint32(cvalue.BgColor)
	result.FieldColumn = TableColumnIdx(cvalue.Column)
	return result
}

// [Internal] sizeof() ~ 112
// We use the terminology "Enabled" to refer to a column that is not Hidden by user/api.
// We use the terminology "Clipped" to refer to a column that is out of sight because of scrolling/clipping.
// This is in contrast with some user-facing api such as IsItemVisible() / IsRectVisible() which use "Visible" to mean "not clipped".
type TableColumn struct {
	// TODO: contains unsupported fields
	data unsafe.Pointer
}

func (self TableColumn) handle() (result *C.ImGuiTableColumn, releaseFn func()) {
	result = (*C.ImGuiTableColumn)(self.data)
	return result, func() {}
}

func (self TableColumn) c() (result C.ImGuiTableColumn, fin func()) {
	resultPtr, finFn := self.handle()
	return *resultPtr, finFn
}

func newTableColumnFromC(cvalue *C.ImGuiTableColumn) *TableColumn {
	result := new(TableColumn)
	result.data = unsafe.Pointer(cvalue)
	return result
}

// sizeof() ~ 12
type TableColumnSettings struct {
	// TODO: contains unsupported fields
	data unsafe.Pointer
}

func (self TableColumnSettings) handle() (result *C.ImGuiTableColumnSettings, releaseFn func()) {
	result = (*C.ImGuiTableColumnSettings)(self.data)
	return result, func() {}
}

func (self TableColumnSettings) c() (result C.ImGuiTableColumnSettings, fin func()) {
	resultPtr, finFn := self.handle()
	return *resultPtr, finFn
}

func newTableColumnSettingsFromC(cvalue *C.ImGuiTableColumnSettings) *TableColumnSettings {
	result := new(TableColumnSettings)
	result.data = unsafe.Pointer(cvalue)
	return result
}

// Sorting specification for one column of a table (sizeof == 12 bytes)
type TableColumnSortSpecs struct {
	// TODO: contains unsupported fields
	data unsafe.Pointer
}

func (self TableColumnSortSpecs) handle() (result *C.ImGuiTableColumnSortSpecs, releaseFn func()) {
	result = (*C.ImGuiTableColumnSortSpecs)(self.data)
	return result, func() {}
}

func (self TableColumnSortSpecs) c() (result C.ImGuiTableColumnSortSpecs, fin func()) {
	resultPtr, finFn := self.handle()
	return *resultPtr, finFn
}

func newTableColumnSortSpecsFromC(cvalue *C.ImGuiTableColumnSortSpecs) *TableColumnSortSpecs {
	result := new(TableColumnSortSpecs)
	result.data = unsafe.Pointer(cvalue)
	return result
}

// Per-instance data that needs preserving across frames (seemingly most others do not need to be preserved aside from debug needs. Does that means they could be moved to ImGuiTableTempData?)
type TableInstanceData struct {
	FieldTableInstanceID    ID
	FieldLastOuterHeight    float32 // Outer height from last frame
	FieldLastFirstRowHeight float32 // Height of first row from last frame (FIXME: this is used as "header height" and may be reworked)
	FieldLastFrozenHeight   float32 // Height of frozen section from last frame
	FieldHoveredRowLast     int32   // Index of row which was hovered last frame.
	FieldHoveredRowNext     int32   // Index of row hovered this frame, set after encountering it.
}

func (self TableInstanceData) handle() (result *C.ImGuiTableInstanceData, releaseFn func()) {
	result = new(C.ImGuiTableInstanceData)
	FieldTableInstanceID := self.FieldTableInstanceID

	result.TableInstanceID = C.ImGuiID(FieldTableInstanceID)
	FieldLastOuterHeight := self.FieldLastOuterHeight

	result.LastOuterHeight = C.float(FieldLastOuterHeight)
	FieldLastFirstRowHeight := self.FieldLastFirstRowHeight

	result.LastFirstRowHeight = C.float(FieldLastFirstRowHeight)
	FieldLastFrozenHeight := self.FieldLastFrozenHeight

	result.LastFrozenHeight = C.float(FieldLastFrozenHeight)
	FieldHoveredRowLast := self.FieldHoveredRowLast

	result.HoveredRowLast = C.int(FieldHoveredRowLast)
	FieldHoveredRowNext := self.FieldHoveredRowNext

	result.HoveredRowNext = C.int(FieldHoveredRowNext)
	releaseFn = func() {
	}
	return result, releaseFn
}

func (self TableInstanceData) c() (result C.ImGuiTableInstanceData, fin func()) {
	resultPtr, finFn := self.handle()
	return *resultPtr, finFn
}

func newTableInstanceDataFromC(cvalue *C.ImGuiTableInstanceData) *TableInstanceData {
	result := new(TableInstanceData)
	result.FieldTableInstanceID = ID(cvalue.TableInstanceID)
	result.FieldLastOuterHeight = float32(cvalue.LastOuterHeight)
	result.FieldLastFirstRowHeight = float32(cvalue.LastFirstRowHeight)
	result.FieldLastFrozenHeight = float32(cvalue.LastFrozenHeight)
	result.FieldHoveredRowLast = int32(cvalue.HoveredRowLast)
	result.FieldHoveredRowNext = int32(cvalue.HoveredRowNext)
	return result
}

// This is designed to be stored in a single ImChunkStream (1 header followed by N ImGuiTableColumnSettings, etc.)
type TableSettings struct {
	FieldID              ID         // Set to 0 to invalidate/delete the setting
	FieldSaveFlags       TableFlags // Indicate data we want to save using the Resizable/Reorderable/Sortable/Hideable flags (could be using its own flags..)
	FieldRefScale        float32    // Reference scale to be able to rescale columns on font/dpi changes.
	FieldColumnsCount    TableColumnIdx
	FieldColumnsCountMax TableColumnIdx // Maximum number of columns this settings instance can store, we can recycle a settings instance with lower number of columns but not higher
	FieldWantApply       bool           // Set when loaded from .ini data (to enable merging/loading .ini data into an already running context)
}

func (self TableSettings) handle() (result *C.ImGuiTableSettings, releaseFn func()) {
	result = new(C.ImGuiTableSettings)
	FieldID := self.FieldID

	result.ID = C.ImGuiID(FieldID)
	FieldSaveFlags := self.FieldSaveFlags

	result.SaveFlags = C.ImGuiTableFlags(FieldSaveFlags)
	FieldRefScale := self.FieldRefScale

	result.RefScale = C.float(FieldRefScale)
	FieldColumnsCount := self.FieldColumnsCount

	result.ColumnsCount = C.ImGuiTableColumnIdx(FieldColumnsCount)
	FieldColumnsCountMax := self.FieldColumnsCountMax

	result.ColumnsCountMax = C.ImGuiTableColumnIdx(FieldColumnsCountMax)
	FieldWantApply := self.FieldWantApply

	result.WantApply = C.bool(FieldWantApply)
	releaseFn = func() {
	}
	return result, releaseFn
}

func (self TableSettings) c() (result C.ImGuiTableSettings, fin func()) {
	resultPtr, finFn := self.handle()
	return *resultPtr, finFn
}

func newTableSettingsFromC(cvalue *C.ImGuiTableSettings) *TableSettings {
	result := new(TableSettings)
	result.FieldID = ID(cvalue.ID)
	result.FieldSaveFlags = TableFlags(cvalue.SaveFlags)
	result.FieldRefScale = float32(cvalue.RefScale)
	result.FieldColumnsCount = TableColumnIdx(cvalue.ColumnsCount)
	result.FieldColumnsCountMax = TableColumnIdx(cvalue.ColumnsCountMax)
	result.FieldWantApply = cvalue.WantApply == C.bool(true)
	return result
}

// Sorting specifications for a table (often handling sort specs for a single column, occasionally more)
// Obtained by calling TableGetSortSpecs().
// When 'SpecsDirty == true' you can sort your data. It will be true with sorting specs have changed since last call, or the first time.
// Make sure to set 'SpecsDirty = false' after sorting, else you may wastefully sort your data every frame!
type TableSortSpecs struct {
	FieldSpecs      *TableColumnSortSpecs // Pointer to sort spec array.
	FieldSpecsCount int32                 // Sort spec count. Most often 1. May be > 1 when ImGuiTableFlags_SortMulti is enabled. May be == 0 when ImGuiTableFlags_SortTristate is enabled.
	FieldSpecsDirty bool                  // Set to true when specs have changed since last time! Use this to sort again, then clear the flag.
}

func (self TableSortSpecs) handle() (result *C.ImGuiTableSortSpecs, releaseFn func()) {
	result = new(C.ImGuiTableSortSpecs)
	FieldSpecs := self.FieldSpecs
	FieldSpecsArg, FieldSpecsFin := FieldSpecs.handle()
	result.Specs = FieldSpecsArg
	FieldSpecsCount := self.FieldSpecsCount

	result.SpecsCount = C.int(FieldSpecsCount)
	FieldSpecsDirty := self.FieldSpecsDirty

	result.SpecsDirty = C.bool(FieldSpecsDirty)
	releaseFn = func() {
		FieldSpecsFin()
	}
	return result, releaseFn
}

func (self TableSortSpecs) c() (result C.ImGuiTableSortSpecs, fin func()) {
	resultPtr, finFn := self.handle()
	return *resultPtr, finFn
}

func newTableSortSpecsFromC(cvalue *C.ImGuiTableSortSpecs) *TableSortSpecs {
	result := new(TableSortSpecs)
	result.FieldSpecs = newTableColumnSortSpecsFromC(cvalue.Specs)
	result.FieldSpecsCount = int32(cvalue.SpecsCount)
	result.FieldSpecsDirty = cvalue.SpecsDirty == C.bool(true)
	return result
}

// Transient data that are only needed between BeginTable() and EndTable(), those buffers are shared (1 per level of stacked table).
// - Accessing those requires chasing an extra pointer so for very frequently used data we leave them in the main table structure.
// - We also leave out of this structure data that tend to be particularly useful for debugging/metrics.
// sizeof() ~ 112 bytes.
type TableTempData struct {
	FieldTableIndex                   int32   // Index in g.Tables.Buf[] pool
	FieldLastTimeActive               float32 // Last timestamp this structure was used
	FieldUserOuterSize                Vec2    // outer_size.x passed to BeginTable()
	FieldDrawSplitter                 DrawListSplitter
	FieldHostBackupWorkRect           Rect    // Backup of InnerWindow->WorkRect at the end of BeginTable()
	FieldHostBackupParentWorkRect     Rect    // Backup of InnerWindow->ParentWorkRect at the end of BeginTable()
	FieldHostBackupPrevLineSize       Vec2    // Backup of InnerWindow->DC.PrevLineSize at the end of BeginTable()
	FieldHostBackupCurrLineSize       Vec2    // Backup of InnerWindow->DC.CurrLineSize at the end of BeginTable()
	FieldHostBackupCursorMaxPos       Vec2    // Backup of InnerWindow->DC.CursorMaxPos at the end of BeginTable()
	FieldHostBackupColumnsOffset      Vec1    // Backup of OuterWindow->DC.ColumnsOffset at the end of BeginTable()
	FieldHostBackupItemWidth          float32 // Backup of OuterWindow->DC.ItemWidth at the end of BeginTable()
	FieldHostBackupItemWidthStackSize int32   // Backup of OuterWindow->DC.ItemWidthStack.Size at the end of BeginTable()

}

func (self TableTempData) handle() (result *C.ImGuiTableTempData, releaseFn func()) {
	result = new(C.ImGuiTableTempData)
	FieldTableIndex := self.FieldTableIndex

	result.TableIndex = C.int(FieldTableIndex)
	FieldLastTimeActive := self.FieldLastTimeActive

	result.LastTimeActive = C.float(FieldLastTimeActive)
	FieldUserOuterSize := self.FieldUserOuterSize

	result.UserOuterSize = FieldUserOuterSize.toC()
	FieldDrawSplitter := self.FieldDrawSplitter
	FieldDrawSplitterArg, FieldDrawSplitterFin := FieldDrawSplitter.c()
	result.DrawSplitter = FieldDrawSplitterArg
	FieldHostBackupWorkRect := self.FieldHostBackupWorkRect

	result.HostBackupWorkRect = FieldHostBackupWorkRect.toC()
	FieldHostBackupParentWorkRect := self.FieldHostBackupParentWorkRect

	result.HostBackupParentWorkRect = FieldHostBackupParentWorkRect.toC()
	FieldHostBackupPrevLineSize := self.FieldHostBackupPrevLineSize

	result.HostBackupPrevLineSize = FieldHostBackupPrevLineSize.toC()
	FieldHostBackupCurrLineSize := self.FieldHostBackupCurrLineSize

	result.HostBackupCurrLineSize = FieldHostBackupCurrLineSize.toC()
	FieldHostBackupCursorMaxPos := self.FieldHostBackupCursorMaxPos

	result.HostBackupCursorMaxPos = FieldHostBackupCursorMaxPos.toC()
	FieldHostBackupColumnsOffset := self.FieldHostBackupColumnsOffset
	FieldHostBackupColumnsOffsetArg, FieldHostBackupColumnsOffsetFin := FieldHostBackupColumnsOffset.c()
	result.HostBackupColumnsOffset = FieldHostBackupColumnsOffsetArg
	FieldHostBackupItemWidth := self.FieldHostBackupItemWidth

	result.HostBackupItemWidth = C.float(FieldHostBackupItemWidth)
	FieldHostBackupItemWidthStackSize := self.FieldHostBackupItemWidthStackSize

	result.HostBackupItemWidthStackSize = C.int(FieldHostBackupItemWidthStackSize)
	releaseFn = func() {
		FieldDrawSplitterFin()

		FieldHostBackupColumnsOffsetFin()
	}
	return result, releaseFn
}

func (self TableTempData) c() (result C.ImGuiTableTempData, fin func()) {
	resultPtr, finFn := self.handle()
	return *resultPtr, finFn
}

func newTableTempDataFromC(cvalue *C.ImGuiTableTempData) *TableTempData {
	result := new(TableTempData)
	result.FieldTableIndex = int32(cvalue.TableIndex)
	result.FieldLastTimeActive = float32(cvalue.LastTimeActive)
	result.FieldUserOuterSize = *(&Vec2{}).fromC(cvalue.UserOuterSize)
	result.FieldDrawSplitter = *newDrawListSplitterFromC(func() *C.ImDrawListSplitter { result := cvalue.DrawSplitter; return &result }())

	result.FieldHostBackupWorkRect = *(&Rect{}).fromC(cvalue.HostBackupWorkRect)
	result.FieldHostBackupParentWorkRect = *(&Rect{}).fromC(cvalue.HostBackupParentWorkRect)
	result.FieldHostBackupPrevLineSize = *(&Vec2{}).fromC(cvalue.HostBackupPrevLineSize)
	result.FieldHostBackupCurrLineSize = *(&Vec2{}).fromC(cvalue.HostBackupCurrLineSize)
	result.FieldHostBackupCursorMaxPos = *(&Vec2{}).fromC(cvalue.HostBackupCursorMaxPos)
	result.FieldHostBackupColumnsOffset = *newVec1FromC(func() *C.ImVec1 { result := cvalue.HostBackupColumnsOffset; return &result }())

	result.FieldHostBackupItemWidth = float32(cvalue.HostBackupItemWidth)
	result.FieldHostBackupItemWidthStackSize = int32(cvalue.HostBackupItemWidthStackSize)
	return result
}

// Helper: Growable text buffer for logging/accumulating text
// (this could be called 'ImGuiTextBuilder' / 'ImGuiStringBuilder')
type TextBuffer struct {
	FieldBuf Vector[string]
}

func (self TextBuffer) handle() (result *C.ImGuiTextBuffer, releaseFn func()) {
	result = new(C.ImGuiTextBuffer)
	FieldBuf := self.FieldBuf
	FieldBufData := FieldBuf.Data
	FieldBufDataArg, FieldBufDataFin := WrapString(FieldBufData)
	FieldBufVecArg := new(C.ImVector_char)
	FieldBufVecArg.Size = C.int(FieldBuf.Size)
	FieldBufVecArg.Capacity = C.int(FieldBuf.Capacity)
	FieldBufVecArg.Data = FieldBufDataArg
	FieldBuf.pinner.Pin(FieldBufVecArg.Data)

	result.Buf = *FieldBufVecArg
	releaseFn = func() {
		FieldBufDataFin()
		FieldBuf.pinner.Unpin()
	}
	return result, releaseFn
}

func (self TextBuffer) c() (result C.ImGuiTextBuffer, fin func()) {
	resultPtr, finFn := self.handle()
	return *resultPtr, finFn
}

func newTextBufferFromC(cvalue *C.ImGuiTextBuffer) *TextBuffer {
	result := new(TextBuffer)
	result.FieldBuf = newVectorFromC(cvalue.Buf.Size, cvalue.Buf.Capacity, C.GoString(cvalue.Buf.Data))
	return result
}

// Helper: Parse and apply text filters. In format "aaaaa[,bbbb][,ccccc]"
type TextFilter struct {
	// TODO: contains unsupported fields
	data unsafe.Pointer
}

func (self TextFilter) handle() (result *C.ImGuiTextFilter, releaseFn func()) {
	result = (*C.ImGuiTextFilter)(self.data)
	return result, func() {}
}

func (self TextFilter) c() (result C.ImGuiTextFilter, fin func()) {
	resultPtr, finFn := self.handle()
	return *resultPtr, finFn
}

func newTextFilterFromC(cvalue *C.ImGuiTextFilter) *TextFilter {
	result := new(TextFilter)
	result.data = unsafe.Pointer(cvalue)
	return result
}

// Helper: ImGuiTextIndex<>
// Maintain a line index for a text buffer. This is a strong candidate to be moved into the public API.
type TextIndex struct {
	FieldLineOffsets Vector[*int32]
	FieldEndOffset   int32 // Because we don't own text buffer we need to maintain EndOffset (may bake in LineOffsets?)
}

func (self TextIndex) handle() (result *C.ImGuiTextIndex, releaseFn func()) {
	result = new(C.ImGuiTextIndex)
	FieldLineOffsets := self.FieldLineOffsets
	FieldLineOffsetsData := FieldLineOffsets.Data
	FieldLineOffsetsDataArg, FieldLineOffsetsDataFin := WrapNumberPtr[C.int, int32](FieldLineOffsetsData)
	FieldLineOffsetsVecArg := new(C.ImVector_int)
	FieldLineOffsetsVecArg.Size = C.int(FieldLineOffsets.Size)
	FieldLineOffsetsVecArg.Capacity = C.int(FieldLineOffsets.Capacity)
	FieldLineOffsetsVecArg.Data = FieldLineOffsetsDataArg
	FieldLineOffsets.pinner.Pin(FieldLineOffsetsVecArg.Data)

	result.LineOffsets = *FieldLineOffsetsVecArg
	FieldEndOffset := self.FieldEndOffset

	result.EndOffset = C.int(FieldEndOffset)
	releaseFn = func() {
		FieldLineOffsetsDataFin()
		FieldLineOffsets.pinner.Unpin()
	}
	return result, releaseFn
}

func (self TextIndex) c() (result C.ImGuiTextIndex, fin func()) {
	resultPtr, finFn := self.handle()
	return *resultPtr, finFn
}

func newTextIndexFromC(cvalue *C.ImGuiTextIndex) *TextIndex {
	result := new(TextIndex)
	result.FieldLineOffsets = newVectorFromC(cvalue.LineOffsets.Size, cvalue.LineOffsets.Capacity, (*int32)(cvalue.LineOffsets.Data))
	result.FieldEndOffset = int32(cvalue.EndOffset)
	return result
}

// [Internal]
type TextRange struct {
	FieldB string
	FieldE string
}

func (self TextRange) handle() (result *C.ImGuiTextRange, releaseFn func()) {
	result = new(C.ImGuiTextRange)
	FieldB := self.FieldB
	FieldBArg, FieldBFin := WrapString(FieldB)
	result.b = FieldBArg
	FieldE := self.FieldE
	FieldEArg, FieldEFin := WrapString(FieldE)
	result.e = FieldEArg
	releaseFn = func() {
		FieldBFin()
		FieldEFin()
	}
	return result, releaseFn
}

func (self TextRange) c() (result C.ImGuiTextRange, fin func()) {
	resultPtr, finFn := self.handle()
	return *resultPtr, finFn
}

func newTextRangeFromC(cvalue *C.ImGuiTextRange) *TextRange {
	result := new(TextRange)
	result.FieldB = C.GoString(cvalue.b)
	result.FieldE = C.GoString(cvalue.e)
	return result
}

// Returned by GetTypingSelectRequest(), designed to eventually be public.
type TypingSelectRequest struct {
	FieldFlags           TypingSelectFlags // Flags passed to GetTypingSelectRequest()
	FieldSearchBufferLen int32
	FieldSearchBuffer    string // Search buffer contents (use full string. unless SingleCharMode is set, in which case use SingleCharSize).
	FieldSelectRequest   bool   // Set when buffer was modified this frame, requesting a selection.
	FieldSingleCharMode  bool   // Notify when buffer contains same character repeated, to implement special mode. In this situation it preferred to not display any on-screen search indication.
	FieldSingleCharSize  int    // Length in bytes of first letter codepoint (1 for ascii, 2-4 for UTF-8). If (SearchBufferLen==RepeatCharSize) only 1 letter has been input.
}

func (self TypingSelectRequest) handle() (result *C.ImGuiTypingSelectRequest, releaseFn func()) {
	result = new(C.ImGuiTypingSelectRequest)
	FieldFlags := self.FieldFlags

	result.Flags = C.ImGuiTypingSelectFlags(FieldFlags)
	FieldSearchBufferLen := self.FieldSearchBufferLen

	result.SearchBufferLen = C.int(FieldSearchBufferLen)
	FieldSearchBuffer := self.FieldSearchBuffer
	FieldSearchBufferArg, FieldSearchBufferFin := WrapString(FieldSearchBuffer)
	result.SearchBuffer = FieldSearchBufferArg
	FieldSelectRequest := self.FieldSelectRequest

	result.SelectRequest = C.bool(FieldSelectRequest)
	FieldSingleCharMode := self.FieldSingleCharMode

	result.SingleCharMode = C.bool(FieldSingleCharMode)
	FieldSingleCharSize := self.FieldSingleCharSize

	result.SingleCharSize = C.ImS8(FieldSingleCharSize)
	releaseFn = func() {
		FieldSearchBufferFin()
	}
	return result, releaseFn
}

func (self TypingSelectRequest) c() (result C.ImGuiTypingSelectRequest, fin func()) {
	resultPtr, finFn := self.handle()
	return *resultPtr, finFn
}

func newTypingSelectRequestFromC(cvalue *C.ImGuiTypingSelectRequest) *TypingSelectRequest {
	result := new(TypingSelectRequest)
	result.FieldFlags = TypingSelectFlags(cvalue.Flags)
	result.FieldSearchBufferLen = int32(cvalue.SearchBufferLen)
	result.FieldSearchBuffer = C.GoString(cvalue.SearchBuffer)
	result.FieldSelectRequest = cvalue.SelectRequest == C.bool(true)
	result.FieldSingleCharMode = cvalue.SingleCharMode == C.bool(true)
	result.FieldSingleCharSize = int(cvalue.SingleCharSize)
	return result
}

// Storage for GetTypingSelectRequest()
type TypingSelectState struct {
	// TODO: contains unsupported fields
	data unsafe.Pointer
}

func (self TypingSelectState) handle() (result *C.ImGuiTypingSelectState, releaseFn func()) {
	result = (*C.ImGuiTypingSelectState)(self.data)
	return result, func() {}
}

func (self TypingSelectState) c() (result C.ImGuiTypingSelectState, fin func()) {
	resultPtr, finFn := self.handle()
	return *resultPtr, finFn
}

func newTypingSelectStateFromC(cvalue *C.ImGuiTypingSelectState) *TypingSelectState {
	result := new(TypingSelectState)
	result.data = unsafe.Pointer(cvalue)
	return result
}

// - Currently represents the Platform Window created by the application which is hosting our Dear ImGui windows.
// - With multi-viewport enabled, we extend this concept to have multiple active viewports.
// - In the future we will extend this concept further to also represent Platform Monitor and support a "no main platform window" operation mode.
// - About Main Area vs Work Area:
//   - Main Area = entire viewport.
//   - Work Area = entire viewport minus sections used by main menu bars (for platform windows), or by task bar (for platform monitor).
//   - Windows are generally trying to stay within the Work Area of their host viewport.
type Viewport struct {
	FieldID               ID            // Unique identifier for the viewport
	FieldFlags            ViewportFlags // See ImGuiViewportFlags_
	FieldPos              Vec2          // Main Area: Position of the viewport (Dear ImGui coordinates are the same as OS desktop/native coordinates)
	FieldSize             Vec2          // Main Area: Size of the viewport.
	FieldWorkPos          Vec2          // Work Area: Position of the viewport minus task bars, menus bars, status bars (>= Pos)
	FieldWorkSize         Vec2          // Work Area: Size of the viewport minus task bars, menu bars, status bars (<= Size)
	FieldDpiScale         float32       // 1.0f = 96 DPI = No extra scale.
	FieldParentViewportId ID            // (Advanced) 0: no parent. Instruct the platform backend to setup a parent/child relationship between platform windows.
	FieldDrawData         *DrawData     // The ImDrawData corresponding to this viewport. Valid after Render() and until the next call to NewFrame().
	// Platform/Backend Dependent Data
	// Our design separate the Renderer and Platform backends to facilitate combining default backends with each others.
	// When our create your own backend for a custom engine, it is possible that both Renderer and Platform will be handled
	// by the same system and you may not need to use all the UserData/Handle fields.
	// The library never uses those fields, they are merely storage to facilitate backend implementation.
	FieldRendererUserData      unsafe.Pointer // void* to hold custom data structure for the renderer (e.g. swap chain, framebuffers etc.). generally set by your Renderer_CreateWindow function.
	FieldPlatformUserData      unsafe.Pointer // void* to hold custom data structure for the OS / platform (e.g. windowing info, render context). generally set by your Platform_CreateWindow function.
	FieldPlatformHandle        unsafe.Pointer // void* for FindViewportByPlatformHandle(). (e.g. suggested to use natural platform handle such as HWND, GLFWWindow*, SDL_Window*)
	FieldPlatformHandleRaw     unsafe.Pointer // void* to hold lower-level, platform-native window handle (under Win32 this is expected to be a HWND, unused for other platforms), when using an abstraction layer like GLFW or SDL (where PlatformHandle would be a SDL_Window*)
	FieldPlatformWindowCreated bool           // Platform window has been created (Platform_CreateWindow() has been called). This is false during the first frame where a viewport is being created.
	FieldPlatformRequestMove   bool           // Platform window requested move (e.g. window was moved by the OS / host window manager, authoritative position will be OS window position)
	FieldPlatformRequestResize bool           // Platform window requested resize (e.g. window was resized by the OS / host window manager, authoritative size will be OS window size)
	FieldPlatformRequestClose  bool           // Platform window requested closure (e.g. window was moved by the OS / host window manager, e.g. pressing ALT-F4)
}

func (self Viewport) handle() (result *C.ImGuiViewport, releaseFn func()) {
	result = new(C.ImGuiViewport)
	FieldID := self.FieldID

	result.ID = C.ImGuiID(FieldID)
	FieldFlags := self.FieldFlags

	result.Flags = C.ImGuiViewportFlags(FieldFlags)
	FieldPos := self.FieldPos

	result.Pos = FieldPos.toC()
	FieldSize := self.FieldSize

	result.Size = FieldSize.toC()
	FieldWorkPos := self.FieldWorkPos

	result.WorkPos = FieldWorkPos.toC()
	FieldWorkSize := self.FieldWorkSize

	result.WorkSize = FieldWorkSize.toC()
	FieldDpiScale := self.FieldDpiScale

	result.DpiScale = C.float(FieldDpiScale)
	FieldParentViewportId := self.FieldParentViewportId

	result.ParentViewportId = C.ImGuiID(FieldParentViewportId)
	FieldDrawData := self.FieldDrawData
	FieldDrawDataArg, FieldDrawDataFin := FieldDrawData.handle()
	result.DrawData = FieldDrawDataArg
	FieldRendererUserData := self.FieldRendererUserData
	FieldRendererUserDataArg, FieldRendererUserDataFin := WrapVoidPtr(FieldRendererUserData)
	result.RendererUserData = FieldRendererUserDataArg
	FieldPlatformUserData := self.FieldPlatformUserData
	FieldPlatformUserDataArg, FieldPlatformUserDataFin := WrapVoidPtr(FieldPlatformUserData)
	result.PlatformUserData = FieldPlatformUserDataArg
	FieldPlatformHandle := self.FieldPlatformHandle
	FieldPlatformHandleArg, FieldPlatformHandleFin := WrapVoidPtr(FieldPlatformHandle)
	result.PlatformHandle = FieldPlatformHandleArg
	FieldPlatformHandleRaw := self.FieldPlatformHandleRaw
	FieldPlatformHandleRawArg, FieldPlatformHandleRawFin := WrapVoidPtr(FieldPlatformHandleRaw)
	result.PlatformHandleRaw = FieldPlatformHandleRawArg
	FieldPlatformWindowCreated := self.FieldPlatformWindowCreated

	result.PlatformWindowCreated = C.bool(FieldPlatformWindowCreated)
	FieldPlatformRequestMove := self.FieldPlatformRequestMove

	result.PlatformRequestMove = C.bool(FieldPlatformRequestMove)
	FieldPlatformRequestResize := self.FieldPlatformRequestResize

	result.PlatformRequestResize = C.bool(FieldPlatformRequestResize)
	FieldPlatformRequestClose := self.FieldPlatformRequestClose

	result.PlatformRequestClose = C.bool(FieldPlatformRequestClose)
	releaseFn = func() {
		FieldDrawDataFin()
		FieldRendererUserDataFin()
		FieldPlatformUserDataFin()
		FieldPlatformHandleFin()
		FieldPlatformHandleRawFin()
	}
	return result, releaseFn
}

func (self Viewport) c() (result C.ImGuiViewport, fin func()) {
	resultPtr, finFn := self.handle()
	return *resultPtr, finFn
}

func newViewportFromC(cvalue *C.ImGuiViewport) *Viewport {
	result := new(Viewport)
	result.FieldID = ID(cvalue.ID)
	result.FieldFlags = ViewportFlags(cvalue.Flags)
	result.FieldPos = *(&Vec2{}).fromC(cvalue.Pos)
	result.FieldSize = *(&Vec2{}).fromC(cvalue.Size)
	result.FieldWorkPos = *(&Vec2{}).fromC(cvalue.WorkPos)
	result.FieldWorkSize = *(&Vec2{}).fromC(cvalue.WorkSize)
	result.FieldDpiScale = float32(cvalue.DpiScale)
	result.FieldParentViewportId = ID(cvalue.ParentViewportId)
	result.FieldDrawData = newDrawDataFromC(cvalue.DrawData)
	result.FieldRendererUserData = unsafe.Pointer(cvalue.RendererUserData)
	result.FieldPlatformUserData = unsafe.Pointer(cvalue.PlatformUserData)
	result.FieldPlatformHandle = unsafe.Pointer(cvalue.PlatformHandle)
	result.FieldPlatformHandleRaw = unsafe.Pointer(cvalue.PlatformHandleRaw)
	result.FieldPlatformWindowCreated = cvalue.PlatformWindowCreated == C.bool(true)
	result.FieldPlatformRequestMove = cvalue.PlatformRequestMove == C.bool(true)
	result.FieldPlatformRequestResize = cvalue.PlatformRequestResize == C.bool(true)
	result.FieldPlatformRequestClose = cvalue.PlatformRequestClose == C.bool(true)
	return result
}

// ImGuiViewport Private/Internals fields (cardinal sin: we are using inheritance!)
// Every instance of ImGuiViewport is in fact a ImGuiViewportP.
type ViewportP struct {
	// TODO: contains unsupported fields
	data unsafe.Pointer
}

func (self ViewportP) handle() (result *C.ImGuiViewportP, releaseFn func()) {
	result = (*C.ImGuiViewportP)(self.data)
	return result, func() {}
}

func (self ViewportP) c() (result C.ImGuiViewportP, fin func()) {
	resultPtr, finFn := self.handle()
	return *resultPtr, finFn
}

func newViewportPFromC(cvalue *C.ImGuiViewportP) *ViewportP {
	result := new(ViewportP)
	result.data = unsafe.Pointer(cvalue)
	return result
}

// Storage for one window
type Window struct {
	// TODO: contains unsupported fields
	data unsafe.Pointer
}

func (self Window) handle() (result *C.ImGuiWindow, releaseFn func()) {
	result = (*C.ImGuiWindow)(self.data)
	return result, func() {}
}

func (self Window) c() (result C.ImGuiWindow, fin func()) {
	resultPtr, finFn := self.handle()
	return *resultPtr, finFn
}

func newWindowFromC(cvalue *C.ImGuiWindow) *Window {
	result := new(Window)
	result.data = unsafe.Pointer(cvalue)
	return result
}

// [ALPHA] Rarely used / very advanced uses only. Use with SetNextWindowClass() and DockSpace() functions.
// Important: the content of this class is still highly WIP and likely to change and be refactored
// before we stabilize Docking features. Please be mindful if using this.
// Provide hints:
// - To the platform backend via altered viewport flags (enable/disable OS decoration, OS task bar icons, etc.)
// - To the platform backend for OS level parent/child relationships of viewport.
// - To the docking system for various options and filtering.
type WindowClass struct {
	FieldClassId                    ID            // User data. 0 = Default class (unclassed). Windows of different classes cannot be docked with each others.
	FieldParentViewportId           ID            // Hint for the platform backend. -1: use default. 0: request platform backend to not parent the platform. != 0: request platform backend to create a parent<>child relationship between the platform windows. Not conforming backends are free to e.g. parent every viewport to the main viewport or not.
	FieldViewportFlagsOverrideSet   ViewportFlags // Viewport flags to set when a window of this class owns a viewport. This allows you to enforce OS decoration or task bar icon, override the defaults on a per-window basis.
	FieldViewportFlagsOverrideClear ViewportFlags // Viewport flags to clear when a window of this class owns a viewport. This allows you to enforce OS decoration or task bar icon, override the defaults on a per-window basis.
	FieldTabItemFlagsOverrideSet    TabItemFlags  // [EXPERIMENTAL] TabItem flags to set when a window of this class gets submitted into a dock node tab bar. May use with ImGuiTabItemFlags_Leading or ImGuiTabItemFlags_Trailing.
	FieldDockNodeFlagsOverrideSet   DockNodeFlags // [EXPERIMENTAL] Dock node flags to set when a window of this class is hosted by a dock node (it doesn't have to be selected!)
	FieldDockingAlwaysTabBar        bool          // Set to true to enforce single floating windows of this class always having their own docking node (equivalent of setting the global io.ConfigDockingAlwaysTabBar)
	FieldDockingAllowUnclassed      bool          // Set to true to allow windows of this class to be docked/merged with an unclassed window. // FIXME-DOCK: Move to DockNodeFlags override?
}

func (self WindowClass) handle() (result *C.ImGuiWindowClass, releaseFn func()) {
	result = new(C.ImGuiWindowClass)
	FieldClassId := self.FieldClassId

	result.ClassId = C.ImGuiID(FieldClassId)
	FieldParentViewportId := self.FieldParentViewportId

	result.ParentViewportId = C.ImGuiID(FieldParentViewportId)
	FieldViewportFlagsOverrideSet := self.FieldViewportFlagsOverrideSet

	result.ViewportFlagsOverrideSet = C.ImGuiViewportFlags(FieldViewportFlagsOverrideSet)
	FieldViewportFlagsOverrideClear := self.FieldViewportFlagsOverrideClear

	result.ViewportFlagsOverrideClear = C.ImGuiViewportFlags(FieldViewportFlagsOverrideClear)
	FieldTabItemFlagsOverrideSet := self.FieldTabItemFlagsOverrideSet

	result.TabItemFlagsOverrideSet = C.ImGuiTabItemFlags(FieldTabItemFlagsOverrideSet)
	FieldDockNodeFlagsOverrideSet := self.FieldDockNodeFlagsOverrideSet

	result.DockNodeFlagsOverrideSet = C.ImGuiDockNodeFlags(FieldDockNodeFlagsOverrideSet)
	FieldDockingAlwaysTabBar := self.FieldDockingAlwaysTabBar

	result.DockingAlwaysTabBar = C.bool(FieldDockingAlwaysTabBar)
	FieldDockingAllowUnclassed := self.FieldDockingAllowUnclassed

	result.DockingAllowUnclassed = C.bool(FieldDockingAllowUnclassed)
	releaseFn = func() {
	}
	return result, releaseFn
}

func (self WindowClass) c() (result C.ImGuiWindowClass, fin func()) {
	resultPtr, finFn := self.handle()
	return *resultPtr, finFn
}

func newWindowClassFromC(cvalue *C.ImGuiWindowClass) *WindowClass {
	result := new(WindowClass)
	result.FieldClassId = ID(cvalue.ClassId)
	result.FieldParentViewportId = ID(cvalue.ParentViewportId)
	result.FieldViewportFlagsOverrideSet = ViewportFlags(cvalue.ViewportFlagsOverrideSet)
	result.FieldViewportFlagsOverrideClear = ViewportFlags(cvalue.ViewportFlagsOverrideClear)
	result.FieldTabItemFlagsOverrideSet = TabItemFlags(cvalue.TabItemFlagsOverrideSet)
	result.FieldDockNodeFlagsOverrideSet = DockNodeFlags(cvalue.DockNodeFlagsOverrideSet)
	result.FieldDockingAlwaysTabBar = cvalue.DockingAlwaysTabBar == C.bool(true)
	result.FieldDockingAllowUnclassed = cvalue.DockingAllowUnclassed == C.bool(true)
	return result
}

type WindowDockStyle struct {
	// TODO: contains unsupported fields
	data unsafe.Pointer
}

func (self WindowDockStyle) handle() (result *C.ImGuiWindowDockStyle, releaseFn func()) {
	result = (*C.ImGuiWindowDockStyle)(self.data)
	return result, func() {}
}

func (self WindowDockStyle) c() (result C.ImGuiWindowDockStyle, fin func()) {
	resultPtr, finFn := self.handle()
	return *resultPtr, finFn
}

func newWindowDockStyleFromC(cvalue *C.ImGuiWindowDockStyle) *WindowDockStyle {
	result := new(WindowDockStyle)
	result.data = unsafe.Pointer(cvalue)
	return result
}

// Windows data saved in imgui.ini file
// Because we never destroy or rename ImGuiWindowSettings, we can store the names in a separate buffer easily.
// (this is designed to be stored in a ImChunkStream buffer, with the variable-length Name following our structure)
type WindowSettings struct {
	// TODO: contains unsupported fields
	data unsafe.Pointer
}

func (self WindowSettings) handle() (result *C.ImGuiWindowSettings, releaseFn func()) {
	result = (*C.ImGuiWindowSettings)(self.data)
	return result, func() {}
}

func (self WindowSettings) c() (result C.ImGuiWindowSettings, fin func()) {
	resultPtr, finFn := self.handle()
	return *resultPtr, finFn
}

func newWindowSettingsFromC(cvalue *C.ImGuiWindowSettings) *WindowSettings {
	result := new(WindowSettings)
	result.data = unsafe.Pointer(cvalue)
	return result
}

// Data saved for each window pushed into the stack
type WindowStackData struct {
	FieldWindow                   *Window
	FieldParentLastItemDataBackup LastItemData
	FieldStackSizesOnBegin        StackSizes // Store size of various stacks for asserting
}

func (self WindowStackData) handle() (result *C.ImGuiWindowStackData, releaseFn func()) {
	result = new(C.ImGuiWindowStackData)
	FieldWindow := self.FieldWindow
	FieldWindowArg, FieldWindowFin := FieldWindow.handle()
	result.Window = FieldWindowArg
	FieldParentLastItemDataBackup := self.FieldParentLastItemDataBackup
	FieldParentLastItemDataBackupArg, FieldParentLastItemDataBackupFin := FieldParentLastItemDataBackup.c()
	result.ParentLastItemDataBackup = FieldParentLastItemDataBackupArg
	FieldStackSizesOnBegin := self.FieldStackSizesOnBegin
	FieldStackSizesOnBeginArg, FieldStackSizesOnBeginFin := FieldStackSizesOnBegin.c()
	result.StackSizesOnBegin = FieldStackSizesOnBeginArg
	releaseFn = func() {
		FieldWindowFin()
		FieldParentLastItemDataBackupFin()
		FieldStackSizesOnBeginFin()
	}
	return result, releaseFn
}

func (self WindowStackData) c() (result C.ImGuiWindowStackData, fin func()) {
	resultPtr, finFn := self.handle()
	return *resultPtr, finFn
}

func newWindowStackDataFromC(cvalue *C.ImGuiWindowStackData) *WindowStackData {
	result := new(WindowStackData)
	result.FieldWindow = newWindowFromC(cvalue.Window)
	result.FieldParentLastItemDataBackup = *newLastItemDataFromC(func() *C.ImGuiLastItemData { result := cvalue.ParentLastItemDataBackup; return &result }())

	result.FieldStackSizesOnBegin = *newStackSizesFromC(func() *C.ImGuiStackSizes { result := cvalue.StackSizesOnBegin; return &result }())

	return result
}

// Transient per-window data, reset at the beginning of the frame. This used to be called ImGuiDrawContext, hence the DC variable name in ImGuiWindow.
// (That's theory, in practice the delimitation between ImGuiWindow and ImGuiWindowTempData is quite tenuous and could be reconsidered..)
// (This doesn't need a constructor because we zero-clear it as part of ImGuiWindow and all frame-temporary data are setup on Begin)
type WindowTempData struct {
	// TODO: contains unsupported fields
	data unsafe.Pointer
}

func (self WindowTempData) handle() (result *C.ImGuiWindowTempData, releaseFn func()) {
	result = (*C.ImGuiWindowTempData)(self.data)
	return result, func() {}
}

func (self WindowTempData) c() (result C.ImGuiWindowTempData, fin func()) {
	resultPtr, finFn := self.handle()
	return *resultPtr, finFn
}

func newWindowTempDataFromC(cvalue *C.ImGuiWindowTempData) *WindowTempData {
	result := new(WindowTempData)
	result.data = unsafe.Pointer(cvalue)
	return result
}

type Vec1 struct {
	FieldX float32
}

func (self Vec1) handle() (result *C.ImVec1, releaseFn func()) {
	result = new(C.ImVec1)
	FieldX := self.FieldX

	result.x = C.float(FieldX)
	releaseFn = func() {
	}
	return result, releaseFn
}

func (self Vec1) c() (result C.ImVec1, fin func()) {
	resultPtr, finFn := self.handle()
	return *resultPtr, finFn
}

func newVec1FromC(cvalue *C.ImVec1) *Vec1 {
	result := new(Vec1)
	result.FieldX = float32(cvalue.x)
	return result
}

type STBTexteditState struct {
	FieldCursor             int32
	FieldSelect_start       int32 // selection start point
	FieldSelect_end         int32
	FieldInsert_mode        uint
	FieldRow_count_per_page int32
	/////////////////////
	//
	// private data
	//
	FieldCursor_at_end_of_line uint // not implemented yet
	FieldInitialized           uint
	FieldHas_preferred_x       uint
	FieldSingle_line           uint
	FieldPadding1              uint
	FieldPadding2              uint
	FieldPadding3              uint
	FieldPreferred_x           float32 // this determines where the cursor up/down tries to seek to along x
	FieldUndostate             StbUndoState
}

func (self STBTexteditState) handle() (result *C.STB_TexteditState, releaseFn func()) {
	result = new(C.STB_TexteditState)
	FieldCursor := self.FieldCursor

	result.cursor = C.int(FieldCursor)
	FieldSelect_start := self.FieldSelect_start

	result.select_start = C.int(FieldSelect_start)
	FieldSelect_end := self.FieldSelect_end

	result.select_end = C.int(FieldSelect_end)
	FieldInsert_mode := self.FieldInsert_mode

	result.insert_mode = C.uchar(FieldInsert_mode)
	FieldRow_count_per_page := self.FieldRow_count_per_page

	result.row_count_per_page = C.int(FieldRow_count_per_page)
	FieldCursor_at_end_of_line := self.FieldCursor_at_end_of_line

	result.cursor_at_end_of_line = C.uchar(FieldCursor_at_end_of_line)
	FieldInitialized := self.FieldInitialized

	result.initialized = C.uchar(FieldInitialized)
	FieldHas_preferred_x := self.FieldHas_preferred_x

	result.has_preferred_x = C.uchar(FieldHas_preferred_x)
	FieldSingle_line := self.FieldSingle_line

	result.single_line = C.uchar(FieldSingle_line)
	FieldPadding1 := self.FieldPadding1

	result.padding1 = C.uchar(FieldPadding1)
	FieldPadding2 := self.FieldPadding2

	result.padding2 = C.uchar(FieldPadding2)
	FieldPadding3 := self.FieldPadding3

	result.padding3 = C.uchar(FieldPadding3)
	FieldPreferred_x := self.FieldPreferred_x

	result.preferred_x = C.float(FieldPreferred_x)
	FieldUndostate := self.FieldUndostate
	FieldUndostateArg, FieldUndostateFin := FieldUndostate.c()
	result.undostate = FieldUndostateArg
	releaseFn = func() {
		FieldUndostateFin()
	}
	return result, releaseFn
}

func (self STBTexteditState) c() (result C.STB_TexteditState, fin func()) {
	resultPtr, finFn := self.handle()
	return *resultPtr, finFn
}

func newSTBTexteditStateFromC(cvalue *C.STB_TexteditState) *STBTexteditState {
	result := new(STBTexteditState)
	result.FieldCursor = int32(cvalue.cursor)
	result.FieldSelect_start = int32(cvalue.select_start)
	result.FieldSelect_end = int32(cvalue.select_end)
	result.FieldInsert_mode = uint(cvalue.insert_mode)
	result.FieldRow_count_per_page = int32(cvalue.row_count_per_page)
	result.FieldCursor_at_end_of_line = uint(cvalue.cursor_at_end_of_line)
	result.FieldInitialized = uint(cvalue.initialized)
	result.FieldHas_preferred_x = uint(cvalue.has_preferred_x)
	result.FieldSingle_line = uint(cvalue.single_line)
	result.FieldPadding1 = uint(cvalue.padding1)
	result.FieldPadding2 = uint(cvalue.padding2)
	result.FieldPadding3 = uint(cvalue.padding3)
	result.FieldPreferred_x = float32(cvalue.preferred_x)
	result.FieldUndostate = *newStbUndoStateFromC(func() *C.StbUndoState { result := cvalue.undostate; return &result }())

	return result
}

// result of layout query
type StbTexteditRow struct {
	FieldX0               float32 // starting x location, end x location (allows for align=right, etc)
	FieldX1               float32 // starting x location, end x location (allows for align=right, etc)
	FieldBaseline_y_delta float32 // position of baseline relative to previous row's baseline
	FieldYmin             float32 // height of row above and below baseline
	FieldYmax             float32 // height of row above and below baseline
	FieldNum_chars        int32
}

func (self StbTexteditRow) handle() (result *C.StbTexteditRow, releaseFn func()) {
	result = new(C.StbTexteditRow)
	FieldX0 := self.FieldX0

	result.x0 = C.float(FieldX0)
	FieldX1 := self.FieldX1

	result.x1 = C.float(FieldX1)
	FieldBaseline_y_delta := self.FieldBaseline_y_delta

	result.baseline_y_delta = C.float(FieldBaseline_y_delta)
	FieldYmin := self.FieldYmin

	result.ymin = C.float(FieldYmin)
	FieldYmax := self.FieldYmax

	result.ymax = C.float(FieldYmax)
	FieldNum_chars := self.FieldNum_chars

	result.num_chars = C.int(FieldNum_chars)
	releaseFn = func() {
	}
	return result, releaseFn
}

func (self StbTexteditRow) c() (result C.StbTexteditRow, fin func()) {
	resultPtr, finFn := self.handle()
	return *resultPtr, finFn
}

func newStbTexteditRowFromC(cvalue *C.StbTexteditRow) *StbTexteditRow {
	result := new(StbTexteditRow)
	result.FieldX0 = float32(cvalue.x0)
	result.FieldX1 = float32(cvalue.x1)
	result.FieldBaseline_y_delta = float32(cvalue.baseline_y_delta)
	result.FieldYmin = float32(cvalue.ymin)
	result.FieldYmax = float32(cvalue.ymax)
	result.FieldNum_chars = int32(cvalue.num_chars)
	return result
}

// //////////////////////////////////////////////////////////////////////
//
//	STB_TexteditState
//
// Definition of STB_TexteditState which you should store
// per-textfield; it includes cursor position, selection state,
// and undo state.
type StbUndoRecord struct {
	// private data
	FieldWhere         int32
	FieldInsert_length int32
	FieldDelete_length int32
	FieldChar_storage  int32
}

func (self StbUndoRecord) handle() (result *C.StbUndoRecord, releaseFn func()) {
	result = new(C.StbUndoRecord)
	FieldWhere := self.FieldWhere

	result.where = C.int(FieldWhere)
	FieldInsert_length := self.FieldInsert_length

	result.insert_length = C.int(FieldInsert_length)
	FieldDelete_length := self.FieldDelete_length

	result.delete_length = C.int(FieldDelete_length)
	FieldChar_storage := self.FieldChar_storage

	result.char_storage = C.int(FieldChar_storage)
	releaseFn = func() {
	}
	return result, releaseFn
}

func (self StbUndoRecord) c() (result C.StbUndoRecord, fin func()) {
	resultPtr, finFn := self.handle()
	return *resultPtr, finFn
}

func newStbUndoRecordFromC(cvalue *C.StbUndoRecord) *StbUndoRecord {
	result := new(StbUndoRecord)
	result.FieldWhere = int32(cvalue.where)
	result.FieldInsert_length = int32(cvalue.insert_length)
	result.FieldDelete_length = int32(cvalue.delete_length)
	result.FieldChar_storage = int32(cvalue.char_storage)
	return result
}

type StbUndoState struct {
	// TODO: contains unsupported fields
	data unsafe.Pointer
}

func (self StbUndoState) handle() (result *C.StbUndoState, releaseFn func()) {
	result = (*C.StbUndoState)(self.data)
	return result, func() {}
}

func (self StbUndoState) c() (result C.StbUndoState, fin func()) {
	resultPtr, finFn := self.handle()
	return *resultPtr, finFn
}

func newStbUndoStateFromC(cvalue *C.StbUndoState) *StbUndoState {
	result := new(StbUndoState)
	result.data = unsafe.Pointer(cvalue)
	return result
}
