// Code generated by cmd/codegen from https://github.com/AllenDang/cimgui-go.
// DO NOT EDIT.

package imgui

// #include <stdlib.h>
// #include <memory.h>
// #include "extra_types.h"
// #include "cimgui_wrapper.h"
import "C"
import "unsafe"

// Helper: ImBitVector
// Store 1-bit per value.
type BitVector struct {
	// TODO: contains unsupported fields
	data unsafe.Pointer
}

func (self BitVector) handle() (result *C.ImBitVector, releaseFn func()) {
	result = (*C.ImBitVector)(self.data)
	return result, func() {}
}

func (self BitVector) c() (result C.ImBitVector, fin func()) {
	resultPtr, finFn := self.handle()
	return *resultPtr, finFn
}

func newBitVectorFromC(cvalue *C.ImBitVector) *BitVector {
	result := new(BitVector)
	result.data = unsafe.Pointer(cvalue)
	return result
}

// [Internal] For use by ImDrawListSplitter
type DrawChannel struct {
	// TODO: contains unsupported fields
	data unsafe.Pointer
}

func (self DrawChannel) handle() (result *C.ImDrawChannel, releaseFn func()) {
	result = (*C.ImDrawChannel)(self.data)
	return result, func() {}
}

func (self DrawChannel) c() (result C.ImDrawChannel, fin func()) {
	resultPtr, finFn := self.handle()
	return *resultPtr, finFn
}

func newDrawChannelFromC(cvalue *C.ImDrawChannel) *DrawChannel {
	result := new(DrawChannel)
	result.data = unsafe.Pointer(cvalue)
	return result
}

// Typically, 1 command = 1 GPU draw call (unless command is a callback)
//   - VtxOffset: When 'io.BackendFlags & ImGuiBackendFlags_RendererHasVtxOffset' is enabled,
//     this fields allow us to render meshes larger than 64K vertices while keeping 16-bit indices.
//     Backends made for <1.71. will typically ignore the VtxOffset fields.
//   - The ClipRect/TextureId/VtxOffset fields must be contiguous as we memcmp() them together (this is asserted for).
type DrawCmd struct {
	// TODO: contains unsupported fields
	data unsafe.Pointer
}

func (self DrawCmd) handle() (result *C.ImDrawCmd, releaseFn func()) {
	result = (*C.ImDrawCmd)(self.data)
	return result, func() {}
}

func (self DrawCmd) c() (result C.ImDrawCmd, fin func()) {
	resultPtr, finFn := self.handle()
	return *resultPtr, finFn
}

func newDrawCmdFromC(cvalue *C.ImDrawCmd) *DrawCmd {
	result := new(DrawCmd)
	result.data = unsafe.Pointer(cvalue)
	return result
}

// [Internal] For use by ImDrawList
type DrawCmdHeader struct {
	FieldlipRect  Vec4
	FieldextureId TextureID
	FieldtxOffset uint32
}

func (self DrawCmdHeader) handle() (result *C.ImDrawCmdHeader, releaseFn func()) {
	result = new(C.ImDrawCmdHeader)
	FieldlipRect := self.FieldlipRect

	result.ClipRect = FieldlipRect.toC()
	FieldextureId := self.FieldextureId

	result.TextureId = C.ImTextureID(FieldextureId)
	FieldtxOffset := self.FieldtxOffset

	result.VtxOffset = C.uint(FieldtxOffset)
	releaseFn = func() {
	}
	return result, releaseFn
}

func (self DrawCmdHeader) c() (result C.ImDrawCmdHeader, fin func()) {
	resultPtr, finFn := self.handle()
	return *resultPtr, finFn
}

func newDrawCmdHeaderFromC(cvalue *C.ImDrawCmdHeader) *DrawCmdHeader {
	result := new(DrawCmdHeader)
	result.FieldlipRect = *(&Vec4{}).fromC(cvalue.ClipRect)
	result.FieldextureId = TextureID(cvalue.TextureId)
	result.FieldtxOffset = uint32(cvalue.VtxOffset)
	return result
}

// All draw data to render a Dear ImGui frame
// (NB: the style and the naming convention here is a little inconsistent, we currently preserve them for backward compatibility purpose,
// as this is one of the oldest structure exposed by the library! Basically, ImDrawList == CmdList)
type DrawData struct {
	// TODO: contains unsupported fields
	data unsafe.Pointer
}

func (self DrawData) handle() (result *C.ImDrawData, releaseFn func()) {
	result = (*C.ImDrawData)(self.data)
	return result, func() {}
}

func (self DrawData) c() (result C.ImDrawData, fin func()) {
	resultPtr, finFn := self.handle()
	return *resultPtr, finFn
}

func newDrawDataFromC(cvalue *C.ImDrawData) *DrawData {
	result := new(DrawData)
	result.data = unsafe.Pointer(cvalue)
	return result
}

type DrawDataBuilder struct {
	// TODO: contains unsupported fields
	data unsafe.Pointer
}

func (self DrawDataBuilder) handle() (result *C.ImDrawDataBuilder, releaseFn func()) {
	result = (*C.ImDrawDataBuilder)(self.data)
	return result, func() {}
}

func (self DrawDataBuilder) c() (result C.ImDrawDataBuilder, fin func()) {
	resultPtr, finFn := self.handle()
	return *resultPtr, finFn
}

func newDrawDataBuilderFromC(cvalue *C.ImDrawDataBuilder) *DrawDataBuilder {
	result := new(DrawDataBuilder)
	result.data = unsafe.Pointer(cvalue)
	return result
}

// Draw command list
// This is the low-level list of polygons that ImGui:: functions are filling. At the end of the frame,
// all command lists are passed to your ImGuiIO::RenderDrawListFn function for rendering.
// Each dear imgui window contains its own ImDrawList. You can use ImGui::GetWindowDrawList() to
// access the current window draw list and draw custom primitives.
// You can interleave normal ImGui:: calls and adding primitives to the current draw list.
// In single viewport mode, top-left is == GetMainViewport()->Pos (generally 0,0), bottom-right is == GetMainViewport()->Pos+Size (generally io.DisplaySize).
// You are totally free to apply whatever transformation matrix to want to the data (depending on the use of the transformation you may want to apply it to ClipRect as well!)
// Important: Primitives are always added to the list and not culled (culling is done at higher-level by ImGui:: functions), if you use this API a lot consider coarse culling your drawn objects.
type DrawList struct {
	// TODO: contains unsupported fields
	data unsafe.Pointer
}

func (self DrawList) handle() (result *C.ImDrawList, releaseFn func()) {
	result = (*C.ImDrawList)(self.data)
	return result, func() {}
}

func (self DrawList) c() (result C.ImDrawList, fin func()) {
	resultPtr, finFn := self.handle()
	return *resultPtr, finFn
}

func newDrawListFromC(cvalue *C.ImDrawList) *DrawList {
	result := new(DrawList)
	result.data = unsafe.Pointer(cvalue)
	return result
}

// Data shared between all ImDrawList instances
// You may want to create your own instance of this if you want to use ImDrawList completely without ImGui. In that case, watch out for future changes to this structure.
type DrawListSharedData struct {
	// TODO: contains unsupported fields
	data unsafe.Pointer
}

func (self DrawListSharedData) handle() (result *C.ImDrawListSharedData, releaseFn func()) {
	result = (*C.ImDrawListSharedData)(self.data)
	return result, func() {}
}

func (self DrawListSharedData) c() (result C.ImDrawListSharedData, fin func()) {
	resultPtr, finFn := self.handle()
	return *resultPtr, finFn
}

func newDrawListSharedDataFromC(cvalue *C.ImDrawListSharedData) *DrawListSharedData {
	result := new(DrawListSharedData)
	result.data = unsafe.Pointer(cvalue)
	return result
}

// Split/Merge functions are used to split the draw list into different layers which can be drawn into out of order.
// This is used by the Columns/Tables API, so items of each column can be batched together in a same draw call.
type DrawListSplitter struct {
	Fieldurrent  int32                // Current channel number (0)
	Fieldount    int32                // Number of active channels (1+)
	Fieldhannels Vector[*DrawChannel] // Draw channels (not resized down so _Count might be < Channels.Size)
}

func (self DrawListSplitter) handle() (result *C.ImDrawListSplitter, releaseFn func()) {
	result = new(C.ImDrawListSplitter)
	Fieldurrent := self.Fieldurrent

	result._Current = C.int(Fieldurrent)
	Fieldount := self.Fieldount

	result._Count = C.int(Fieldount)
	Fieldhannels := self.Fieldhannels
	FieldhannelsData := Fieldhannels.Data
	FieldhannelsDataArg, FieldhannelsDataFin := FieldhannelsData.handle()
	FieldhannelsVecArg := new(C.ImVector_ImDrawChannel)
	FieldhannelsVecArg.Size = C.int(Fieldhannels.Size)
	FieldhannelsVecArg.Capacity = C.int(Fieldhannels.Capacity)
	FieldhannelsVecArg.Data = FieldhannelsDataArg

	result._Channels = *FieldhannelsVecArg
	releaseFn = func() {
		FieldhannelsDataFin()
	}
	return result, releaseFn
}

func (self DrawListSplitter) c() (result C.ImDrawListSplitter, fin func()) {
	resultPtr, finFn := self.handle()
	return *resultPtr, finFn
}

func newDrawListSplitterFromC(cvalue *C.ImDrawListSplitter) *DrawListSplitter {
	result := new(DrawListSplitter)
	result.Fieldurrent = int32(cvalue._Current)
	result.Fieldount = int32(cvalue._Count)
	result.Fieldhannels = newVectorFromC(cvalue._Channels.Size, cvalue._Channels.Capacity, newDrawChannelFromC(cvalue._Channels.Data))
	return result
}

type DrawVert struct {
	Fieldos Vec2
	Fieldv  Vec2
	Fieldol uint32
}

func (self DrawVert) handle() (result *C.ImDrawVert, releaseFn func()) {
	result = new(C.ImDrawVert)
	Fieldos := self.Fieldos

	result.pos = Fieldos.toC()
	Fieldv := self.Fieldv

	result.uv = Fieldv.toC()
	Fieldol := self.Fieldol

	result.col = C.ImU32(Fieldol)
	releaseFn = func() {
	}
	return result, releaseFn
}

func (self DrawVert) c() (result C.ImDrawVert, fin func()) {
	resultPtr, finFn := self.handle()
	return *resultPtr, finFn
}

func newDrawVertFromC(cvalue *C.ImDrawVert) *DrawVert {
	result := new(DrawVert)
	result.Fieldos = *(&Vec2{}).fromC(cvalue.pos)
	result.Fieldv = *(&Vec2{}).fromC(cvalue.uv)
	result.Fieldol = uint32(cvalue.col)
	return result
}

// Font runtime data and rendering
// ImFontAtlas automatically loads a default embedded font for you when you call GetTexDataAsAlpha8() or GetTexDataAsRGBA32().
type Font struct {
	// TODO: contains unsupported fields
	data unsafe.Pointer
}

func (self Font) handle() (result *C.ImFont, releaseFn func()) {
	result = (*C.ImFont)(self.data)
	return result, func() {}
}

func (self Font) c() (result C.ImFont, fin func()) {
	resultPtr, finFn := self.handle()
	return *resultPtr, finFn
}

func newFontFromC(cvalue *C.ImFont) *Font {
	result := new(Font)
	result.data = unsafe.Pointer(cvalue)
	return result
}

// Load and rasterize multiple TTF/OTF fonts into a same texture. The font atlas will build a single texture holding:
//   - One or more fonts.
//   - Custom graphics data needed to render the shapes needed by Dear ImGui.
//   - Mouse cursor shapes for software cursor rendering (unless setting 'Flags |= ImFontAtlasFlags_NoMouseCursors' in the font atlas).
//
// It is the user-code responsibility to setup/build the atlas, then upload the pixel data into a texture accessible by your graphics api.
//   - Optionally, call any of the AddFont*** functions. If you don't call any, the default font embedded in the code will be loaded for you.
//   - Call GetTexDataAsAlpha8() or GetTexDataAsRGBA32() to build and retrieve pixels data.
//   - Upload the pixels data into a texture within your graphics system (see imgui_impl_xxxx.cpp examples)
//   - Call SetTexID(my_tex_id); and pass the pointer/identifier to your texture in a format natural to your graphics API.
//     This value will be passed back to you during rendering to identify the texture. Read FAQ entry about ImTextureID for more details.
//
// Common pitfalls:
//   - If you pass a 'glyph_ranges' array to AddFont*** functions, you need to make sure that your array persist up until the
//     atlas is build (when calling GetTexData*** or Build()). We only copy the pointer, not the data.
//   - Important: By default, AddFontFromMemoryTTF() takes ownership of the data. Even though we are not writing to it, we will free the pointer on destruction.
//     You can set font_cfg->FontDataOwnedByAtlas=false to keep ownership of your data and it won't be freed,
//   - Even though many functions are suffixed with "TTF", OTF data is supported just as well.
//   - This is an old API and it is currently awkward for those and various other reasons! We will address them in the future!
type FontAtlas struct {
	// TODO: contains unsupported fields
	data unsafe.Pointer
}

func (self FontAtlas) handle() (result *C.ImFontAtlas, releaseFn func()) {
	result = (*C.ImFontAtlas)(self.data)
	return result, func() {}
}

func (self FontAtlas) c() (result C.ImFontAtlas, fin func()) {
	resultPtr, finFn := self.handle()
	return *resultPtr, finFn
}

func newFontAtlasFromC(cvalue *C.ImFontAtlas) *FontAtlas {
	result := new(FontAtlas)
	result.data = unsafe.Pointer(cvalue)
	return result
}

// See ImFontAtlas::AddCustomRectXXX functions.
type FontAtlasCustomRect struct {
	Fieldidth         uint    // Input    // Desired rectangle dimension
	Fieldeight        uint    // Input    // Desired rectangle dimension
	Field             uint    // Output   // Packed position in Atlas
	Field             uint    // Output   // Packed position in Atlas
	FieldlyphID       uint32  // Input    // For custom font glyphs only (ID < 0x110000)
	FieldlyphAdvanceX float32 // Input    // For custom font glyphs only: glyph xadvance
	FieldlyphOffset   Vec2    // Input    // For custom font glyphs only: glyph display offset
	Fieldont          *Font   // Input    // For custom font glyphs only: target font
}

func (self FontAtlasCustomRect) handle() (result *C.ImFontAtlasCustomRect, releaseFn func()) {
	result = new(C.ImFontAtlasCustomRect)
	Fieldidth := self.Fieldidth

	result.Width = C.ushort(Fieldidth)
	Fieldeight := self.Fieldeight

	result.Height = C.ushort(Fieldeight)
	Field := self.Field

	result.X = C.ushort(Field)
	Field := self.Field

	result.Y = C.ushort(Field)
	FieldlyphID := self.FieldlyphID

	result.GlyphID = C.uint(FieldlyphID)
	FieldlyphAdvanceX := self.FieldlyphAdvanceX

	result.GlyphAdvanceX = C.float(FieldlyphAdvanceX)
	FieldlyphOffset := self.FieldlyphOffset

	result.GlyphOffset = FieldlyphOffset.toC()
	Fieldont := self.Fieldont
	FieldontArg, FieldontFin := Fieldont.handle()
	result.Font = FieldontArg
	releaseFn = func() {
		FieldontFin()
	}
	return result, releaseFn
}

func (self FontAtlasCustomRect) c() (result C.ImFontAtlasCustomRect, fin func()) {
	resultPtr, finFn := self.handle()
	return *resultPtr, finFn
}

func newFontAtlasCustomRectFromC(cvalue *C.ImFontAtlasCustomRect) *FontAtlasCustomRect {
	result := new(FontAtlasCustomRect)
	result.Fieldidth = uint(cvalue.Width)
	result.Fieldeight = uint(cvalue.Height)
	result.Field = uint(cvalue.X)
	result.Field = uint(cvalue.Y)
	result.FieldlyphID = uint32(cvalue.GlyphID)
	result.FieldlyphAdvanceX = float32(cvalue.GlyphAdvanceX)
	result.FieldlyphOffset = *(&Vec2{}).fromC(cvalue.GlyphOffset)
	result.Fieldont = newFontFromC(cvalue.Font)
	return result
}

// This structure is likely to evolve as we add support for incremental atlas updates
type FontBuilderIO struct {
	// TODO: contains unsupported fields
	data unsafe.Pointer
}

func (self FontBuilderIO) handle() (result *C.ImFontBuilderIO, releaseFn func()) {
	result = (*C.ImFontBuilderIO)(self.data)
	return result, func() {}
}

func (self FontBuilderIO) c() (result C.ImFontBuilderIO, fin func()) {
	resultPtr, finFn := self.handle()
	return *resultPtr, finFn
}

func newFontBuilderIOFromC(cvalue *C.ImFontBuilderIO) *FontBuilderIO {
	result := new(FontBuilderIO)
	result.data = unsafe.Pointer(cvalue)
	return result
}

type FontConfig struct {
	// TODO: contains unsupported fields
	data unsafe.Pointer
}

func (self FontConfig) handle() (result *C.ImFontConfig, releaseFn func()) {
	result = (*C.ImFontConfig)(self.data)
	return result, func() {}
}

func (self FontConfig) c() (result C.ImFontConfig, fin func()) {
	resultPtr, finFn := self.handle()
	return *resultPtr, finFn
}

func newFontConfigFromC(cvalue *C.ImFontConfig) *FontConfig {
	result := new(FontConfig)
	result.data = unsafe.Pointer(cvalue)
	return result
}

// Hold rendering data for one glyph.
// (Note: some language parsers may fail to convert the 31+1 bitfield members, in this case maybe drop store a single u32 or we can rework this)
type FontGlyph struct {
	// TODO: contains unsupported fields
	data unsafe.Pointer
}

func (self FontGlyph) handle() (result *C.ImFontGlyph, releaseFn func()) {
	result = (*C.ImFontGlyph)(self.data)
	return result, func() {}
}

func (self FontGlyph) c() (result C.ImFontGlyph, fin func()) {
	resultPtr, finFn := self.handle()
	return *resultPtr, finFn
}

func newFontGlyphFromC(cvalue *C.ImFontGlyph) *FontGlyph {
	result := new(FontGlyph)
	result.data = unsafe.Pointer(cvalue)
	return result
}

// Helper to build glyph ranges from text/string data. Feed your application strings/characters to it then call BuildRanges().
// This is essentially a tightly packed of vector of 64k booleans = 8KB storage.
type FontGlyphRangesBuilder struct {
	// TODO: contains unsupported fields
	data unsafe.Pointer
}

func (self FontGlyphRangesBuilder) handle() (result *C.ImFontGlyphRangesBuilder, releaseFn func()) {
	result = (*C.ImFontGlyphRangesBuilder)(self.data)
	return result, func() {}
}

func (self FontGlyphRangesBuilder) c() (result C.ImFontGlyphRangesBuilder, fin func()) {
	resultPtr, finFn := self.handle()
	return *resultPtr, finFn
}

func newFontGlyphRangesBuilderFromC(cvalue *C.ImFontGlyphRangesBuilder) *FontGlyphRangesBuilder {
	result := new(FontGlyphRangesBuilder)
	result.data = unsafe.Pointer(cvalue)
	return result
}

// Stacked color modifier, backup of modified data so we can restore it
type ColorMod struct {
	// TODO: contains unsupported fields
	data unsafe.Pointer
}

func (self ColorMod) handle() (result *C.ImGuiColorMod, releaseFn func()) {
	result = (*C.ImGuiColorMod)(self.data)
	return result, func() {}
}

func (self ColorMod) c() (result C.ImGuiColorMod, fin func()) {
	resultPtr, finFn := self.handle()
	return *resultPtr, finFn
}

func newColorModFromC(cvalue *C.ImGuiColorMod) *ColorMod {
	result := new(ColorMod)
	result.data = unsafe.Pointer(cvalue)
	return result
}

// Storage data for BeginComboPreview()/EndComboPreview()
type ComboPreviewData struct {
	// TODO: contains unsupported fields
	data unsafe.Pointer
}

func (self ComboPreviewData) handle() (result *C.ImGuiComboPreviewData, releaseFn func()) {
	result = (*C.ImGuiComboPreviewData)(self.data)
	return result, func() {}
}

func (self ComboPreviewData) c() (result C.ImGuiComboPreviewData, fin func()) {
	resultPtr, finFn := self.handle()
	return *resultPtr, finFn
}

func newComboPreviewDataFromC(cvalue *C.ImGuiComboPreviewData) *ComboPreviewData {
	result := new(ComboPreviewData)
	result.data = unsafe.Pointer(cvalue)
	return result
}

type Context struct {
	// TODO: contains unsupported fields
	data unsafe.Pointer
}

func (self Context) handle() (result *C.ImGuiContext, releaseFn func()) {
	result = (*C.ImGuiContext)(self.data)
	return result, func() {}
}

func (self Context) c() (result C.ImGuiContext, fin func()) {
	resultPtr, finFn := self.handle()
	return *resultPtr, finFn
}

func newContextFromC(cvalue *C.ImGuiContext) *Context {
	result := new(Context)
	result.data = unsafe.Pointer(cvalue)
	return result
}

type ContextHook struct {
	// TODO: contains unsupported fields
	data unsafe.Pointer
}

func (self ContextHook) handle() (result *C.ImGuiContextHook, releaseFn func()) {
	result = (*C.ImGuiContextHook)(self.data)
	return result, func() {}
}

func (self ContextHook) c() (result C.ImGuiContextHook, fin func()) {
	resultPtr, finFn := self.handle()
	return *resultPtr, finFn
}

func newContextHookFromC(cvalue *C.ImGuiContextHook) *ContextHook {
	result := new(ContextHook)
	result.data = unsafe.Pointer(cvalue)
	return result
}

// Type information associated to one ImGuiDataType. Retrieve with DataTypeGetInfo().
type DataTypeInfo struct {
	Fieldize     uint64 // Size in bytes
	Fieldame     string // Short descriptive name for the type, for debugging
	FieldrintFmt string // Default printf format for the type
	FieldcanFmt  string // Default scanf format for the type
}

func (self DataTypeInfo) handle() (result *C.ImGuiDataTypeInfo, releaseFn func()) {
	result = new(C.ImGuiDataTypeInfo)
	Fieldize := self.Fieldize

	result.Size = C.xulong(Fieldize)
	Fieldame := self.Fieldame
	FieldameArg, FieldameFin := WrapString(Fieldame)
	result.Name = FieldameArg
	FieldrintFmt := self.FieldrintFmt
	FieldrintFmtArg, FieldrintFmtFin := WrapString(FieldrintFmt)
	result.PrintFmt = FieldrintFmtArg
	FieldcanFmt := self.FieldcanFmt
	FieldcanFmtArg, FieldcanFmtFin := WrapString(FieldcanFmt)
	result.ScanFmt = FieldcanFmtArg
	releaseFn = func() {
		FieldameFin()
		FieldrintFmtFin()
		FieldcanFmtFin()
	}
	return result, releaseFn
}

func (self DataTypeInfo) c() (result C.ImGuiDataTypeInfo, fin func()) {
	resultPtr, finFn := self.handle()
	return *resultPtr, finFn
}

func newDataTypeInfoFromC(cvalue *C.ImGuiDataTypeInfo) *DataTypeInfo {
	result := new(DataTypeInfo)
	result.Fieldize = uint64(cvalue.Size)
	result.Fieldame = C.GoString(cvalue.Name)
	result.FieldrintFmt = C.GoString(cvalue.PrintFmt)
	result.FieldcanFmt = C.GoString(cvalue.ScanFmt)
	return result
}

type DataTypeTempStorage struct {
	// TODO: contains unsupported fields
	data unsafe.Pointer
}

func (self DataTypeTempStorage) handle() (result *C.ImGuiDataTypeTempStorage, releaseFn func()) {
	result = (*C.ImGuiDataTypeTempStorage)(self.data)
	return result, func() {}
}

func (self DataTypeTempStorage) c() (result C.ImGuiDataTypeTempStorage, fin func()) {
	resultPtr, finFn := self.handle()
	return *resultPtr, finFn
}

func newDataTypeTempStorageFromC(cvalue *C.ImGuiDataTypeTempStorage) *DataTypeTempStorage {
	result := new(DataTypeTempStorage)
	result.data = unsafe.Pointer(cvalue)
	return result
}

type DataVarInfo struct {
	// TODO: contains unsupported fields
	data unsafe.Pointer
}

func (self DataVarInfo) handle() (result *C.ImGuiDataVarInfo, releaseFn func()) {
	result = (*C.ImGuiDataVarInfo)(self.data)
	return result, func() {}
}

func (self DataVarInfo) c() (result C.ImGuiDataVarInfo, fin func()) {
	resultPtr, finFn := self.handle()
	return *resultPtr, finFn
}

func newDataVarInfoFromC(cvalue *C.ImGuiDataVarInfo) *DataVarInfo {
	result := new(DataVarInfo)
	result.data = unsafe.Pointer(cvalue)
	return result
}

type DockContext struct {
	// TODO: contains unsupported fields
	data unsafe.Pointer
}

func (self DockContext) handle() (result *C.ImGuiDockContext, releaseFn func()) {
	result = (*C.ImGuiDockContext)(self.data)
	return result, func() {}
}

func (self DockContext) c() (result C.ImGuiDockContext, fin func()) {
	resultPtr, finFn := self.handle()
	return *resultPtr, finFn
}

func newDockContextFromC(cvalue *C.ImGuiDockContext) *DockContext {
	result := new(DockContext)
	result.data = unsafe.Pointer(cvalue)
	return result
}

// sizeof() 156~192
type DockNode struct {
	// TODO: contains unsupported fields
	data unsafe.Pointer
}

func (self DockNode) handle() (result *C.ImGuiDockNode, releaseFn func()) {
	result = (*C.ImGuiDockNode)(self.data)
	return result, func() {}
}

func (self DockNode) c() (result C.ImGuiDockNode, fin func()) {
	resultPtr, finFn := self.handle()
	return *resultPtr, finFn
}

func newDockNodeFromC(cvalue *C.ImGuiDockNode) *DockNode {
	result := new(DockNode)
	result.data = unsafe.Pointer(cvalue)
	return result
}

// Stacked storage data for BeginGroup()/EndGroup()
type GroupData struct {
	FieldindowID                           ID
	FieldackupCursorPos                    Vec2
	FieldackupCursorMaxPos                 Vec2
	FieldackupIndent                       Vec1
	FieldackupGroupOffset                  Vec1
	FieldackupCurrLineSize                 Vec2
	FieldackupCurrLineTextBaseOffset       float32
	FieldackupActiveIdIsAlive              ID
	FieldackupActiveIdPreviousFrameIsAlive bool
	FieldackupHoveredIdIsAlive             bool
	FieldmitItem                           bool
}

func (self GroupData) handle() (result *C.ImGuiGroupData, releaseFn func()) {
	result = new(C.ImGuiGroupData)
	FieldindowID := self.FieldindowID

	result.WindowID = C.ImGuiID(FieldindowID)
	FieldackupCursorPos := self.FieldackupCursorPos

	result.BackupCursorPos = FieldackupCursorPos.toC()
	FieldackupCursorMaxPos := self.FieldackupCursorMaxPos

	result.BackupCursorMaxPos = FieldackupCursorMaxPos.toC()
	FieldackupIndent := self.FieldackupIndent
	FieldackupIndentArg, FieldackupIndentFin := FieldackupIndent.c()
	result.BackupIndent = FieldackupIndentArg
	FieldackupGroupOffset := self.FieldackupGroupOffset
	FieldackupGroupOffsetArg, FieldackupGroupOffsetFin := FieldackupGroupOffset.c()
	result.BackupGroupOffset = FieldackupGroupOffsetArg
	FieldackupCurrLineSize := self.FieldackupCurrLineSize

	result.BackupCurrLineSize = FieldackupCurrLineSize.toC()
	FieldackupCurrLineTextBaseOffset := self.FieldackupCurrLineTextBaseOffset

	result.BackupCurrLineTextBaseOffset = C.float(FieldackupCurrLineTextBaseOffset)
	FieldackupActiveIdIsAlive := self.FieldackupActiveIdIsAlive

	result.BackupActiveIdIsAlive = C.ImGuiID(FieldackupActiveIdIsAlive)
	FieldackupActiveIdPreviousFrameIsAlive := self.FieldackupActiveIdPreviousFrameIsAlive

	result.BackupActiveIdPreviousFrameIsAlive = C.bool(FieldackupActiveIdPreviousFrameIsAlive)
	FieldackupHoveredIdIsAlive := self.FieldackupHoveredIdIsAlive

	result.BackupHoveredIdIsAlive = C.bool(FieldackupHoveredIdIsAlive)
	FieldmitItem := self.FieldmitItem

	result.EmitItem = C.bool(FieldmitItem)
	releaseFn = func() {
		FieldackupIndentFin()
		FieldackupGroupOffsetFin()
	}
	return result, releaseFn
}

func (self GroupData) c() (result C.ImGuiGroupData, fin func()) {
	resultPtr, finFn := self.handle()
	return *resultPtr, finFn
}

func newGroupDataFromC(cvalue *C.ImGuiGroupData) *GroupData {
	result := new(GroupData)
	result.FieldindowID = ID(cvalue.WindowID)
	result.FieldackupCursorPos = *(&Vec2{}).fromC(cvalue.BackupCursorPos)
	result.FieldackupCursorMaxPos = *(&Vec2{}).fromC(cvalue.BackupCursorMaxPos)
	result.FieldackupIndent = *newVec1FromC(cvalue.BackupIndent)

	result.FieldackupGroupOffset = *newVec1FromC(cvalue.BackupGroupOffset)

	result.FieldackupCurrLineSize = *(&Vec2{}).fromC(cvalue.BackupCurrLineSize)
	result.FieldackupCurrLineTextBaseOffset = float32(cvalue.BackupCurrLineTextBaseOffset)
	result.FieldackupActiveIdIsAlive = ID(cvalue.BackupActiveIdIsAlive)
	result.FieldackupActiveIdPreviousFrameIsAlive = cvalue.BackupActiveIdPreviousFrameIsAlive == C.bool(true)
	result.FieldackupHoveredIdIsAlive = cvalue.BackupHoveredIdIsAlive == C.bool(true)
	result.FieldmitItem = cvalue.EmitItem == C.bool(true)
	return result
}

type IO struct {
	// TODO: contains unsupported fields
	data unsafe.Pointer
}

func (self IO) handle() (result *C.ImGuiIO, releaseFn func()) {
	result = (*C.ImGuiIO)(self.data)
	return result, func() {}
}

func (self IO) c() (result C.ImGuiIO, fin func()) {
	resultPtr, finFn := self.handle()
	return *resultPtr, finFn
}

func newIOFromC(cvalue *C.ImGuiIO) *IO {
	result := new(IO)
	result.data = unsafe.Pointer(cvalue)
	return result
}

type InputEvent struct {
	// TODO: contains unsupported fields
	data unsafe.Pointer
}

func (self InputEvent) handle() (result *C.ImGuiInputEvent, releaseFn func()) {
	result = (*C.ImGuiInputEvent)(self.data)
	return result, func() {}
}

func (self InputEvent) c() (result C.ImGuiInputEvent, fin func()) {
	resultPtr, finFn := self.handle()
	return *resultPtr, finFn
}

func newInputEventFromC(cvalue *C.ImGuiInputEvent) *InputEvent {
	result := new(InputEvent)
	result.data = unsafe.Pointer(cvalue)
	return result
}

type InputEventAppFocused struct {
	Fieldocused bool
}

func (self InputEventAppFocused) handle() (result *C.ImGuiInputEventAppFocused, releaseFn func()) {
	result = new(C.ImGuiInputEventAppFocused)
	Fieldocused := self.Fieldocused

	result.Focused = C.bool(Fieldocused)
	releaseFn = func() {
	}
	return result, releaseFn
}

func (self InputEventAppFocused) c() (result C.ImGuiInputEventAppFocused, fin func()) {
	resultPtr, finFn := self.handle()
	return *resultPtr, finFn
}

func newInputEventAppFocusedFromC(cvalue *C.ImGuiInputEventAppFocused) *InputEventAppFocused {
	result := new(InputEventAppFocused)
	result.Fieldocused = cvalue.Focused == C.bool(true)
	return result
}

type InputEventKey struct {
	// TODO: contains unsupported fields
	data unsafe.Pointer
}

func (self InputEventKey) handle() (result *C.ImGuiInputEventKey, releaseFn func()) {
	result = (*C.ImGuiInputEventKey)(self.data)
	return result, func() {}
}

func (self InputEventKey) c() (result C.ImGuiInputEventKey, fin func()) {
	resultPtr, finFn := self.handle()
	return *resultPtr, finFn
}

func newInputEventKeyFromC(cvalue *C.ImGuiInputEventKey) *InputEventKey {
	result := new(InputEventKey)
	result.data = unsafe.Pointer(cvalue)
	return result
}

type InputEventMouseButton struct {
	// TODO: contains unsupported fields
	data unsafe.Pointer
}

func (self InputEventMouseButton) handle() (result *C.ImGuiInputEventMouseButton, releaseFn func()) {
	result = (*C.ImGuiInputEventMouseButton)(self.data)
	return result, func() {}
}

func (self InputEventMouseButton) c() (result C.ImGuiInputEventMouseButton, fin func()) {
	resultPtr, finFn := self.handle()
	return *resultPtr, finFn
}

func newInputEventMouseButtonFromC(cvalue *C.ImGuiInputEventMouseButton) *InputEventMouseButton {
	result := new(InputEventMouseButton)
	result.data = unsafe.Pointer(cvalue)
	return result
}

// FIXME: Structures in the union below need to be declared as anonymous unions appears to be an extension?
// Using ImVec2() would fail on Clang 'union member 'MousePos' has a non-trivial default constructor'
type InputEventMousePos struct {
	// TODO: contains unsupported fields
	data unsafe.Pointer
}

func (self InputEventMousePos) handle() (result *C.ImGuiInputEventMousePos, releaseFn func()) {
	result = (*C.ImGuiInputEventMousePos)(self.data)
	return result, func() {}
}

func (self InputEventMousePos) c() (result C.ImGuiInputEventMousePos, fin func()) {
	resultPtr, finFn := self.handle()
	return *resultPtr, finFn
}

func newInputEventMousePosFromC(cvalue *C.ImGuiInputEventMousePos) *InputEventMousePos {
	result := new(InputEventMousePos)
	result.data = unsafe.Pointer(cvalue)
	return result
}

type InputEventMouseViewport struct {
	FieldoveredViewportID ID
}

func (self InputEventMouseViewport) handle() (result *C.ImGuiInputEventMouseViewport, releaseFn func()) {
	result = new(C.ImGuiInputEventMouseViewport)
	FieldoveredViewportID := self.FieldoveredViewportID

	result.HoveredViewportID = C.ImGuiID(FieldoveredViewportID)
	releaseFn = func() {
	}
	return result, releaseFn
}

func (self InputEventMouseViewport) c() (result C.ImGuiInputEventMouseViewport, fin func()) {
	resultPtr, finFn := self.handle()
	return *resultPtr, finFn
}

func newInputEventMouseViewportFromC(cvalue *C.ImGuiInputEventMouseViewport) *InputEventMouseViewport {
	result := new(InputEventMouseViewport)
	result.FieldoveredViewportID = ID(cvalue.HoveredViewportID)
	return result
}

type InputEventMouseWheel struct {
	// TODO: contains unsupported fields
	data unsafe.Pointer
}

func (self InputEventMouseWheel) handle() (result *C.ImGuiInputEventMouseWheel, releaseFn func()) {
	result = (*C.ImGuiInputEventMouseWheel)(self.data)
	return result, func() {}
}

func (self InputEventMouseWheel) c() (result C.ImGuiInputEventMouseWheel, fin func()) {
	resultPtr, finFn := self.handle()
	return *resultPtr, finFn
}

func newInputEventMouseWheelFromC(cvalue *C.ImGuiInputEventMouseWheel) *InputEventMouseWheel {
	result := new(InputEventMouseWheel)
	result.data = unsafe.Pointer(cvalue)
	return result
}

type InputEventText struct {
	Fieldhar uint32
}

func (self InputEventText) handle() (result *C.ImGuiInputEventText, releaseFn func()) {
	result = new(C.ImGuiInputEventText)
	Fieldhar := self.Fieldhar

	result.Char = C.uint(Fieldhar)
	releaseFn = func() {
	}
	return result, releaseFn
}

func (self InputEventText) c() (result C.ImGuiInputEventText, fin func()) {
	resultPtr, finFn := self.handle()
	return *resultPtr, finFn
}

func newInputEventTextFromC(cvalue *C.ImGuiInputEventText) *InputEventText {
	result := new(InputEventText)
	result.Fieldhar = uint32(cvalue.Char)
	return result
}

// Shared state of InputText(), passed as an argument to your callback when a ImGuiInputTextFlags_Callback* flag is used.
// The callback function should return 0 by default.
// Callbacks (follow a flag name and see comments in ImGuiInputTextFlags_ declarations for more details)
// - ImGuiInputTextFlags_CallbackEdit:        Callback on buffer edit (note that InputText() already returns true on edit, the callback is useful mainly to manipulate the underlying buffer while focus is active)
// - ImGuiInputTextFlags_CallbackAlways:      Callback on each iteration
// - ImGuiInputTextFlags_CallbackCompletion:  Callback on pressing TAB
// - ImGuiInputTextFlags_CallbackHistory:     Callback on pressing Up/Down arrows
// - ImGuiInputTextFlags_CallbackCharFilter:  Callback on character inputs to replace or discard them. Modify 'EventChar' to replace or discard, or return 1 in callback to discard.
// - ImGuiInputTextFlags_CallbackResize:      Callback on buffer capacity changes request (beyond 'buf_size' parameter value), allowing the string to grow.
type InputTextCallbackData struct {
	// TODO: contains unsupported fields
	data unsafe.Pointer
}

func (self InputTextCallbackData) handle() (result *C.ImGuiInputTextCallbackData, releaseFn func()) {
	result = (*C.ImGuiInputTextCallbackData)(self.data)
	return result, func() {}
}

func (self InputTextCallbackData) c() (result C.ImGuiInputTextCallbackData, fin func()) {
	resultPtr, finFn := self.handle()
	return *resultPtr, finFn
}

func newInputTextCallbackDataFromC(cvalue *C.ImGuiInputTextCallbackData) *InputTextCallbackData {
	result := new(InputTextCallbackData)
	result.data = unsafe.Pointer(cvalue)
	return result
}

// Internal temporary state for deactivating InputText() instances.
type InputTextDeactivatedState struct {
	FieldD    ID             // widget id owning the text state (which just got deactivated)
	FieldextA Vector[string] // text buffer
}

func (self InputTextDeactivatedState) handle() (result *C.ImGuiInputTextDeactivatedState, releaseFn func()) {
	result = new(C.ImGuiInputTextDeactivatedState)
	FieldD := self.FieldD

	result.ID = C.ImGuiID(FieldD)
	FieldextA := self.FieldextA
	FieldextAData := FieldextA.Data
	FieldextADataArg, FieldextADataFin := WrapString(FieldextAData)
	FieldextAVecArg := new(C.ImVector_char)
	FieldextAVecArg.Size = C.int(FieldextA.Size)
	FieldextAVecArg.Capacity = C.int(FieldextA.Capacity)
	FieldextAVecArg.Data = FieldextADataArg

	result.TextA = *FieldextAVecArg
	releaseFn = func() {
		FieldextADataFin()
	}
	return result, releaseFn
}

func (self InputTextDeactivatedState) c() (result C.ImGuiInputTextDeactivatedState, fin func()) {
	resultPtr, finFn := self.handle()
	return *resultPtr, finFn
}

func newInputTextDeactivatedStateFromC(cvalue *C.ImGuiInputTextDeactivatedState) *InputTextDeactivatedState {
	result := new(InputTextDeactivatedState)
	result.FieldD = ID(cvalue.ID)
	result.FieldextA = newVectorFromC(cvalue.TextA.Size, cvalue.TextA.Capacity, C.GoString(cvalue.TextA.Data))
	return result
}

// Internal state of the currently focused/edited text input box
// For a given item ID, access with ImGui::GetInputTextState()
type InputTextState struct {
	// TODO: contains unsupported fields
	data unsafe.Pointer
}

func (self InputTextState) handle() (result *C.ImGuiInputTextState, releaseFn func()) {
	result = (*C.ImGuiInputTextState)(self.data)
	return result, func() {}
}

func (self InputTextState) c() (result C.ImGuiInputTextState, fin func()) {
	resultPtr, finFn := self.handle()
	return *resultPtr, finFn
}

func newInputTextStateFromC(cvalue *C.ImGuiInputTextState) *InputTextState {
	result := new(InputTextState)
	result.data = unsafe.Pointer(cvalue)
	return result
}

// [Internal] Storage used by IsKeyDown(), IsKeyPressed() etc functions.
// If prior to 1.87 you used io.KeysDownDuration[] (which was marked as internal), you should use GetKeyData(key)->DownDuration and *NOT* io.KeysData[key]->DownDuration.
type KeyData struct {
	Fieldown             bool    // True for if key is down
	FieldownDuration     float32 // Duration the key has been down (<0.0f: not pressed, 0.0f: just pressed, >0.0f: time held)
	FieldownDurationPrev float32 // Last frame duration the key has been down
	FieldnalogValue      float32 // 0.0f..1.0f for gamepad values
}

func (self KeyData) handle() (result *C.ImGuiKeyData, releaseFn func()) {
	result = new(C.ImGuiKeyData)
	Fieldown := self.Fieldown

	result.Down = C.bool(Fieldown)
	FieldownDuration := self.FieldownDuration

	result.DownDuration = C.float(FieldownDuration)
	FieldownDurationPrev := self.FieldownDurationPrev

	result.DownDurationPrev = C.float(FieldownDurationPrev)
	FieldnalogValue := self.FieldnalogValue

	result.AnalogValue = C.float(FieldnalogValue)
	releaseFn = func() {
	}
	return result, releaseFn
}

func (self KeyData) c() (result C.ImGuiKeyData, fin func()) {
	resultPtr, finFn := self.handle()
	return *resultPtr, finFn
}

func newKeyDataFromC(cvalue *C.ImGuiKeyData) *KeyData {
	result := new(KeyData)
	result.Fieldown = cvalue.Down == C.bool(true)
	result.FieldownDuration = float32(cvalue.DownDuration)
	result.FieldownDurationPrev = float32(cvalue.DownDurationPrev)
	result.FieldnalogValue = float32(cvalue.AnalogValue)
	return result
}

// This extends ImGuiKeyData but only for named keys (legacy keys don't support the new features)
// Stored in main context (1 per named key). In the future it might be merged into ImGuiKeyData.
type KeyOwnerData struct {
	FieldwnerCurr        ID
	FieldwnerNext        ID
	FieldockThisFrame    bool // Reading this key requires explicit owner id (until end of frame). Set by ImGuiInputFlags_LockThisFrame.
	FieldockUntilRelease bool // Reading this key requires explicit owner id (until key is released). Set by ImGuiInputFlags_LockUntilRelease. When this is true LockThisFrame is always true as well.
}

func (self KeyOwnerData) handle() (result *C.ImGuiKeyOwnerData, releaseFn func()) {
	result = new(C.ImGuiKeyOwnerData)
	FieldwnerCurr := self.FieldwnerCurr

	result.OwnerCurr = C.ImGuiID(FieldwnerCurr)
	FieldwnerNext := self.FieldwnerNext

	result.OwnerNext = C.ImGuiID(FieldwnerNext)
	FieldockThisFrame := self.FieldockThisFrame

	result.LockThisFrame = C.bool(FieldockThisFrame)
	FieldockUntilRelease := self.FieldockUntilRelease

	result.LockUntilRelease = C.bool(FieldockUntilRelease)
	releaseFn = func() {
	}
	return result, releaseFn
}

func (self KeyOwnerData) c() (result C.ImGuiKeyOwnerData, fin func()) {
	resultPtr, finFn := self.handle()
	return *resultPtr, finFn
}

func newKeyOwnerDataFromC(cvalue *C.ImGuiKeyOwnerData) *KeyOwnerData {
	result := new(KeyOwnerData)
	result.FieldwnerCurr = ID(cvalue.OwnerCurr)
	result.FieldwnerNext = ID(cvalue.OwnerNext)
	result.FieldockThisFrame = cvalue.LockThisFrame == C.bool(true)
	result.FieldockUntilRelease = cvalue.LockUntilRelease == C.bool(true)
	return result
}

// Routing table entry (sizeof() == 16 bytes)
type KeyRoutingData struct {
	// TODO: contains unsupported fields
	data unsafe.Pointer
}

func (self KeyRoutingData) handle() (result *C.ImGuiKeyRoutingData, releaseFn func()) {
	result = (*C.ImGuiKeyRoutingData)(self.data)
	return result, func() {}
}

func (self KeyRoutingData) c() (result C.ImGuiKeyRoutingData, fin func()) {
	resultPtr, finFn := self.handle()
	return *resultPtr, finFn
}

func newKeyRoutingDataFromC(cvalue *C.ImGuiKeyRoutingData) *KeyRoutingData {
	result := new(KeyRoutingData)
	result.data = unsafe.Pointer(cvalue)
	return result
}

// Routing table: maintain a desired owner for each possible key-chord (key + mods), and setup owner in NewFrame() when mods are matching.
// Stored in main context (1 instance)
type KeyRoutingTable struct {
	// TODO: contains unsupported fields
	data unsafe.Pointer
}

func (self KeyRoutingTable) handle() (result *C.ImGuiKeyRoutingTable, releaseFn func()) {
	result = (*C.ImGuiKeyRoutingTable)(self.data)
	return result, func() {}
}

func (self KeyRoutingTable) c() (result C.ImGuiKeyRoutingTable, fin func()) {
	resultPtr, finFn := self.handle()
	return *resultPtr, finFn
}

func newKeyRoutingTableFromC(cvalue *C.ImGuiKeyRoutingTable) *KeyRoutingTable {
	result := new(KeyRoutingTable)
	result.data = unsafe.Pointer(cvalue)
	return result
}

// Status storage for the last submitted item
type LastItemData struct {
	// TODO: contains unsupported fields
	data unsafe.Pointer
}

func (self LastItemData) handle() (result *C.ImGuiLastItemData, releaseFn func()) {
	result = (*C.ImGuiLastItemData)(self.data)
	return result, func() {}
}

func (self LastItemData) c() (result C.ImGuiLastItemData, fin func()) {
	resultPtr, finFn := self.handle()
	return *resultPtr, finFn
}

func newLastItemDataFromC(cvalue *C.ImGuiLastItemData) *LastItemData {
	result := new(LastItemData)
	result.data = unsafe.Pointer(cvalue)
	return result
}

// Helper: Manually clip large list of items.
// If you have lots evenly spaced items and you have random access to the list, you can perform coarse
// clipping based on visibility to only submit items that are in view.
// The clipper calculates the range of visible items and advance the cursor to compensate for the non-visible items we have skipped.
// (Dear ImGui already clip items based on their bounds but: it needs to first layout the item to do so, and generally
//
//	fetching/submitting your own data incurs additional cost. Coarse clipping using ImGuiListClipper allows you to easily
//	scale using lists with tens of thousands of items without a problem)
//
// Usage:
//
//	ImGuiListClipper clipper;
//	clipper.Begin(1000);         // We have 1000 elements, evenly spaced.
//	while (clipper.Step())
//	    for (int i = clipper.DisplayStart; i < clipper.DisplayEnd; i++)
//	        ImGui::Text("line number %d", i);
//
// Generally what happens is:
// - Clipper lets you process the first element (DisplayStart = 0, DisplayEnd = 1) regardless of it being visible or not.
// - User code submit that one element.
// - Clipper can measure the height of the first element
// - Clipper calculate the actual range of elements to display based on the current clipping rectangle, position the cursor before the first visible element.
// - User code submit visible elements.
// - The clipper also handles various subtleties related to keyboard/gamepad navigation, wrapping etc.
type ListClipper struct {
	Fieldtx          *Context       // Parent UI context
	FieldisplayStart int32          // First item to display, updated by each call to Step()
	FieldisplayEnd   int32          // End of items to display (exclusive)
	FieldtemsCount   int32          // [Internal] Number of items
	FieldtemsHeight  float32        // [Internal] Height of item after a first step and item submission can calculate it
	FieldtartPosY    float32        // [Internal] Cursor position at the time of Begin() or after table frozen rows are all processed
	FieldempData     unsafe.Pointer // [Internal] Internal data
}

func (self ListClipper) handle() (result *C.ImGuiListClipper, releaseFn func()) {
	result = new(C.ImGuiListClipper)
	Fieldtx := self.Fieldtx
	FieldtxArg, FieldtxFin := Fieldtx.handle()
	result.Ctx = FieldtxArg
	FieldisplayStart := self.FieldisplayStart

	result.DisplayStart = C.int(FieldisplayStart)
	FieldisplayEnd := self.FieldisplayEnd

	result.DisplayEnd = C.int(FieldisplayEnd)
	FieldtemsCount := self.FieldtemsCount

	result.ItemsCount = C.int(FieldtemsCount)
	FieldtemsHeight := self.FieldtemsHeight

	result.ItemsHeight = C.float(FieldtemsHeight)
	FieldtartPosY := self.FieldtartPosY

	result.StartPosY = C.float(FieldtartPosY)
	FieldempData := self.FieldempData

	result.TempData = (FieldempData)
	releaseFn = func() {
		FieldtxFin()
	}
	return result, releaseFn
}

func (self ListClipper) c() (result C.ImGuiListClipper, fin func()) {
	resultPtr, finFn := self.handle()
	return *resultPtr, finFn
}

func newListClipperFromC(cvalue *C.ImGuiListClipper) *ListClipper {
	result := new(ListClipper)
	result.Fieldtx = newContextFromC(cvalue.Ctx)
	result.FieldisplayStart = int32(cvalue.DisplayStart)
	result.FieldisplayEnd = int32(cvalue.DisplayEnd)
	result.FieldtemsCount = int32(cvalue.ItemsCount)
	result.FieldtemsHeight = float32(cvalue.ItemsHeight)
	result.FieldtartPosY = float32(cvalue.StartPosY)
	result.FieldempData = unsafe.Pointer(cvalue.TempData)
	return result
}

// Temporary clipper data, buffers shared/reused between instances
type ListClipperData struct {
	FieldistClipper     *ListClipper
	FieldossynessOffset float32
	FieldtepNo          int32
	FieldtemsFrozen     int32
	Fieldanges          Vector[*ListClipperRange]
}

func (self ListClipperData) handle() (result *C.ImGuiListClipperData, releaseFn func()) {
	result = new(C.ImGuiListClipperData)
	FieldistClipper := self.FieldistClipper
	FieldistClipperArg, FieldistClipperFin := FieldistClipper.handle()
	result.ListClipper = FieldistClipperArg
	FieldossynessOffset := self.FieldossynessOffset

	result.LossynessOffset = C.float(FieldossynessOffset)
	FieldtepNo := self.FieldtepNo

	result.StepNo = C.int(FieldtepNo)
	FieldtemsFrozen := self.FieldtemsFrozen

	result.ItemsFrozen = C.int(FieldtemsFrozen)
	Fieldanges := self.Fieldanges
	FieldangesData := Fieldanges.Data
	FieldangesDataArg, FieldangesDataFin := FieldangesData.handle()
	FieldangesVecArg := new(C.ImVector_ImGuiListClipperRange)
	FieldangesVecArg.Size = C.int(Fieldanges.Size)
	FieldangesVecArg.Capacity = C.int(Fieldanges.Capacity)
	FieldangesVecArg.Data = FieldangesDataArg

	result.Ranges = *FieldangesVecArg
	releaseFn = func() {
		FieldistClipperFin()

		FieldangesDataFin()
	}
	return result, releaseFn
}

func (self ListClipperData) c() (result C.ImGuiListClipperData, fin func()) {
	resultPtr, finFn := self.handle()
	return *resultPtr, finFn
}

func newListClipperDataFromC(cvalue *C.ImGuiListClipperData) *ListClipperData {
	result := new(ListClipperData)
	result.FieldistClipper = newListClipperFromC(cvalue.ListClipper)
	result.FieldossynessOffset = float32(cvalue.LossynessOffset)
	result.FieldtepNo = int32(cvalue.StepNo)
	result.FieldtemsFrozen = int32(cvalue.ItemsFrozen)
	result.Fieldanges = newVectorFromC(cvalue.Ranges.Size, cvalue.Ranges.Capacity, newListClipperRangeFromC(cvalue.Ranges.Data))
	return result
}

// Note that Max is exclusive, so perhaps should be using a Begin/End convention.
type ListClipperRange struct {
	Fieldin                 int32
	Fieldax                 int32
	FieldosToIndexConvert   bool // Begin/End are absolute position (will be converted to indices later)
	FieldosToIndexOffsetMin int  // Add to Min after converting to indices
	FieldosToIndexOffsetMax int  // Add to Min after converting to indices
}

func (self ListClipperRange) handle() (result *C.ImGuiListClipperRange, releaseFn func()) {
	result = new(C.ImGuiListClipperRange)
	Fieldin := self.Fieldin

	result.Min = C.int(Fieldin)
	Fieldax := self.Fieldax

	result.Max = C.int(Fieldax)
	FieldosToIndexConvert := self.FieldosToIndexConvert

	result.PosToIndexConvert = C.bool(FieldosToIndexConvert)
	FieldosToIndexOffsetMin := self.FieldosToIndexOffsetMin

	result.PosToIndexOffsetMin = C.ImS8(FieldosToIndexOffsetMin)
	FieldosToIndexOffsetMax := self.FieldosToIndexOffsetMax

	result.PosToIndexOffsetMax = C.ImS8(FieldosToIndexOffsetMax)
	releaseFn = func() {
	}
	return result, releaseFn
}

func (self ListClipperRange) c() (result C.ImGuiListClipperRange, fin func()) {
	resultPtr, finFn := self.handle()
	return *resultPtr, finFn
}

func newListClipperRangeFromC(cvalue *C.ImGuiListClipperRange) *ListClipperRange {
	result := new(ListClipperRange)
	result.Fieldin = int32(cvalue.Min)
	result.Fieldax = int32(cvalue.Max)
	result.FieldosToIndexConvert = cvalue.PosToIndexConvert == C.bool(true)
	result.FieldosToIndexOffsetMin = int(cvalue.PosToIndexOffsetMin)
	result.FieldosToIndexOffsetMax = int(cvalue.PosToIndexOffsetMax)
	return result
}

type LocEntry struct {
	// TODO: contains unsupported fields
	data unsafe.Pointer
}

func (self LocEntry) handle() (result *C.ImGuiLocEntry, releaseFn func()) {
	result = (*C.ImGuiLocEntry)(self.data)
	return result, func() {}
}

func (self LocEntry) c() (result C.ImGuiLocEntry, fin func()) {
	resultPtr, finFn := self.handle()
	return *resultPtr, finFn
}

func newLocEntryFromC(cvalue *C.ImGuiLocEntry) *LocEntry {
	result := new(LocEntry)
	result.data = unsafe.Pointer(cvalue)
	return result
}

// Simple column measurement, currently used for MenuItem() only.. This is very short-sighted/throw-away code and NOT a generic helper.
type MenuColumns struct {
	// TODO: contains unsupported fields
	data unsafe.Pointer
}

func (self MenuColumns) handle() (result *C.ImGuiMenuColumns, releaseFn func()) {
	result = (*C.ImGuiMenuColumns)(self.data)
	return result, func() {}
}

func (self MenuColumns) c() (result C.ImGuiMenuColumns, fin func()) {
	resultPtr, finFn := self.handle()
	return *resultPtr, finFn
}

func newMenuColumnsFromC(cvalue *C.ImGuiMenuColumns) *MenuColumns {
	result := new(MenuColumns)
	result.data = unsafe.Pointer(cvalue)
	return result
}

type MetricsConfig struct {
	FieldhowDebugLog                 bool
	FieldhowStackTool                bool
	FieldhowWindowsRects             bool
	FieldhowWindowsBeginOrder        bool
	FieldhowTablesRects              bool
	FieldhowDrawCmdMesh              bool
	FieldhowDrawCmdBoundingBoxes     bool
	FieldhowAtlasTintedWithTextColor bool
	FieldhowDockingNodes             bool
	FieldhowWindowsRectsType         int32
	FieldhowTablesRectsType          int32
}

func (self MetricsConfig) handle() (result *C.ImGuiMetricsConfig, releaseFn func()) {
	result = new(C.ImGuiMetricsConfig)
	FieldhowDebugLog := self.FieldhowDebugLog

	result.ShowDebugLog = C.bool(FieldhowDebugLog)
	FieldhowStackTool := self.FieldhowStackTool

	result.ShowStackTool = C.bool(FieldhowStackTool)
	FieldhowWindowsRects := self.FieldhowWindowsRects

	result.ShowWindowsRects = C.bool(FieldhowWindowsRects)
	FieldhowWindowsBeginOrder := self.FieldhowWindowsBeginOrder

	result.ShowWindowsBeginOrder = C.bool(FieldhowWindowsBeginOrder)
	FieldhowTablesRects := self.FieldhowTablesRects

	result.ShowTablesRects = C.bool(FieldhowTablesRects)
	FieldhowDrawCmdMesh := self.FieldhowDrawCmdMesh

	result.ShowDrawCmdMesh = C.bool(FieldhowDrawCmdMesh)
	FieldhowDrawCmdBoundingBoxes := self.FieldhowDrawCmdBoundingBoxes

	result.ShowDrawCmdBoundingBoxes = C.bool(FieldhowDrawCmdBoundingBoxes)
	FieldhowAtlasTintedWithTextColor := self.FieldhowAtlasTintedWithTextColor

	result.ShowAtlasTintedWithTextColor = C.bool(FieldhowAtlasTintedWithTextColor)
	FieldhowDockingNodes := self.FieldhowDockingNodes

	result.ShowDockingNodes = C.bool(FieldhowDockingNodes)
	FieldhowWindowsRectsType := self.FieldhowWindowsRectsType

	result.ShowWindowsRectsType = C.int(FieldhowWindowsRectsType)
	FieldhowTablesRectsType := self.FieldhowTablesRectsType

	result.ShowTablesRectsType = C.int(FieldhowTablesRectsType)
	releaseFn = func() {
	}
	return result, releaseFn
}

func (self MetricsConfig) c() (result C.ImGuiMetricsConfig, fin func()) {
	resultPtr, finFn := self.handle()
	return *resultPtr, finFn
}

func newMetricsConfigFromC(cvalue *C.ImGuiMetricsConfig) *MetricsConfig {
	result := new(MetricsConfig)
	result.FieldhowDebugLog = cvalue.ShowDebugLog == C.bool(true)
	result.FieldhowStackTool = cvalue.ShowStackTool == C.bool(true)
	result.FieldhowWindowsRects = cvalue.ShowWindowsRects == C.bool(true)
	result.FieldhowWindowsBeginOrder = cvalue.ShowWindowsBeginOrder == C.bool(true)
	result.FieldhowTablesRects = cvalue.ShowTablesRects == C.bool(true)
	result.FieldhowDrawCmdMesh = cvalue.ShowDrawCmdMesh == C.bool(true)
	result.FieldhowDrawCmdBoundingBoxes = cvalue.ShowDrawCmdBoundingBoxes == C.bool(true)
	result.FieldhowAtlasTintedWithTextColor = cvalue.ShowAtlasTintedWithTextColor == C.bool(true)
	result.FieldhowDockingNodes = cvalue.ShowDockingNodes == C.bool(true)
	result.FieldhowWindowsRectsType = int32(cvalue.ShowWindowsRectsType)
	result.FieldhowTablesRectsType = int32(cvalue.ShowTablesRectsType)
	return result
}

type NavItemData struct {
	// TODO: contains unsupported fields
	data unsafe.Pointer
}

func (self NavItemData) handle() (result *C.ImGuiNavItemData, releaseFn func()) {
	result = (*C.ImGuiNavItemData)(self.data)
	return result, func() {}
}

func (self NavItemData) c() (result C.ImGuiNavItemData, fin func()) {
	resultPtr, finFn := self.handle()
	return *resultPtr, finFn
}

func newNavItemDataFromC(cvalue *C.ImGuiNavItemData) *NavItemData {
	result := new(NavItemData)
	result.data = unsafe.Pointer(cvalue)
	return result
}

// Store data emitted by TreeNode() for usage by TreePop() to implement ImGuiTreeNodeFlags_NavLeftJumpsBackHere.
// This is the minimum amount of data that we need to perform the equivalent of NavApplyItemToResult() and which we can't infer in TreePop()
// Only stored when the node is a potential candidate for landing on a Left arrow jump.
type NavTreeNodeData struct {
	// TODO: contains unsupported fields
	data unsafe.Pointer
}

func (self NavTreeNodeData) handle() (result *C.ImGuiNavTreeNodeData, releaseFn func()) {
	result = (*C.ImGuiNavTreeNodeData)(self.data)
	return result, func() {}
}

func (self NavTreeNodeData) c() (result C.ImGuiNavTreeNodeData, fin func()) {
	resultPtr, finFn := self.handle()
	return *resultPtr, finFn
}

func newNavTreeNodeDataFromC(cvalue *C.ImGuiNavTreeNodeData) *NavTreeNodeData {
	result := new(NavTreeNodeData)
	result.data = unsafe.Pointer(cvalue)
	return result
}

type NextItemData struct {
	// TODO: contains unsupported fields
	data unsafe.Pointer
}

func (self NextItemData) handle() (result *C.ImGuiNextItemData, releaseFn func()) {
	result = (*C.ImGuiNextItemData)(self.data)
	return result, func() {}
}

func (self NextItemData) c() (result C.ImGuiNextItemData, fin func()) {
	resultPtr, finFn := self.handle()
	return *resultPtr, finFn
}

func newNextItemDataFromC(cvalue *C.ImGuiNextItemData) *NextItemData {
	result := new(NextItemData)
	result.data = unsafe.Pointer(cvalue)
	return result
}

// Storage for SetNexWindow** functions
type NextWindowData struct {
	// TODO: contains unsupported fields
	data unsafe.Pointer
}

func (self NextWindowData) handle() (result *C.ImGuiNextWindowData, releaseFn func()) {
	result = (*C.ImGuiNextWindowData)(self.data)
	return result, func() {}
}

func (self NextWindowData) c() (result C.ImGuiNextWindowData, fin func()) {
	resultPtr, finFn := self.handle()
	return *resultPtr, finFn
}

func newNextWindowDataFromC(cvalue *C.ImGuiNextWindowData) *NextWindowData {
	result := new(NextWindowData)
	result.data = unsafe.Pointer(cvalue)
	return result
}

type OldColumnData struct {
	// TODO: contains unsupported fields
	data unsafe.Pointer
}

func (self OldColumnData) handle() (result *C.ImGuiOldColumnData, releaseFn func()) {
	result = (*C.ImGuiOldColumnData)(self.data)
	return result, func() {}
}

func (self OldColumnData) c() (result C.ImGuiOldColumnData, fin func()) {
	resultPtr, finFn := self.handle()
	return *resultPtr, finFn
}

func newOldColumnDataFromC(cvalue *C.ImGuiOldColumnData) *OldColumnData {
	result := new(OldColumnData)
	result.data = unsafe.Pointer(cvalue)
	return result
}

type OldColumns struct {
	// TODO: contains unsupported fields
	data unsafe.Pointer
}

func (self OldColumns) handle() (result *C.ImGuiOldColumns, releaseFn func()) {
	result = (*C.ImGuiOldColumns)(self.data)
	return result, func() {}
}

func (self OldColumns) c() (result C.ImGuiOldColumns, fin func()) {
	resultPtr, finFn := self.handle()
	return *resultPtr, finFn
}

func newOldColumnsFromC(cvalue *C.ImGuiOldColumns) *OldColumns {
	result := new(OldColumns)
	result.data = unsafe.Pointer(cvalue)
	return result
}

// Helper: Execute a block of code at maximum once a frame. Convenient if you want to quickly create a UI within deep-nested code that runs multiple times every frame.
// Usage: static ImGuiOnceUponAFrame oaf; if (oaf) ImGui::Text("This will be called only once per frame");
type OnceUponAFrame struct {
	FieldefFrame int32
}

func (self OnceUponAFrame) handle() (result *C.ImGuiOnceUponAFrame, releaseFn func()) {
	result = new(C.ImGuiOnceUponAFrame)
	FieldefFrame := self.FieldefFrame

	result.RefFrame = C.int(FieldefFrame)
	releaseFn = func() {
	}
	return result, releaseFn
}

func (self OnceUponAFrame) c() (result C.ImGuiOnceUponAFrame, fin func()) {
	resultPtr, finFn := self.handle()
	return *resultPtr, finFn
}

func newOnceUponAFrameFromC(cvalue *C.ImGuiOnceUponAFrame) *OnceUponAFrame {
	result := new(OnceUponAFrame)
	result.FieldefFrame = int32(cvalue.RefFrame)
	return result
}

// Data payload for Drag and Drop operations: AcceptDragDropPayload(), GetDragDropPayload()
type Payload struct {
	// TODO: contains unsupported fields
	data unsafe.Pointer
}

func (self Payload) handle() (result *C.ImGuiPayload, releaseFn func()) {
	result = (*C.ImGuiPayload)(self.data)
	return result, func() {}
}

func (self Payload) c() (result C.ImGuiPayload, fin func()) {
	resultPtr, finFn := self.handle()
	return *resultPtr, finFn
}

func newPayloadFromC(cvalue *C.ImGuiPayload) *Payload {
	result := new(Payload)
	result.data = unsafe.Pointer(cvalue)
	return result
}

// (Optional) Access via ImGui::GetPlatformIO()
type PlatformIO struct {
	// TODO: contains unsupported fields
	data unsafe.Pointer
}

func (self PlatformIO) handle() (result *C.ImGuiPlatformIO, releaseFn func()) {
	result = (*C.ImGuiPlatformIO)(self.data)
	return result, func() {}
}

func (self PlatformIO) c() (result C.ImGuiPlatformIO, fin func()) {
	resultPtr, finFn := self.handle()
	return *resultPtr, finFn
}

func newPlatformIOFromC(cvalue *C.ImGuiPlatformIO) *PlatformIO {
	result := new(PlatformIO)
	result.data = unsafe.Pointer(cvalue)
	return result
}

// (Optional) Support for IME (Input Method Editor) via the io.SetPlatformImeDataFn() function.
type PlatformImeData struct {
	FieldantVisible     bool    // A widget wants the IME to be visible
	FieldnputPos        Vec2    // Position of the input cursor
	FieldnputLineHeight float32 // Line height
}

func (self PlatformImeData) handle() (result *C.ImGuiPlatformImeData, releaseFn func()) {
	result = new(C.ImGuiPlatformImeData)
	FieldantVisible := self.FieldantVisible

	result.WantVisible = C.bool(FieldantVisible)
	FieldnputPos := self.FieldnputPos

	result.InputPos = FieldnputPos.toC()
	FieldnputLineHeight := self.FieldnputLineHeight

	result.InputLineHeight = C.float(FieldnputLineHeight)
	releaseFn = func() {
	}
	return result, releaseFn
}

func (self PlatformImeData) c() (result C.ImGuiPlatformImeData, fin func()) {
	resultPtr, finFn := self.handle()
	return *resultPtr, finFn
}

func newPlatformImeDataFromC(cvalue *C.ImGuiPlatformImeData) *PlatformImeData {
	result := new(PlatformImeData)
	result.FieldantVisible = cvalue.WantVisible == C.bool(true)
	result.FieldnputPos = *(&Vec2{}).fromC(cvalue.InputPos)
	result.FieldnputLineHeight = float32(cvalue.InputLineHeight)
	return result
}

// (Optional) This is required when enabling multi-viewport. Represent the bounds of each connected monitor/display and their DPI.
// We use this information for multiple DPI support + clamping the position of popups and tooltips so they don't straddle multiple monitors.
type PlatformMonitor struct {
	FieldainPos        Vec2           // Coordinates of the area displayed on this monitor (Min = upper left, Max = bottom right)
	FieldainSize       Vec2           // Coordinates of the area displayed on this monitor (Min = upper left, Max = bottom right)
	FieldorkPos        Vec2           // Coordinates without task bars / side bars / menu bars. Used to avoid positioning popups/tooltips inside this region. If you don't have this info, please copy the value for MainPos/MainSize.
	FieldorkSize       Vec2           // Coordinates without task bars / side bars / menu bars. Used to avoid positioning popups/tooltips inside this region. If you don't have this info, please copy the value for MainPos/MainSize.
	FieldpiScale       float32        // 1.0f = 96 DPI
	FieldlatformHandle unsafe.Pointer // Backend dependant data (e.g. HMONITOR, GLFWmonitor*, SDL Display Index, NSScreen*)
}

func (self PlatformMonitor) handle() (result *C.ImGuiPlatformMonitor, releaseFn func()) {
	result = new(C.ImGuiPlatformMonitor)
	FieldainPos := self.FieldainPos

	result.MainPos = FieldainPos.toC()
	FieldainSize := self.FieldainSize

	result.MainSize = FieldainSize.toC()
	FieldorkPos := self.FieldorkPos

	result.WorkPos = FieldorkPos.toC()
	FieldorkSize := self.FieldorkSize

	result.WorkSize = FieldorkSize.toC()
	FieldpiScale := self.FieldpiScale

	result.DpiScale = C.float(FieldpiScale)
	FieldlatformHandle := self.FieldlatformHandle

	result.PlatformHandle = (FieldlatformHandle)
	releaseFn = func() {
	}
	return result, releaseFn
}

func (self PlatformMonitor) c() (result C.ImGuiPlatformMonitor, fin func()) {
	resultPtr, finFn := self.handle()
	return *resultPtr, finFn
}

func newPlatformMonitorFromC(cvalue *C.ImGuiPlatformMonitor) *PlatformMonitor {
	result := new(PlatformMonitor)
	result.FieldainPos = *(&Vec2{}).fromC(cvalue.MainPos)
	result.FieldainSize = *(&Vec2{}).fromC(cvalue.MainSize)
	result.FieldorkPos = *(&Vec2{}).fromC(cvalue.WorkPos)
	result.FieldorkSize = *(&Vec2{}).fromC(cvalue.WorkSize)
	result.FieldpiScale = float32(cvalue.DpiScale)
	result.FieldlatformHandle = unsafe.Pointer(cvalue.PlatformHandle)
	return result
}

// Storage for current popup stack
type PopupData struct {
	FieldopupId         ID      // Set on OpenPopup()
	Fieldindow          *Window // Resolved on BeginPopup() - may stay unresolved if user never calls OpenPopup()
	FieldackupNavWindow *Window // Set on OpenPopup(), a NavWindow that will be restored on popup close
	FieldarentNavLayer  int32   // Resolved on BeginPopup(). Actually a ImGuiNavLayer type (declared down below), initialized to -1 which is not part of an enum, but serves well-enough as "not any of layers" value
	FieldpenFrameCount  int32   // Set on OpenPopup()
	FieldpenParentId    ID      // Set on OpenPopup(), we need this to differentiate multiple menu sets from each others (e.g. inside menu bar vs loose menu items)
	FieldpenPopupPos    Vec2    // Set on OpenPopup(), preferred popup position (typically == OpenMousePos when using mouse)
	FieldpenMousePos    Vec2    // Set on OpenPopup(), copy of mouse position at the time of opening popup
}

func (self PopupData) handle() (result *C.ImGuiPopupData, releaseFn func()) {
	result = new(C.ImGuiPopupData)
	FieldopupId := self.FieldopupId

	result.PopupId = C.ImGuiID(FieldopupId)
	Fieldindow := self.Fieldindow
	FieldindowArg, FieldindowFin := Fieldindow.handle()
	result.Window = FieldindowArg
	FieldackupNavWindow := self.FieldackupNavWindow
	FieldackupNavWindowArg, FieldackupNavWindowFin := FieldackupNavWindow.handle()
	result.BackupNavWindow = FieldackupNavWindowArg
	FieldarentNavLayer := self.FieldarentNavLayer

	result.ParentNavLayer = C.int(FieldarentNavLayer)
	FieldpenFrameCount := self.FieldpenFrameCount

	result.OpenFrameCount = C.int(FieldpenFrameCount)
	FieldpenParentId := self.FieldpenParentId

	result.OpenParentId = C.ImGuiID(FieldpenParentId)
	FieldpenPopupPos := self.FieldpenPopupPos

	result.OpenPopupPos = FieldpenPopupPos.toC()
	FieldpenMousePos := self.FieldpenMousePos

	result.OpenMousePos = FieldpenMousePos.toC()
	releaseFn = func() {
		FieldindowFin()
		FieldackupNavWindowFin()
	}
	return result, releaseFn
}

func (self PopupData) c() (result C.ImGuiPopupData, fin func()) {
	resultPtr, finFn := self.handle()
	return *resultPtr, finFn
}

func newPopupDataFromC(cvalue *C.ImGuiPopupData) *PopupData {
	result := new(PopupData)
	result.FieldopupId = ID(cvalue.PopupId)
	result.Fieldindow = newWindowFromC(cvalue.Window)
	result.FieldackupNavWindow = newWindowFromC(cvalue.BackupNavWindow)
	result.FieldarentNavLayer = int32(cvalue.ParentNavLayer)
	result.FieldpenFrameCount = int32(cvalue.OpenFrameCount)
	result.FieldpenParentId = ID(cvalue.OpenParentId)
	result.FieldpenPopupPos = *(&Vec2{}).fromC(cvalue.OpenPopupPos)
	result.FieldpenMousePos = *(&Vec2{}).fromC(cvalue.OpenMousePos)
	return result
}

type PtrOrIndex struct {
	Fieldtr   unsafe.Pointer // Either field can be set, not both. e.g. Dock node tab bars are loose while BeginTabBar() ones are in a pool.
	Fieldndex int32          // Usually index in a main pool.
}

func (self PtrOrIndex) handle() (result *C.ImGuiPtrOrIndex, releaseFn func()) {
	result = new(C.ImGuiPtrOrIndex)
	Fieldtr := self.Fieldtr

	result.Ptr = (Fieldtr)
	Fieldndex := self.Fieldndex

	result.Index = C.int(Fieldndex)
	releaseFn = func() {
	}
	return result, releaseFn
}

func (self PtrOrIndex) c() (result C.ImGuiPtrOrIndex, fin func()) {
	resultPtr, finFn := self.handle()
	return *resultPtr, finFn
}

func newPtrOrIndexFromC(cvalue *C.ImGuiPtrOrIndex) *PtrOrIndex {
	result := new(PtrOrIndex)
	result.Fieldtr = unsafe.Pointer(cvalue.Ptr)
	result.Fieldndex = int32(cvalue.Index)
	return result
}

type SettingsHandler struct {
	// TODO: contains unsupported fields
	data unsafe.Pointer
}

func (self SettingsHandler) handle() (result *C.ImGuiSettingsHandler, releaseFn func()) {
	result = (*C.ImGuiSettingsHandler)(self.data)
	return result, func() {}
}

func (self SettingsHandler) c() (result C.ImGuiSettingsHandler, fin func()) {
	resultPtr, finFn := self.handle()
	return *resultPtr, finFn
}

func newSettingsHandlerFromC(cvalue *C.ImGuiSettingsHandler) *SettingsHandler {
	result := new(SettingsHandler)
	result.data = unsafe.Pointer(cvalue)
	return result
}

type ShrinkWidthItem struct {
	Fieldndex        int32
	Fieldidth        float32
	FieldnitialWidth float32
}

func (self ShrinkWidthItem) handle() (result *C.ImGuiShrinkWidthItem, releaseFn func()) {
	result = new(C.ImGuiShrinkWidthItem)
	Fieldndex := self.Fieldndex

	result.Index = C.int(Fieldndex)
	Fieldidth := self.Fieldidth

	result.Width = C.float(Fieldidth)
	FieldnitialWidth := self.FieldnitialWidth

	result.InitialWidth = C.float(FieldnitialWidth)
	releaseFn = func() {
	}
	return result, releaseFn
}

func (self ShrinkWidthItem) c() (result C.ImGuiShrinkWidthItem, fin func()) {
	resultPtr, finFn := self.handle()
	return *resultPtr, finFn
}

func newShrinkWidthItemFromC(cvalue *C.ImGuiShrinkWidthItem) *ShrinkWidthItem {
	result := new(ShrinkWidthItem)
	result.Fieldndex = int32(cvalue.Index)
	result.Fieldidth = float32(cvalue.Width)
	result.FieldnitialWidth = float32(cvalue.InitialWidth)
	return result
}

// Resizing callback data to apply custom constraint. As enabled by SetNextWindowSizeConstraints(). Callback is called during the next Begin().
// NB: For basic min/max size constraint on each axis you don't need to use the callback! The SetNextWindowSizeConstraints() parameters are enough.
type SizeCallbackData struct {
	FieldserData    unsafe.Pointer // Read-only.   What user passed to SetNextWindowSizeConstraints(). Generally store an integer or float in here (need reinterpret_cast<>).
	Fieldos         Vec2           // Read-only.   Window position, for reference.
	FieldurrentSize Vec2           // Read-only.   Current window size.
	FieldesiredSize Vec2           // Read-write.  Desired size, based on user's mouse position. Write to this field to restrain resizing.
}

func (self SizeCallbackData) handle() (result *C.ImGuiSizeCallbackData, releaseFn func()) {
	result = new(C.ImGuiSizeCallbackData)
	FieldserData := self.FieldserData

	result.UserData = (FieldserData)
	Fieldos := self.Fieldos

	result.Pos = Fieldos.toC()
	FieldurrentSize := self.FieldurrentSize

	result.CurrentSize = FieldurrentSize.toC()
	FieldesiredSize := self.FieldesiredSize

	result.DesiredSize = FieldesiredSize.toC()
	releaseFn = func() {
	}
	return result, releaseFn
}

func (self SizeCallbackData) c() (result C.ImGuiSizeCallbackData, fin func()) {
	resultPtr, finFn := self.handle()
	return *resultPtr, finFn
}

func newSizeCallbackDataFromC(cvalue *C.ImGuiSizeCallbackData) *SizeCallbackData {
	result := new(SizeCallbackData)
	result.FieldserData = unsafe.Pointer(cvalue.UserData)
	result.Fieldos = *(&Vec2{}).fromC(cvalue.Pos)
	result.FieldurrentSize = *(&Vec2{}).fromC(cvalue.CurrentSize)
	result.FieldesiredSize = *(&Vec2{}).fromC(cvalue.DesiredSize)
	return result
}

type StackLevelInfo struct {
	// TODO: contains unsupported fields
	data unsafe.Pointer
}

func (self StackLevelInfo) handle() (result *C.ImGuiStackLevelInfo, releaseFn func()) {
	result = (*C.ImGuiStackLevelInfo)(self.data)
	return result, func() {}
}

func (self StackLevelInfo) c() (result C.ImGuiStackLevelInfo, fin func()) {
	resultPtr, finFn := self.handle()
	return *resultPtr, finFn
}

func newStackLevelInfoFromC(cvalue *C.ImGuiStackLevelInfo) *StackLevelInfo {
	result := new(StackLevelInfo)
	result.data = unsafe.Pointer(cvalue)
	return result
}

type StackSizes struct {
	FieldizeOfIDStack         int
	FieldizeOfColorStack      int
	FieldizeOfStyleVarStack   int
	FieldizeOfFontStack       int
	FieldizeOfFocusScopeStack int
	FieldizeOfGroupStack      int
	FieldizeOfItemFlagsStack  int
	FieldizeOfBeginPopupStack int
	FieldizeOfDisabledStack   int
}

func (self StackSizes) handle() (result *C.ImGuiStackSizes, releaseFn func()) {
	result = new(C.ImGuiStackSizes)
	FieldizeOfIDStack := self.FieldizeOfIDStack

	result.SizeOfIDStack = C.short(FieldizeOfIDStack)
	FieldizeOfColorStack := self.FieldizeOfColorStack

	result.SizeOfColorStack = C.short(FieldizeOfColorStack)
	FieldizeOfStyleVarStack := self.FieldizeOfStyleVarStack

	result.SizeOfStyleVarStack = C.short(FieldizeOfStyleVarStack)
	FieldizeOfFontStack := self.FieldizeOfFontStack

	result.SizeOfFontStack = C.short(FieldizeOfFontStack)
	FieldizeOfFocusScopeStack := self.FieldizeOfFocusScopeStack

	result.SizeOfFocusScopeStack = C.short(FieldizeOfFocusScopeStack)
	FieldizeOfGroupStack := self.FieldizeOfGroupStack

	result.SizeOfGroupStack = C.short(FieldizeOfGroupStack)
	FieldizeOfItemFlagsStack := self.FieldizeOfItemFlagsStack

	result.SizeOfItemFlagsStack = C.short(FieldizeOfItemFlagsStack)
	FieldizeOfBeginPopupStack := self.FieldizeOfBeginPopupStack

	result.SizeOfBeginPopupStack = C.short(FieldizeOfBeginPopupStack)
	FieldizeOfDisabledStack := self.FieldizeOfDisabledStack

	result.SizeOfDisabledStack = C.short(FieldizeOfDisabledStack)
	releaseFn = func() {
	}
	return result, releaseFn
}

func (self StackSizes) c() (result C.ImGuiStackSizes, fin func()) {
	resultPtr, finFn := self.handle()
	return *resultPtr, finFn
}

func newStackSizesFromC(cvalue *C.ImGuiStackSizes) *StackSizes {
	result := new(StackSizes)
	result.FieldizeOfIDStack = int(cvalue.SizeOfIDStack)
	result.FieldizeOfColorStack = int(cvalue.SizeOfColorStack)
	result.FieldizeOfStyleVarStack = int(cvalue.SizeOfStyleVarStack)
	result.FieldizeOfFontStack = int(cvalue.SizeOfFontStack)
	result.FieldizeOfFocusScopeStack = int(cvalue.SizeOfFocusScopeStack)
	result.FieldizeOfGroupStack = int(cvalue.SizeOfGroupStack)
	result.FieldizeOfItemFlagsStack = int(cvalue.SizeOfItemFlagsStack)
	result.FieldizeOfBeginPopupStack = int(cvalue.SizeOfBeginPopupStack)
	result.FieldizeOfDisabledStack = int(cvalue.SizeOfDisabledStack)
	return result
}

// State for Stack tool queries
type StackTool struct {
	FieldastActiveFrame         int32
	FieldtackLevel              int32 // -1: query stack and resize Results, >= 0: individual stack level
	FieldueryId                 ID    // ID to query details for
	Fieldesults                 Vector[*StackLevelInfo]
	FieldopyToClipboardOnCtrlC  bool
	FieldopyToClipboardLastTime float32
}

func (self StackTool) handle() (result *C.ImGuiStackTool, releaseFn func()) {
	result = new(C.ImGuiStackTool)
	FieldastActiveFrame := self.FieldastActiveFrame

	result.LastActiveFrame = C.int(FieldastActiveFrame)
	FieldtackLevel := self.FieldtackLevel

	result.StackLevel = C.int(FieldtackLevel)
	FieldueryId := self.FieldueryId

	result.QueryId = C.ImGuiID(FieldueryId)
	Fieldesults := self.Fieldesults
	FieldesultsData := Fieldesults.Data
	FieldesultsDataArg, FieldesultsDataFin := FieldesultsData.handle()
	FieldesultsVecArg := new(C.ImVector_ImGuiStackLevelInfo)
	FieldesultsVecArg.Size = C.int(Fieldesults.Size)
	FieldesultsVecArg.Capacity = C.int(Fieldesults.Capacity)
	FieldesultsVecArg.Data = FieldesultsDataArg

	result.Results = *FieldesultsVecArg
	FieldopyToClipboardOnCtrlC := self.FieldopyToClipboardOnCtrlC

	result.CopyToClipboardOnCtrlC = C.bool(FieldopyToClipboardOnCtrlC)
	FieldopyToClipboardLastTime := self.FieldopyToClipboardLastTime

	result.CopyToClipboardLastTime = C.float(FieldopyToClipboardLastTime)
	releaseFn = func() {
		FieldesultsDataFin()
	}
	return result, releaseFn
}

func (self StackTool) c() (result C.ImGuiStackTool, fin func()) {
	resultPtr, finFn := self.handle()
	return *resultPtr, finFn
}

func newStackToolFromC(cvalue *C.ImGuiStackTool) *StackTool {
	result := new(StackTool)
	result.FieldastActiveFrame = int32(cvalue.LastActiveFrame)
	result.FieldtackLevel = int32(cvalue.StackLevel)
	result.FieldueryId = ID(cvalue.QueryId)
	result.Fieldesults = newVectorFromC(cvalue.Results.Size, cvalue.Results.Capacity, newStackLevelInfoFromC(cvalue.Results.Data))
	result.FieldopyToClipboardOnCtrlC = cvalue.CopyToClipboardOnCtrlC == C.bool(true)
	result.FieldopyToClipboardLastTime = float32(cvalue.CopyToClipboardLastTime)
	return result
}

// Helper: Key->Value storage
// Typically you don't have to worry about this since a storage is held within each Window.
// We use it to e.g. store collapse state for a tree (Int 0/1)
// This is optimized for efficient lookup (dichotomy into a contiguous buffer) and rare insertion (typically tied to user interactions aka max once a frame)
// You can use it as custom user storage for temporary values. Declare your own storage if, for example:
// - You want to manipulate the open/close state of a particular sub-tree in your interface (tree node uses Int 0/1 to store their state).
// - You want to store custom debug data easily without adding or editing structures in your code (probably not efficient, but convenient)
// Types are NOT stored, so it is up to you to make sure your Key don't collide with different types.
type Storage struct {
	Fieldata Vector[*StoragePair]
}

func (self Storage) handle() (result *C.ImGuiStorage, releaseFn func()) {
	result = new(C.ImGuiStorage)
	Fieldata := self.Fieldata
	FieldataData := Fieldata.Data
	FieldataDataArg, FieldataDataFin := FieldataData.handle()
	FieldataVecArg := new(C.ImVector_ImGuiStoragePair)
	FieldataVecArg.Size = C.int(Fieldata.Size)
	FieldataVecArg.Capacity = C.int(Fieldata.Capacity)
	FieldataVecArg.Data = FieldataDataArg

	result.Data = *FieldataVecArg
	releaseFn = func() {
		FieldataDataFin()
	}
	return result, releaseFn
}

func (self Storage) c() (result C.ImGuiStorage, fin func()) {
	resultPtr, finFn := self.handle()
	return *resultPtr, finFn
}

func newStorageFromC(cvalue *C.ImGuiStorage) *Storage {
	result := new(Storage)
	result.Fieldata = newVectorFromC(cvalue.Data.Size, cvalue.Data.Capacity, newStoragePairFromC(cvalue.Data.Data))
	return result
}

// [Internal]
type StoragePair struct {
	// TODO: contains unsupported fields
	data unsafe.Pointer
}

func (self StoragePair) handle() (result *C.ImGuiStoragePair, releaseFn func()) {
	result = (*C.ImGuiStoragePair)(self.data)
	return result, func() {}
}

func (self StoragePair) c() (result C.ImGuiStoragePair, fin func()) {
	resultPtr, finFn := self.handle()
	return *resultPtr, finFn
}

func newStoragePairFromC(cvalue *C.ImGuiStoragePair) *StoragePair {
	result := new(StoragePair)
	result.data = unsafe.Pointer(cvalue)
	return result
}

type Style struct {
	// TODO: contains unsupported fields
	data unsafe.Pointer
}

func (self Style) handle() (result *C.ImGuiStyle, releaseFn func()) {
	result = (*C.ImGuiStyle)(self.data)
	return result, func() {}
}

func (self Style) c() (result C.ImGuiStyle, fin func()) {
	resultPtr, finFn := self.handle()
	return *resultPtr, finFn
}

func newStyleFromC(cvalue *C.ImGuiStyle) *Style {
	result := new(Style)
	result.data = unsafe.Pointer(cvalue)
	return result
}

// Stacked style modifier, backup of modified data so we can restore it. Data type inferred from the variable.
type StyleMod struct {
	// TODO: contains unsupported fields
	data unsafe.Pointer
}

func (self StyleMod) handle() (result *C.ImGuiStyleMod, releaseFn func()) {
	result = (*C.ImGuiStyleMod)(self.data)
	return result, func() {}
}

func (self StyleMod) c() (result C.ImGuiStyleMod, fin func()) {
	resultPtr, finFn := self.handle()
	return *resultPtr, finFn
}

func newStyleModFromC(cvalue *C.ImGuiStyleMod) *StyleMod {
	result := new(StyleMod)
	result.data = unsafe.Pointer(cvalue)
	return result
}

// Storage for a tab bar (sizeof() 152 bytes)
type TabBar struct {
	// TODO: contains unsupported fields
	data unsafe.Pointer
}

func (self TabBar) handle() (result *C.ImGuiTabBar, releaseFn func()) {
	result = (*C.ImGuiTabBar)(self.data)
	return result, func() {}
}

func (self TabBar) c() (result C.ImGuiTabBar, fin func()) {
	resultPtr, finFn := self.handle()
	return *resultPtr, finFn
}

func newTabBarFromC(cvalue *C.ImGuiTabBar) *TabBar {
	result := new(TabBar)
	result.data = unsafe.Pointer(cvalue)
	return result
}

// Storage for one active tab item (sizeof() 48 bytes)
type TabItem struct {
	// TODO: contains unsupported fields
	data unsafe.Pointer
}

func (self TabItem) handle() (result *C.ImGuiTabItem, releaseFn func()) {
	result = (*C.ImGuiTabItem)(self.data)
	return result, func() {}
}

func (self TabItem) c() (result C.ImGuiTabItem, fin func()) {
	resultPtr, finFn := self.handle()
	return *resultPtr, finFn
}

func newTabItemFromC(cvalue *C.ImGuiTabItem) *TabItem {
	result := new(TabItem)
	result.data = unsafe.Pointer(cvalue)
	return result
}

// FIXME-TABLE: more transient data could be stored in a stacked ImGuiTableTempData: e.g. SortSpecs, incoming RowData
// sizeof() ~ 580 bytes + heap allocs described in TableBeginInitMemory()
type Table struct {
	// TODO: contains unsupported fields
	data unsafe.Pointer
}

func (self Table) handle() (result *C.ImGuiTable, releaseFn func()) {
	result = (*C.ImGuiTable)(self.data)
	return result, func() {}
}

func (self Table) c() (result C.ImGuiTable, fin func()) {
	resultPtr, finFn := self.handle()
	return *resultPtr, finFn
}

func newTableFromC(cvalue *C.ImGuiTable) *Table {
	result := new(Table)
	result.data = unsafe.Pointer(cvalue)
	return result
}

// Transient cell data stored per row.
// sizeof() ~ 6
type TableCellData struct {
	FieldgColor uint32         // Actual color
	Fieldolumn  TableColumnIdx // Column number
}

func (self TableCellData) handle() (result *C.ImGuiTableCellData, releaseFn func()) {
	result = new(C.ImGuiTableCellData)
	FieldgColor := self.FieldgColor

	result.BgColor = C.ImU32(FieldgColor)
	Fieldolumn := self.Fieldolumn

	result.Column = C.ImGuiTableColumnIdx(Fieldolumn)
	releaseFn = func() {
	}
	return result, releaseFn
}

func (self TableCellData) c() (result C.ImGuiTableCellData, fin func()) {
	resultPtr, finFn := self.handle()
	return *resultPtr, finFn
}

func newTableCellDataFromC(cvalue *C.ImGuiTableCellData) *TableCellData {
	result := new(TableCellData)
	result.FieldgColor = uint32(cvalue.BgColor)
	result.Fieldolumn = TableColumnIdx(cvalue.Column)
	return result
}

// [Internal] sizeof() ~ 112
// We use the terminology "Enabled" to refer to a column that is not Hidden by user/api.
// We use the terminology "Clipped" to refer to a column that is out of sight because of scrolling/clipping.
// This is in contrast with some user-facing api such as IsItemVisible() / IsRectVisible() which use "Visible" to mean "not clipped".
type TableColumn struct {
	// TODO: contains unsupported fields
	data unsafe.Pointer
}

func (self TableColumn) handle() (result *C.ImGuiTableColumn, releaseFn func()) {
	result = (*C.ImGuiTableColumn)(self.data)
	return result, func() {}
}

func (self TableColumn) c() (result C.ImGuiTableColumn, fin func()) {
	resultPtr, finFn := self.handle()
	return *resultPtr, finFn
}

func newTableColumnFromC(cvalue *C.ImGuiTableColumn) *TableColumn {
	result := new(TableColumn)
	result.data = unsafe.Pointer(cvalue)
	return result
}

// sizeof() ~ 12
type TableColumnSettings struct {
	// TODO: contains unsupported fields
	data unsafe.Pointer
}

func (self TableColumnSettings) handle() (result *C.ImGuiTableColumnSettings, releaseFn func()) {
	result = (*C.ImGuiTableColumnSettings)(self.data)
	return result, func() {}
}

func (self TableColumnSettings) c() (result C.ImGuiTableColumnSettings, fin func()) {
	resultPtr, finFn := self.handle()
	return *resultPtr, finFn
}

func newTableColumnSettingsFromC(cvalue *C.ImGuiTableColumnSettings) *TableColumnSettings {
	result := new(TableColumnSettings)
	result.data = unsafe.Pointer(cvalue)
	return result
}

// Sorting specification for one column of a table (sizeof == 12 bytes)
type TableColumnSortSpecs struct {
	// TODO: contains unsupported fields
	data unsafe.Pointer
}

func (self TableColumnSortSpecs) handle() (result *C.ImGuiTableColumnSortSpecs, releaseFn func()) {
	result = (*C.ImGuiTableColumnSortSpecs)(self.data)
	return result, func() {}
}

func (self TableColumnSortSpecs) c() (result C.ImGuiTableColumnSortSpecs, fin func()) {
	resultPtr, finFn := self.handle()
	return *resultPtr, finFn
}

func newTableColumnSortSpecsFromC(cvalue *C.ImGuiTableColumnSortSpecs) *TableColumnSortSpecs {
	result := new(TableColumnSortSpecs)
	result.data = unsafe.Pointer(cvalue)
	return result
}

// Per-instance data that needs preserving across frames (seemingly most others do not need to be preserved aside from debug needs. Does that means they could be moved to ImGuiTableTempData?)
type TableInstanceData struct {
	FieldableInstanceID    ID
	FieldastOuterHeight    float32 // Outer height from last frame
	FieldastFirstRowHeight float32 // Height of first row from last frame (FIXME: this is used as "header height" and may be reworked)
	FieldastFrozenHeight   float32 // Height of frozen section from last frame
	FieldoveredRowLast     int32   // Index of row which was hovered last frame.
	FieldoveredRowNext     int32   // Index of row hovered this frame, set after encountering it.
}

func (self TableInstanceData) handle() (result *C.ImGuiTableInstanceData, releaseFn func()) {
	result = new(C.ImGuiTableInstanceData)
	FieldableInstanceID := self.FieldableInstanceID

	result.TableInstanceID = C.ImGuiID(FieldableInstanceID)
	FieldastOuterHeight := self.FieldastOuterHeight

	result.LastOuterHeight = C.float(FieldastOuterHeight)
	FieldastFirstRowHeight := self.FieldastFirstRowHeight

	result.LastFirstRowHeight = C.float(FieldastFirstRowHeight)
	FieldastFrozenHeight := self.FieldastFrozenHeight

	result.LastFrozenHeight = C.float(FieldastFrozenHeight)
	FieldoveredRowLast := self.FieldoveredRowLast

	result.HoveredRowLast = C.int(FieldoveredRowLast)
	FieldoveredRowNext := self.FieldoveredRowNext

	result.HoveredRowNext = C.int(FieldoveredRowNext)
	releaseFn = func() {
	}
	return result, releaseFn
}

func (self TableInstanceData) c() (result C.ImGuiTableInstanceData, fin func()) {
	resultPtr, finFn := self.handle()
	return *resultPtr, finFn
}

func newTableInstanceDataFromC(cvalue *C.ImGuiTableInstanceData) *TableInstanceData {
	result := new(TableInstanceData)
	result.FieldableInstanceID = ID(cvalue.TableInstanceID)
	result.FieldastOuterHeight = float32(cvalue.LastOuterHeight)
	result.FieldastFirstRowHeight = float32(cvalue.LastFirstRowHeight)
	result.FieldastFrozenHeight = float32(cvalue.LastFrozenHeight)
	result.FieldoveredRowLast = int32(cvalue.HoveredRowLast)
	result.FieldoveredRowNext = int32(cvalue.HoveredRowNext)
	return result
}

// This is designed to be stored in a single ImChunkStream (1 header followed by N ImGuiTableColumnSettings, etc.)
type TableSettings struct {
	// TODO: contains unsupported fields
	data unsafe.Pointer
}

func (self TableSettings) handle() (result *C.ImGuiTableSettings, releaseFn func()) {
	result = (*C.ImGuiTableSettings)(self.data)
	return result, func() {}
}

func (self TableSettings) c() (result C.ImGuiTableSettings, fin func()) {
	resultPtr, finFn := self.handle()
	return *resultPtr, finFn
}

func newTableSettingsFromC(cvalue *C.ImGuiTableSettings) *TableSettings {
	result := new(TableSettings)
	result.data = unsafe.Pointer(cvalue)
	return result
}

// Sorting specifications for a table (often handling sort specs for a single column, occasionally more)
// Obtained by calling TableGetSortSpecs().
// When 'SpecsDirty == true' you can sort your data. It will be true with sorting specs have changed since last call, or the first time.
// Make sure to set 'SpecsDirty = false' after sorting, else you may wastefully sort your data every frame!
type TableSortSpecs struct {
	Fieldpecs      *TableColumnSortSpecs // Pointer to sort spec array.
	FieldpecsCount int32                 // Sort spec count. Most often 1. May be > 1 when ImGuiTableFlags_SortMulti is enabled. May be == 0 when ImGuiTableFlags_SortTristate is enabled.
	FieldpecsDirty bool                  // Set to true when specs have changed since last time! Use this to sort again, then clear the flag.
}

func (self TableSortSpecs) handle() (result *C.ImGuiTableSortSpecs, releaseFn func()) {
	result = new(C.ImGuiTableSortSpecs)
	Fieldpecs := self.Fieldpecs
	FieldpecsArg, FieldpecsFin := Fieldpecs.handle()
	result.Specs = FieldpecsArg
	FieldpecsCount := self.FieldpecsCount

	result.SpecsCount = C.int(FieldpecsCount)
	FieldpecsDirty := self.FieldpecsDirty

	result.SpecsDirty = C.bool(FieldpecsDirty)
	releaseFn = func() {
		FieldpecsFin()
	}
	return result, releaseFn
}

func (self TableSortSpecs) c() (result C.ImGuiTableSortSpecs, fin func()) {
	resultPtr, finFn := self.handle()
	return *resultPtr, finFn
}

func newTableSortSpecsFromC(cvalue *C.ImGuiTableSortSpecs) *TableSortSpecs {
	result := new(TableSortSpecs)
	result.Fieldpecs = newTableColumnSortSpecsFromC(cvalue.Specs)
	result.FieldpecsCount = int32(cvalue.SpecsCount)
	result.FieldpecsDirty = cvalue.SpecsDirty == C.bool(true)
	return result
}

// Transient data that are only needed between BeginTable() and EndTable(), those buffers are shared (1 per level of stacked table).
// - Accessing those requires chasing an extra pointer so for very frequently used data we leave them in the main table structure.
// - We also leave out of this structure data that tend to be particularly useful for debugging/metrics.
// sizeof() ~ 112 bytes.
type TableTempData struct {
	FieldableIndex                   int32   // Index in g.Tables.Buf[] pool
	FieldastTimeActive               float32 // Last timestamp this structure was used
	FieldserOuterSize                Vec2    // outer_size.x passed to BeginTable()
	FieldrawSplitter                 DrawListSplitter
	FieldostBackupWorkRect           Rect    // Backup of InnerWindow->WorkRect at the end of BeginTable()
	FieldostBackupParentWorkRect     Rect    // Backup of InnerWindow->ParentWorkRect at the end of BeginTable()
	FieldostBackupPrevLineSize       Vec2    // Backup of InnerWindow->DC.PrevLineSize at the end of BeginTable()
	FieldostBackupCurrLineSize       Vec2    // Backup of InnerWindow->DC.CurrLineSize at the end of BeginTable()
	FieldostBackupCursorMaxPos       Vec2    // Backup of InnerWindow->DC.CursorMaxPos at the end of BeginTable()
	FieldostBackupColumnsOffset      Vec1    // Backup of OuterWindow->DC.ColumnsOffset at the end of BeginTable()
	FieldostBackupItemWidth          float32 // Backup of OuterWindow->DC.ItemWidth at the end of BeginTable()
	FieldostBackupItemWidthStackSize int32   // Backup of OuterWindow->DC.ItemWidthStack.Size at the end of BeginTable()

}

func (self TableTempData) handle() (result *C.ImGuiTableTempData, releaseFn func()) {
	result = new(C.ImGuiTableTempData)
	FieldableIndex := self.FieldableIndex

	result.TableIndex = C.int(FieldableIndex)
	FieldastTimeActive := self.FieldastTimeActive

	result.LastTimeActive = C.float(FieldastTimeActive)
	FieldserOuterSize := self.FieldserOuterSize

	result.UserOuterSize = FieldserOuterSize.toC()
	FieldrawSplitter := self.FieldrawSplitter
	FieldrawSplitterArg, FieldrawSplitterFin := FieldrawSplitter.c()
	result.DrawSplitter = FieldrawSplitterArg
	FieldostBackupWorkRect := self.FieldostBackupWorkRect

	result.HostBackupWorkRect = FieldostBackupWorkRect.toC()
	FieldostBackupParentWorkRect := self.FieldostBackupParentWorkRect

	result.HostBackupParentWorkRect = FieldostBackupParentWorkRect.toC()
	FieldostBackupPrevLineSize := self.FieldostBackupPrevLineSize

	result.HostBackupPrevLineSize = FieldostBackupPrevLineSize.toC()
	FieldostBackupCurrLineSize := self.FieldostBackupCurrLineSize

	result.HostBackupCurrLineSize = FieldostBackupCurrLineSize.toC()
	FieldostBackupCursorMaxPos := self.FieldostBackupCursorMaxPos

	result.HostBackupCursorMaxPos = FieldostBackupCursorMaxPos.toC()
	FieldostBackupColumnsOffset := self.FieldostBackupColumnsOffset
	FieldostBackupColumnsOffsetArg, FieldostBackupColumnsOffsetFin := FieldostBackupColumnsOffset.c()
	result.HostBackupColumnsOffset = FieldostBackupColumnsOffsetArg
	FieldostBackupItemWidth := self.FieldostBackupItemWidth

	result.HostBackupItemWidth = C.float(FieldostBackupItemWidth)
	FieldostBackupItemWidthStackSize := self.FieldostBackupItemWidthStackSize

	result.HostBackupItemWidthStackSize = C.int(FieldostBackupItemWidthStackSize)
	releaseFn = func() {
		FieldrawSplitterFin()

		FieldostBackupColumnsOffsetFin()
	}
	return result, releaseFn
}

func (self TableTempData) c() (result C.ImGuiTableTempData, fin func()) {
	resultPtr, finFn := self.handle()
	return *resultPtr, finFn
}

func newTableTempDataFromC(cvalue *C.ImGuiTableTempData) *TableTempData {
	result := new(TableTempData)
	result.FieldableIndex = int32(cvalue.TableIndex)
	result.FieldastTimeActive = float32(cvalue.LastTimeActive)
	result.FieldserOuterSize = *(&Vec2{}).fromC(cvalue.UserOuterSize)
	result.FieldrawSplitter = *newDrawListSplitterFromC(cvalue.DrawSplitter)

	result.FieldostBackupWorkRect = *(&Rect{}).fromC(cvalue.HostBackupWorkRect)
	result.FieldostBackupParentWorkRect = *(&Rect{}).fromC(cvalue.HostBackupParentWorkRect)
	result.FieldostBackupPrevLineSize = *(&Vec2{}).fromC(cvalue.HostBackupPrevLineSize)
	result.FieldostBackupCurrLineSize = *(&Vec2{}).fromC(cvalue.HostBackupCurrLineSize)
	result.FieldostBackupCursorMaxPos = *(&Vec2{}).fromC(cvalue.HostBackupCursorMaxPos)
	result.FieldostBackupColumnsOffset = *newVec1FromC(cvalue.HostBackupColumnsOffset)

	result.FieldostBackupItemWidth = float32(cvalue.HostBackupItemWidth)
	result.FieldostBackupItemWidthStackSize = int32(cvalue.HostBackupItemWidthStackSize)
	return result
}

// Helper: Growable text buffer for logging/accumulating text
// (this could be called 'ImGuiTextBuilder' / 'ImGuiStringBuilder')
type TextBuffer struct {
	Fielduf Vector[string]
}

func (self TextBuffer) handle() (result *C.ImGuiTextBuffer, releaseFn func()) {
	result = new(C.ImGuiTextBuffer)
	Fielduf := self.Fielduf
	FieldufData := Fielduf.Data
	FieldufDataArg, FieldufDataFin := WrapString(FieldufData)
	FieldufVecArg := new(C.ImVector_char)
	FieldufVecArg.Size = C.int(Fielduf.Size)
	FieldufVecArg.Capacity = C.int(Fielduf.Capacity)
	FieldufVecArg.Data = FieldufDataArg

	result.Buf = *FieldufVecArg
	releaseFn = func() {
		FieldufDataFin()
	}
	return result, releaseFn
}

func (self TextBuffer) c() (result C.ImGuiTextBuffer, fin func()) {
	resultPtr, finFn := self.handle()
	return *resultPtr, finFn
}

func newTextBufferFromC(cvalue *C.ImGuiTextBuffer) *TextBuffer {
	result := new(TextBuffer)
	result.Fielduf = newVectorFromC(cvalue.Buf.Size, cvalue.Buf.Capacity, C.GoString(cvalue.Buf.Data))
	return result
}

// Helper: Parse and apply text filters. In format "aaaaa[,bbbb][,ccccc]"
type TextFilter struct {
	// TODO: contains unsupported fields
	data unsafe.Pointer
}

func (self TextFilter) handle() (result *C.ImGuiTextFilter, releaseFn func()) {
	result = (*C.ImGuiTextFilter)(self.data)
	return result, func() {}
}

func (self TextFilter) c() (result C.ImGuiTextFilter, fin func()) {
	resultPtr, finFn := self.handle()
	return *resultPtr, finFn
}

func newTextFilterFromC(cvalue *C.ImGuiTextFilter) *TextFilter {
	result := new(TextFilter)
	result.data = unsafe.Pointer(cvalue)
	return result
}

// Helper: ImGuiTextIndex<>
// Maintain a line index for a text buffer. This is a strong candidate to be moved into the public API.
type TextIndex struct {
	// TODO: contains unsupported fields
	data unsafe.Pointer
}

func (self TextIndex) handle() (result *C.ImGuiTextIndex, releaseFn func()) {
	result = (*C.ImGuiTextIndex)(self.data)
	return result, func() {}
}

func (self TextIndex) c() (result C.ImGuiTextIndex, fin func()) {
	resultPtr, finFn := self.handle()
	return *resultPtr, finFn
}

func newTextIndexFromC(cvalue *C.ImGuiTextIndex) *TextIndex {
	result := new(TextIndex)
	result.data = unsafe.Pointer(cvalue)
	return result
}

// [Internal]
type TextRange struct {
	Field string
	Field string
}

func (self TextRange) handle() (result *C.ImGuiTextRange, releaseFn func()) {
	result = new(C.ImGuiTextRange)
	Field := self.Field
	FieldArg, FieldFin := WrapString(Field)
	result.b = FieldArg
	Field := self.Field
	FieldArg, FieldFin := WrapString(Field)
	result.e = FieldArg
	releaseFn = func() {
		FieldFin()
		FieldFin()
	}
	return result, releaseFn
}

func (self TextRange) c() (result C.ImGuiTextRange, fin func()) {
	resultPtr, finFn := self.handle()
	return *resultPtr, finFn
}

func newTextRangeFromC(cvalue *C.ImGuiTextRange) *TextRange {
	result := new(TextRange)
	result.Field = C.GoString(cvalue.b)
	result.Field = C.GoString(cvalue.e)
	return result
}

// - Currently represents the Platform Window created by the application which is hosting our Dear ImGui windows.
// - With multi-viewport enabled, we extend this concept to have multiple active viewports.
// - In the future we will extend this concept further to also represent Platform Monitor and support a "no main platform window" operation mode.
// - About Main Area vs Work Area:
//   - Main Area = entire viewport.
//   - Work Area = entire viewport minus sections used by main menu bars (for platform windows), or by task bar (for platform monitor).
//   - Windows are generally trying to stay within the Work Area of their host viewport.
type Viewport struct {
	// TODO: contains unsupported fields
	data unsafe.Pointer
}

func (self Viewport) handle() (result *C.ImGuiViewport, releaseFn func()) {
	result = (*C.ImGuiViewport)(self.data)
	return result, func() {}
}

func (self Viewport) c() (result C.ImGuiViewport, fin func()) {
	resultPtr, finFn := self.handle()
	return *resultPtr, finFn
}

func newViewportFromC(cvalue *C.ImGuiViewport) *Viewport {
	result := new(Viewport)
	result.data = unsafe.Pointer(cvalue)
	return result
}

// ImGuiViewport Private/Internals fields (cardinal sin: we are using inheritance!)
// Every instance of ImGuiViewport is in fact a ImGuiViewportP.
type ViewportP struct {
	// TODO: contains unsupported fields
	data unsafe.Pointer
}

func (self ViewportP) handle() (result *C.ImGuiViewportP, releaseFn func()) {
	result = (*C.ImGuiViewportP)(self.data)
	return result, func() {}
}

func (self ViewportP) c() (result C.ImGuiViewportP, fin func()) {
	resultPtr, finFn := self.handle()
	return *resultPtr, finFn
}

func newViewportPFromC(cvalue *C.ImGuiViewportP) *ViewportP {
	result := new(ViewportP)
	result.data = unsafe.Pointer(cvalue)
	return result
}

// Storage for one window
type Window struct {
	// TODO: contains unsupported fields
	data unsafe.Pointer
}

func (self Window) handle() (result *C.ImGuiWindow, releaseFn func()) {
	result = (*C.ImGuiWindow)(self.data)
	return result, func() {}
}

func (self Window) c() (result C.ImGuiWindow, fin func()) {
	resultPtr, finFn := self.handle()
	return *resultPtr, finFn
}

func newWindowFromC(cvalue *C.ImGuiWindow) *Window {
	result := new(Window)
	result.data = unsafe.Pointer(cvalue)
	return result
}

// [ALPHA] Rarely used / very advanced uses only. Use with SetNextWindowClass() and DockSpace() functions.
// Important: the content of this class is still highly WIP and likely to change and be refactored
// before we stabilize Docking features. Please be mindful if using this.
// Provide hints:
// - To the platform backend via altered viewport flags (enable/disable OS decoration, OS task bar icons, etc.)
// - To the platform backend for OS level parent/child relationships of viewport.
// - To the docking system for various options and filtering.
type WindowClass struct {
	// TODO: contains unsupported fields
	data unsafe.Pointer
}

func (self WindowClass) handle() (result *C.ImGuiWindowClass, releaseFn func()) {
	result = (*C.ImGuiWindowClass)(self.data)
	return result, func() {}
}

func (self WindowClass) c() (result C.ImGuiWindowClass, fin func()) {
	resultPtr, finFn := self.handle()
	return *resultPtr, finFn
}

func newWindowClassFromC(cvalue *C.ImGuiWindowClass) *WindowClass {
	result := new(WindowClass)
	result.data = unsafe.Pointer(cvalue)
	return result
}

type WindowDockStyle struct {
	// TODO: contains unsupported fields
	data unsafe.Pointer
}

func (self WindowDockStyle) handle() (result *C.ImGuiWindowDockStyle, releaseFn func()) {
	result = (*C.ImGuiWindowDockStyle)(self.data)
	return result, func() {}
}

func (self WindowDockStyle) c() (result C.ImGuiWindowDockStyle, fin func()) {
	resultPtr, finFn := self.handle()
	return *resultPtr, finFn
}

func newWindowDockStyleFromC(cvalue *C.ImGuiWindowDockStyle) *WindowDockStyle {
	result := new(WindowDockStyle)
	result.data = unsafe.Pointer(cvalue)
	return result
}

// Windows data saved in imgui.ini file
// Because we never destroy or rename ImGuiWindowSettings, we can store the names in a separate buffer easily.
// (this is designed to be stored in a ImChunkStream buffer, with the variable-length Name following our structure)
type WindowSettings struct {
	// TODO: contains unsupported fields
	data unsafe.Pointer
}

func (self WindowSettings) handle() (result *C.ImGuiWindowSettings, releaseFn func()) {
	result = (*C.ImGuiWindowSettings)(self.data)
	return result, func() {}
}

func (self WindowSettings) c() (result C.ImGuiWindowSettings, fin func()) {
	resultPtr, finFn := self.handle()
	return *resultPtr, finFn
}

func newWindowSettingsFromC(cvalue *C.ImGuiWindowSettings) *WindowSettings {
	result := new(WindowSettings)
	result.data = unsafe.Pointer(cvalue)
	return result
}

// Data saved for each window pushed into the stack
type WindowStackData struct {
	Fieldindow                   *Window
	FieldarentLastItemDataBackup LastItemData
	FieldtackSizesOnBegin        StackSizes // Store size of various stacks for asserting
}

func (self WindowStackData) handle() (result *C.ImGuiWindowStackData, releaseFn func()) {
	result = new(C.ImGuiWindowStackData)
	Fieldindow := self.Fieldindow
	FieldindowArg, FieldindowFin := Fieldindow.handle()
	result.Window = FieldindowArg
	FieldarentLastItemDataBackup := self.FieldarentLastItemDataBackup
	FieldarentLastItemDataBackupArg, FieldarentLastItemDataBackupFin := FieldarentLastItemDataBackup.c()
	result.ParentLastItemDataBackup = FieldarentLastItemDataBackupArg
	FieldtackSizesOnBegin := self.FieldtackSizesOnBegin
	FieldtackSizesOnBeginArg, FieldtackSizesOnBeginFin := FieldtackSizesOnBegin.c()
	result.StackSizesOnBegin = FieldtackSizesOnBeginArg
	releaseFn = func() {
		FieldindowFin()
		FieldarentLastItemDataBackupFin()
		FieldtackSizesOnBeginFin()
	}
	return result, releaseFn
}

func (self WindowStackData) c() (result C.ImGuiWindowStackData, fin func()) {
	resultPtr, finFn := self.handle()
	return *resultPtr, finFn
}

func newWindowStackDataFromC(cvalue *C.ImGuiWindowStackData) *WindowStackData {
	result := new(WindowStackData)
	result.Fieldindow = newWindowFromC(cvalue.Window)
	result.FieldarentLastItemDataBackup = *newLastItemDataFromC(cvalue.ParentLastItemDataBackup)

	result.FieldtackSizesOnBegin = *newStackSizesFromC(cvalue.StackSizesOnBegin)

	return result
}

// Transient per-window data, reset at the beginning of the frame. This used to be called ImGuiDrawContext, hence the DC variable name in ImGuiWindow.
// (That's theory, in practice the delimitation between ImGuiWindow and ImGuiWindowTempData is quite tenuous and could be reconsidered..)
// (This doesn't need a constructor because we zero-clear it as part of ImGuiWindow and all frame-temporary data are setup on Begin)
type WindowTempData struct {
	// TODO: contains unsupported fields
	data unsafe.Pointer
}

func (self WindowTempData) handle() (result *C.ImGuiWindowTempData, releaseFn func()) {
	result = (*C.ImGuiWindowTempData)(self.data)
	return result, func() {}
}

func (self WindowTempData) c() (result C.ImGuiWindowTempData, fin func()) {
	resultPtr, finFn := self.handle()
	return *resultPtr, finFn
}

func newWindowTempDataFromC(cvalue *C.ImGuiWindowTempData) *WindowTempData {
	result := new(WindowTempData)
	result.data = unsafe.Pointer(cvalue)
	return result
}

type Vec1 struct {
	Field float32
}

func (self Vec1) handle() (result *C.ImVec1, releaseFn func()) {
	result = new(C.ImVec1)
	Field := self.Field

	result.x = C.float(Field)
	releaseFn = func() {
	}
	return result, releaseFn
}

func (self Vec1) c() (result C.ImVec1, fin func()) {
	resultPtr, finFn := self.handle()
	return *resultPtr, finFn
}

func newVec1FromC(cvalue *C.ImVec1) *Vec1 {
	result := new(Vec1)
	result.Field = float32(cvalue.x)
	return result
}

type STBTexteditState struct {
	Fieldursor             int32
	Fieldelect_start       int32 // selection start point
	Fieldelect_end         int32
	Fieldnsert_mode        uint
	Fieldow_count_per_page int32
	/////////////////////
	//
	// private data
	//
	Fieldursor_at_end_of_line uint // not implemented yet
	Fieldnitialized           uint
	Fieldas_preferred_x       uint
	Fieldingle_line           uint
	Fieldadding1              uint
	Fieldadding2              uint
	Fieldadding3              uint
	Fieldreferred_x           float32 // this determines where the cursor up/down tries to seek to along x
	Fieldndostate             StbUndoState
}

func (self STBTexteditState) handle() (result *C.STB_TexteditState, releaseFn func()) {
	result = new(C.STB_TexteditState)
	Fieldursor := self.Fieldursor

	result.cursor = C.int(Fieldursor)
	Fieldelect_start := self.Fieldelect_start

	result.select_start = C.int(Fieldelect_start)
	Fieldelect_end := self.Fieldelect_end

	result.select_end = C.int(Fieldelect_end)
	Fieldnsert_mode := self.Fieldnsert_mode

	result.insert_mode = C.uchar(Fieldnsert_mode)
	Fieldow_count_per_page := self.Fieldow_count_per_page

	result.row_count_per_page = C.int(Fieldow_count_per_page)
	Fieldursor_at_end_of_line := self.Fieldursor_at_end_of_line

	result.cursor_at_end_of_line = C.uchar(Fieldursor_at_end_of_line)
	Fieldnitialized := self.Fieldnitialized

	result.initialized = C.uchar(Fieldnitialized)
	Fieldas_preferred_x := self.Fieldas_preferred_x

	result.has_preferred_x = C.uchar(Fieldas_preferred_x)
	Fieldingle_line := self.Fieldingle_line

	result.single_line = C.uchar(Fieldingle_line)
	Fieldadding1 := self.Fieldadding1

	result.padding1 = C.uchar(Fieldadding1)
	Fieldadding2 := self.Fieldadding2

	result.padding2 = C.uchar(Fieldadding2)
	Fieldadding3 := self.Fieldadding3

	result.padding3 = C.uchar(Fieldadding3)
	Fieldreferred_x := self.Fieldreferred_x

	result.preferred_x = C.float(Fieldreferred_x)
	Fieldndostate := self.Fieldndostate
	FieldndostateArg, FieldndostateFin := Fieldndostate.c()
	result.undostate = FieldndostateArg
	releaseFn = func() {
		FieldndostateFin()
	}
	return result, releaseFn
}

func (self STBTexteditState) c() (result C.STB_TexteditState, fin func()) {
	resultPtr, finFn := self.handle()
	return *resultPtr, finFn
}

func newSTBTexteditStateFromC(cvalue *C.STB_TexteditState) *STBTexteditState {
	result := new(STBTexteditState)
	result.Fieldursor = int32(cvalue.cursor)
	result.Fieldelect_start = int32(cvalue.select_start)
	result.Fieldelect_end = int32(cvalue.select_end)
	result.Fieldnsert_mode = uint(cvalue.insert_mode)
	result.Fieldow_count_per_page = int32(cvalue.row_count_per_page)
	result.Fieldursor_at_end_of_line = uint(cvalue.cursor_at_end_of_line)
	result.Fieldnitialized = uint(cvalue.initialized)
	result.Fieldas_preferred_x = uint(cvalue.has_preferred_x)
	result.Fieldingle_line = uint(cvalue.single_line)
	result.Fieldadding1 = uint(cvalue.padding1)
	result.Fieldadding2 = uint(cvalue.padding2)
	result.Fieldadding3 = uint(cvalue.padding3)
	result.Fieldreferred_x = float32(cvalue.preferred_x)
	result.Fieldndostate = *newStbUndoStateFromC(cvalue.undostate)

	return result
}

// result of layout query
type StbTexteditRow struct {
	Field0               float32 // starting x location, end x location (allows for align=right, etc)
	Field1               float32 // starting x location, end x location (allows for align=right, etc)
	Fieldaseline_y_delta float32 // position of baseline relative to previous row's baseline
	Fieldmin             float32 // height of row above and below baseline
	Fieldmax             float32 // height of row above and below baseline
	Fieldum_chars        int32
}

func (self StbTexteditRow) handle() (result *C.StbTexteditRow, releaseFn func()) {
	result = new(C.StbTexteditRow)
	Field0 := self.Field0

	result.x0 = C.float(Field0)
	Field1 := self.Field1

	result.x1 = C.float(Field1)
	Fieldaseline_y_delta := self.Fieldaseline_y_delta

	result.baseline_y_delta = C.float(Fieldaseline_y_delta)
	Fieldmin := self.Fieldmin

	result.ymin = C.float(Fieldmin)
	Fieldmax := self.Fieldmax

	result.ymax = C.float(Fieldmax)
	Fieldum_chars := self.Fieldum_chars

	result.num_chars = C.int(Fieldum_chars)
	releaseFn = func() {
	}
	return result, releaseFn
}

func (self StbTexteditRow) c() (result C.StbTexteditRow, fin func()) {
	resultPtr, finFn := self.handle()
	return *resultPtr, finFn
}

func newStbTexteditRowFromC(cvalue *C.StbTexteditRow) *StbTexteditRow {
	result := new(StbTexteditRow)
	result.Field0 = float32(cvalue.x0)
	result.Field1 = float32(cvalue.x1)
	result.Fieldaseline_y_delta = float32(cvalue.baseline_y_delta)
	result.Fieldmin = float32(cvalue.ymin)
	result.Fieldmax = float32(cvalue.ymax)
	result.Fieldum_chars = int32(cvalue.num_chars)
	return result
}

// //////////////////////////////////////////////////////////////////////
//
//	STB_TexteditState
//
// Definition of STB_TexteditState which you should store
// per-textfield; it includes cursor position, selection state,
// and undo state.
type StbUndoRecord struct {
	// private data
	Fieldhere         int32
	Fieldnsert_length int32
	Fieldelete_length int32
	Fieldhar_storage  int32
}

func (self StbUndoRecord) handle() (result *C.StbUndoRecord, releaseFn func()) {
	result = new(C.StbUndoRecord)
	Fieldhere := self.Fieldhere

	result.where = C.int(Fieldhere)
	Fieldnsert_length := self.Fieldnsert_length

	result.insert_length = C.int(Fieldnsert_length)
	Fieldelete_length := self.Fieldelete_length

	result.delete_length = C.int(Fieldelete_length)
	Fieldhar_storage := self.Fieldhar_storage

	result.char_storage = C.int(Fieldhar_storage)
	releaseFn = func() {
	}
	return result, releaseFn
}

func (self StbUndoRecord) c() (result C.StbUndoRecord, fin func()) {
	resultPtr, finFn := self.handle()
	return *resultPtr, finFn
}

func newStbUndoRecordFromC(cvalue *C.StbUndoRecord) *StbUndoRecord {
	result := new(StbUndoRecord)
	result.Fieldhere = int32(cvalue.where)
	result.Fieldnsert_length = int32(cvalue.insert_length)
	result.Fieldelete_length = int32(cvalue.delete_length)
	result.Fieldhar_storage = int32(cvalue.char_storage)
	return result
}

type StbUndoState struct {
	// TODO: contains unsupported fields
	data unsafe.Pointer
}

func (self StbUndoState) handle() (result *C.StbUndoState, releaseFn func()) {
	result = (*C.StbUndoState)(self.data)
	return result, func() {}
}

func (self StbUndoState) c() (result C.StbUndoState, fin func()) {
	resultPtr, finFn := self.handle()
	return *resultPtr, finFn
}

func newStbUndoStateFromC(cvalue *C.StbUndoState) *StbUndoState {
	result := new(StbUndoState)
	result.data = unsafe.Pointer(cvalue)
	return result
}
