package main

import (
	"fmt"
	"github.com/kpango/glg"
	"log"
	"os"
)

const (
	generatorInfo   = "// Code generated by cmd/codegen from https://github.com/AllenDang/cimgui-go.\n// DO NOT EDIT.\n\n"
	goPackageHeader = generatorInfo + "package imgui\n\n"
	cppFileHeader   = generatorInfo
)

// this cextracts enums and structs names from json file.
func getEnumAndStructNames(enumJsonBytes []byte) (enumNames []GoIdentifier, structNames []CIdentifier, err error) {
	enums, err := getEnumDefs(enumJsonBytes)
	if err != nil {
		return nil, nil, fmt.Errorf("cannot get enum definitions: %w", err)
	}

	structs, err := getStructDefs(enumJsonBytes)
	if err != nil {
		return nil, nil, fmt.Errorf("cannot get struct definitions: %w", err)
	}

	for _, e := range enums {
		enumNames = append(enumNames, e.Name.renameEnum())
	}

	for _, s := range structs {
		if !shouldSkipStruct(s.Name) {
			structNames = append(structNames, s.Name)
		}
	}

	return
}

func validateFiles(f *flags) {
	stat, err := os.Stat(f.defJsonPath)
	if err != nil || stat.IsDir() {
		glg.Fatal("Invalid definitions json file path")
	}

	stat, err = os.Stat(f.enumsJsonpath)
	if err != nil || stat.IsDir() {
		glg.Fatal("Invalid enum json file path")
	}

	stat, err = os.Stat(f.typedefsJsonpath)
	if err != nil || stat.IsDir() {
		glg.Fatal("Invalid typedefs json file path")
	}
}

// this stores file bytes of our json files
type jsonData struct {
	structAndEnums,
	typedefs,
	defs,

	refStructAndEnums,
	refTypedefs []byte
}

func loadData(f *flags) (*jsonData, error) {
	var err error

	result := &jsonData{}

	result.defs, err = os.ReadFile(f.defJsonPath)
	if err != nil {
		return nil, fmt.Errorf("cannot read definitions json file: %w", err)
	}

	result.typedefs, err = os.ReadFile(f.typedefsJsonpath)
	if err != nil {
		return nil, fmt.Errorf("cannot read typedefs json file: %w", err)
	}

	result.structAndEnums, err = os.ReadFile(f.enumsJsonpath)
	if err != nil {
		log.Panic(err)
	}

	if len(f.refEnumsJsonPath) > 0 {
		result.refStructAndEnums, err = os.ReadFile(f.refEnumsJsonPath)
		if err != nil {
			return nil, fmt.Errorf("cannot read reference struct and enums json file: %w", err)
		}
	}

	if len(f.refTypedefsJsonPath) > 0 {
		result.refTypedefs, err = os.ReadFile(f.refTypedefsJsonPath)
		if err != nil {
			return nil, fmt.Errorf("cannot read reference typedefs json file: %w", err)
		}
	}

	return result, nil
}

// this will store json data processed by appropiate pre-rocessors
// (parsed json)
type objectsDats struct {
	funcs                 []FuncDef
	structs               []StructDef
	enums                 []EnumDef
	typedefs, refTypedefs *Typedefs
}

func parseJson(jsonData *jsonData) (*objectsDats, error) {
	var err error

	result := &objectsDats{}

	// get definitions from json file
	result.funcs, err = getFunDefs(jsonData.defs)
	if err != nil {
		return nil, fmt.Errorf("cannot get function definitions: %w", err)
	}

	result.enums, err = getEnumDefs(jsonData.structAndEnums)
	if err != nil {
		return nil, fmt.Errorf("cannot get enum definitions: %w", err)
	}

	result.typedefs, err = getTypedefs(jsonData.typedefs)
	if err != nil {
		return nil, fmt.Errorf("cannot get typedefs: %w", err)
	}

	result.structs, err = getStructDefs(jsonData.structAndEnums)
	if err != nil {
		return nil, fmt.Errorf("cannot get struct definitions: %w", err)
	}

	result.refTypedefs = make(map[CIdentifier]string)
	if len(jsonData.refTypedefs) > 0 {
		typedefs, err := getTypedefs(jsonData.refTypedefs)
		if err != nil {
			return nil, fmt.Errorf("cannot get reference typedefs: %w", err)
		}

		result.refTypedefs = typedefs.data
	}
}

// DataPack struct stores internal data of our generator
type DataPack struct {
	prefix     string
	validFuncs map[CIdentifier]bool
	// TODO: might want to remove this
	flags *flags
}

func main() {
	data := new(DataPack)
	flags := parse()
	validateFiles(flags)

	jsonData, err := loadData(flags)
	if err != nil {
		glg.Fatalf("cannot load data: %v", err)
	}

	objectsData, err := parseJson(jsonData)
	if err != nil {
		glg.Fatalf("cannot parse json: %v", err)
	}

	validFuncs, err := generateCppWrapper(flags.prefix, flags.include, funcs)
	if err != nil {
		log.Panic(err)
	}

	data.prefix = flags.prefix
	data.flags = flags

	var es, ss = make([]GoIdentifier, 0), make([]CIdentifier, 0)
	// generate reference only enum and struct names
	if len(jsonData.refStructAndEnums) > 0 {
		es, ss, err = getEnumAndStructNames(jsonData.refStructAndEnums)
		if err != nil {
			log.Panic(err)
		}
	}

	callbacks, err := proceedTypedefs(flags.prefix, typedefs, structs, enums, refTypedefs)

	// generate code
	enumNames := generateGoEnums(flags.prefix, enums)
	//structNames := generateGoStructs(*prefix, structs, enums, es, ss, refTypedefs)
	structNames := make([]CIdentifier, 0)

	structAccessorFuncs, err := generateCppStructsAccessor(flags.prefix, validFuncs, structs)
	if err != nil {
		log.Panic(err)
	}

	validFuncs = append(validFuncs, structAccessorFuncs...)

	if len(jsonData.refStructAndEnums) > 0 {
		enumNames = append(enumNames, es...)
		structNames = append(structNames, ss...)
	}

	structNames = append(structNames, callbacks...)

	if err := generateGoFuncs(flags.prefix, validFuncs, enumNames, structNames, refTypedefs); err != nil {
		log.Panic(err)
	}
}
